#+LATEX_HEADER: \usepackage{xeCJK}
#+LATEX_HEADER: \setCJKmainfont{STKaiti}
#+OPTIONS: \n:t ^:nil  toc:nil
#+TODO: TODO(t) STARTED(s) WAITING(w) | DONE(d) CANCELED(c)
* 预研工作
** android O
https://www.ithome.com/html/android/309497.htm
https://en.wikipedia.org/wiki/Android_O
** 智能语音
*** 会议
**** AS216b
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EBAAE@srv-mail-02.actions.com.cn][RE: AS216B立项通过]]
**** 语音前处理预立项
[[mu4e:msgid:29180296.78481.1493370386557.JavaMail.fwint2@srd-fw-share009][会议记录:语音前处理模块项目的预立项评审第一次会议]]
**** 0424 5116预研
***** 周总
+ 需要考虑DSP给第三方开发
+ 可以做为预研项目，不需要计算ROI
+ 考虑ATJ2167
+ 不需要考虑成本，研发优先
+ 需要第三方开发DSP
**** 地平线
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB7E9@srv-mail-02.actions.com.cn][Roobo&地平线的出差记录]]
**** 迪韵 3605D
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB6AA@srv-mail-02.actions.com.cn][20170414-迪韵&火百灵客户拜访的出差报告-雷长发 .doc]]

	3605项目，初步项目名EchoLike-T1，当前的目标客户是一家江苏的，下一步期望我们在场3方客户会议，当前客户期望是3个月后能够送出过认证

	Airpaly和DLAN是WIFI音箱的标配规格，这个需要市场再落实。
	迪韵和第三方专门开了一颗ADC的IC，预计5月底能够拿到IC
规格：6路ADC，SNR spec是95dB,DR:98dB（需要实际IC测试）
	全志的G102和G202基本没有人使用，当前语音识别使用的依然是R16，全志的ADC是4路ADC，DR是106的dB（给迪韵的资料），没有实际使用过。
	4MIC的有希望能够迈过门槛，当前最好的算法还是比8MIC的差了不少，他们的对比方式，没有指标。
	CX20924是4路DMIC输入，比CX20921贵1个美金。CX20921的模块他们拿到的价格是6美金（含税，包含算法）
	彭总认为echo产品下一步会分化为2类：echo继续发展，重视其音箱规格，音效和音质部分需要加强；另一类是DOT类更简化产品，弱化speaker功能，凸显控制功能。他们更看好后者。
	当前RK也在强推3229和3066，迪韵认为3066的性能偏弱，只能配合CX20921做方案，他不看好3066.3229属于高端多6~8 MIC比较好，但是量不够。
	多MIC方案中模拟输出的MENS会因为一致性好可能成为多MIC应用下的主流。模拟输出的MENS价格也在持续走低，已经不到5倍价格了。

 乐百灵
	给我们演示了双MIC的样机效果（宣传指标：远场5m，唤醒率94%，识别率90%），唤醒不了的情况还是比较多发生（给我们的解释是里面的测试固件，其实我们手上的echo dot也一样）。
	乐百灵的这款双MIC采用的方式直接CX20921贴主板上，没有用模块。AEC没有使用ADC，直接使用的是AP出来的I2S的输出连接到CX20921上，CX20921负责下采样。同时这个方案是有音效的，音效是外挂IC，也就是说当前的AEC是从音效处理之前采集的。他给我们的说法是这样做多对性能有影响的，只是当时为了省ADC才这样做了。
	乐百灵采用的是云之声的语音识别算法，云之声将云识别算法和CX20921打包方式给乐白灵。
	唤醒词部分是他们自己的算法，他们可以更换唤醒词。咨询唤醒词的运算量，他说的他们自己的很小。他对CX20921的冷唤醒词识别不是很看好。
	他也提到了Airpaly和DLNA的需求是WIFI音箱的must需求。
	语音识别库：老朱看来认为故事机和WIFI音箱是两个不同的产品，对算法要求不同，他给我们的解释是故事机针对小孩，WIFI音箱针对大人，大人小孩的声音识别训练模型是有差异的（待确认），我们3503故事机和WIFI音箱公用语音识别的方式关注一下这个。
	乐白灵的模具因为语音识别做过多次调整，最后选择将MIC的腔体放在上偏后面，同时模具设计上对震动音箱等都有充分考虑。他的说法是这部分对算法效果影响非常大。
	他们手上有语音识别且蓝牙和WIFI切换的模具，是一款公模。比较切合我们ATS3503的WIFI音箱的方案需求。
	初步沟通准备从他们家购买单MIC和双MIC的模具作为我们标案开发使用


3605项目，初步项目名EchoLike-T1，当前的目标客户是一家江苏的，定位国外市场，资源第一步只考虑Amazon（国内市场放后面再考虑），下一步期望炬力在场3方客户会议（终端客户希望IC原厂的表态），当前客户期望是3个月后能够送出过认证
2.方案规格：已经基本有初版，迪韵前期与客户就手上已有平台讨论确认了。 IC先选定ATS3605，方案先使用NAND，DDR先预选128MB（根据预处理和sensory唤醒词算法的内存需求最终确定后再看是否需要换成64MB），WIFI模组选定博通AP6212，当前这个客户不需要LCD（但期望能够提供一个可以演示UI的DEMO用于接触更多的其他潜在客户，UI最好开放给迪韵开发和替换）；手机端配置APP使用迪韵已有的；amazon认证方式：直接迪韵配合江苏客户去过认证。
3.	当前提供的ATS3605的开发环境，根据前期的熟悉和了解，期望软件补充3个部分的内容：DLAN和AirPlay的音频接收，BT蓝牙的驱动，标准的ALSA
4.	硬件平台的要求：需要炬芯协助实现MIC阵列子板和3605的EVB板的对接；另外产品化的硬件设计，迪韵提供模具机构图，期望这个3个月送认证的硬件设计由炬芯安排；
5.	人力：算法及方案开发，迪韵当前投入1.5人。炬力当前已经调配专门的团队，有专门的驱动和内核以及硬件的负责同事。
6.	讨论到的关键路径的任务和时间点：
A．	MIC阵列模块的接口迪韵发给炬芯（4.14已经给出），炬芯评估与3605 EVB对接实现方案（飞线，修改转接子板还是需要重出板子，以及出核心板待定），承诺时间点：飞线或者简单转接子板1周搞定，如果设计修改EVB的话，需要2周时间，目标是期望以最快的方式给算法调试提供硬件平台；同时迪韵使用当前手上的3605的EVB进行算法的移植，算法移植工作量预计1周半。
B．	需求规格：迪韵发出当前规格版本，同时炬芯安排评估当前SDK是否有遗漏需要开发（当前已知的3大点已经提出），同时根据当前规格评估出方案的BOM，然后约谈3方会议。
C．	模具的3D结构信息，考虑试验样机的硬件设计，贴片（需要外包）

**** 3605D
[[mu4e:msgid:22283209.72775.1491959999616.JavaMail.fwint2@srd-fw-share009][会议记录:讨论3605D方案规划]]
**** CITS 2017
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F36F30@srv-mail-02.actions.com.cn][答复: 2017 CITE展会参观报告]]
2017cite展
出差内容：
深圳cite展（中国集成电路技术展）
关注重点是智能家居和人工智能在消费类应用。
关于智能家居，接触了海尔，tcl，创维，海信，康佳几家。
海尔的U+自定义了协议，有云接口，也有局域网内部的接口。但是侧重在云
接口上，断掉外网后的局域网小循环则放在其次。有点类似亚马逊。家电单
品突破为主。
TCL则重点放在局域网的小循环的协议上。也可以接外网云设备。感觉更多像
Control4。产品以房地产商合作的前装为主。
这也是目前智能家居的两种实现方式：一种侧重云接入为主，重视单品；另
外一种侧重本地系统的整体转换，重视开发商的前装市场。
但海尔的协议不开放，必须使用hairer的模块，wifi主要是高通4004和
realtek的。Ble用的8762，zigbee用自家的芯片不开放给外部使用。
TCL的设备物联网方面，主要和京东微联合作，因为认知家电产品京东比淘宝
买的多，所以认为京东微联比阿里小智在家电产品有更大的影响力。
其他家电视机厂：
创维，则转型向社区服务，比如o2o洗衣机和o2o付费电视。在智能家居系统
的布局相对少。
长虹，海信，康佳更多的是电视机本身的技术，如曲面屏，手机多协议推送
，或语音搜索等。
人工智能方面：
科大讯飞系摊子最大。在深圳建立产品团队，和支持团队，针对华南地区的
客户的接入和服务。同时在推广VR进入学校教学和职业教育，联合了教育资
源的公司在开发VR内容。注资淘云，整合幼教内容、语音技术和对玩具厂商
给予授权。
Intel展台上，展示了商用机器人naopaper（做展示为主），和科大的差别是
有机械的控制这块。科大体系侧重语音的人工智能，侧重消费类产品，娱乐
，教育产品。
高通的展台，人工智能这块做了Qualcomm Zeorth机器学习的引擎，其核心不
是在云，而是在本地计算。这是和前两种不同的方式。
其他的亮点：京东方转型做结合3色墨水屏的商超服务，电子标签整店替换和
后台网络控制整套解决方案。
照片分享：https://pan.baidu.com/s/1qYrZKUo
结论、感想及建议：
1，智能家居体确实各家的思路和玩法不同，包括国内外的。等各自大起来，
会出现各体系连接的过程。
2，人工智能，以语音接入方式最热，云脑的方式是目前主流，也不乏本地机
器学习的努力。人工智能第一波消费类的赚钱应该在语音方向。幼教方面已
经开始在赚钱了，内容资源和技术整合可能会是个趋势。
**** 关于智能语音在蓝牙和Wifi音箱市场上的落地
[[mu4e:msgid:2307181.71992.1491807792153.JavaMail.fwint2@srd-fw-share009][会议记录:关于智能语音在蓝牙和Wifi音箱市场上的落地]]
***** 周总
5118plus  5119 + 成本取决于核高基
5116 用来摸规格
5116C/5120 不做远场的规格
new ic（m3 + DSP）解决2mic或3mic的远场以及音效， 不仅仅只做预处理器，
用来兼顾蓝牙的语音预处理
***** 肖凯平
****** 故事机 3503
近场 （按键唤醒， 按键打断）
****** m3 + DSP + bt/wifi combo  + 解码
3503 + 远场 + 音效
类似echo 3~5米， 关键词唤醒， 关键词打断
3605D的costdown版本
****** echo 使用的经典蓝牙遥控器
***** 张洪波
****** 5116
+ 远场
  使用科胜讯cx20921， 使用sensory的唤醒词。科胜讯的功耗太高。
  打电话过程中打断， 误唤醒会比较高
+ 近场
  不需要vad vat， 使用按键就可以。在任何时候都可以按键进行识别。
****** 5116C/5120
+ 只考虑唤醒词， 不考虑蓝牙远场
+ 蓝牙播放音乐+音效需要增加70K， 5116c已经增加32k， sensory要求70k（ram + rom）
+ 只考虑蓝牙耳机的近场（非按键）
+ 远场
    本地播放+蓝牙后台连接+打断+语音识别
  远场需要绑定云
  识别的调教需要云和预处理配合才可以
****** 远场+蓝牙
蓝牙speaker
远场拾音芯片
****** WIFI音箱
m3 + DSP + bt/wifi combo  + 解码用来主打WIFI音箱。
蓝牙only音箱 + 8761就可以。 不需要加5116C， 但需要移植蓝牙音箱的功能
***** 雷长发
VAT  VAD低功耗唤醒系统
按键唤醒
静音环境下，脱离按键唤醒
放音环境下，打断
+ 蓝牙是否可以可靠的唤醒手机
+ 使用5116 + DSP远场拾音
**** 市场部会议
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04EC4F2A@srv-mail-02.actions.com.cn][答复: 2017年4月 市场部/企划部 联席会议——智能语音主题]]

*** doc
聊一聊麦克风阵列技术：语音交互应该选用怎样的方案？｜深度
http://www.leiphone.com/news/201610/BSlh3Kf6wcqNCRH9.html
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EBAE8@srv-mail-02.actions.com.cn][RE: 关于多mic算法的内部评测标准？]]
*** 微信
**** 0610
昨天和科胜讯的人聊几个重要的信息

1，亚马逊的音箱认证目前全球只有linkplay一家过了，搭配科胜讯双mic。第二家可能是通力，正在用科胜讯的双mic在送认证。通力内部有实验室可测亚马逊标准的测试环境。通力也在配合科胜讯的4mic算法芯片。国内大量算法公司在努力过多mic算法，至今还无成功先例。
2，双mic在国外已经满足需求，4mic的需求主要是国内的需求，性能上双mic接近echo体验，但是没有bf的效果，4mic的略好，可实现bf和唤醒方向灯的功能（非认证强制要求）。
3，亚马逊认证除了声音的认证外还有两大系列的功能性认证需求。具体是哪些，要具体产品去过。
4，关于sensory的唤醒，mtk的7688用的是250k的库，据说是去年12月的测试标准，现在测试标准还在不断加严格，上次我们看到一份3月的标准简介。据说主要差别是把人声命令降低了5db，把噪声提高了5db。所以mtk7688的可能过不了新标准了。这也是新的产品越来越难过alexa认证的原因。
5，关于科胜讯的唤醒词，在科胜讯上可放sensory的40k模型的唤醒词，但误唤醒率过不了认证，亚马逊标准3次/24小时。如果到40k的会较大误唤醒（比如，30次一天）。如果sensory认可我们使用，是可以把“alexa”和“芝麻开门”两个唤醒词的固件给我们，没有额外费用增加。

robert说法是亚马逊用的算法资源太多，之前是2.5个a53。现在压缩到2个a53。另外一个a53，做音效。一个做应用扩展。

科胜讯给了看了一家客户对比测试的报告。主要是不同噪声db级别，不同音乐db级别，不同角度的唤醒，还有某几句话的不同距离测试唤醒。

我觉得我们还是过度聚焦在多mic算法上了。问题的关键在于认证是否仅仅认证多mic算法？ 如果认证要确保亚马逊其他算法和应用有效。那么就不用再思考 3503 或者其他mcu➕dsp架构过认证这回事。这是架构性和方向性的问题


昨天CEVA的人过来演示多mic效果，是在灿芯在SMIC55做的500MHz的TL410(我们之前的TL421的速度受限于SRAM,实现部分应该有空间，待论证)芯片上跑sensory唤醒词“hello,ceva”外加4条命令同时跑Alang 4mic远场算法，我们体验的效果不好，他们解释是TL410的性能不够。另外CEVA内部有开发X2的4MIC算法，今年Q3出来，可以提供给X2客户使用。另外一个信息是alibaba一家全资子公司正在做X2的IC，目标是6MIC,今年Q4 IC出来，另外Alibaba合作一家开了TL421的一颗，预计Q3 IC出来，也是6MIC,其他老赵帮忙补充吧
**** 0622 CEVA
1. alibaba使用的X2是他和C-sky合资的公司在做的，目标6~8MIC，MCU可能就是中天的802
2. allwinner使用SDT评估，C直接编译的话效果A7和X2基本一样，后来调用CEVA优化库优势就体现出来了，他们评估6MIC的语音前处理需要X2运行400MHz，当前CEVA与他们说接受协助优化，可以再优化20~30%。
3. amazon使用X2：芯片提供是DSPG（正在研发），算法使用了双核X2，频率是800MHz，对应的算法用ARM的CPU需要跑3~4GHz，还有额外的一个X2用于低功耗设计。
4. 微纳感知评估的一个数据是ARM A9运行 1GHz的跑的算法，他们评估TL421 350MHz可以完成。他们的ADC外包用的是dophin的IP。
5.
*** 耳朵IC
**** X2评估
***** X2资料提到的WIFI性能
结合给的WIFI资料， 他们的WIFI的baseband（mac）部分需要的50MHz的性能。
TCP/IP, EMAC RTOS的性能需求是15MHz
***** 3503性能需求
+ 场景
  播放边下载边播放网络320Kbps的mp3数据，此时主要的功能模块（解码，网络下载，usb读卡器，文件系统同时读写）
+ 实际数据
  CPU占有率 80%， 10532毫秒内，cache miss 的时间是 3950ms
  CPU运行156M，SPI Nor的速率为48MHz  四线模式， 每次cache miss需要的时间为3.3us (相当158个cycle，没有CRC的理论最快 140个cycle）
  折算出来的cpu的性能相当于82MHz， 320Kbps的mp3解码需要50MHz， 那么此时系统需要的就是32Mhz
***** X2可以跑系统
从指令集上看，开始支持char类型为8bit，因此对C程序的可移植性不会有大的影响了。
从寄存器上看，开始有32个通用寄存器了，也比较容易跑控制逻辑代码了
性能上看core mark按照资料有4.3/MHz，相比M4k更好的。
目前给的评估环境，找不到如何使用timer和中断的方法，所以不太好测试，后续需要更多的资料和环境来测试。
***** 各个平台CoreMark对比
CoreMark对比如下：
| IC         | Cpu/Clk        | Compile&argument                                            | Code       |   CoreMark | CoreMark/MHz |
| Cordio-tc2 | Cortex-M0+ 32M | ARM Compiler 5.06 update 1 --cpu Cortex-M0+ -O3 -Otime      | RAM        |  64.513404 |        2.016 |
| Cordio-tc2 | Cortex-M0+ 32M | ARM Compiler 5.06 update 1 --cpu Cortex-M0+ -O3             | RAM        |  39.142952 |        1.223 |
| 3503       | MIPS4K 150M    | /mips-2014.11/bin/mips-sde-elf-gcc (GCC4.9.1) -mips32r2 -Os | SNOR/Cache | 333.333333 |        2.222 |
| 3503       | MIPS4K 150M    | /mips-2014.11/bin/mips-sde-elf-gcc (GCC4.9.1) -mips32r2 -Os | RAM        | 333.333333 |        2.222 |
| NXP K64f   | Cortex-M4 120M | ARM Compiler 5.06 update 1 -O3 -Otime                       | EFLASH     | 283.889283 |        2.366 |
| NXP K64f   | Cortex-M4 120M | ARM Compiler 5.06 update 1 -O3 -Otime                       | RAM        | 218.658892 |        1.822 |
|5202e|	Cortex-A5 Single-Core 960M|	arm-linux-androideabi-4.7 -march=armv7-a -mthumb -Os	|ddr|	1676.727029|	1.747|

分析：
+ 编译参数有较大影响。修改编译参数前后后Cordio-tc2上CoreMark相差较大。
+ 3503在SNOR和RAM中运行结果相同。因为CoreMark代码规模不大（<16Kbytes），可以全部缓冲在cache中。
+ K64f在flash中运行的效率高过在ram中运行。因为M4是哈佛结构，在flash中运行能充分利用取指和取数据走不同的总线的优势。
+ 5202e的CoreMark偏低。
+ Ceva x2在simulator上运行的结果可能参考意义不大。

***** 架构建议也评估下 单核 + spi nor 执行代码 + 内部Sram的方案
主要考虑如下：
****** spi nor性能可能好于sdr ram的性能
+ spi nor 和 sdr ram的基本性能可能只有不到2倍的差距
  sdr 用 166MHz  16bit
  spi nor 最快的已经有  80MHz DDR模式  8bit
  在cache line的size为64byte的情况下，性能差距已经不到2倍

  龚建给SDR的4线 nor的数据：
  #+begin_quote
  SPI NOR最快的模式，就是下面的AXH模式，如下时序：地址以4IO的模式发送，不用发EB的Command
  需要的SPI Cycle是12的地址Cycle+64*8/4(64Byte的Cache Line)=140Cycle。GD SPI时钟最快的Fast Read是120MHz。
  #+end_quote
  钟旭给的sdr ram的数据:
  #+begin_quote
  1、SDR在没有命令拥塞的情况下：
  最快：  3+64/2=35cycle；
  最慢：  3+3+3+64/2+2=43cycle；
  2、如果有命令拥塞（其他master读写命令在命令队列里等着）的情况下：
  最坏的情况：所有命令都是读写切换且同一个bank的情况
  (3+3+3+32*8/16+2)*4+(3+3+3+64/2+2)=151 cycle;
  #+end_quote
+ 使用spi cache跑代码可以充分利用x2 的哈佛结构
  从前面测试的coremark的数据就可以看出，哈佛结构对性能影响很大，这样的话，spi cache和sdr ram的2倍不到的性能会继续缩小
  | NXP K64f | Cortex-M4 120M | ARM Compiler 5.06 update 1 -O3 -Otime | EFLASH | 283.889283 | 2.366 |
   | NXP K64f | Cortex-M4 120M | ARM Compiler 5.06 update 1 -O3 -Otime | RAM | 218.658892 | 1.822 |
+ X2的MSS（存储子系统架构）会更容易碰到sd ram的读写切换情况
  X2的MSS支持如下特性：
  指令预取，会最多预取4个fetch line， 每个fetch line是128bit
  cache miss是非阻塞的， ICACHE 和 DCACHE都可以发出多个outstanding的请求
  考虑这种特性的话， sdr ram的优势会进一步降低， 有可能比spi nor还慢
****** 可以把性能要求较高的部分放到sram中来充分利用DSP的性能
相对于sd ram， 片内做一定量的sram， 在有特别的性能需求的时候， 可以跑程序和数据放在sram上跑，
sram 的性能会显著的比sdr ram好很多

**** mail
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791BFF@srv-mail-02.actions.com.cn][RE: 关于“耳朵”SOC IC的立项准备工作]]
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791CCA@srv-mail-02.actions.com.cn][RE: CEVA X2评估]]
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791D19@srv-mail-02.actions.com.cn][耳朵SOC的DSP选型评估]]
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791D13@srv-mail-02.actions.com.cn][转发: TL420&TL421&X2的信息]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906329E0E@srv-mail-02.actions.com.cn][X2 license]]
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791CEC@srv-mail-02.actions.com.cn][FW: TL420&TL421&X2的信息]]
**** doc
***** CEVA X2
****** CEVA-X2 Block Diagram
******* Program Control Unit
The Program Control Unit (PCU) is divided into three sub-units: the Dispatcher, the Interrupt handler, and the Program Sequencer.
The Dispatcher aligns the instructions from the program memory and dispatches them to the different units. It includes an instruction queue and manages 16-bit and 32-bit instruction alignment.
The interrupt handler handles incoming interrupts, and changes the program counter accordingly.
The Program Sequencer ensures proper program flow, whether sequential or non-sequential. It manages the Program Counter (PC) and has various mechanisms for different types of noncontinuous instructions:
• Branch Mechanism: Manages all branches, subroutine calls, and subroutine return operations
• Branch Target Buffer (BTB): Minimizes the penalty for change of flow execution
• Branch Prediction Mechanism: Predicts the target address to minimize the penalty
of branches and changes of flow
• Exception Handling: Manages all software/hardware interrupts and resets acceptance
******* Scalar Processing Unit
The Scalar Processing Unit (SPU) handles all of the scalar computations and bit- manipulation operations, and provides efficient OOB C-compiler support for both control and DSP-oriented operations. The SPU consists of two separate computational sub-units named SPUx. The sub-units are independent and can execute instructions in parallel to other sub-units
******* Load and Store Unit
The Load and Store Unit (LSU) is responsible for all data memory accesses. The unit is divided into two sub-units, the LS0 and LS1, which are capable of loading and storing from/ to the data memory using various addressing modes.
The LSU supports a load bandwidth of up to 128 bits per cycle and, in parallel, supports a store bandwidth of up to 128 bits per cycle
The LSU generates two independent 32-bit addresses in each cycle, according to the following addressing modes:
• Indirect addressing, including post-modification
• Indexed, using a base register and an immediate value or a pointer, including post-modification
• Direct, fully embedded in the instruction (long direct)
• Stack, using a Stack Pointer (SP) register for pushing and popping to/from the software stack
****** Memory Subsystem
The CEVA-X2 Memory Subsystem (MSS) is an extended system that can be easily adapted for full SoC integration. The MSS consists of the following:
• Program Memory Subsystem (PMSS): Contains an optional L1 program memory and four-way cache
• Data Memory Subsystem (DMSS): Contains L1 data memory and an optional cache

While the core accesses the L1 memories and cache with no wait-states, accessing the
external memories may require several wait-states.

The CEVA-X2 supports up to 4 GB of memory space, and has up to eight separate physical interfaces (up to seven for data memory and one for program memory). This enables the core to simultaneously access both the program and data memories in parallel with Tightly Coupled Extensions (TCE). The MSS provides the core with simultaneous accesses to one instruction fetch stream and one data fetch stream. The PCU accesses the program memory, and the LSU accesses the data memory.

The MSS contains standard interfaces for connecting the core to external devices and/or peripherals. These interfaces include three AXI master ports for data and one AXI master port for program, four optional AXI slave ports for external masters, a hardware accelerator connection to the data memory, and an APB3 port. All of the ports are fully compliant with Advanced Microcontroller Bus Architecture (AMBA).

The CEVA-X2 supports 4 GB of data memory space and 4 GB of program memory space. Up to two 32-bit data addresses can be issued in every cycle to the data memory, as well as a single 32-bit program address to the program memory.

Program memory access is always aligned as a single 128-bit line (fetch-line). The fetch-line is fetched only when it is required by the PCU. Because the Dispatcher in the PCU is responsible for aligning them, instructions within the program memory are not aligned.

The CEVA-X2 DMSS uses Data DMA (DDMA) to transfer data between the local memory and an external memory, without interfering with core execution. In addition, the DMSS implements a special DMA Queue manager (QMAN) mechanism that enables the user to activate the DDMA without core intervention and without having to use real-time software.
****** Register File
The CEVA-X2 contains a General Register File (GRF) that consists of 32 32-bit registers. The registers are referred to as r0 through 63

The Predicate Register File (PRF) consists of the scalar predicate registers, which are used for scalar operations and load/store operations. Each predicate can be used as a multiple predicate for SIMD load/store and for SIMD operations to conditionally mask individual SIMD operations.
The CEVA-X2 includes 15 dual scalar predicate registers marked as prX.b(2). Each predicate register is a dual bit, and can be used for conditional execution of instructions.

The Address Register File (ARF) consists of a stack pointer, modulo registers, and step registers

The System Register File (SRF) consists of registers that control the program execution (for example, of the Program Counter (PC)) and return registers from subroutines and interrupts (retreg, retregi, and retregn). These registers are primarily used by the PCU.
****** Scalar Processing Unit
The Scalar Processing Unit (SPU) consists of two independent units named SPUx. The functional units perform independent operations in parallel, each according to the specific instruction within the instruction packet.
Each SPU instruction within the instruction packet can be independently conditional, based on one of 15 predicate registers. For single instruction multiple data (SIMD) type instructions, each operation can be masked separately (for more details, see Section 4.4).
The SPUs incorporate three execution stages. As a result, various instructions take a different number of cycles to execute. The number of stages an instruction requires for execution determines the cycle penalty before the result can be used by another instruction.
****** Load and Store Unit
The Load and Store Unit (LSU) does the following:
• Generates the address for the data
• Performs the data memory load and store operations
• Unpacks and packs the loaded and stored data
• Writes/reads it to/from the internal registers of the processor
The LSU includes two load and store units named LS0 and LS1. LS0 is used for loading data from the memory, and LS1 is used for storing data into the memory.
The LS0 and LS1 units support the following main mechanisms:
• Linear address generation of a 32-bit address according to one of the addressing modes. The address points to a byte location in the data memory space.
• Read bandwidth is 128 and write bandwidth is 128 bits for the SPU, LSU, and PCU units. This enables both the LS0 and LS1 to read and write their maximum bandwidth with byte alignment.
• Two types of address register modifications are available: linear modification and modulo modification. Each LSU can modify the general registers or the stack pointer.

The LS0 and LS1 units are connected to a common General Register File (GRF). The GRF contains 32-bit registers, general registers, step registers, and a stack-pointer register.

The LSU includes three mode registers that control the behavior of the post-modification and address-generation mechanisms.
All of the LSU instructions can be conditional using one of the predicate registers. The SPU contains dedicated instructions that can affect the predicate registers. In addition, dual short (S2) type load and store instructions can be predicated using the dual predicates to mask the load and store operations. This enables the LSU to load and store only part of the dual short according to the dual predicates.
****** Memory Accesses
******* Unaligned Memory Access
Unaligned data memory access is fully supported by the hardware without any core stall cycles. The ability to support aligned and unaligned accesses without penalty can have the advantage of fewer instructions, which leads to increased core performance and reduced code size.
******* LSU Operations
The LSU can manipulate the loaded and stored data types. In load operations, the LSU can read one data element from memory, change the element type, and then write it to the processor register. In store operations, the LSU can read the data element from the processor register, change the element type, and then store it to memory.
******* Read-after-Write Sequence
The write buffer adds latency to the write transactions; however, it must be transparent to the core read transactions. An address-match mechanism enables stalling the core reading data that is not yet written to memory.
****** Program Control Unit
******* Introduction
The Program Control Unit (PCU) handles the program memory interface, the alignment of instruction packets from the program memory, the dispatching of instructions to the various functional units, and the execution flow of instruction packets in the core.
Dedicated mechanisms in the PCU support both sequential and non-sequential instruction flows. The latter occurs due to branches and interrupts.
******* Instruction Dispatcher
The encoding scheme of the core is VLIW. This implies that an instruction packet is comprised of one or several instructions, where each instruction is associated with one of the core’s functional units. Each instruction occupies one slot in the instruction packet.
The instruction dispatcher identifies the instructions that form the instruction packet, and then issues each instruction to the functional unit(s) with which it is associated.
******** Alignment Unit
The Alignment unit identifies the instruction packet, and then loads it to the instruction register.
The instruction packet opcodes that are fetched from the program memory are stored in a temporary buffer, called the instruction queue
During sequential operations, the Alignment unit selects a group of 32 bits from the queue. The number of double-words (DWs) selected is determined by the fetch-line width, which is either four or eight DWs.
******** Dispatch Unit
The Dispatch unit issues all of the instructions that have to be executed in the current cycle (that is, the instruction packet) to the appropriate functional units. Immediate extension indications are also issued to the functional units by the Dispatch unit.
The input to the Dispatch unit is the instruction register, which is loaded by the alignment unit.
******* Program Sequencer
The Program Sequencer controls the fetching of instruction packets from the program memory, as well as all of the aspects of sequential and non-sequential instruction flows in the core.
The following elements form the Program Sequencer:
• Instruction Fetch Unit (IFU)
• Instruction decoder (for PCU instructions)
• Branch mechanism
• Branch target buffer mechanism (BTB)
• Interrupt handler
******** Instruction Fetch Unit
During each instruction fetch, four or eight consecutive DWs (core-type dependent) are fetched from the program memory: the DW at the current address, and seven (three) additional DWs from the addresses that immediately follow. The set of fetched DWs is called a fetch-line and its width is 128/256 bits.
The first address of the fetch-line must be a multiple of the fetch width. Instruction packet addresses can point to any word address within the fetch-line. Because the shortest instruction packet can be a word (two bytes), byte-address resolution is not needed for program memory addressing, which means that the LSB of the instruction packet address is always cleared.
********* Sequential Fetch Mechanism
Sequential fetching of instruction packets is performed when the core executes a sequential block of instruction packets.
During sequential operation, successive fetch-lines are read from memory. Each fetch-line contains one or more instruction packets.Because the number of instructions that are executed in parallel constantly varies, instruction packets are often fetched several cycles in advance (that is, ahead of the cycle during which they are needed).
A set of four registers, called the queue, is implemented in the program sequencer. Each fetched line is loaded to one of the queue’s registers, which provides temporary storage for instruction packets that are fetched in advance of their execution. The width of the queue registers is identical to the width of the fetch-line

Program memory fetches are not initiated every cycle. The fetch mechanism determines when to issue a program memory fetch, depending on the state of the queue.
The sequential fetch mechanism ensures correct and continuous program flow, and prevents overflow in the queue. In every cycle, this mechanism decides whether to issue a new fetch. The decision is based on the following information:
• The status of the queue (the number of valid words in the queue).
• The number of words that the current instruction packet consumes.
• The currently active fetches (because a fetch operation takes two cycles, the mechanism keeps track of fetches that were initiated in the two preceding cycles).
********* Non-SequentialFetchMechanism
A non-sequential instruction flow is an event in which the normal sequential flow of instruction packets is suspended, and an instruction packet from a different address is fetched. The non-sequential fetch mechanism generates all of the non-sequential addresses.
******** Program Sequencer Register Access
The set of directly accessible Program Sequencer registers is referred to as the Sequencer Register File (SRF).
******** Branch Mechanism
The target address of a branch-type instruction can be specified in the following ways:
• An absolute address encoded within the instruction opcode
• A relative offset (relative to the address of the branch instruction), encoded within the instruction opcode
• An absolute address specified within a GRF register
• An absolute address specified within one of the return registers

All of these instructions are multi-cycle. These instructions take several cycles to execute for the following reasons:
• Fetching the opcode of the instruction packet at the target address takes two cycles.
• The status of the condition (predicate register) is known only at a late pipeline stage.
To minimize the cycle penalty of these instructions, the following dedicated mechanisms are implemented in the PCU:
• Delay slots
• Branch prediction mechanisms: either using a Branch Target Buffer (BTB),
********* Delay Slots in Branch Instructions
The programmer can use up to four instruction packets in delay slots in most branch instructions.
The instruction packets in the delay slots must be composed of single-cycle instructions that do not break the pipeline. In addition, instruction packets in delay slots are non-interruptible.
********* Branch Target Buffer(BTB)
he BTB mechanism calculates the target address based on the current address. Its operation is done before any information is extracted from the instruction packet, and is based solely on the current fetch address and the past behavior of this fetched address. The BTB size is configurable for 128 or 256 entries.
********* Static Branch Prediction Support
If the taken/not-taken switch in the syntax is omitted, the default behavior for the branch instructions that are subjected to branch prediction is:
• Not-taken when the instruction is predicated
• Taken when no predicate is used

Determining whether a certain branch is mostly taken or not-taken is generally not as straightforward as in this example. To efficiently determine the best prediction switch for every branch, a profiler utility can be run on the code, and the selection of the prediction switches can be based on these statistics.

Correct prediction can reduce the cycle count of the branch by two cycles, and incorrect prediction can increase it by two cycles.
********* Call and Return Instructions
During the execution of a call instruction, the return address is written to an internal register, which is called retreg (return register). When a return instruction is executed, the return address is taken from the retreg register.
********* Target Instruction Packet Alignment
The target of a branch instruction can be located anywhere within a fetch-line, and instruction packets can cross fetch-line boundaries. If the instruction packet at the target of the branch crosses a fetch-line boundary, two lines must be fetched before execution of the instruction packet can begin.

The additional single-cycle penalty can be avoided by aligning instruction packets to the fetch-line boundaries that are targets of branch instructions and originally cross a fetch-line boundary. This can be done by padding the instruction packet preceding the target instruction packet with parallel nop instructions,
********* Exception Handling
The core supports the following interrupts:
• Six hardware maskable interrupts (INT0, INT1, INT2, INT3, INT4, and VINT)
• Four software maskable interrupts (trap{t0}, trap{t1}, trap{t2}, and trap{t3})
• One non-maskable interrupt (NMI)
• One non-maskable software interrupt (trap)
• One emulation software interrupt (trape)
• Two hardware breakpoint interrupts (BI and PABP)
********** Interrupt Latency and Non-Interruptible States
Latency of the NMI, INT0, INT1, INT2, INT3, INT4, VINT and BI interrupts is two cycles, assuming that the core is in an interruptible state. The interrupt latency is calculated as the number of cycles between the assertion of the interrupt request and activation of the appropriate interrupt acknowledge signal.

The penalty for the hardware interrupts (NMI, INT0, INT1, INT2, INT3, INT4, VINT, and BI) is five cycles, assuming that the processor is in an interruptible state. The interrupt penalty is calculated as the number of cycles in which the core does not execute any instructions.
****** Pipeline
The following is a description of the common stages:
• IF: Instruction Fetch, which is divided into two sub-stages: IF1 and IF2
• D: Dispatch/Decode, which is divided into two sub-stages: D1 and D2
• A: Address Generation, one stage
• M: Memory Access, one stage
• E: Scalar Execution, which is divided into four sub-stages: E1, E2, E3, and E4
******* Instruction Fetch Stages
Instruction fetch execution operates over two stages, IF1 and IF2:
• IF1: During this stage, the program address is issued by the PCU. The program address is decoded by the MSS and a memory read is initiated.
• IF2: This stage is dedicated for program memory access. The fetch-line is registered in the instruction queue at the end of this stage. The size of the fetch-line is either 128 bits or 256 bits.
******* Dispatch/Decode Stages
Dispatch/decode execution operates over two stages, D1 and D2:
• D1: The core selects a packet of 16, 32, 48, or 64 bits from the queue. This packet contains the instruction packet that is either the next instruction or a group of instructions that should be executed in parallel. At the end of this stage, the instruction packet register is loaded with the instruction packet.
• D2: In this stage, each instruction within the instruction packet register is dispatched to the appropriate unit in the core.
******* Address Generation Stages
Address generation execution operates over two stages, A and M:
• A: The core reads the relevant registers and performs address and modulo calculation and read/write strobe generation. The pointer’s post-modification value is calculated.
• M: Address post-modification results are written to the register file and data memory is accessed. Registers are read from the register file into the SPUs.
******* Scalar Execution Stages
Scalar execution operates over four stages, E1, E2, E3, and E4:
• E1: Single-stage scalar operations are executed.
• E2: Dual-stage scalar operations (multiply) are completed.
• E3: Accumulation is performed on MAC-type operations.
• E4: Results are written to the register file.
***** MSS
****** overview
The CEVA-X1/CEVA-X2 MSS supports up to 4 GB of unified memory space for program memory (PMEM) and 4 GB for data memory (DMEM), and has up to four separate physical interfaces: up to three for data memory and one for program memory. This enables the core to simultaneously access both the program and data memories.
The MSS provides the CEVA-X1/CEVA-X2 DSP core with simultaneous accesses to one instruction fetch stream and two data fetch streams. The Load Store Unit (LSU) is responsible for accessing the data memory, and the Program Control Unit (PCU) is responsible for accessing the program memory.
The CEVA-X1/CEVA-X2 MSS can access two different types of memories: internal memories, also referred to as local memories (on-chip), and external memories (which might be located on-chip and/or off-chip). While the core accesses the internal memories with no wait-states, accessing the external memories might require several wait-states.
The CEVA-X1/CEVA-X2 MSS contains standard interfaces for connecting the core to external devices and/or peripherals. These interfaces include up to four AXI master ports (program and data), up to four AXI slave ports, and an APB3 port. All of the ports are fully compliant with the Advanced Microcontroller Bus Architecture (AMBA). The MSS also contains JTAG and APB3 interfaces for debug support.
****** Program Memory Subsystem
The PMSS supports highly predictable execution times as well as less predictable execution times. Software designers can have complete control over the location of the instructions within the PMSS; for example, time-critical code can run from either the local memory or from a locked cache-line, while less-time-critical code can run either from the cache or from the external memory directly. This enables them to benefit from both the highly predictable execution provided by a local memory, as well as the flexible software development capabilities provided by a cache.

The PMSS is connected to an external memory controller via an AMBA4 interface. The cache consists of a memory set that holds the actual cached line data, as well as a tag memory, which is used to determine whether an address is cached and whether the instruction is valid. Tightly Coupled Memory (TCM) is also supported and is accessed with zero wait-states
******* Feature List
The PMSS supports the following main features:
● 4 GB program memory linear space
● Configurable TCM memory size
● Software and hardware pre-fetch capability
● Program DMA (PDMA)
● Four-way set-associative instruction cache
● Cache software operations (invalidation, pre-fetch, lock, and unlock)
● MP_PORT_WIDTH bit-wide AXI master port
● Optional ECC; one error correction and two error detections on all RAM and cache blocks
● Non-blocking cache and fetch-line access
******* Program Memory Controller
The Program Memory Controller (PMC) is responsible for controlling access to the TCM, the cache, and the external memory from the core.
For core access, the PMC receives a program address and a read indication. The address is only applied to the set and tag memories if the address falls outside of the TCM boundary.
When no TCM address is accessed, the program fetch-line is either served to the core queue with zero latency (for a cache hit), or fetched from the external memory (for a cache miss or non-cacheable region).
In any core access to a non-TCM address space, the PMC checks the cacheable attribute of the corresponding IACU region. When the address is mapped to a cacheable region, the tag data of each way is compared with the requested address, and the result (combined with the valid state) is used to determine a hit/miss. When the address is mapped to a non-cacheable region, the PMC sends the request to the EPP.
******* Internal Program Memory
The internal program memory contains the program fetch-lines that are read whenever a fetch-line is requested by the core. The PMSS consists of a TCM and an instruction cache. Both the TCM and the instruction cache (on a hit) are accessed with zero wait-states.
******* L1 Instruction Cache
● Optional four-way set-associative cache
● Zero-cycle stall on a hit
● Hardware-configurable size
● Pseudo-LRU replacement policy
● Hardware pre-fetch
● Miss pipeline support
● Non-blocking read support
******** Handling Cache Misses
********* Read Misses
L1IC read misses initiated by the core (as well as pre-fetches) are handled by requesting a cache-line fill from the external memory. A cache-line fill is requested from the EPP, and then the returned cache-line is written to the way specified by the L1IC replacement algorithm (the victim way).
If the request was initiated by the core and each cache-line contains two core fetch-lines, the requested fetch-line is requested first using a WRAP transaction from the AXI and served to the core directly and to the cache.
If the request was to abort, the cache-line request is aborted if the AXI transaction was not yet initiated, or it is written only to the cache if it was already sent to the AXI.
********* Non-Blocking Read Miss
To serve the core with the requested data as soon as it is available, the cache- line fills requests from the EPP using a WRAP burst request, where the core-requested fetch-line arrives first and is served to the core, while the rest of the cache-lines arrive on the following beats into the cache without interfering with the core. When the cache-line request was initiated by a software operation, the cache-line fill still uses a WRAP burst request that is started from the beginning of the cache-line.
********* Program Direct Memory Access
The Program Memory Controller includes a direct memory access unit (PDMA) that performs downloads from the external memory to internal program memory.
******* External Program Port
The external memory is accessed in the following cases:
● A cache miss occurs. The PMC requests a cache-line (using a four-beat WRAP burst) from the external port.
● The core requests an instruction from an address that is outside of the TCM range, and the requested address is to a non-cacheable region (or the cache is disabled) using a two-beat WRAP burst.
● The PDMA download reads from external memory and writes to the internal memory.
● When the OCEM accesses the EPP for a read or write, the OCEM uses a one-beat burst for write accesses and a two-beat burst for read accesses.
****** Data Memory Subsystem
******** Overview
The Data Memory Subsystem (DMSS) provides data from either the local memory or the external memory to the CEVA-X1/CEVA-X2 core.
The DMSS is both hardware- and software-configurable, which enables hardware and software designers to have complete control over its structure, functionality, and performance. End users have control over the availability of different components (such as the number of AMBA ports and the size of the local RAMs).
The DMSS supports highly predictable execution times by placing data in the local memory. Software designers can have complete control over the location of the data within the DMSS; for example, time-critical data can run from the local memory, while less-time-critical data can run from the external memory.
The DMSS is designed to achieve a balance between high performance, small area, and low power consumption, which enables it to be used in a wide variety of systems and applications.
The DMSS is subdivided into the IDM and the external memory:
● The IDM, which is part of the MSS, contains a relatively small amount of memory, and is also referred to as the local memory.
● The external memory can be located on-chip and/or off-chip, and is accessed via one of the AXIm0/AXIm1 master ports or the External Data Port (EDP).
The CEVA-X1/CEVA-X2 core can issue a load and store operation simultaneously:
● The L (load) unit connects to the DMSS using an LD_WIDTH-bit read bus.
● The S (store) unit connects to the DMSS using an ST_WIDTH-bit write bus.
The SPU accesses the data memory without any alignment restriction.
******** feature list
********* Non-Blocking Write Support
The L1 cache supports non-blocking writes. This means that, after a write miss, the core is not stopped and the cache-line fill process is continued in parallel with the core normal operation.
********* Non-Blocking Read Support
The L1 cache supports non-blocking reads. This means that, after a read miss, the cache-line fill request starts from the core-requested address (using a WRAP request) and will serve it to the core.
This prevents the core from halting while the rest of the data is written to the cache-line. The cache-line fill process is continued in parallel with the core’s normal operation.
******** Internal Data Memory
Because multiple sources can access the IDM simultaneously, it is divided into either two or four blocks to reduce the possibility of conflicts between the various accesses. Two or four blocks are selected during IP installation. If a block and/or bank conflict occurs, a wait cycle is inserted to the non-granted source(s).
The IDM can be configured as follows:
● 512 KB, 256 KB, 128 KB or 64 KB memory size configuration.
● Two or four block memory structure (the various units can transfer data located in various blocks without conflicts).
● Total block memory width is 2 x LD_WIDTH bits.
● Each block is composed of N= LD_WIDTH/16 memory banks. The addresses are interleaved over the banks within each block, in the same row boundaries.
● Each bank is 32 bits wide (4-byte write enabled).
******** Data Write Buffer
The CEVA-X1/CEVA-X2 core issues the address and controls (that is, read/write and size) in the M stage of the pipeline. The data in write transactions is available in the E3 stage, three cycles later. An address delay mechanism is implemented to ensure the proper functionality of the memory during write transactions.
An address delay is used to synchronize the data with its respective address. When ready, the address (along with the data and transaction attributes) is pushed into one of the queue buffers that administer the pending write transactions. The WB queue reduces core wait cycles that can occur as a result of memory bank conflicts.
The WB unit is divided into the following functional blocks:
● LS address delay line
● One queue
● LS read-after-write and strong ordering (RAW/SO) match blocks

The WB queue has two entries, each containing a single element that is comprised of a 32-bit address, ST_WIDTH-bit data, and attributes. The queue has one input port and two output ports (WBA, WBB). All writes to an IDM memory bank, as well as all writes to the external memory, are written in the order they occur in the core, but later IDM writes can be written before earlier writes to the external memory if the external port is not available.
******** L1 Data Cache
The L1 Data Cache (L1DC) is responsible for servicing data accesses from the core for L1DC-cacheable data. The main L1DC features are:
● Optional two/four-way set-associative cache
● Zero-cycle stall for way hit
● Write-Through and Copy-Back write policy
● Hardware-configurable size and structure
● Pseudo-LRU victim way selection
● Software pre-fetch, invalidate, flush, lock, and unlock of cache entries
● Hardware pre-fetch
● Miss pipelining support
● Non-blocking read and write support
● Cross tags unaligned support
********* Non-Blocking Cache
L1DC read and write accesses are non-blocking cache accesses, which means that the core is only stopped when the MSS cannot accept data from the core or cannot provide the core with the requested data. It is not stopped when the L1DC is busy with internal operations (for example, cache-line fill or software operations).
******** Queue and Buffer Managers
The CEVA-X1/CEVA-X2 data memory subsystem (DMSS) implements a special DMA manager (DMAN) that enables users to activate the DDMA without using real-time software.
The DMAN is composed of two main components:
● Queue Manager (QMAN): Manages queues of DMA tasks by selecting the next task to be executed by the DDMA.
For more details, see Section 3.14.1.
● Buffer Manager (BMAN): Implements FIFO-based memory management by sending source and/or destination buffer status indications to the QMAN.
****** Memory Subsystem Programming Model

***** Tensilica
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791ED1@srv-mail-02.actions.com.cn][转发:Tensilica DSP的资料]]
***** 3605D
****** 开发
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F1035B7155@srv-mail-02.actions.com.cn][答复: GS700E 拉一个开发分支同步LS370A(GL5202E)]]
****** 规格
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A902BF@srv-mail-02.actions.com.cn][LS360F MRD]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749063297F5@srv-mail-02.actions.com.cn][转发: 发送电子邮件: US282A ASET工具调音说明_V2.2_20170331.pdf, ASET在线调试工具usb通信协议.doc]]

****** 火百灵
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311027918C2@srv-mail-02.actions.com.cn][火百灵方案的规格]]
******* TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0514426C@srv-mail-02.actions.com.cn][火百灵&PVo的KT案子深圳会议]]
******* TODO [[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791BE3@srv-mail-02.actions.com.cn][RE: ATS3605 EVB对接CX20810的驱动调试]]
******* TODO [[mu4e:msgid:tencent_15169A6E2DED8EBA56372239@qq.com][回复：答复: 回复：答复:  ATS3605软件需求总结]]
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791B13@srv-mail-02.actions.com.cn][转发: 火百灵方案的规格]]
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791B12@srv-mail-02.actions.com.cn][转发: AP6356S datasheet_V1.1_03182015(1).pdf]]

****** alsalib
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10353B84F@srv-mail-02.actions.com.cn][alsalib使用文档]]
****** TODO 64M 内存确认
****** 架构评估
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C3EB@srv-mail-02.actions.com.cn][LS3605D_方案架构评估报告]]
****** 播放器
https://en.wikipedia.org/wiki/Media_player_(software)
******* VLC
https://en.wikipedia.org/wiki/VLC_media_player
https://wiki.videolan.org/LibVLC
https://wiki.videolan.org/VLC_media_player/
******* MPlayer
https://en.wikipedia.org/wiki/MPlayer
******** MPlayer can play many formats, including:[9]
Physical media: CDs, DVDs, Video CDs, Blu-ray discs
Container formats: 3GP, AVI, ASF, FLV, Matroska, MOV (QuickTime), MP4, NUT, Ogg, OGM, RealMedia, Bink
******** Video formats:
Cinepak, DV, H.263, H.264/MPEG-4 AVC, HuffYUV, Indeo, MJPEG, MPEG-1, MPEG-2, MPEG-4 Part 2, RealVideo, Sorenson, Theora, WMV, Bink
******** Audio formats:
AAC, AC3, ALAC, AMR, DTS, FLAC, Intel Music Coder, Monkey's Audio, MP3, Musepack, RealAudio, Shorten, Speex, Vorbis, WMA, Bink
******** Subtitle formats:
AQTitle, ASS/SSA, CC, JACOsub, MicroDVD, MPsub, OGM, PJS, RT, Sami, SRT, SubViewer, VOBsub, VPlayer
******** Image formats:
BMP, JPEG, MNG, PCX, PTX, TGA, TIFF, SGI, Sun Raster
******** Protocols:
RTP, RTSP, HTTP, FTP, MMS, Netstream (mpst://), SMB, ffmpeg:// (Uses FFmpeg's protocol implementations)
******** output driver
MPlayer can also use a variety of output driver protocols to display video,
including VDPAU, the X video extension, OpenGL, DirectX, Direct3D, Quartz Compositor, VESA, Framebuffer, SDL and rarer ones such as ASCII art (using AAlib and libcaca) and Blinkenlights. It can also be used to display TV from a TV card using the device tv://channel, or play and capture radio channels via radio://channel|frequency.
******** Interface and graphical front-ends
Gnome-MPlayer v1.0.9 on GNOME with the "Adwaita" Dark theme
Like GStreamer, MPlayer is a command-line application and there are a couple of front-ends available, which use GUI widgets of GTK+, Qt or some other widget library. When not using these front-ends, mplayer can still display video in a window (with no visible controls on it), and is controlled using a keyboard.
GTK+-based are gmplayer (official[10][11]) and Gnome-MPlayer
Qt-based are SMPlayer and KMPlayer, among others.
Cocoa-based are MPlayer OS X Extended and MPlayerX[12]
******* GStreamer
https://en.wikipedia.org/wiki/GStreamer
******** Video acceleration
Through special plugins provided by Texas Instruments, GStreamer makes use of hardware acceleration provided by e.g. Texas Instruments DaVinci.
There are various SIP blocks that can do the computations to decode certain video codecs, such as PureVideo, UVD, QuickSync Video, TI Ducati and more. Such needs to be supported by the device driver, which in turn provides one or multiple interfaces, like VDPAU, VAAPI, Distributed Codec Engine or DXVA to end-user software like MPlayer to access this hardware and offload computation to it.

It is possible to use Video Coding Engine with GStreamer through the OpenMAX IL wrapper plugin gst-omx.[17] This is for example possible on the Raspberry Pi.[18]
The SIP core present on some Texas Instruments SoCs is also accessible through GStreamer: gst-dmai, gst-openmax, gst-dsp.[19]
VDPAU and VAAPI are supported with GNOME Videos >= 2.28.0 and GStreamer >= 0.10.26 since 2010[20]
********* VDPAU
Video Decode and Presentation API for Unix (VDPAU) is a royalty-free application programming interface (API) as well as its implementation as free and open-source library (libvdpau) distributed under the MIT License.[1]

The VDPAU interface is to be implemented by device drivers, such as Nvidia GeForce driver, nouveau, amdgpu, to offer end-user software, such as VLC media player or GStreamer, a standardized access to available video decompression acceleration hardware in the form of application-specific integrated circuit blocks on graphics processing units (GPU), such as Nvidia PureVideo or Unified Video Decoder and make use of it.
********* VAAPI
Video Acceleration API (VA API) is a royalty-free API as well as its implementation as free and open-source library (libVA) distributed under the MIT License.

The VA API interface is to be implemented by device drivers to offer end-user software, such as VLC media player or GStreamer, access to available video acceleration hardware, such as PureVideo (through the libva-vdpau driver, which implements VA API in terms of VDPAU) or Unified Video Decoder.

The API enables and provides access to hardware-accelerated video processing, using hardware such as graphics processing units (GPU) to accelerate video encoding and decoding by offloading processing from the central processing unit (CPU).
******** Media formats
The Good, Bad and Ugly GStreamer plugins mentioned earlier provide, alongside processing elements/filters of all kinds, support for a wide variety of file formats, protocols and multimedia codecs.

In addition to those, support for more than a hundred compression formats (including MPEG-1, MPEG-2, MPEG-4, H.261, H.263, H.264, RealVideo, MP3, WMV, FLV, etc.[22][23]) is transparently provided through the GStreamer FFmpeg/libav plug-in. See the Libav and FFmpeg pages for a complete list of media formats provided by these plug-ins.

******* OpenMAX
https://en.wikipedia.org/wiki/OpenMAX#Integration_layer
******** OpenMAX AL
https://www.khronos.org/openmax/al/
********* profile
********** DATA ACCESS
Playback of audio and video files Y
Rendering of image sources Y
Recording and storage of audio and video sources Y
Capture and storage of image sources Y
Support for various media container formats Y
Specify a stream source (local/remote file, memory/flash, etc.) Y
Identify data sources by name, such as URL/URI, or by file handle Y
Respect DRM Y
Select an input source from among a multitude of available inputs Y
Select an output destination from among a multitude of available outputs
********** DEVICE CAMERA
Camera flash activation Y
Camera Effects Y
Exposure settings (exposure time, aperture and ISO sensitivity) Y
Focus control (including macro-focus on/off) Y
White balance control Y
Optical and digital zoom
********** PLAYBACK, RECORDING AND PROCESSING CONTROLS
“VCR-type” playback modes: play, pause, stop, rewind, fast-forward Y
Play multiple sounds at a given time Y
Playback of raw PCM audio Y
Playback of sampled audio encoded in a form other than raw PCM
Playback of mono and stereo sampled audio Y
Volume control Y
Audio balance control Y
Audio pan control Y
End-to-end looping of audio/video content Y
Audio/video segment looping Y
Seeking to a seek point (such as chapter) Y
Route media to multiple simultaneous outputs Y
Set a sound’s priority Y
Audio equalization Y
Audio recording from a microphone or on-device line-in jack Y
Audio recording from another software component Y
Record audio to a non-PCM format Y
Recording modes: record and stop Y
Query the estimated size of the output image based on current image settings
********** PER-APPLICATION SETTINGS
Use key-value pairs to query and set both the codec and non-codec configurations of the underlying media engine
********** PER-OBJECT SETTINGS
Set video encoder properties: frame rate, bitrate (constant/variable), size, resolution, duration limit and codec format
Set audio encoder properties: bitrate (constant/variable), channel count, duration limit, sampling frequency, codec format, size, and resolution
Set image encoder properties: codec format, size and resolution
Set and query image/video encoder special effects, if supported. Effects include, but are
not limited to, “monochrome”, “sepia”, “emboss”, “paintbrush”, “solarize”, “red-eye Y reduction”, “cartoon” and “negative”
********** METADATA
Extract metadata from media files and embedded media streams
Insert/edit metadata in recorded media content
********** EVENT AND ERROR NOTIFICATIONS
Callbacks for periodic media positioning (such as for progress bar) Y
Callback alerts when playback is in a prescribed position (such as for looping) Y
Callbacks for error conditions
********** CAPABILITY QUERIES
Enumerate and query the capabilities of available input sources
Enumerate and query the capabilities of available output destinations
Query the API version number
Query capabilities of the OpenMAX AL implementation
********** MISCELLANEOUS
Query the degree to which an OpenMAX AL implementation is based on OpenMAX IL: none, partial or full
Extensibility
Minimum 16-bit PCM audio output
********** To create an object process:
• Create and realize an engine object if one has not been created already.
• Obtain the XAEngineItf interface from this object.
• Call the appropriate object creation method of this interface.
• If the call succeeds, the method will return an XAObjectItf interface of the new object.
• After working with the object, call the Destroy() method of the XAObjectItf to free the object and
its resources.
********** The Relationship Between Objects and Interfaces
The set of interfaces exposed by an object is determined by three factors:
• The object’s type
• The interfaces requested by the application during the object’s creation
• The interfaces added and removed by the application during the object’s lifetime
********* Object Overview
OpenMAX AL represents entities in its architecture as objects, including:
• Engine Object
• Media Objects
• Metadata Extractor Object
• Audio Output Mix Objects
• Camera Objects
• LED Array Objects
• Radio Objects
• Vibration Control Objects
********** Engine Object
The engine object is the entry point to the OpenMAX AL API. This object enables you to create all the other objects used in OpenMAX AL.
The engine object is special in the sense that it is created using a global function, xaCreateEngine
The engine object represents the system’s various multimedia-related devices via unique device IDs. It supports the enumeration of audio input, audio output, camera, radio, LED and vibrator devices as well as mechanisms to query their capabilities.
********** Media Objects
A media object implements a multimedia use case by performing some media processing task given a prescribed set of inputs and outputs. Media objects include (but are not limited to) objects that present and capture media streams, often referred to as players and recorders, respectively. They operate on audio, video, and image data or some combination of them.
The following characteristics define a media object:
• The operation it performs, denoted by the creation method used to instantiate the media object.
• The inputs it draws data from, denoted as its data sources and specified at media object creation.
• The outputs it sends data to, denoted as its data sinks and specified at media object creation.
********** Metadata Extractor Object
Player objects support reading of the metadata of the media content and recorder objects support writing metadata. However, sometimes it is useful just to be able to read metadata without having to be able to playback the media.
Metadata Extractor object can be used for reading metadata without allocating resources for media playback.
********** Audio Output Mix Object
The API allows for routing of audio to multiple audio outputs and includes an audio output mix object that facilitates this functionality. The application retrieves an output mix object from the engine and may specify that output mix as the sink for a media object.
********** Camera Object
Control of one of the device’s cameras is handled via the Camera object. The number of cameras supported by a device and their capabilities can be retrieved from the media engine via the XACameraCapabilitiesItf interface. A camera I/O device exposes the XACameraItf interface, which is used to control camera features such as flash, focusing, metering, exposure compensation, sensitivity, shutter speed, aperture, white balance, and zoom. The camera I/O object is connected to a media recorder media object to capture still images or video.
********** Display Regions
Conceptually OpenMAX AL maintains three separate notions relating to the visual output:
• Display: Corresponds to the entire logical screen area (or “desktop”). The display is provided by the native windowing manager in the form of a native handle. All interaction with this entity is handled exclusively via native interfaces using the native handle (not via OpenMAX AL). Multiple media objects may operate on the same display.
• Window: Corresponds to the window within the display. A window may be sized to encompass the entire display and yet it is considered an independent entity (for instance, a fullsize window may be later sized down to a region less than the entire display or have other windows on top of or behind it). The window is provided by the native windowing manager in the form of a native handle. All interaction with this entity is handled exclusively via native interfaces using the native handle (not via the OpenMAX AL). Multiple media objects may operate on the same window.
• Region: Corresponds to the area within the native window where the media object presents its output. This may include the entire window area or be some subset of the window area. The region is specific to a particular media objec
********* OpenMAX AL Use Cases
------------
********** Audio and Video Playback
------------------
[[./pic/屏幕快照 2017-05-26 下午11.33.12.png]]

******** Implementations
Android 4.0 and later exposes OpenMAX AL as part of its NDK (Native Development Kit).[15]
LIM OpenMAX is an open source implementation of OpenMAX AL and OpenMAX IL for Linux
Bellagio is an open source OpenMAX IL implementation for Linux maintained by STMicroelectronics.[16]
Tizonia is an open source OpenMAX IL implementation for Linux[17]
GStreamer (GST) is an open source multimedia framework used by several application, and it can use OpenMAX IL modules with its "gst-omx" module.[18]
C-only, optimized for NEON (Cortex A8) and SIMD (for ARM11 cores using ARMv6 architecture) optimized OpenMAX DL libraries are available at [1][19]
********* Bellagio
http://omxil.sourceforge.net

******** Comparison with OpenSL ES
OpenSL ES (Open Sound Library for Embedded Systems) is another Khronos Group API that also provides an audio library for the same target market as OpenMAX AL. OpenSL ES and OpenMAX AL share the same common architecture and have a few common features:

Audio playback and recording
Basic MIDI playback
Metadata extraction

****** qq物联
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906260A58@srv-mail-02.actions.com.cn][答复: 关于QQ物联SDK依赖库]]
****** cx20810
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791AB8@srv-mail-02.actions.com.cn][ATS3605 EVB对接CX20810的驱动调试]]
****** open WRT
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C400@srv-mail-02.actions.com.cn][openwrt_sqlite]]
******* share lib 空间优化
https://stackoverflow.com/questions/31354641/c-reduce-library-size-by-excluding-unnecessary-functions-programmatically
https://stackoverflow.com/questions/8021470/how-to-optimize-size-of-shared-library

******** elf
https://docs.oracle.com/cd/E19683-01/817-3677/6mj8mbtc9/index.html#chapter6-73709

***** as216B
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311027918A8@srv-mail-02.actions.com.cn][AS216B项目开发进展]]
AS216B项目的代码已经上传到svn代码服务器：
http://srv-fw:8080/SVN2/AS216B/trunk/AS216B
** 支持工作
*** v700
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B530E9@srv-mail-02.actions.com.cn][答复: V700分体机闪屏抖屏问题]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749062609E9@srv-mail-02.actions.com.cn][答复: 【V700】小辣椒-视频播放问题]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD062031C81@srv-mail-02.actions.com.cn][答复: 雅士V700生产问题汇总]]
[[mu4e:msgid:1215223C59CBD54AA38F93133AF342D503DF5EE0@srv-mail-02.actions.com.cn][答复: V700: 屏幕同比缩放显示]]
*** S900
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061654A7@srv-mail-02.actions.com.cn][答复: 深圳图麟科技计划采用贵公司S900系列芯片，请给予必要的技术支持]]
**** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0514420A@srv-mail-02.actions.com.cn][VR unity行业apk咨询]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEB692@srv-mail-02.actions.com.cn][答复: S900配置PMU SGPIO端口]]
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B051446FE@srv-mail-02.actions.com.cn][答复: S900电量计相关问题讨论]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52C78@srv-mail-02.actions.com.cn][答复: S900电量计相关问题讨论]]
**** TODO [[mu4e:msgid:0E3AB831E505F842818BA4F9798C30A4016F275B@srv-mail-02.actions.com.cn][答复: 答复: 答复: 答复: OpenMaxIL]]
*** S700
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52AF4@srv-mail-02.actions.com.cn][答复: 【CB7】【CVBS】兼容性问题]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52AAD@srv-mail-02.actions.com.cn][答复: 【瑞泰】【S700】【CVBS】客户添加cvbs导致gpu异常，系统卡死在android动画]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEB59A@srv-mail-02.actions.com.cn][S700 gpu&core调频调压修改]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52D9B@srv-mail-02.actions.com.cn][S700 cb6 开机进入桌面插入耳机点击触摸屏有噪音]]
**** TODO [[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52A47@srv-mail-02.actions.com.cn][【瑞泰】【S700】【显示】 S700平台cvbsout功能需求]]
**** TODO [[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEB3ED@srv-mail-02.actions.com.cn][答复: 答复: 【众联科技】【S700】【WIFI】Miracast sink不稳定问题]]
***** TODO [[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52B3E@srv-mail-02.actions.com.cn][答复: s700 usb转sata上电问题patch]]
*** S500
*** TODO [[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B5330D@srv-mail-02.actions.com.cn][答复: S500&S700 HDMI为主显开机后插入支持EDID自适应最高分辨率]]
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F1035B7749@srv-mail-02.actions.com.cn][答复: S500&S700 HDMI热插拔分辨率]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B5299C@srv-mail-02.actions.com.cn][答复: 【方糖】【S500】【显示】开机logo不正常]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52B84@srv-mail-02.actions.com.cn][答复: S500 领芯 台式机 插USB口的3G或4G模块上网黑屏死机]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52F99@srv-mail-02.actions.com.cn][答复: 2603C 的A版B版的问题]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52E17@srv-mail-02.actions.com.cn][【全星】【59plus】【HDMI】客户自带HDMI显示器不能点亮]]
*** 7059
大华案子
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B05145027@srv-mail-02.actions.com.cn][答复: 2603C 的A版B版的问题]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52E17@srv-mail-02.actions.com.cn][【全星】【59plus】【HDMI】客户自带HDMI显示器不能点亮]]
[[mu4e:msgid:1215223C59CBD54AA38F93133AF342D503DF5B3F@srv-mail-02.actions.com.cn][答复: 7059 - I2C 2 时钟配置无效问题]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEB6E3@srv-mail-02.actions.com.cn][转发: 7059C 调试10.1寸屏MIPI屏资料]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52A9E@srv-mail-02.actions.com.cn][转发: 关于7059/S500 广告机 老化视频时 视频暂停的问题 setVideoSurfaceTexture failed: -22]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906329A27@srv-mail-02.actions.com.cn][答复: 写特定mac地址后系统kernel panic问题]]
*** 7051
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEB17A@srv-mail-02.actions.com.cn][【7051】降低给视频播放预留的内存大小]]
* vendor
** 富迪
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791856@srv-mail-02.actions.com.cn][FW: 拜访富迪的出差报告]]
** TODO [[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F7490625FFF6@srv-mail-02.actions.com.cn][答复: 我已与您共享文件CK803]]
** 96board
[[mu4e:msgid:45C9CD6E9A1F8E40A999E51EF137BF15324B7C@srv-mail-02.actions.com.cn][about Linaro 96board-IoT Edition for Actions ATS3503]]
** 科胜讯
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EBAF5@srv-mail-02.actions.com.cn][RE: Actions与Conexant技术支持对接]]
** broadcom
蓝牙语音遥控器
[[mu4e:msgid:2017050817343430007115@yippee-elec.com][回复:<矩芯/意天> 提供语音遥控器头端补丁]]
** mbed
是的，mbed OS 5 可以用了
https://makerdiary.co/introducing-mbed-os-5/
https://makerdiary.co/open-hardware-nrf52832-mdk/
** 庆科
mico
http://developer.mico.io
** 4G模块
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04FA9EC7@srv-mail-02.actions.com.cn][问个4G模块的事]]
** 易观
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB93C@srv-mail-02.actions.com.cn][易观：智能语音应用专题分析——中国人工智能行业系列分析2017V11.pdf]]
** st
iot sdk
http://www.st.com/zh/evaluation-tools/b-l475e-iot01a.html
** 南方硅谷
*** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B049D58F4@srv-mail-02.actions.com.cn][答复: 有关南方硅谷Wifi 模组采购]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8FB81@srv-mail-02.actions.com.cn][有关公司WIFI  IP  外购的可能性]]
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0503D310@srv-mail-02.actions.com.cn][ATS3503炬芯和南方硅谷的加快协同开发的会议说明]]
** google
*** GMS
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A246DF@srv-mail-02.actions.com.cn][转发: Pegatron 3PL Newsletter]]
*** TODO Android O
http://www.androidcentral.com/android-o
JSON Web Token - 在Web应用间安全地传递信息
http://blog.leapoahead.com/2015/09/06/understanding-jwt/
*** google cloud
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10336C94F@srv-mail-02.actions.com.cn][转发: Google Follow-up]]
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10336C94E@srv-mail-02.actions.com.cn][转发: Google Cloud Follow-up (Google I/O Launch)]]
*** speech api
http://blog.laobubu.net/546
https://cloud.google.com/speech/
https://cloud.google.com/speech/docs/how-to
** arm
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB4FB@srv-mail-02.actions.com.cn][ARM的AD5 IP的介绍和效果演示]]
** baidu
*** 百度语音 asr
**** key
App ID: 9345458
API Key: mG95q1G6tQNgj3HkeKTMncW1
Secret Key: df6c11e2c11837c9453f21982766528b

("access_token"
 "24.38056c3ed01c466c5f60e8574be1b6aa.2592000.1491111095.282335-9345458"
 "session_key"
 "9mzdCPw6/Hqv7jUAHFcC0PV7eQffG2TPRzOTaQpQsmZ9o8HL28vlp5fdQivsGEhBtMIfK/k2qq2gKq3k1lTEuNVRcfl8"
 "scope"
 "public audio_voice_assistant_get audio_tts_post wise_adapt lebo_resource_base lightservice_public hetu_basic lightcms_map_poi kaidian_kaidian wangrantest_test wangrantest_test1 bnstest_test1 bnstest_test2 ApsMisTest_Test权限 vis-classify_flower"
 "refresh_token"
 "25.adc3662ac8277f931d20a1bd9e5f10a6.315360000.1803879095.282335-9345458"
 "session_secret" "c4f5b77109726d468d85e9bbe36b352f" "expires_in" 2592000)

**** lisp code
(setf drakma:*header-stream* *standard-output*)

(let ((stream (drakma:http-request "https://openapi.baidu.com/oauth/2.0/token"
                                   :method :post
                                   :close nil
                                   :want-stream t
                                   :parameters
                                   '(("grant_type" . "client_credentials")
                                     ("client_id" .
                                      "mG95q1G6tQNgj3HkeKTMncW1")
                                     ("client_secret" .
                                      "df6c11e2c11837c9453f21982766528b")))))
  (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
  (yason:parse stream :object-as :plist))


(let ((stream (drakma:http-request "http://vop.baidu.com/server_api"
                                   :method :post
                                   :close nil
                                   :want-stream t
                                   :content #p "/Users/zhangdongfeng/Desktop/2017/3503/baidu/Baidu_Voice_RestApi_SampleCode/sample/test.pcm"
                                   :content-type "audio/pcm;rate=8000"
                                   :content-length 52512
                                   :parameters
                                   '(("cuid" . "serial987654321")
                                     ("token" .
                                      "24.38056c3ed01c466c5f60e8574be1b6aa.2592000.1491111095.282335-9345458")))))
  (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
  (yason:parse stream :object-as :plist))

(defun get-voice-upload-json ()
  (let* ((pcm (file-at-once #p "/Users/zhangdongfeng/Desktop/2017/3503/baidu/Baidu_Voice_RestApi_SampleCode/sample/test.pcm" :element-type 'unsigned-byte )))
    (with-output-to-string (s)
      (yason:encode
       (alexandria:plist-hash-table
       `("format"  "pcm" "rate" 8000  "channel" 1
                    "cuid" "serial987654321"
                    "token" "24.38056c3ed01c466c5f60e8574be1b6aa.2592000.1491111095.282335-9345458"
                    "speech" ,(cl-base64:usb8-array-to-base64-string pcm)
                    "len" ,(length pcm))
        :test #'equal)
       s))))

(let ((stream (drakma:http-request "http://vop.baidu.com/server_api"
                                   :method :post
                                   :close nil
                                   :want-stream t
                                   :content (get-voice-upload-json)
                                   :content-type "application/json"
                                   :content-length (length (get-voice-upload-json))
                                   )))
  (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
  (yason:parse stream :object-as :plist))

(let ((stream (drakma:http-request "http://vop.baidu.com/server_api"
                                       :method :post
                                       :close nil
                                       :want-stream t
                                       :content #p "/Users/zhangdongfeng/Desktop/2017/3503/roobo/RECORD.AMR"
                                       :content-type "audio/amr;rate=8000"
                                       :content-length 15174
                                       :parameters
                                       '(("cuid" . "serial987654321")
                                         ("token" .
                                          "24.38056c3ed01c466c5f60e8574be1b6aa.2592000.1491111095.282335-9345458")))))
      (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
      (yason:parse stream :object-as :plist))

**** REST API定义
http://yuyin.baidu.com/docs/asr/57
postman
https://www.getpostman.com
*** 语义理解
http://yuyin.baidu.com/docs/asr/65
语义理解目前不支持rest api接口。
http://yuyin.baidu.com/bbs/q/891
{\"raw_text\":\"北京明天天气\",
\"parsed_text\":\"北京 明天 天气\",
\"results\":[{
\"domain\":\"weather\",
\"intent\":\"query\",
\"score\":1,
\"object\":{
\"date\": \"2013-09-25,2013-09-25\",
\"region\":\"北京\"
}}]}
*** 度秘
[[mu4e:msgid:BAF1FE2D-1EB4-4EE7-8EF8-75D7998F6DA8@actions-semi.com][Fwd: 度秘SDK!]]
阅读了SDK的文档，还是提供的sdk的方式， 没有rest api的方式

** microsoft
*** azure
https://docs.microsoft.com/zh-cn/azure/
https://docsmsftpdfs.blob.core.windows.net/guides/azure/azure-developer-guide.pdf
https://azure.microsoft.com/zh-cn/services/machine-learning/
Docker
http://baike.baidu.com/link?url=oeOvRCGBYVeUhnlbtFwp6r1NmPy7nikE7Ihx7WKX4CfGUeVM6kUS2-RMllLkR7IRLOTAFolu4Tu2kkVvRwQixq
X509
http://baike.baidu.com/item/x509?sefr=cr
IOT
*** 识别
https://azure.microsoft.com/zh-cn/services/cognitive-services/speaker-recognition/

** huawei
*** liteos
【链接】HuaweiLiteOS快速入门
http://developer.huawei.com/ict/cn/site-iot/article/liteos-start
东东  21:15:39
【链接】LITEOS/LiteOS_Kernel
https://github.com/LITEOS/LiteOS_Kernel
只有kernel开源， 没有看到其他部分， 不支持mips
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F37DB8@srv-mail-02.actions.com.cn][转发: 炬芯科技的芯片移植liteos和对接hilink协议]]
** amazon
*** avs
rest api
https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/content/avs-api-overview
sample code
https://github.com/alexa/alexa-avs-sample-app
/Users/zhangdongfeng/Desktop/tmp/aws/alexa-avs-sample-app/samples/companionService
npm start
/Users/zhangdongfeng/Desktop/tmp/aws/alexa-avs-sample-app/samples/javaclient
mvn exec:exec
** aliyun
账号
1qaz2wsx12
2wsx1qaz

Access key:
LTAIqcDTW9H51JB4
secret:
28gxbtkHkGJsEFw7ChuXEkcRldtUjb

https://help.aliyun.com/document_detail/32290.html?spm=5176.doc49179.2.8.cctgre
*** iot
https://open.aliplus.com/docs/open/module/wifi/spec.html
阿里提供的是sdk，不是http的开放api， 需要移植操作系统的接口

** 搜狗
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F37C05@srv-mail-02.actions.com.cn][转发: 搜狗语音demo]]
[[mu4e:msgid:8052E2BCBBC3F246AF9C6B50C39BCFBAD04CB74F@SOGOUBJMB08.sogou-inc.com][答复: 搜狗炬芯语音需求讨论]]
** mediawin
[[mu4e:msgid:201704221354103646803@media-win.com][Re: RE: 关于炬芯-迪韵的4MIC的项目]]

 alsa的示例程序只要能实现录音和播放即可。可参考http://blog.csdn.net/zd394071264/article/details/8300045。
 avs的示例程序可参考树莓派开源代码，参照androidCompanionApp部分，改用c/c++封装。对应示例链接：https://github.com/alexa/alexa-avs-sample-app。

是的，根据亚马逊AVS API说明，结合树莓派的示例代码进行封装。需要注意的
是，音频需要分帧（10ms）实时上传，最好不要采用一次性发送到AVS的方式，
以提高响应速度。
** mips
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74905FFA609@srv-mail-02.actions.com.cn][转发: MIPS Core requirement, 工具链介绍]]
** 地平线
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB7E9@srv-mail-02.actions.com.cn][Roobo&地平线的出差记录]]
** 科大讯飞
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10336D07B@srv-mail-02.actions.com.cn][答复: 科大讯飞与全志科技签订战略合作协议 - 集微网:老杳微信号laoyaoshow]]
** img
[[mu4e:msgid:44C4BD37C5E50146BE0A8676C5F6CF032283D802@HHMAIL01.hh.imgtec.org][RE: PowerVR update for 8XE/8XEP and AI]]
** 京东
joylink_dev_sdk 在 ubuntu 运行时资源占用情况:
包括子设备部分:
ram:4-6K
rom:184K
*** 开发者中心
http://devsmart.jd.com/dev/openDocDir#
京东微联是京东针对未来智慧生活而全力打造的智能平台，其目标是帮助智能硬件厂家打造体验更好的智能硬件产品，为消费者提供一站式的智能产品体验。通过微联App，用户可以对不同品牌智能产品进行远程控制，并实现产品之间的联动。同时针对个人健康情况，记录运动、睡眠等信息，进行完整的数据收集，提供个性服务。随着智能化时代的来临，京东微联致力于为您提供简单、快乐的智能生活体验。
京东微联在首届亚洲消费电子展（CES Asia）众多参选产品中脱颖而出，获得“最佳智能家居产品”大奖。作为京东在万物互联时代的入口级产品，微联将帮助用户实现智慧生活体验的梦想。
该应用可实现的功能包括：一个App控制所有智能设备，智能设备的便捷发现和配置，随时随地的远程管理，众多穿戴设备、健康设备的接入以及个人健康档案生成等。同时还可以设置不同的应用场景，在智能家居的场景中，我们可支持空调、净化器、电饭煲、净水机、灯光、插座等智能设备的远程控制，在智慧健康的场景中，我们可支持手环、血糖仪、体脂仪等智能设备的数据收集，为您实现一手掌控简单智能生活的愿望。

开放服务是将京东微联的数据通过JOS(京东开放服务)接口暴露给第三方开发者。第三方开发者接入京东智能云开放服务， 通过既有的接口开发出与微联类似功能的三方应用。用户可以不使用京东微联而使用三方开发者自己开发的APP就能获取该用户在京东微联绑定的设备列表、，控制授权设备等功能。
*** ECC-ECDH
http://blog.sina.com.cn/s/blog_55a9111c01011zxz.html
.ECDH:
       ECC算法用途比RSA还猛，不仅可以加解密、签名验证。还可以与DH结合使用，用于密钥磋商，这个密钥交换算法称为ECDH。交换双方可以在不共享任何秘密的情况下协商出一个密钥。ECC是建立在基于椭圆曲线的离散对数问题上的密码体制，给定椭圆曲线上的一个点P，一个整数k，求解Q=kP很容易；给定一个点P、Q，知道Q=kP，求整数k确是一个难题。ECDH即建立在此数学难题之上。密钥磋商过程：
       假设密钥交换双方为Alice、Bob，其有共享曲线参数（椭圆曲线E、阶N、基点G）。
1) Alice生成随机整数a，计算A=a*G。Bob生成随机整数b，计算B=b*G。
2) Alice将A传递给Bob。A的传递可以公开，即攻击者可以获取A。由于椭圆曲线的离散对数问题是难题，所以攻击者不可以通过A、G计算出a。Bob将B传递给Alice。同理，B的传递可以公开。
3 ) Bob收到Alice传递的A，计算Q=b*A
4) Alice收到Bob传递的B，计算Q‘=a*B
Alice、Bob双方即得Q=b*A=b*(a*G)=(b*a)*G=(a*b)*G=a*(b*G)=a*B=Q' (交换律和结合律)，即双方得到一致的密钥Q。

** wise automotive
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8FDEB@srv-mail-02.actions.com.cn][转发: WISE AUTOMOTIVE 介绍资料]]
* 研发会议
** 20171111 OKR
*** 智能影音
| object                  | description                                               | key Reults                 | score |
| 5118B支持wifi故事机规格 | 5118B接口丰富后，可以进一步降低成本和系统功耗，挺高竞争力 | 功能规格支持3503现有规格   |       |
|                         |                                                           | 单系统支持wifi+bt a2dp共存 |       |
|                         |                                                           | 按时完成1~2家alpha客户试产 |       |

| object                          | description                                                | key Reults                        | score |
| 5118基于zephyr的蓝牙mcu开发平台 | 在5118B上支持全栈的蓝牙协议，为蓝牙的差异化市场提供sdk平台 | 蓝牙音频profile完整规格，同US281a |       |
|                                 |                                                            | 其他BR/EDR BLE profile示例        |       |
|                                 |                                                            | 1~2家alpha客户量产                |       |
|                                 |                                                            |                                   |       |

*** 智慧计算
| object               | description                                                  | key Reults                     | score |
| 提高S700平台广泛推广 | 在S700有基本平台后，通过不同行业标案客户的导入，继续完善平台 | 广告机和商显标杆客户design win |       |
|                      |                                                              | S700 LInux版本标杆客户试产     |       |
|                      |                                                              | 更多行业重点客户的design win   |       |

*** 物联网
| object      | description           | key Reults                             | score |
| BLE开发平台 | 基于5601BLE的开发平台 | 基于Keil开发调试的集成SDK              |       |
|             |                       | BLE mesh 语音，常见profile和驱动的示例 |       |
|             |                       | 1~2家遥控器方案的alpha客户试产         |       |
|             |                       | 1~2家mesh客户 mesh和语音的参考设计     |       |
|             |                       | 开发板和96boards支持zephyr原生环境     |       |

** 1107 方案研发三部会议报告
*** 标案项目相关
**** 3703
***** 市场客户支持
+ 联立为后续又报出不少问题以及提了一些新的需求
+ 从1012开始由珠海对接
  1028有出差过来集中澄清了一些问题。目前问题在快速解决中
***** 标案发布
+ 学习版
  1013发布学习版
+ 正式版今天完成回归，明天发布
  主要解决问题：
  客户试产中发现的问题
  256M方案系统测试中新测试出的问题， 256M之前没有重点测试
****** 试产的问题和需求：
1.酷我K歌：始终没有找到合适的版本，最近的一个版本有部分片源导致内存不足闪退（Android 512M平板上也闪退），另外一个版本最近在安排测试，没有闪退但有画面卡住
目前还有低概率的发现卡住的问题，debug发现是apk内部播放器的stop接口问题，还找不到规避办法。
2. 关机插usb充电，黑屏后无法唤醒
问题：原提供的学习版上minicharge没有开源，仅支持on/off按键来亮屏
待办：提供minicharge的源码 （patch准备中，今天可以提供验证）
3. Android和非Android下音量要保持一致
问题：Android原生的音量固定最大15级，所以在非Android环境下设置音量大于15，进出apk后音量就变,成15了。
待办：
1)	提供patch解决一致性问题。（patch已提供）
2)	系统测试用例补充：晓玲复现后安排
4. Android apk退出后提示正在启动应用
问题：apk的机制，标案内置的爱奇艺版本没有该问题，LLW内置的apk有。
待办：
1)	已告知LLW通过更换图片来解决（将“正在启动”改为“请稍候”）这样即使退出也是显示“请稍候”。
2)	标案取消图片，优化了加载性能，改为黑色。（改动比较散，随sdk发布后验证）
5. flash进度保存
待办：标案支持的是标准的swf decoder，LLW用标准的swf（PC上可以支持进度保存的优化）自行验证。
6. 外部混响
问题：插着麦克风开机后无声音
待办：已提供修改方法，需要应用配合修改。
7. 开关机闪屏
待办：
1)	开机闪屏：需要改回3FB才能解决，随sdk发布后验证。
2)	关机闪屏：有样机出现，Actions继续澄清。
8. APK关闭升级
待办：
1)	已提供禁止升级的方法。
2)	发布文档增加说明：老宋
一般性问题：
1.  媒体文件加解密支持（可扩展方式）
待办：随sdk发布提供
新需求：
1. OTA需要同229R的需求一致
待办：姚确认229R实现方式后，370a跟进保持一致。
**** 3503
+ patch发布
  1103第二阶段发布后的patch发布，解决发布后，试产发现的问题： 音频削顶， wifi休眠唤醒，wifi异常复位和一个低概率死机问题。
+ 芯蓝图支持
  芯蓝图除了智伴方案外其他的案子都已经送样，暂时没有发现更多的问题
  智伴目前又发现漏掉一个比较大的规格，m3u8格式的支持， 除去这个规格外的样机已经送样
  目前暂未有新的问题报出。
**** s700
+ linux学习版固件
  已经发给客户试用，有测试出一些问题，解决中
  仍有一些遗留规格未完成：视频格式，显示支持hdmi/lcd， 以及声音支持，完成这部分规格和主要bug修改后，可以发一个学习版本的sdk
+ 阿尔法客户导入
  建议基于学习版进行阿尔法客户的导入，需要是视频硬件码等利用上硬件加速的客户，通过配合的过程中完善和收敛sdk
**** 5601
+ 固化代码
  要把zephyr中的一些重要配置项，从编译可配置改成运行可配置，这部分有不少工作量，进行中
+ zephyr的BLE
  使用cordio evb测试组送测， 目前看zephyr的测试情况没有太太问题。
+ arm bug解决
  arm出差过来，上周5给了一版rom代码，确认之前内部发现的问题有解决，继续确认是否还有其他问题
*** 预研相关
**** csb开发
目前代码基本熟悉，开始修改增加csb的代码，
**** 5118B 开发平台
***** 内存管理
主要跟内存管理相关，又和架构小组开会继续讨论确定下来，基本沿用3503的内存管理方式。
+ 系统heap不使用有碎片风险的管理算法
+ 应用heap由应用选择要使用的内存算法
+ 算法库使用静态分配的方式使用内存
  增加把特定场景下算法不使用的内存释放给用户使用，
***** BLE
裁剪了一个BLE的固件给蓝牙指纹锁评估，并提供给客户
在有限的支持下，客户已经完成了算法，spi nor复用的传感器下的功能和性能验证，满足要求，并对性能比较满意
***** 蓝牙mcu协议栈
btstack的协议支持还比较齐全，目前已经porting到zephyr，需要继续评估，
下一步可以考虑基于btstack来做完整的推歌的规格。
详细的规格参考5118的规格来做
先满足3505后续的单系统蓝牙需求
**** WIFI音频
+ RTK 资源开销
  已经完成RTK模组在zephyr os上带起，总共花了3周时间， 一周学习，一周代码编写， 一周调试。
  需要的内存大概要70kb，在3503和5118上支持不了
  基本的iperf， ping测试，没有发现太多问题。
  预研应该可以暂停了， 后续5120支持的话应该主要是调试的工作量
** 1106 智慧计算工作会议
*** S700 Liux
+ 发布学习版本固件给方糖和ucrobotics使用
**** 主要问题
+ 音频整合
  音频通了，但代码未整合到主分支，人力冲突原因，预计本周整合
+ opengl不支持硬件加速
  mali GPU只能支持opengl ES的硬件加速，
  open GL的是通过软件模拟的方法实现的，因此glxgears分数不如S500
+ 鼠标隐藏
  kms这部分的支持还未完善
+ LCD/HDMI自适应
  目前支持HDMI和LCD的单显，自适应和双显功能支持待完成
+ 蓝牙功能目前只支持命令行使用
*** 7051 晨芯问题
使用watch dog来规避可能在充电场景的死机问题，星期天160台老化目前暂未发现充不进电的现象
8189 cob wifi驱动死机问题，继续和rtk跟进
*** 方案评估
+ 视美泰
  视美泰大的需求点s700可以支持，具体的细项需要后续项目开展中更详细的互动。
  质量和稳定性要求高。个性化的点也很多，预期工作量和周期会比较长。
  建议的支持方式：需要珠海有客户的硬件环境，一些功能和问题由珠海直接沟通和支持。深圳支持有专人全程参与。
+ 小悠游戏机方案
  3703上增加HDMI支持后，应该可以满足客户的需求了， 目前用标案发布版本开发，后续更新3703第三次发布版本即可。

** 1029 alexa 蓝牙支持
普通的蓝牙音箱就可以，目前看不需要支持特别的skill
echo可以支持扫描蓝牙音箱
也可以被设置成可被发现模式，让手机连接
使用的profile主要是a2dp和avrcp
** 1026 zephyr os带起rtk wifi
*** 主要工作
从开始看freertos参考代码到移植调试，到功能调通，能扫描ap，连上ap，收发网络数据，大约总工作量约为3周。
工作量	工作内容
1周	参考STM32-F411R+RTL8189代码，运行板子跟踪wifi的初始化、扫描ap，连接ap过程，参考os适配层代码，调试软硬件环境准备
1周	Wifi os层适配代码编写，sdio操作接口适配编写，tcp/ip网络协议层对接，增加wifi功能操作接口，代码编译整理
1周	联系realtek进行调试，增加测试代码，简单测试wifi

*** 调试主要遇到的问题：
1、	开始提供的wifi lib存在字节不对问题；
2、	Os适配层函数返回值无说明，开始时存在返回值与期望值对应不上问题；
3、	Sdio中断，主控输入中断只支持沿触发，而wifi送出的中断为低电平中断，主控需要适应sdio的低电平中断方式；
4、	硬件飞线存在干扰；

其它mips平台移植调试时间评估：2周
一周时间进行接口适配，一周时间调试。 如果仍是zephyr os，主要是调试时间1周
建议
现在所见的realtek wifi模组，所支持的sdio中断都是从sdio的D1发出的，没有单独的gpio用于送出中断，boardcom模组有单独gpio用于送出中断。而所见的realtek、boardcom模组，sdio的中断都是电平触发的。
对于1线sdio接口的主控，建议主控支持电平触发中断，方便sdio的中断处理（调试南方硅谷wifi模组时，也是由于sdio中断问题折腾过一番）。

*** 对比南方硅谷WIFI

对比看，南方硅谷的wifi只需要23Kbyte内存，而RTL8189FTV需要70Kbyte，主要原因有，南方硅谷wifi驱动已经过内存优化调整，并且收发数据直接使用tcp/ip层的buf，不再额外占用收发buf。而RTL8189FTV看到的数据结构很大，也包含一些无用的数据（如5G的数据，rtl8189ftv不支持5G），在网络buf使用上，rtl8189ftv内部留有专用内存，并且收发数据时还需要再申请内存用。
** 1020 3503SDK反馈
*** 芯蓝图凌工
+ 只能跑一个前台应用，稍显不方便
+ 列表管理刚开始看不懂，看了文档后，明白拆分成100项一条后就看懂了
+ recovery固件和正常固件在同一个sdk中，有遇到过问题
*** 许学飞
+ 其他封装都挺好的
+ 列表管理比较复杂，不容易看懂
*** 领芯
+ 主要是代码开发程度不够，影响他们的深度定制
** 1011SDK中soc命名问题
*** 目的
基于zephyr OS的sdk，同一个sdk可以适配到不同的GL系列，可以看到的是GL5601，GL5118， GL5118B以及GL520.
*** 问题
目前同一个die或对应不同的市场mark，并且也不能做到完全的提前规划，比如GL5118是无线音频规划的IC，第一个产品使用的mark是ATS2815。
后续GL5118拿到智能影音产品线，规划为故事机产品，使用了一个新的mark 3503
按照公司的要求，在sdk的代码中不能出现die的编号，但由于市场mark不能够提前预知，所以sdk总需要区分soc的代码就需要考虑一种方式来区分不同的die和mark。
*** zephyr SDK中实现的方式
+ 目录命名
  arch/mips/soc/ATS35xx
  目录的命令使用mark来命名， 针对不同的标案，可以在发布的时候通过修改目录的名字来解决
+ Kconfig来选择不同IP实现
  使用arch/mips/soc/ATS35xx目录下的Kconfig.defconfig等config文件来通过Kconfig的select和depend等方式来选择不同的功能模块IP的版本
  不同IC如果使用不同的IP的话， 只要使用的数字不冲突就可以了。
  功能模块的Kconfig命名使用如下格式：uart_actions100
+ 功能模块IP命名
  各个驱动下的Kconfig应当也使用mark来命名， 比如Kconfig.actions100
  对应的驱动文件的名字  uart_actions100
+ 代码中的函数命令
  使用gpio_actions100_read等格式的名字
+ 使用范围
  主要适用于kernel  driver等和ic寄存器等直接相关的部分， 应用层的功能配置不需要跟mark相关， 可以使用通用的actions这个名字
** 1011 方案研发三部会议报告
*** 标案项目相关
**** 3703
+ 支持联立为试产， 目前还有一个播放视频老化停止问题
+ 今天发布一个版本
**** 360F
+ miscinfo 和 2mic aec问题澄清
  mic底噪问题-65，最终需要-90db
+ 平台测试用例测试组验收了一次
+ 还没有正式模具，可能测试不了最终效果
+ 争取本周送测
**** 3503
+ 本周发布第二阶段完整规格
  支持psram， 卡热插拔， opus， 蓝牙双系统，vad
  第二阶段结束
+ 支持客户完成智伴试产后， 后续转给深圳支持
**** s700
+ 已经完成
  GUI gpu加速
  支持u盘升级
+ 视频硬解码
  正在开发中，完成后可以集成一个学习版
**** 5601
初步讨论了架构和后续工作
+ PTS测试
  自己完成测试工具
+ 固化代码
  协议栈和mesh， 大部分proflie应该都可以在ram中完成，可以先不固化
  固化代码基于1.9做适当调整
+ zephyr的BLE
  目前zephyr文档和代码里只看到ble stack的pts测试，没有profilervice的pts测试。
  如果要过profilervice的pts测试，需要我们来完成，这部分不固化的话，可以放到后面来做
+ ROM测试
  mesh测试使用 FPGA+nordic+cordio evb来构建异构mesh
  协议栈性能测试，使用数传来测试配对，链接，吞吐量等
*** 预研相关
**** 5118B 开发平台
了解合肥需求，主要跟内存管理相关，重新review了一下
裁剪了一个BLE的固件给蓝牙指纹锁评估，并提供给客户，还未有反馈
**** 蓝牙mcu协议栈
+ 在zephyr上带起了a2dp功能，
  花费了一周左右时间， 功能还不完善
+ btstack
  找到一个新的开源的在zephyr上可以跑的蓝牙协议栈，需要后续详细评估一下
  license如下：
  BTstack is free for non-commercial use. However, for commercial use, tell us a bit about your project to get a quote.
  如果评估可用的话， 再具体去沟通下
**** WIFI音频
+ 资源开销
  使用stm32的板子， 使用realtek更新的FreeRTOS的SDK后， 可以正常的跑起来了，Wifi sta模式，驱动初始化完成，没做任何操作时heap内存使用，动态的heap加上静态内存大概80K左右， 在3503上， 南方硅谷的模组使用的内存不到30K，所以内存的差距在50K左右， 在3503或5118上很难再挤出来这么多的内存。
+ zephyr上带起情况
  准备了硬件环境， sdio可以扫描到， 未有时间做进一步工作
+ marvell测试情况
  在复杂网络环境都会卡顿
+ 高码流音频流缓冲
  在网络不太差的情况下， 资源比较丰富的IOT芯片，还是比较大的可能做到高码率不卡顿的
  需要想办法尽快找到市场能够接受的卡顿标准。如果标准较高的话， 大部分的iot芯片都应该不可以
**** aihora AB1520S
+ cpu使用80251
+ ram 32K， 其中heap 19k
+ Flash部分
  固化了1M的nor， 总共用了551,663字节， 其中代码289,118， DSP的代码是168，354，剩下的注释配置数据， 其中语音提示音配置数据54,893，包含了中英文， 一种语言的话大概27K
+ ROM部分
  从FE8000开始的96k是rom，大部分（75K左右）是蓝牙的链路控制（LC），主机控制（HC），以及链路控制切换（LCS），剩下的一些其他代码，主要是kernel，设备驱动，以及SDK的一些运行环境的代码。
+ DSP
  语音提示，语音命令，解码等都是通过dsp来完成的， mcu和dsp之间是通过一个mailbox来进行交互的。
  从DSP的配置文件中可以看到4路AEC的配置 AEC/NR/AVC， 接收和发送的噪声消除   VAD的配置， 双mic的配置，接收和发送的音效设置，还有一些PLC， PEQ等配置，以及不太看明白的其他配置。
  在SDK中有语音命令的配置数据以及处理流程。
** 1010 合肥反馈问题
*** Linux的内存管理
linux的内存是比较复杂和轻巧的，要考虑的问题很多，我们在3503中和us282f中使用的方式，都可以从linux的解决方案中找到影子，以目前在项目中使用的linux 3.10的内存为例（linux最新的内存管理系统还没看过），简单描述下linux的内存管理系统，再讨论其他RTOS的内存管理系统
**** 物理内存管理
+ 4k内存页
  linux最基本的内存管理是按照内存页来管理的， 把全部物理内存按照4k大小（可配置，一般都是4k）来划分出来。
+ 伙伴算法
  多个4K内存页的分配使用的内存分配方式是伙伴算法（buddy）。
  整个4k的连续空间，在Linux中会被划分为多个连续的块（比如8M）， 使用buddy算法的时候，比如要分配一个1M大小的连续空间， 会先把8M拆分成2个4M， 把其中一个4M拆分成2个2M， 再把其中的一个2M拆分成两个1M， 然后拿其中的一个1M满足分配。 每一个这样的拆分出来的两块就成为一对伙伴。
  在释放这个1M的块时， 如果对应的伙伴是空闲的， 那么就会合并成一个更大的块， 更大的块的伙伴如果是空闲的， 那么会继续合并下去。
  伙伴系统的好处就是相对没那么容易碎片化。缺点是可能会有内存浪费。
+ 内存分配
  + 应用层
    应用不同进程都自己的页表，因此按照物理内存单页分配的方式，通过进程的页表映射成连续虚拟空间就可以了。应用内存的分配只需要分配单个的4k页就能满足要求了
    同时，分配给应用的物理内存，内核随时都可以通过修改进程页表的方式来收回（代码段只读内存）或者移动（数据等读写内存）。而这个行为完全对应用程序透明。
  + 内核和驱动程序
    linux是一个巨内核的系统，内核本身和驱动程序都是在同一个地址空间内，因此分配的数据物理内存不能移动。代码部分也不能缺页，都是常驻在内存中的。
    在需要的内存小于4k的时候，任意单个4k页就可以满足， 但如果需要的内存大于4k， 则必须分配物理上连续的内存页，这个就必须要在整个内存空间中整理出来连续的段才可以满足内存分配

    主要的问题就是内存片问题，在系统运行较长的时候，很难整理出连续的物理内存页。在7029平板方案中，有遇到过问题，1G内存，usb传输申请一个连续的32kbyte的buffer都申请不出来。

    碎片问题的避免在linux中有几个办法：
    + 提前申请，占住不放
      避免重复分配和释放。 但有些问题不适合这样解决。同时也会稍微的降低一下内存利用率
    + 使用vmalloc
      分配的时候仍然分配物理不连续的内存，为分配的内存创建新的内存页表来映射成连续内存
      但这种方法只能用在只被cpu访问的内存上，不能被dma访问，另外一方面，32bit内核的这个内存映射区域是比较少的
    + CMA的方式
      以性能为代价，解决在内核中分配连续物理内存的方式
***** 内存碎片的缓解和解决
****** 内存碎片的缓解
linux在CMA之前已经做了一些防止内存碎片化的动作， 主要如下：
+ 划分成多个迁移类型(MIGRATE_TYPES)来适配不同的分配需求
    把内存区域划分成多个MIGRATE_TYPES的区域， 比如MIGRATE_UNMOVABLE, MIGRATE_RECLAIMABLE,  MIGRATE_MOVABLE, MIGRATE_RESERVE等，迁移类型按照8M（假设max order=11）对齐。
  + MIGRATE_RESERVE是最后的预备队，用于紧急内存分配。
  + MIGRATE_RECLAIMABLE用于可回收的内存分配，
  + MIGRATE_UNMOVABLE是通常的不可以移动的内存分配，
  + MIGRATE_MOVABLE用于可移动的内存分配，
    根据内存分配的使用者需求，确定在那个区域中进行分配，这样可以减少单页的内存分配打断连续的内存区域的概率。
+ 内存回收尽可能减少碎片
  linux系统为了更好的性能，会尽可能把空闲的内存用于缓存，当系统空闲的内存低于一定水平线（watermark）后就会进行内存扫描，在扫描中会尽可能回收出连续的区域
  + 对可以回收的内存进行回收， 回收的同时会把连续的小块区域合并成大块区域
  + 对造成连续区域碎片的可以移动的内存页，迁移这些页内的内容，重新合并成一个连续区域
+ 迁移类型之间的fallback来解决内存复用
  当一个迁移类型中的内存页不够分配的时候，就会fallback到其他迁移类型中，会根据不同的分配类型确定fallback的顺序。
  fallback相当于借用，每次借用的时候都是按照一个max_order_block来借用的， 比如我们配置的这个值是11，那么每次借用就是2048*4K=8M大小。借用的时候归还也是整块归还。
+ oom Killer
  当内存分配不允许失败，同时内存由于碎片分配不出来时，会执行oom（out of memory）过程，据一些规则，挑选某些进程，直接杀死这些进程来释放内存

即使采用了以上种种缓解内存碎片的办法，仍然会遇到因为内存碎片导致整个系统几乎不能用的情况。
****** CMA（continuous memory allocation）
在kernel 3.4以后开始引入了CMA内存分配的方式，主要是用来满足大块的连续内存分配，原理如下：
+ 设置一个新的迁移类型MIGRATE_CMA
  系统使用的内存，只有允许移动的系统内存才能在CMA中分配，其他不能移动的内存分配也不能迁移到CMA这个区域。
+ 使用dma_alloc_coherent来分配物理连续内存
  当需要连续物理内存的时候，调用dma_alloc_coherent会把选定区域的内存页迁移出去，形成连续物理内存。

通过这种方式可以满足大部分的驱动和内核的连续物理内存要求，并在驱动不使用cma内存的时候，又可以用于可移动的系统内存分配，提供内存利用率。
即使这样，如果CMA区域内按照CMA的分配方式也可以出现碎片，这种就只能通过把CMA区域设定得足够大来解决。

**** slab分配器
根据前面的讨论，对小于4k的内存分配，简单的一个单页分配就可以解决问题，没有碎片的问题，但如果仅仅为了分配几个字节就使用一个页，太浪费了，所以就出现了slab分配器。

通过kmem_cache_create创建一个slab高速缓存，创建的时候会指定在该slab中的object的大小，初始的object的个数。实现就是使用多个不连续的4k的页，每一个4k的页满足很多个对象的分配（4096/object大小），这样可以提高内存的利用率。

在kernel的不同子系统中都有使用各种大小的高速缓存，高速缓存的好处有：
+ 没有碎片问题
  每个高速缓存可以简单理解为一个可伸缩的数组，每一项都是固定大小的
+ 分配快速
  内存的分配不涉及到kernel的内存分配子系统，后者是相当复杂和缓慢的
+ 内存利用率高
  几乎没有字节浪费
+ cache line优化
  使用cacheline着色等技术，优化cache访问
+ 可以动态伸缩
  在使用的对象不多的时候，可以把内存还给系统。分配空间不够用的时候，会从系统中再申请新的4k页。

除了各个子系统的专用的高速缓存外， linux系统中还提供了通用的高速缓存用于内存分配，通用的slab中的object的大小分别是， 16，32，64，128，256 一直到1024大小。
*** RTOS中的动态内存分配
**** 282f的动态内存分配
目前合肥的需求是提供一个不需要支持wifi，和仅仅需要支持蓝牙的开发平台，采用的方法是保留系统最基本的框架（去掉wifi，解码，播放，录音，网络等）， 移植了282f的动态内存管理机制，能提供出来的最大的内存有98K。

2828f中使用内存策略简单如下：
+ 各个功能模块，都尽量使用动态内存分配的malloc和free来分配内存
+ 尽量不使用静态内存，或slab的方式，把可用的内存尽可能的都留给heap
+ 使用防碎片的heap管理算法
  把可以使用的内存分为2k页大小的block， 每一个进程使用内存时，会先从系统中分配一个2k的页，在每一个2k页内使用伙伴系统来管理内存。2k只有全部空闲的话才会还给系统。
****** 内存碎片问题
  通用的动态内存管理算法最大的问题就是碎片的问题，linux算是为放置碎片做了更多的工作的，同时还有mmu，可以移动内存，仍然避免不了碎片问题， 只有使用cma之后，才解决了驱动程序和内核需要的碎片问题。
  282f的内存管理机制与linux相比，更不容易解决问题，主要如下：
  + 没有mmu
    因此不能做通过移动内存的方式来合并素片
  + 防碎片措施少得多
    有更多的碎片的可能
  + 可管理的内存少太多
    管理的内存越多，遇到碎片的可能就越少

  282f的算法很类似前面讨论的基本的linux对4k页的管理的方式的方法，  linux中每8M（max_block_order=11的时候）是一个block， 其中8M内就是使用伙伴系统管理的。
  在这里我们把linux的4K的页当做282f中的一个字节。8M刚好是2K个页。可以相当于282f的2k的block。

  根据以前做平板的经验可以知道，在没有使用CMA内存之前， 在1G内存（相当于256K个页）的情况下，最后分配一个32K大小的页（相当于8个页），都分配不出来。这个还是在linux还有更多的防止碎片化的机制（不同的迁移类型来隔离分配，移动内存页来减少碎片）的情况，如果在同样的内存压力情况下，282f的碎片问题应该更难解决。

  282f在实际的使用中没有遇到很多的碎片问题，有两个可能的解释：
  + 总的内存在各个场景下还是相对比较宽裕的，
    不管哪种通用的内存管理系统，在总内存压力不大，分配的size不够碎，动态并发性不高的时候，还是相对不太容易遇到碎片问题的。
  + 或者不同场景下内存使用的时候需要注意特别的顺序。
    专门优化各个应用场景，让应用或系统模块申请内存的方式配合起来，避免碎片出现。
**** 3503 系统中的内存使用策略
***** 主分支目前故事机方案的内存使用情况
| module name             | data size |
| actions应用框架核心服务 |    31,102 |
| 应用框架开源部分        |    14, 753 |
| 网络核心协议栈          |    24,441 |
| wifi驱动相关栈             |     8,995 |
| 内核                    |     6,632 |
| 设备驱动                |     3,999 |
| 故事机应用              |     3,032 |

说明：
+ 解码库部分  53k
  不同编码格式和解码格式是共用内存的， 相互overlay，最大的overy是53K
+ 系统框架和核心服务  31K
  主要是两部分核心服务使用的heap和stack，启动heap 17k， stack 12k左右， heap中还包含了wifi驱动使用的动态内存。
+ 应用开源部分 14K
  提供给用用程序使用的堆， 和系统核心服务使用的heap分开管理
+ 网络协议栈部分 24K
  主要是网络使用的buffer， 总共10个， 每个1.6k，以及其他的一些小buffer，
+ wifi驱动  9k
  wifi固件这部分主要是驱动使用的静态内存部分，主要是一个比较大的stack。wifi驱动使用动态内存都在应用框架的heak中分配
+ 内核和其他驱动 10K
***** zephyr中的内存使用策略
在zephyr中，内存使用的思路如下：
+ 静态或全局变量
  对重要的数据结构，使用全局变量的方式，比如大部分的内核和设备驱动，
+ 静态的pool
  大量的同一类型和的的数据结构或同样大小的缓冲区，使用类似linux的高速缓存slab结构，在zephyr中称为pool，但与linux的高速缓存不同的是，zephyr中的slab底层没有页系统支持，所以是不可以伸缩的。
  这部分主要是网络协议栈中使用的网络缓冲区，以及相应的数据结构
+ 通用heap
  zephyr中提供了一种heap的管理算法，就是把一整块的内存区域使用伙伴算法来管理。
  尽管zephyr提供了这种方式，但在整个的系统代码中并没有使用。
+ 3503增加的heap管理机制
  由于有一些需求，使用静态变量或pool都不能满足，而必须要使用heap的方式，主要有：
  + wifi驱动在运行的时候需要经常的动态分配不同大小的内存，需要10多K左右
  + 网络上层协议的解析，比如jason格式的parse，需要经常的分配和释放内存
  + 应用各个互斥场景切换，比如播放，录音，百科文档，语音留言等。

  为了充分利用内存就需要使用heap的方式，在3503中增加一种heap的管理方式，暂且命名为slab_heap吧。

  slab_heap使用的方法类似linux的通用高速缓存的方式，会提供32，64，128， 256，512，1024..等各种size的pool。每个pool根据实际的需要配置一个个数。

  与linux通用的高速缓存不同的有两点：各个pool的size不一定是2的整数幂，每个pool支持有限的伸缩。

  在3503的发布版本上，整个系统只提供了一个slab_heap，凡是需要动态内存的地方都这个heap，在内部的开发分支上，把不开源的系统服务和wifi使用一个slab heap， 然后所有开源部分的应用使用另外一个slab heap。前者为17k， 后者为14k。分开的好处就是应用的内存使用永远不会影响到系统。
****** 内存利用率问题
使用slab heap的有点是没有内存碎片的问题， 缺点是如果在多场景下提高内存利用率的问题。

举例如下：
目前我们需要同时支持蓝牙和wifi的功能，这两部分都属于不开源的部分，都使用系统的slab heap。但两者的使用方式如下：
wif音频运行时i需要的内存是 10个 512*3 的buffer， 蓝牙音频运行时需要的是30个512字节的buffer，wifi和蓝牙驱动都需要同时存在。
如果内存管理算法做得足够好，那么理论上来说15K的内存就够了。而使用slab_heap的方式，可能就需要25K才够。主要原因是10个512*3的buffer，并不能有效的作为30个512字节的buffer来使用。

可能的改进：
如果这样的情况出现较多，可以考虑进一步增加slab heap的功能和feature，在slab heap之下再增加linux的页管理的机制。最终实现不同size的pool可以真正的动态伸缩，通过底层的页来在不同的pool中复用内存。
这样的修改除了增加复杂性外，需要根据sdk的实际情况来权衡一些要考虑的问题，从目前sdk的实际情况看，利用率是ok的， 不增加是更好的选择，后续整合蓝牙音频后，再具体情况看一下
要考虑的问题有：
+ 底层页的大小
  页至少要能够满足一个最大的object的大小， 比如2k。
  每一个pool即使用不到2k大小， 也会占用一个页， 比如32byte的object， 如果数量不多可能就会浪费一些内存。
+ 回收页的机制
  如何，何时回收，缩减某些pool的size，以腾出内存给需要的pool。
***** broadcom wiced BT的动态内存管理
broadcom的wiced bt是一个蓝牙的开发平台，同时支持BR EDR  BLE以及各种profile。
| Technology            | Bluetooth (BR + EDR + BLE)                        |
| Bluetooth Spec.       | Bluetooth 4.2                                     |
| RX Sensitivity        | -93.5 dBm                                         |
| Max. TX Power         | 12 dBm (Programmable TX Power)                    |
| Power-Class           | Class 1, Class 2                                  |
| CPU Core              | ARM Cortex M3                                     |
| Flash/EEPROM          | Ext. Flash/EEPROM support                         |
| Internal              | 848 KB ROM                                        |
| SRAM                  | 352 KB                                            |
| Coexistence Interface | GCI SECI (2-wire)                                 |
| Serial Interfaces     | 2 UART, 2 SPI, I2C, PCM, I2S                      |
| ADC                   | 10-bit @ 100 KHz (Static) 13-bit @ 16 KHz (Audio) |
| GPIOs                 | Up to 24                                          |

在每一个应用的开始会调用wiced_bt_stack_init来初始化， 该函数的第三个参数就是sdk的buffer的配置， 针对不同的使用场景，有不同的buffer配置， 比如对a2dp协议的例子：
#+BEGIN_SRC C
 * Configure buffer pools used by the stack  according to application's requirement
 *
 * Pools must be ordered in increasing buf_size.
 * If a pool runs out of buffers, the next  pool will be used
const wiced_bt_cfg_buf_pool_t a2dp_sink_cfg_buf_pools[] =
{
/*  { buf_size, buf_count } */
    { 64,       12  },      /* Small Buffer Pool */
    { 272,      6   },      /* Medium Buffer Pool (used for HCI & RFCOMM control messages, min recommended size is 360) */
    { 1056,     6   },      /* Large Buffer Pool  (used for HCI ACL messages) */
    { 1056,     0   },      /* Extra Large Buffer Pool - Used for avdt media packets and miscellaneous (if not needed, set buf_count to 0) */
};
#+END_SRC
在这里可以看出，使用了几个固定大小的pool分别用于hci， avdtp协议的动态内存分配， 这些协议在wiced bt平台是不开源的。

而对开源部分的内存使用，wiced bt中提供了多种内存管理算法以供选择。有基于pool的方式的， 也有基于通用的heap管理的方式的。
***** aihora AB1520S耳机和音箱方案

洛达的AB1520s方案的ram总共32k， 其中13k左右是全局变量使用，剩下的19k用作动态分配的heap， 内存堆管理使用多个预先配置的pool的方式，

一个典型的具体配置如下：
| pool名称             | 大小（项数x大小） |
| CallArrayEntries     | 16 * 4            |
| TimerArrayEntries    | 50 * 4            |
| OSMEM1ArrayEnties    | 40 *50            |
| OSMEM2SmallTxEntries | 9 * 702           |
| OSMEM2TinyRxEntries  | 3 * 62            |
| OSMEM2SmallRxEntries | 3 * 1100          |
| OSMEM2LargeRxEntries | 2 * 1100          |
| UartDmaRxBufSize     | 380               |
**** FreeRTOS中的heap管理
FreeRTOS提供了5种HEAP分配方案。各应用可以按照自己的实际需求来选择合适的HEAP实现方式。HEAP实现代码位于Source/Portable/MemMang目录下。
***** 方案 1 - heap_1.c
这是所有方案里最简单的。当内存分配后，它不允许释放内存，但除了这点，它适合于大量的应用。若应用永远不会删除任务或队列（永远不会调用 vTaskDelete () 或 vQueueDelete ()），则可使用。
heap_1.c 适用于很多在内核启动前即创建了所有任务和队列的小实时系统。
***** 方案 2 - heap_2.c
此方案使用了最佳适用算法，与方案1不同，它允许释放之前分配的块。然而，它不会将相邻的自由块合并为一个大块。
heap_2.c 适合于很多必须动态创建任务的小实时系统。
***** 方案 3 - heap_3.c
它仅是标准 malloc() 和 free() 函数的封装。它可确保线程安全。此方案特点为：
• 需要链接器建立堆，编译器库提供 malloc() 和 free() 的实现。
• 它不是确定性的。
• 可能会大幅增加内核代码量。
***** 方案 4 - heap_4.c
此方案使用了首先适用算法，与方案 2 不同，它不会将相邻的自由内存块合并为一个大块（它不包含合并算法）。
***** 方案 5 - heap_5.c
它允许程序设置多个非连续内存堆，比如需要快速访问的内存堆设置在片内RAM，稍微慢速访问的内存堆设置在外部RAM。每个内存堆的起始地址和大小由应用程序设计者定义。

*** 建议的主要的设计策略
RTOS的系统，受限于实际可用的资源，需要针对最大场景对内存资源做一些大的规划，不能太指望通用的heap管理策略。
+ RTOS需要减少动态内存的使用方式
  分多个层次：
  适合使用全局数据的使用全局数据
  适合使用专用的高速缓存pool的使用专用的pool
  必须使用动态内存的才使用动态内存，而不是都尽可能的都是用动态内存。
+ 平台整合功能的动态内存使用方式需要使用可预测的管理方式
  比如3503整合的wifi 音频相关的功能，后续会继续整合的蓝牙音频相关功能。
  这部分的内存使用应当使用可以避免内存碎片的管理方式，内存碎片的最大的问题就是不可以预测性。
  这部分的动态内存使用方式最好和应用的动态内存使用分开。分开的好处是容易做针对性的优化来提高使用率，以及不受应用内存分配算法的影响。
+ 可以整合多种动态内存算法，提供给应用层使用
  由于平台上的应用的需求是千变万化的，可以也应当考虑提供多种算法供实际应用选择，同时也需要考虑能方便客户整合自己的内存管理算法。

  举两个实际的例子：
  + 合肥客户
    只需要蓝牙的controller功能，甚至都不需要协议栈。
    这种情况下，裁剪掉其他功能后，可以有接近100k的内存，主要的代码都是客户自己的代码， 提供一个类似282f的算法那也是可以的， 遇到碎片问题客户应该可以自行解决。
    也可以由客户自己整合内存管理算法。
  + 指纹锁
    只需要蓝牙BLE的功能，
    甚至不需要使用内存分配算法， 整个算法是自己管理内存的。

*** RTOS选型
**** RTOS对比

目前主要的RTOS的操作系统可以参见下面的链接
https://www.osrtos.com
http://www.linuxidc.com/Linux/2016-11/137178.htm

主要考察了如下几个OS：
|              | mbed OS      | FreeRTOS                   | Zephyr                          | nuttx      |
| 资源占用     | 较小         | 小                         | 小                              | 较大       |
| 许可证       | apache 2.0   | LGPL                       | Apache 2.0                      | bsd        |
| 社区         | 主要arm大厂  | 个人开发者                 | 个人，intel，nordic以及linaro等 | 基本无     |
| 无线协议支持 | 以太网       | 以太网                     | 15.4，蓝牙，以太网              | 以太网     |
| 组件         | 有不开源部分 | 有不开源部分，且许可证不同 | 开源                            | 开源       |
| 跨平台       | arm          | arm mips                   | arm 可增加mips                  | arm mips   |
| 可配置性     | 一般         | 不同组件不同               | 好    Kconfig                   | 好 Kconfig |
| 组件丰富程度 | 好           | 不好                       | 较好                            | 最好       |
| 开发便利性   | 最好         | 不相关                     | gcc环境，后续会支持keil，iar等  | gcc环境    |
| soc hal      | 有           | 无                         | 有                              | 有         |
| 文档化       | 好           | 一般                       | 好                              | 差         |

也同时也评估过其他的OS ，比如rt-thread  contiki等。

选择主要考虑如下方面：
+ 资源占用
  从资源占用看， 这4个os都基本可以满足要去， 除了nuttx稍大一些外
+ 许可证
  bsd，和apache的许可证是最适合商用的， 可以根据自己需要闭源和开源都没有限制。
  FreeRTOS本身是LGPL的，相对还好，主要问题是， FreeRTOS之上的组件的都是不同的license，有一些不开源的同时，还不是免费的。
  如果选择FreeRTOS的话，比较好用的上层组件只有lwip这个tcp/ip的协议栈，这个也是最常看到的组合，其他比较多的组件有license和开源的问题。
+ 社区支持
  之所以选择一个新的操作系统来，主要还是为了这一点，要充分利用开源和社区的力量，尽量避免独力发展一套私有系统。如果重点不是考虑这一点，继续使用ucos也是一个选择。
  + nuttx
    从社区支持看， nuttx基本都是由主要的开发者一个人维护的，是最大的问题
  + FreeRTOS
    FreeRTOS采用的比较多，尤其是FreeRTOS + lwip的组合，基本上每一个wifi vendor都有提供这样组合的示例。但FreeRTOS的问题也很明显，基本只有一个核心可以用。其他部分基本都要自己完成。
  + mbed
    mbeded主要是arm在推动，各个arm芯片的供应商支持mbed的方式，主要是把自己的芯片和开发板适配到mbed平台。
    mbed平台的其他各部分组件的整合是arm和社区推动的，但特别的松散，但评估的时候看，各个组件的质量不同，整合起来的质量和稳定性也不尽如意。同时，有一些组件还包含二进制的部分
    5601的ic，可以考虑后续适配到mbed上
  + zephyr
    license是apache的， 同时整合进来的组件都是apache或bsd的license，也没有不开源的部分，目前已经整理进来很丰富的组件了， 比如tcp/ip， ble，zigbee， 文件系统，mtls等。
    是Linux Foundation托管的项目，采用了类linux内核的社区模式，个人开发者也可以参与其中，同时也有比较多的大公司主导推动，intel，synopsis  nxp nordic 等公司。
    目前zephyr的发展和迭代都非常快，bug修复也很快。像BLE的mesh在标准发布没有多久就可以支持了。https://www.linux.com/news/event/open-source-summit-na/2017/4/building-wearable-device-zephyr
+ 无线协议支持
  在评估了前面几条后，zephyr基本上就是唯一选择了。如果是arm soc，可以支持mbed平台而已。并不会作为主要的软件基线。
  选择zephyr还要一个重要的考虑就是，可以整合蓝牙音频，以及蓝牙BLE和WIFI相关的到同一个平台中。
  这样可以让多颗IC使用同一个软件平台。
+ 可配置性支持
  zephyr和nuttx都使用了类似linux的Kcofig系统，比较方便配置需要的功能，这个虽然不是至关重要的功能，也是很需要的一个功能，方便后续再一个sdk中逐渐整合越来越丰富的功能，但又能很容易的去掉不要的功能。

  两个例子：
  支持基本蓝牙功能后，合肥基于wifi故事机的版本， 经过简单的配置和一些修改就整合出来一个蓝牙的版本。
  蓝牙指纹锁需要提供一个BLE的版本，这个通过简单配置，较少的工作就可以提供一个BLE版本的功能。
+ 其他方面
  剩下的其他方面的影响并不致命，就算遇上问题也是可以克服的， 比如：
  + 音频解码
    就算linux这样的系统也需要一定的整合工作， 对RTOS需要自己整合
  + GUI
    zephyr并没有整个显示和GUI，估计将来也不会整合GUI进来， 这个工作如果需要可以由我们自己完成
  + API不成熟
    由于zephyr整个项目还处于早期，所以，经常还会出现api的大幅变化，这个需要我们在同步跟踪新版本的时候，有所取舍同时也需要做好测试
  + bug较多
    从目前看，kernel本身没有遇到太多问题，其他网络等组件，还不够成熟，甚者有一些低级错误，但这个影响还好，一来是zephyr自身修复较快，二来，小系统我们自己也是可以掌握和debug的，
**** zephyr是否适合做复杂系统
系统的复杂性主要是由几个方面带来的
+ 系统的主要功能，
+ 功能之间的主要关系和协作，
+ 所受到的环境或资源限制，
+ 要达到的质量和性能要求。
从这几个方面来说，os核心的选择主要影响后两者。 os+组件的选择会同时影响这4个方面。当然，最重要的影响还是产品的规格。

从复杂系统角度而言，用linux是最好的选择。

但就RTOS而言，从考察的各个系统来说：
nuttx可以认为是linux的瘦身版，在稍微放宽资源限制的时候，是最适合的， os核心的服务很丰富，也有丰富的组件，但由于生态的原因不能选择。
FreeRTOS基本上可用的就是os+lwip，其他部分都需要自己构建
mbed和zephyr差不多，但mbed的os本身是有一些问题的，组件同样有一些问题。

可以拿我们熟悉的ucos来做一个对比， 我们使用的ucos也只使用一个核心，其他部分全是我们自己构建的，就单纯对比ucos和zephyr的核心来说， zephyr相对uc的核心提供了更多的操作系统相关的服务，我们使用uc可以做到的复杂性，使用zephyr一定是可以做的。
zephyr系统除了核心外，我们还是复用了很多其他的组件的，只是没有的组件需要我们自己（或其他第三方）构建，相对uc系统而言，已经大大的减少了工作量了， 因而会更容易。

因此，使用zephyr构建复杂系统不应该会有很大的不足。

总的来说:
zephyr算一个复杂度中等的os， 比uc提供的功能丰富一些。其实就目前看对BLE only的都稍微重了一点。
contiki和mbed os 是更轻量级的，洛达的os是更轻量级的， 完成蓝牙音频的功能也没有问题
nuttx是更重量级的， 基本算瘦身的linux。
** 1009 合肥凤美谈话
+ 合肥之前反馈的sdk问题的回复
  内存相关问题和zephyr os本身的选择问题，已做说明
+ 蓝牙协议栈问题
  现在的蓝牙客户使用的协议栈不太清楚来源， 主要是用蓝牙发射。这个可以了解下后续的资源需求，看是否可以满足。
  ivt协议栈肯定可以做为保底的选项，需要移植5118和重新适配bt engine相关的部分。
  目前找到一个开源的传统蓝牙协议栈， 需要评估下是否合适。但商用需要交费
+ wilink
  mmc 3.0 速度不如预期
  usb wifi功耗稳定性问题
  对方评估了rk的方案，认为比我们的方案要好，具体还不清楚指那些方面， 后续需要约一下对方讨论下技术细节
+ 5118联合开发
  5118B tape out后就需要及早规划这部分了， 看如何分工合作
** 1009 aihora分析
*** 存储器布局
| START     | END       | USED      | MEMORY              |
| 009607H | 00EFFFH |   3584 | EDATA               |
| 00F000H | 00FFDFH |   3690 | EDATA_HIEDATA       |
| 00FFE0H | 00FFFFH |      2 | EDATA_PATCH_PARA    |
| 800040H | 800FFFH |    334 | ECODE_STARTUP       |
| 801000H | 801FFFH |    366 | HCONST_MP_PARAM     |
| 801000H | 801FFFH |    663 | HCONST_MP_PARAM_F   |
| 802000H | 8020FFH |     64 | HCONST_DESCRIP      |
| 802100H | 8022FFH |    468 | HCONST_CFGHEAD      |
| 802300H | 80FFFFH |     48 | CODE                |
| 802300H | 84FFFFH |   1415 | ECODE               |
| 802300H | 84FFFFH |   3898 | HCONST              |
| 802300H | 84FFFFH | 289118 | ECODE_FLASH         |
| 802300H | 84FFFFH |   8322 | HCONST_FLASH        |
| 850000H | 87FFFFH | 168354 | HCONST_DSP_ROM      |
| 880000H | 88FFFFH |  15816 | HCONST_CONFIG       |
| 890000H | 8F5FFFH |  54893 | HCONST_VO_DAT       |
| 8F6000H | 8F6FFFH |   4094 | HCONST_DSP_FUNCPARA |
| 8F7000H | 8F7FFFH |    543 | HCONST_DSP_HPFPARA  |
| 8F7000H | 8F7FFFH |   2224 | HCONST_DSP_PEQPARA  |
| 8F8000H | 8F8FFFH |      1 | HCONST_APP_CALLNAME |
| 8F9000H | 8F9FFFH |    503 | HCONST_MMI_V_NVRAM2 |
| 8F9600H | 8F9FFFH |      3 | MMI_C_V_NVRAM2      |
| 8FA000H | 8FAFFFH | 503 | HCONST_MMI_V_NVRAM  |
| 8FA600H | 8FAFFFH | 3 | MMI_C_V_NVRAM       |

+ 内存部分
  0x8000~0x9607 共5639字节ROM和闭源部分使用的全局内存，其中还包含一些在ram中的patch代码，
  0xf000 开始的3690字节的内存，存放的主要是不开源部分，在flash上的代码使用的全局内存，比如充电，温度，fm以及蓝牙链路管理的一些数据结构。
  0x9607 开始的3584字节 开始的部分主要就是开源部分使用的内存，包括MMI，驱动，以及profile等。
  剩下的大约19k的内存，用作全局的heap， heap是按照多个pool管理的，
  一个典型的具体配置如下：
  | pool名称             | 大小（项数x大小） |
  | CallArrayEntries     | 16 * 4            |
  | TimerArrayEntries    | 50 * 4            |
  | OSMEM1ArrayEnties    | 40 *50            |
  | OSMEM2SmallTxEntries | 9 * 702           |
  | OSMEM2TinyRxEntries  | 3 * 62            |
  | OSMEM2SmallRxEntries | 3 * 1100          |
  | OSMEM2LargeRxEntries | 2 * 1100          |
  | UartDmaRxBufSize     | 380               |
+ Flash部分
  固化了1M的nor， 总共用了551,663字节， 其中代码289,118， DSP的代码是168，354，剩下的注释配置数据， 其中语音提示音配置数据54,893，包含了中英文， 一种语言的话大概27K
+ ROM部分
  从FE8000开始的96k是rom，大部分（75K左右）是蓝牙的链路控制（LC），主机控制（HC），以及链路控制切换（LCS），剩下的一些其他代码，主要是kernel，设备驱动，以及SDK的一些运行环境的代码。
*** 主要模块
**** 模块划分
主要模块的资源开销如下：
| module name | code size | data size | rodata size |
| COMMON      |      3924 |       226 |         842 |
| sector      |         0 |         0 |       22300 |
| DRIVER      |     32958 |       486 |       55750 |
| DSP         |       904 |         5 |           0 |
| MMI         |     73329 |      1560 |        2928 |
| HC          |     20125 |       939 |        1271 |
| LM          |     94343 |      2526 |        2329 |
| LC          |     12326 |      2234 |         296 |
| L2CAP       |      6673 |       380 |         506 |
| GAP         |      2284 |        25 |           0 |
| SDAP        |      6484 |        98 |          55 |
| HFP         |      7250 |        94 |        1688 |
| A2DP        |      9754 |       136 |         164 |
| AVRCP       |      4673 |        44 |      184834 |
| RFCOMM      |      6643 |       146 |         274 |
| AVCTP       |      1409 |        44 |          18 |
| AVDTP       |      2978 |        26 |          18 |
| _Rom_Only   |     92860 |      3572 |        5498 |
| Patch       |       859 |         2 |           0 |

**** 模块简述
***** sector
存放在norflash上的配置数据，各个模块的配置数据，包括：soc的寄存器，rf参数，设备驱动，蓝牙相关协议，语音提示音等。
其中dsp的配置中有看到支持两个mic， 4路AEC，以及语音命令。

| file name                                                                  | rodata size |
| .\output\AB1520S\Release_Flash\sector_config0_header.obj                   |          48 |
| .\output\AB1520S\Release_Flash\sector_config1_header.obj                   |         219 |
| .\output\AB1520S\Release_Flash\sector_boundary_header.obj                  |          48 |
| .\output\AB1520S\Release_Flash\sector_voice_data_header.obj                |          21 |
| .\output\AB1520S\Release_Flash\sector_runtime_header.obj                   |          12 |
| .\output\AB1520S\Release_Flash\sector_tool_misc_header.obj                 |          21 |
| .\output\AB1520S\Release_Flash\sector_dsp_data_header.obj                  |          21 |
| .\output\AB1520S\Release_Flash\sector_merge_runtime_header_1.obj           |          39 |
| .\output\AB1520S\Release_Flash\sector_merge_runtime_header_2.obj           |          39 |
| .\output\AB1520S\Release_Flash\sector_a2dp_nvram_ctl_type.obj              |          57 |
| .\output\AB1520S\Release_Flash\sector_driver_buzzer_data_type.obj          |          42 |
| .\output\AB1520S\Release_Flash\sector_driver_led_data_type.obj             |         813 |
| .\output\AB1520S\Release_Flash\sector_driver_ringtone_data_type.obj        |         426 |
| .\output\AB1520S\Release_Flash\sector_hc_parameter_type.obj                |         143 |
| .\output\AB1520S\Release_Flash\sector_lc_misc_ctl.obj                      |          43 |
| .\output\AB1520S\Release_Flash\sector_lm_parameter_type.obj                |           6 |
| .\source\SECTOR\sector_mcu_dsp_parameter_init.obj                          |          22 |
| .\output\AB1520S\Release_Flash\sector_mmi_nvram_keymap.obj                 |         437 |
| .\output\AB1520S\Release_Flash\sector_mmi_nvram_type.obj                   |       1,356 |
| .\output\AB1520S\Release_Flash\sector_sys_local_device_control_type.obj    |          95 |
| .\output\AB1520S\Release_Flash\sector_sys_local_device_info.obj            |          52 |
| .\output\AB1520S\Release_Flash\sector_sys_local_device_EIR.obj             |          54 |
| .\output\AB1520S\Release_Flash\sector_sys_memory_config.obj                |          22 |
| .\output\AB1520S\Release_Flash\sector_mmi_driver_nvram_backup_type.obj     |          45 |
| .\output\AB1520S\Release_Flash\sector_sm_nvram_type.obj                    |           6 |
| .\output\AB1520S\Release_Flash\sector_uart_parameter.obj                   |          16 |
| .\output\AB1520S\Release_Flash\sector_afe_init.obj                         |         513 |
| .\output\AB1520S\Release_Flash\sector_sfr_init.obj                         |         453 |
| .\output\AB1520S\Release_Flash\sector_rf_misc_ctl.obj                      |         132 |
| .\output\AB1520S\Release_Flash\sector_hw_misc_ctl.obj                      |          15 |
| .\output\AB1520S\Release_Flash\sector_gap_nvram_type.obj                   |          11 |
| .\output\AB1520S\Release_Flash\sector_tool_info.obj                        |       2,089 |
| .\output\AB1520S\Release_Flash\sector_ae_info.obj                          |          51 |
| .\source\SECTOR\sector_driver_ctl_type.obj                                 |          49 |
| .\output\AB1520S\Release_Flash\sector_application.obj                      |          10 |
| .\output\AB1520S\Release_Flash\sector_iap2_type.obj                        |           0 |
| .\output\AB1520S\Release_Flash\sector_uart_parameter_eng.obj               |          16 |
| .\output\AB1520S\Release_Flash\sector_le_misc_ctl.obj                      |           0 |
| .\output\AB1520S\Release_Flash\sector_sys_patch_code_init.obj              |         136 |
| .\source\SECTOR\sector_dsp_vp_nb.obj                                       |       8,706 |
| .\output\AB1520S\Release_Flash\sector_mp_parameter.obj                     |         366 |
| .\output\AB1520S\Release_Flash\sector_mmi_driver_variation_nvram_type2.obj |         503 |
| .\output\AB1520S\Release_Flash\sector_mmi_driver_variation_nvram_type.obj  |         503 |
| .\output\AB1520S\Release_Flash\sector_dsp_func_para.obj                    |       4,094 |
| .\output\AB1520S\Release_Flash\sector_dsp_hpf_param_type.obj               |         543 |
| .\output\AB1520S\Release_Flash\sector_dsp_peq_param_type.obj               |           0 |
| .\source\SECTOR\sector_app_callername_data.obj                             |           1 |
| .\output\AB1520S\Release_Flash\sector_mmi_customize_v_nvram2.obj           |           3 |
| .\output\AB1520S\Release_Flash\sector_mmi_customize_v_nvram.obj            |           3 |
| .\output\AB1520S\Release_Flash\sector_mmi_le_variation_nvram_type.obj      |           0 |
| .\output\AB1520S\Release_Flash\sector_mmi_le_variation_nvram_type2.obj     |           0 |
| .\output\AB1520S\Release_Flash\sector_mp_parameter_F.obj                   |           0 |

***** COMMON模块
| .\source\COMMON\flash_descriptor.obj |0 |0 |64 |0|
802000    64 OBJECT   LOCAL  _FlashDescriptor
应该是nor flash的分区划分。
| .\source\COMMON\BootCode.obj |334 |4 |0 |0|
800043   331 FUNC     LOCAL  SYS_DecideBootCode??
boot代码，brom出来应该从这个地方跑起来，跑起来后会填充gFlashDescriptor指向的数据结构，然后再执行sdk_app
9607     4 OBJECT   LOCAL  gFlashDescriptor
在内存9607的位置定义了一个gFlashDescriptor的全局指针， 指向一个flash descriptor的结构， 这个结构描述了在flash的配置区域放置的各种配置数据。
***** 链路层管理

| HC          |     20125 |       939 |        1271 |
| LM          |     94343 |      2526 |        2329 |
| LC          |     12326 |      2234 |         296 |

都不开源
+ HC
  主要是HCI层命令和扩展命令处理
  | file name                       | code size | data size | rodata size |
  | .\source\HC\hc_flash.obj        | 6,883     |       485 |       1,112 |
  | .\source\HC\hci_xport_flash.obj | 448       |         0 |           0 |
  | .\source\HC\INT1_ISRHandler.obj | 182       |         0 |           0 |
  | .\source\HC\HC_VCMD_flash.obj   | 11,051    |        32 |         159 |
  | .\source\HC\ChAssess_Hdlr.obj   | 1,561     |       422 |           0 |
+ LM
  链路层协议处理，包含LMP， AFH，加密key，配对，sniff模式，连接建立(acl sco esco)，电源管理等功能。
  | file name                                          | code size | data size | rodata size |
  | .\source\LM\LM.obj                                 | 24,154    |     2,235 |         578 |
  | .\source\LM\LM_AFH.obj                             | 2,848     |         0 |           7 |
  | .\source\LM\LM_AnyTimePDU.obj                      | 1,643     |         0 |           0 |
  | .\source\LM\LM_AuthEnc.obj                         | 11,130    |         0 |           2 |
  | .\source\LM\LM_CheckFeatures.obj                   | 0         |         0 |           0 |
  | .\source\LM\LM_ConnectSetup.obj                    | 1,416     |         0 |           0 |
  | .\source\LM\LM_CreateConnection.obj                | 3,147     |         0 |           0 |
  | .\source\LM\LM_CreateSynchronousConnection.obj     | 5,167     |         0 |           0 |
  | .\source\LM\LM_Detach.obj                          | 2,366     |         0 |           0 |
  | .\source\LM\LM_ExtendedSynchronousConnectSetup.obj | 2,601     |         0 |           0 |
  | .\source\LM\LM_ExtendedSynchronousDisconnect.obj   | 354       |         0 |           0 |
  | .\source\LM\LM_Hold.obj                            | 1,851     |         0 |           0 |
  | .\source\LM\LM_InformationRequest.obj              | 3,515     |         0 |           0 |
  | .\source\LM\LM_Inquiry.obj                         | 1,210     |         2 |           0 |
  | .\source\LM\LM_Misc.obj                            | 1,005     |         0 |           0 |
  | .\source\LM\LM_PacketTypeChange.obj                | 2,751     |         0 |           0 |
  | .\source\LM\LM_PowerControl.obj                    | 881       |         0 |           0 |
  | .\source\LM\LM_QoS.obj                             | 1,460     |         0 |           0 |
  | .\source\LM\LM_RoleSwitch.obj                      | 5,111     |         0 |           0 |
  | .\source\LM\LM_Security.obj                        | 6,779     |         0 |          36 |
  | .\source\LM\LM_SecurityTable.obj                   | 0         |         0 |       1,536 |
  | .\source\LM\LM_SimplePairing.obj                   | 5,895     |       289 |         170 |
  | .\source\LM\LM_SniffMode.obj                       | 6,526     |         0 |           0 |
  | .\source\LM\LM_SynchronousConnectSetup.obj         | 1,687     |         0 |           0 |
  | .\source\LM\LM_SynchronousDisconnect.obj           | 358       |         0 |           0 |
  | .\source\LM\LM_Testmode.obj                        | 488       |         0 |           0 |
  | .\source\LM\LM_VCMD.obj                            | 0         |         0 |           0 |
+ LC
  链路控制：蓝牙master，slave模式，主从切换，匹克网管理
  | file name                               | code size | data size | rodata size |
  | .\source\LC\lc_flash.obj                | 3,387     |     2,067 |           0 |
  | .\source\ROM\LC\LC_DirectTestmode.obj   | 740       |         0 |          56 |
  | .\source\ROM\LC\LC_Initiating.obj       | 0         |         0 |           0 |
  | .\source\ROM\LC\LC_MasterRoleSwitch.obj | 2,460     |         2 |          96 |
  | .\source\ROM\LC\LC_Testmode.obj         | 3,085     |         1 |          24 |
  | .\source\ROM\LC\LC_Scanning.obj         | 0         |         0 |           0 |
  | .\source\ROM\LC\LC_SlaveRoleSwitch.obj  | 1,823     |         0 |          96 |
  | .\source\LC\LC_RssiScan_flash.obj       | 831       |       164 |          24 |
***** MMI
MMI层都是开源的，
MMI是蓝牙产品中的应用逻辑层，会处理跟协议无关，跟驱动实现本身无关的应用逻辑，相当于一个适配层，实现协议要求的应用处理的动作，和我们实现的bt engine有一些类似。
除了蓝牙协议相关处理外，还有其他的使用驱动的适配层。本身的驱动的实现是不开源的。
| file name                                            | code size | data size | rodata size |
| .\output\AB1520S\Release_Flash\MMI.obj               | 3,129     |     1,045 |           0 |
| .\output\AB1520S\Release_Flash\MMI_Base.obj          | 4,522     |         6 |           0 |
| .\output\AB1520S\Release_Flash\MMI_ChgBat.obj        | 1,080     |         0 |           0 |
| .\output\AB1520S\Release_Flash\MMI_Driver.obj        | 11,387    |       103 |       1,091 |
| .\output\AB1520S\Release_Flash\MMI_Protocol.obj      | 2,255     |        20 |           0 |
| .\output\AB1520S\Release_Flash\MMI_State.obj         | 3,783     |       168 |          96 |
| .\output\AB1520S\Release_Flash\MMI_Timer.obj         | 223       |         0 |           0 |
| .\output\AB1520S\Release_Flash\MMI_SDAP.obj          | 1,993     |         0 |          89 |
| .\output\AB1520S\Release_Flash\MMI_A2DP.obj          | 3,559     |         3 |           0 |
| .\output\AB1520S\Release_Flash\MMI_HFP.obj           | 11,970    |       123 |         577 |
| .\output\AB1520S\Release_Flash\MMI_SectorManager.obj | 1,926     |         3 |           0 |
| .\output\AB1520S\Release_Flash\MMI_ServiceRecord.obj | 0         |        24 |         166 |
| .\output\AB1520S\Release_Flash\MMI_HCI.obj           | 14,275    |        16 |         350 |
| .\output\AB1520S\Release_Flash\MMI_AVRCP.obj         | 4,239     |        26 |         283 |
| .\output\AB1520S\Release_Flash\MMI_FM.obj            | 1,133     |         4 |          92 |
| .\output\AB1520S\Release_Flash\MMI_TestMode.obj      | 1,253     |        16 |          70 |
| .\output\AB1520S\Release_Flash\MMI_LineIn.obj        | 1,946     |         3 |         114 |
| .\output\AB1520S\Release_Flash\MMI_TrspXport.obj     | 0         |         0 |           0 |
| .\output\AB1520S\Release_Flash\MMI_Reconnect.obj     | 4,339     |         0 |           0 |
| .\output\AB1520S\Release_Flash\MMI_LED.obj           | 268       |         0 |           0 |
| .\output\AB1520S\Release_Flash\MMI_Inquiry.obj       | 0         |         0 |           0 |
| .\output\AB1520S\Release_Flash\MMI_FCD.obj           | 49        |         0 |           0 |
| .\output\AB1520S\Release_Flash\MMI_HID.obj           | 0         |         0 |           0 |
| .\output\AB1520S\Release_Flash\MMI_LE.obj            | 0         |         0 |           0 |
***** DRIVER
+ ABSDRIVER
  不开源，
  nor flash的读写，pmu，adc， i2c， gpio， led， i2s驱动。这部分在flash的驱动代码，加上在rom中的代码构成soc上叫完整的底层驱动
  | file name                                      | code size | data size | rodata size |
  | .\source\ABSDRIVER\drv_flash_flash.obj         |       407 |         0 |           0 |
  | .\source\ABSDRIVER\drv_sector_flash.obj        |       564 |        12 |           0 |
  | .\source\ABSDRIVER\drv_pmu_flash.obj           |         0 |         0 |           0 |
  | .\source\ABSDRIVER\drv_adc0_flash.obj          |     1,009 |        54 |           0 |
  | .\source\ABSDRIVER\drv_program_flash_flash.obj |       551 |         0 |           0 |
  | .\source\ABSDRIVER\I2C.obj                     |     1,621 |        15 |           0 |
  | .\source\ABSDRIVER\drv_led.obj                 |     1,140 |        53 |           0 |
  | .\source\ABSDRIVER\drv_gpio_flash.obj          |     1,871 |         0 |           0 |
  | .\source\ABSDRIVER\drv_i2s.obj                 |       320 |         0 |           0 |
+ Voice
 开源，语音提示和语音命令的支持，语音提示的实现比较精巧，分成两个部分， 一部分是提示音本身的data， 一部分是提示音的控制脚本scp，data是很小的语音单元， 比如“电话”  “取消”是两条单独的语音数据。 通过脚本可以组合出，“电话取消”四个字的语音数据。
 语音提示支持中文和英文，大小各是26K左右的大小
 | file name                                               | code size | data size | rodata size |
 | .\source\DRIVER\AudioControl_1520HW.obj                 |     1,877 |         0 |           0 |
 | .\output\AB1520S\Release_Flash\Audio_MailBox.obj        |     1,145 |        24 |         312 |
 | .\output\AB1520S\Release_Flash\AudioControl.obj         |       647 |        28 |           0 |
 | .\output\AB1520S\Release_Flash\AudioControl_1520.obj    |     2,498 |         0 |          16 |
 | .\output\AB1520S\Release_Flash\voice_prompt_ctl.obj     |         0 |         0 |         741 |
 | .\output\AB1520S\Release_Flash\voice_prompt_data_1.obj  |         0 |         0 |      27,316 |
 | .\output\AB1520S\Release_Flash\voice_prompt_data_2.obj  |         0 |         0 |      26,836 |
 | .\output\AB1520S\Release_Flash\voice_command_ctl.obj    |         0 |         0 |           0 |
 | .\output\AB1520S\Release_Flash\voice_command_data_1.obj |         0 |         0 |           0 |
 | .\output\AB1520S\Release_Flash\voice_command_data_2.obj |         0 |         0 |           0 |
 | .\output\AB1520S\Release_Flash\VoicePrompt.obj          |     2,037 |         5 |          78 |
 | .\output\AB1520S\Release_Flash\VoiceCommand.obj         |         0 |         0 |           0 |
+ Driver
  开源，
  使用不开源部分的驱动来处理MMI层发送的消息，相当于一个驱动适配层
  | file name                                      | code size | data size | rodata size |
  | .\output\AB1520S\Release_Flash\Driver_FM.obj   | 1,391     |         2 |           0 |
  | .\output\AB1520S\Release_Flash\Driver_Key.obj  | 2,469     |        51 |           0 |
  | .\output\AB1520S\Release_Flash\Driver_Temp.obj | 951       |        22 |           0 |
  | .\output\AB1520S\Release_Flash\Driver_LED.obj  | 3,354     |        72 |           0 |
  | .\output\AB1520S\Release_Flash\DRIVER.obj      | 5,220     |       138 |         271 |
  | .\output\AB1520S\Release_Flash\DRIVER_1520.obj | 3,886     |        10 |         180 |
***** 核心协议栈
不开源
实现蓝牙协议的核心层
| file name |code size|data size|rodata size| overlay-data-size|
| .\source\L2CAP\L2CAP.obj |1,383 |330 |0 |0|
| .\source\L2CAP\L2CAP_low_energy.obj |0 |0 |0 |0|
| .\source\L2CAP\L2CAP_resource_manager.obj |1,953 |50 |0 |0|
| .\source\L2CAP\L2CAP_signaling.obj |3,337 |0 |506 |0|
| .\source\GAP\GAP.obj |2,284 |25 |0 |0|
| .\source\SDAP\SDAP.obj |6,484 |98 |55 |0|
***** 蓝牙profile
蓝牙耳机相关的profile的实现
| A2DP        |      9754 |       136 |         164 |
| AVRCP       |      4673 |        44 |      184834 |
| RFCOMM      |      6643 |       146 |         274 |
| AVCTP       |      1409 |        44 |          18 |
| AVDTP       |      2978 |        26 |          18 |
  A2DP HFP 和 AVRCP部分开源
| file name                                             | code size | data size | rodata size |
| .\output\AB1520S\Release_Flash\A2DP.obj               | 2,588     |       124 |          88 |
| .\output\AB1520S\Release_Flash\A2DP_MediaChannel.obj  | 1,152     |         0 |           0 |
| .\output\AB1520S\Release_Flash\A2DP_SignalChannel.obj | 6,014     |         0 |           0 |
| .\output\AB1520S\Release_Flash\A2DP_ServiceRecord.obj | 0         |        12 |          76 |
| .\output\AB1520S\Release_Flash\HFP.obj                | 857       |        76 |          54 |
| .\output\AB1520S\Release_Flash\HFP_Core.obj           | 6,393     |         0 |       1,063 |
| .\output\AB1520S\Release_Flash\HFP_ServiceRecord.obj  | 0         |        18 |         571 |
AVCTP AVDTP RFCOMM等协议不开源
| file name                                              | code size | data size | rodata size |
| .\source\AVCTP\AVCTP.obj                               | 1,409     |        44 |          18 |
| .\output\AB1520S\Release_Flash\AVRCP.obj               | 4,673     |        32 |         157 |
| .\output\AB1520S\Release_Flash\AVRCP_ServiceRecord.obj | 0         |        12 |     184,677 |
| .\source\RFCOMM\RFCOMM.obj                             | 2,459     |       146 |          18 |
| .\source\RFCOMM\rfcomm_crc.obj                         | 44        |         0 |         256 |
| .\source\RFCOMM\rfcomm_frame.obj                       | 4,140     |         0 |           0 |
***** Patch
patch基本都是汇编写的， 不是简单的替换整个函数的方式，而是尽量复用ROM中的代码，采用汇编的方式修改部分变量，寄存器和流程的方式。

patch根据实际的需要，有的是放在nor flash上执行的， 比如如下例子， 有的是放在ram中的。

一个patch的例子：

?EP?P003_f1_0xFF1944?P003 SEGMENT 'ECODE_FLASH'
PUBLIC P003_f1_0xFF1944??
RSEG ?EP?P003_f1_0xFF1944?P003	;program segment

P003_f1_0xFF1944??:
DB		0x44, 0x19, 0xFF
DB		0
EJMP	P003_f1_patch

P003_f1_patch:

MOV      0x80, #0xFF
MOV          A, #0x03
MOV      R7,R11
MOVZ     WR6,R7
XRL      WR4,WR4
DEC      DR4,#0x01
ECALL    0xFFEA41  //LC_TIMER_GetExpiredTime
//MOV      0x8052,DR4
MOV      A,R4
MOV         DPTR, #0x8052
MOVX      @DPTR,A
P003_f1_patch_01:
//MOV      DR4,0x8052
MOV         DPTR, #0x8052
MOVX      A,@DPTR
MOV      R4,A
ECALL    0xFFE8EC //LC_TIMER_IsExpired
JZ       P003_f1_patch_01
SETB     0xF8.6
MOV      0x80, #0x00
EJMP     0xFF194B

| .\output\AB1520S\Release_Flash\AB1520_Patch.obj |859 |2 |0 |0|
***** ROM代码
ROM代码总共有90多K，主要功能包括：
+ GPIO驱动
+ PMU驱动
+ SPI flash驱动
+ 旺宏的nor flash驱动
+ TIMER
+ ADC0驱动
+ ADC1驱动
+ 蓝牙时钟
+ UART驱动
+ DMA驱动
+ OS的代码
+ FHS包的处理
+ 链路调度
+ 链路管理的蓝牙时钟，寻呼，查询等底层功能
+ LE的广播和通道管理
+ 链路控制，sniffer，主从切换等
+ HCI传输
+ H4协议支持
+ H5协议支持
+ 测试模式
+ 固件升级接口

*** 任务模型
看来起应该是是一个多任务的操作系统， 这部分不开源，但从os_task.h的头文件来看， 应该是一个简单的多任务系统，代码大小从map表上看大概6K左右，
主要的功能有：
+ 任务管理
+ 内存分配
+ 消息队列
+ Timer管理
没有更丰富的操作系统功能，比如优先级， 信号量等。

系统总共定义了5个任务， 如下：
#define TASKENTRY_KERNEL	TASKDEFINE( Kernel )
#define TASKENTRY_LM		TASKDEFINE( LM )
#define TASKENTRY_HC		TASKDEFINE( HC )
#define TASKENTRY_MMI		TASKDEFINE( MMI )
#define TASKENTRY_DRIVER	TASKDEFINE( DRIVER )

其中:
HC  Kernel  LM都是不开源的，
**** 任务概览
***** HC
上层profile和底层应该仍然使用了hci层来接口。  主要是HCI层命令和扩展命令处理
***** LM
链路层协议处理，包含LMP， AFH，加密key，配对，sniff模式，连接建立(acl sco esco)，电源管理等功能。
***** DRIVER
处理MMI层发送给驱动的消息并调用相应驱动， 处理FM ，timer等驱动时间。
#+BEGIN_SRC C
DRIVER
         DRIVER_ProcMmiCmd();
         DRIVER_FM_Handler();
         DRIVER_Key_Polling();
         DRIVER_MailBoxHandler();
         DRIVER_RingtoneVPFMCmdScheduler();
         DRIVER_CheckTimer();
         DRIVER_CheckPwrKey();
         DRIVER_MuteUnMuteAmpOpenCloseHandler();
         DRIVER_CheckA2DPMusicStartAnchor();
         DRIVER_LED_Scheduler();
         LED_CheckTimer();
         DRIVER_TEMP_Check();
         DemoSound_Polling();
#+END_SRC
***** MMI

MMI是蓝牙产品中的应用逻辑层，处理蓝牙协议相关需要用户处理的事件，除了蓝牙协议相关处理外，还有其他的使用驱动的适配层。
#+BEGIN_SRC C
   MMI
     GAP
     L2CAP();
     MMI_InterruptDebug();
     GAP_TestCaseGeneration();
     MMI_HCI_Handler();
     MMI_PROTOCOL_EventHandler();
     MMI_ProfileHandle();
     MMI_AVRCP_Handle();
     MMI_MusicYouCanSeeHandler();
     MMI_DRV_EventHandler();
     MMI_MediaEventHandler();
     MMI_EEPROMUpdateHandler();
     MMI_SECTOR_SaveData(SAVE_DATA_TYPE_RUNTIME);
     MMI_PollingBatStatus();
     MMI_ConnectableToConDiscoveable();
     MMI_CheckTimer();
     OLED_CheckTimer();
     MMI_LineIn_EncodedDataHandler();
     GAP_TestCaseGeneration();
#+END_SRC

***** Kernel
OS本身任务入口，应该是处理系统相关的一些事件的。
**** 按键处理
在1520s中总共定义了13个物理按键，13个物理按键在不同的蓝牙场景会被映射成统一编码的keycode。同一个按键在不同的蓝牙服务存在的时候会是不同的keycode。

按键处理是在DRIVER这个任务中进行按键查询，在DRIVER_Key_Polling获取按键的扫描码并做好去抖，长按处理。MMI_DRV_KeyParser会根据当前活跃的蓝牙服务，把扫描码映射成统一的keycode。

MMI_DRV_KeyEventHandler根据keycode来调用不同的按键处理函数， 具体流程如下：

#+BEGIN_SRC C
DRIVER
     DRIVER_Key_Polling(void)
       KeypadScanKeyDebounce(&gDriver_Key_Ctl.currKeyBitmap))
       DRIVER_Key_SendEvent(scanInd, KEY_UP);
       gMMI_Drv_Handler.fDriverKeyEvent(keyIndex, keyAction);
       MMI_DRV_KEY_Event(KeyIndex keyIndex, U8 keyAction)
         keyEventCode= MMI_DRV_KeyParser(keyIndex, keyAction);
           gMMI_ctl.driverCtl.keyDownState = MMI_GetTopStateByLink(gMMI_ctl.serviceInd);
         MMI_DRV_KeyHandler(U8 keyEventCode)
           MMI_DRV_KeyEventHandler(gMMI_ctl.serviceInd, keyEventCode);

DRV_KeyEventHandler
     case SYSTEM_KEY_EVENT:
       MMI_DRV_ProcessKeyEvent(linkIndex, index);
               MMI_DRV_KeyVoiceUp
                 MMI_DRV_VoiceAdjustment(linkIndex, KEY_VOICEUP);
                   MMI_A2DP_VolumeControl(linkIndex, isVolumeUp);
                     MMI_A2DP_SendDriverVolCmd(*spkSoundLevelPtr,
                       OSMQ_Put(OSMQ_DRIVER_Command_ptr,
     case HFP_KEY_EVENT:
       MMI_HFP_ProcessKeyEvent(linkIndex, index);
     case AVRCP_KEY_EVENT:
       MMI_AVRCP_ProcessKeyEvent(linkIndex, index);
     case FM_KEY_EVENT:
       MMI_FM_ProcessKeyEvent(linkIndex, index);
     case LINE_IN_KEY_EVENT:
       MMI_LineIn_ProcessKeyEvent(linkIndex, index);
#+END_SRC

**** 任务间通讯
在不同任务间，以及在不用的功能模块间，使用消息队里的方式进行通信， 比如如下序列：
+ GAP运行在MMI任务中，通过OSMQ_GAP_Event_To_MMI_ptr队列发送消息给MMI，
+ MMI在MMI_HCI_Handler获取消息，处理完成后通过MMI_HCI_SendCmd发送到OSMQ_HCIDRV_Command_From_GAP_ptr消息队列中，后者是通过总线发送给HC模块

#+BEGIN_SRC C
   MMI_HCI_Handler();
       OSMQ_Get (OSMQ_GAP_Event_To_MMI_ptr)) != (MMIMsgType XDATA_PTR)NULL)
       switch (msgPtr->eventCode)
       case HCI_EVENT_CONNECTION_REQUEST:
       MMI_HCI_ConnectionReq(msgPtr);
         case LINK_TYPE_ACL_CONNECTION_REQUEST:
         linkIndex = MMI_GetEmptyLinkIndex((U8 XDATA_PTR)&msgPtr->msgBodyPtr.hciEvt.connRequestEvt.BdAddr, FALSE)) < MAX_MULTI_POINT_NO )
         msgPtr->msgOpcode = HCI_CMD_ACCEPT_CONNECTION_REQUEST;
         MMI_HCI_SendCmd(msgPtr);
           OSMQ_Put (OSMQ_HCIDRV_Command_From_GAP_ptr, (U8 XDATA_PTR)msgPtr);
#+END_SRC

系统中使用的消息队列如下：
#+BEGIN_SRC C
    //- Input Queue of Kerner Task
    OSMQ OSMQ_HCI_ACL_Data_To_Host[NUM_OF_SUPPORTED_ACL_LINK];
    OSMQ OSMQ_HCI_Event_To_Host;
    OSMQ OSMQ_HCI_Event_To_Xport;
    //- Input Queue of HC Task
    OSMQ OSMQ_HCI_Command_From_Host;
    OSMQ OSMQ_HCI_Command_To_LC[NUM_OF_SUPPORTED_ACL_LINK];
    //- Input Queue of LM/LL Task
    OSMQ OSMQ_HCI_Command_Relay_To_LM[NUM_OF_SUPPORTED_ACL_LINK];
    OSMQ OSMQ_LMP_Data_To_LM[NUM_OF_SUPPORTED_ACL_LINK];
    #if (LE_SUPPORTED_CONTROLLER)
    OSMQ OSMQ_HCI_Command_To_LL;
    #endif
    //- Input Queue of LC
    OSMQ OSMQ_HCI_ACL_Data_From_Host[NUM_OF_SUPPORTED_ACL_LINK];    /* PDU from Host */
    OSMQ OSMQ_LMP_Data_From_LM[NUM_OF_SUPPORTED_ACL_LINK];
    OSMQ OSMQ_HCI_BC_Data_From_Host;
    //- BC
    OSMQ OSMQ_HC_BC_Data_From_Bus;
    OSMQ OSMQ_code;
    OSMQ OSMQ_I2C_SPI_IssueBuffer;
    //- HC
    OSMQ OSMQ_HC_Event_To_Bus;
    OSMQ OSMQ_HC_Data_To_UART;
    OSMQ OSMQ_HC_Command_From_Bus;
    OSMQ OSMQ_HC_Event_To_UART;
    //- NEW HC
    OSMQ OSMQ_NHC_Event_To_Bus;
    OSMQ OSMQ_NHC_Data_To_Bus;
    OSMQ OSMQ_NHC_Data_From_Bus[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_NHC_Command_From_Bus;
    OSMQ OSMQ_NHC_Command_From_UART;
    OSMQ OSMQ_UART_TX_Data;
    //- LC
    #ifdef INQUIRY_SUPPORT
    OSMQ OSMQ_LC_Inquiry_Command_From_LM;
    OSMQ OSMQ_LC_Inquiry_Event_To_LM;
    #endif
    OSMQ OSMQ_LC_Page_Command_From_LM;
    OSMQ OSMQ_LC_Page_Event_To_LM;
    OSMQ OSMQ_LC_PageScan_Event_To_LM;
    //- LM
    OSMQ OSMQ_HC_CmdRsp;
    OSMQ OSMQ_HC_Rsp_By_Link[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_HC_Cmd_By_Link[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_LM_Event_To_HC;
    OSMQ OSMQ_LM_BCData_To_HC;
    OSMQ OSMQ_LM_Normal_Pdu[MAX_NUM_ACL_LINK];
    //- BC
    OSMQ OSMQ_LC_BCData_From_LM_HC;
    OSMQ OSMQ_LC_BCData_Completed_To_LM_HC;
    //- LC
    OSMQ OSMQ_LC_Data_From_LM[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_LC_Data_From_HC[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_LC_Command_From_LM[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_LC_Event_To_LM[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_LC_Data_To_LM[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_LC_Data_To_HC[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_LC_Completed_Data_To_HC[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_LC_Recycle_Data_To_HC[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_LC_Command_From_HC[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_LC_Event_To_HC[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_LC_Ack_To_LM[MAX_NUM_ACL_LINK];
    OSMQ OSMQ_LC_Data_From_HC_TEMP_NON_AUTO_FLUSH[MAX_NUM_ACL_LINK];
    // HCI
    OSMQ OSMQ_HCIDRV_Data_From_Bus[MAX_MULTI_POINT_NO];
    // GAP
    OSMQ OSMQ_GAP_Command_From_PROFILE;
    OSMQ OSMQ_GAP_Event_To_MMI;
    #ifdef LE_SUPPORTED_HOST
    OSMQ OSMQ_GAP_Event_To_MMILE;
    #endif
    OSMQ OSMQ_LC_Cmd_from_LL;
    OSMQ OSMQ_LC_Data_from_LL[MAX_NUM_LE_LINK];
    OSMQ OSMQ_LC_Ack_To_LL[MAX_NUM_LE_LINK];
    OSMQ OSMQ_LC_Event_To_LL;
    OSMQ OSMQ_LC_Data_To_LL[MAX_NUM_LE_LINK];
    OSMQ OSMQ_LC_LE_Event_To_HC;
    OSMQ OSMQ_LL_Event_To_HC;
    OSMQ OSMQ_HC_Command_To_LL;
    OSMQ OSMQ_HC_Cmd_By_Link_To_LL[MAX_NUM_LE_LINK];
    OSMQ OSMQ_LC_LE_Data_To_HC[MAX_NUM_LE_LINK];
    OSMQ OSMQ_HC_LE_Data_From_Bus[MAX_NUM_LE_LINK];
    OSMQ OSMQ_HC_FlashData_From_UART;
    OSMQ OSMQ_HC_FlashData_To_UART;
    OSMQ OSMQ_NHC_LE_Data_From_Bus[MAX_NUM_LE_LINK];
    #ifdef HID_SOC
    OSMQ OSMQ_MCU_DATA_IN;
    OSMQ OSMQ_MCU_DATA_OUT;
    #endif
    /* For FEA_NEW_CONNHDL */
    OSMQ OSMQ_LM_Free_Link;
    OSMQ OSMQ_LM_Used_Link;
} ALIGN_OSMQ_STRU;
#+END_SRC

**** DSP
语音提示，语音命令，解码等都是通过dsp来完成的， mcu和dsp之间是通过一个mailbox来进行交互的。
***** DSP的配置信息
DSP的功能参数配置， 音箱的定义在 "..\DSP\AB1520S_DSP\DSP_PARA_AB1520S_MUSICBOX_TARGET.txt"文件中，主要包含如下内容：
4路AEC的配置 AEC/NR/AVC， 接收和发送的噪声消除   VAD的配置， 双mic的配置，接收和发送的音效设置，还有一些PLC， PEQ等配置，以及不太看明白的其他配置。

***** MCU和DSP的交互

在mailbox的数据结构中，有两部分，一部分是mcu给dsp的命令， 另外一部分是dsp给mcu的事件响应。
每一个数据结构都有 rw_word来表明当前控制权在mcu还是dsp， 当rw_word为MCU_Owned的时候，mcu才能操作对应的数据结构，mcu操作完数据结构后，把rw_word设置为DSP_Owned，然后通过设置一个特殊寄存器（FBOFFS_WO_DSP_INT_CTL）启动DSP

具体数据结构如下:
#+BEGIN_SRC C
typedef struct                //two mailbox structure include M2D & D2M
{
        M2D_CTL_STRU m2d_ctl;
        D2M_CTL_STRU d2m_ctl;
} MAILBOX_CTL_STRU;

typedef struct d2m_ctl_s
{
        volatile U16 rw_word;
        D2M_EVT_STRU evt_word;
}D2M_CTL_STRU;

typedef struct
{
        volatile U16  rw_word;
    U16 task;
        M2D_CMD_STRU  cmd;
        M2D_PARA_STRU para;
}M2D_CTL_STRU;


VFUN CODE Mailbox_EVENTCB_Handler[] =
{
        CMD_REPLY_EvtHandler,
        VP_END_EvtHandler,
        RT_END_EvtHandler,
    VC_END_EvtHandler
};
#+END_SRC
***** 语音命令的实现流程
sdk中是支持语音命令的，接打电话，语音拨号，以及配对等看到的如下：
VC_DATA_DEFINE	(PAIRING)
VC_DATA_DEFINE	(CHECK_STATUS)
VC_DATA_DEFINE	(MAKE_A_CALL)
VC_DATA_DEFINE	(BATTERY_LEVEL)
VC_DATA_DEFINE	(CHECK_BATTERY)
VC_DATA_DEFINE	(CONNECTION_STATUS)
VC_DATA_DEFINE	(LAST_CALL_OUT)
VC_DATA_DEFINE	(VOICE_DIAL)
VC_DATA_DEFINE	(RING_BACK)
VC_DATA_DEFINE	(WHAT_CAN_I_SAY)
VC_DATA_DEFINE	(TAKE_THE_CALL)
VC_DATA_DEFINE	(REJECT)
VC_DATA_DEFINE	(CANCEL)

****** 主要工作流程

+ VoiceCommand_Start通过mailbox开始启动DSP进入命令监听状态
+ MailBox_EvtHandler在接收到有效的命令后，会通过mailbox发送识别结果
+ Driver_MailBoxOgfVCEvtHandle来处理语音命令结果
  根据语音结果，做相应处理，比如停止掉音乐，并把有效的结果根据当前跑的协议的上下文，转换成一个按键事件， 最后调用MMI_DRV_KeyEventHandler来处理该按键事件
+ 按键事件处理中，完成对应的蓝牙协议的控制动作

  具体代码流程如下：
#+BEGIN_SRC C
VoiceCommand_Start
  DRIVER_SendCmdToMailBox
    MailBox_CmdHandler
       while(gAlignDSP.Mailbox.m2d_ctl.rw_word == DSP_Owned){}
       Mailbox_StateHandler[CMD_PTR->m2d_ctl.cmd.Ogf][CMD_PTR->m2d_ctl.cmd.Ocf] (CMD_PTR);
       PromptStart_SubStateHandler,
           DSP_Enable(CMD_PTR->m2d_ctl.para.dsp_gain_para.DspClock);
           MailBox_State[CMD_PTR->m2d_ctl.cmd.Ogf].CmdPtr = CMD_PTR;
           gAlignDSP.Mailbox.m2d_ctl.rw_word = DSP_Owned;
           HC_SFR_WRITE_BY_FB (FBOFFS_WO_DSP_INT_CTL,0x8);

MailBox_EvtHandler
   Mailbox_EVENTCB_Handler[gAlignDSP.Mailbox.d2m_ctl.evt_word.Evt-EVT_CODE] ();
   VC_END_EvtHandler
       gVC_ctl.result = gAlignDSP.Mailbox.d2m_ctl.evt_word.para.vc_evt_para.vc_result;
       MailboxSendEvtToDriver(EVT_PTR, OGF_VC, OCF_VC_STOP);
         DRIVER_ProcMailboxEvent((U8 XDATA_PTR)EVT_PTR);
           OSMQ_Put(&Driver_MailBox_Evt, (U8 XDATA_PTR)msgPtr);

DRIVER
   DRIVER_MailBoxHandler();
     Driver_MailBoxOgfVCEvtHandle, //OGF_VC,
       DRIVER_SetGainAndMute(TARGET_NONE);
       VoiceCommand_Stopped();
         AUDIO_SetAudioOff (AUDIO_VOICECOMMAND);
         DRIVER_VoiceCommandOffCallback();
           matchedNo = VoiceCommand_GetEvtIndex(gVC_ctl.result);
         gVC_ctl.vcnextLayer = VoiceCommand_VCLayer(matchedNo);
           DRIVER_SendVoiceCommandEndedEvent(gDriver_ctl.playingRingtoneId,
              MMI_DRV_VoiceCommandEnd_Event,//fDriverVoiceCmdEndEvent
                 keyEventCode =
                 MMI_DRV_LookUpKeyMapTable((VoiceCommand_GetActionTable
                 MMI_DRV_VoiceCommand_ResultProcessed(keyEventCode);
                    MMI_DRV_KeyEventHandler(gMMI_ctl.serviceInd, (U8)keyEventCode);
#+END_SRC
*** profile开发
在ab1520S中，底层的核心协议是不开源的， A2DP和AVRCP等和应用层配合比较紧密的协议是开源的。

对每个profile都使用一个MMI_PROFILE_DESC来描述， 在该描述中提供如下信息，profile的任务入口函数， 建立链接的回调，断开连接的回调，以及链接建立后，在链接上的事件和数据回调。

在profile需要的资源初始化后， 就通过SDAP_RegisterServiceRecord注册服务信息到服务发现协议中，这样在对方扫描的时候就可以发现该服务。

最后通过MMI_RegisterProfile把上层profile注册到profile管理系统中。这样通用的profile对应的链接建立，和断开等l2cap所需要的功能就可以被蓝牙协议栈管理了。

当一个profile的链接建立以后，其对应的PROFILE_TASK_FUNC就会在MMI任务中被调用
#+BEGIN_SRC C
        struct stMmiProfileDesc
        {
                U8 profileId;
                PROFILE_TASK_FUNC			ProfileTaskFunc;
                PROFILE_CONNECT_REQUEST		ProfileConnectRequest;
                PROFILE_DISCONNECT_REQUEST	ProfileDisconnectRequest;
                PROFILE_LINK_EVENT			ProfileLinkEvent;
                PROFILE_DATA_EVENT			ProfileDataEvent;
        };
#+END_SRC
**** A2DP profile的例子
A2DP的profile
#+BEGIN_SRC C
static AVDTP_PROFILE_DESC CODE gA2DP_ProfileDesc = {
        { // MMI_PROFILE_DESC
                PROFILE_A2DP,
                A2DP,					//ProfileTaskFunc
                A2DP_ConnectRequest,	//ProfileConnectRequest
                A2DP_DisconnectRequest,	//ProfileDisconnectRequest
                A2DP_Signal_LinkEvent,	//ProfileLinkEvent
                A2DP_Signal_DataEvent,	//ProfileDataEvent
        },
        A2DP_Media_LinkEvent,	//MediaLinkEvent
        A2DP_Media_DataEvent,	//MediaDataEvent
};

A2DP_Init
     _InitMediaCodec();
     SDAP_RegisterServiceRecord(&gA2DP_SinkServiceNode);
     MMI_RegisterProfile(&gA2DP_ProfileNode);

A2DP
     A2DP_SignalHandler(linkIndex);
       eventPtr = OSMQ_Get(&a2dpLinkInfo->OSMQ_AVDTP_Signal_To_A2DP);
       case AVDTP_COMMAND_MSG:
         A2DP_SignalCommandHandler(linkIndex, eventPtr);
     A2DP_CheckTimer(linkIndex);

#+END_SRC
*** SDK编译可配置
sdk中不同的功能，profile可以使用编译宏的方式来配置， 主要在bt_config_profile.h中， 比如音箱的相关配置如下：
#+BEGIN_SRC C
#ifdef STEREO_SOC
        #define DSP_ENABLE
        #define AUDIO_BIST
        //#define LIGHTING_ENABLE
        #define FM_ENABLE
        #ifdef TWS_SETTINGS
                /* ======= device type =======  */
                        #define AIR_MODULE
                        #define PRODUCT_TYPE_A
                /* ======= drivers type =======  */
                        //#define BUZZER_ENABLE
                        #define RINGTONE_ENABLE
                        #define SUPPORT_VOICE_PROMPT
                        #define LINEIN_ENABLE
                        #define PEQ_ENABLE
                        //#define DUAL_MIC_ENABLE
                /* ======= 3.0 Profiles =======  */
                        #define SPP_Profile
                        #define A2DP_Profile
                        #define AVRCP_Profile
                        #define HFP_Profile
                        #define AIRAPP_Profile
                        //#define LCIF_Profile
                        //#define IAP2_Profile
                        //#define OPP_Profile
                        //#define SAP_Profile
                        //#define PBAP_Profile
                        //#define MAP_Profile
                /* ======= 4.0 LE       =======  */
            #ifdef LE_SUPPORTED_HOST_FLASH
                        #define MMI_LE_ENABLE
                        #define MMI_LE_APP_ENABLE
                        #define MMI_LE_ENABLE_ADV
                #define SUPPORT_STATIC_RANDOM_ADDRESS
        #endif
#+END_SRC
*** Flash上的配置信息
**** 配置信息的定义
配置信息的结构都是类似的方式：
比如config0的配置：
| .\output\AB1520S\Release_Flash\sector_config0_header.obj |0 |0 |48 |0|
802100    48 OBJECT   LOCAL  gSectorConfig0Header
中定义类一个48字节的配置信息

在源码中 AB1520S_SVN72747_Headset_OBJ/source/SECTOR/sector_config0_header.c中，会有如下代码：
#pragma userclass (HCONST = CFGHEAD) 指定该文件的数据放到如下段中
| 802100H   | 8022FFH   | 0001D4H   | HCONST_CFGHEAD      |

在文件后面会定义放到该段中的数据，通过c文件包含头文件的方式定义：
#+BEGIN_SRC C
SECTOR_CFG0_HEADER_STRU CODE gSectorConfig0Header =
{
    NUM_OF_SECTOR_CFG0,

    {
            #include "sector_config0_member.h"
        },

        //- CRC
        {0x2E,0xFE}
};
#+END_SRC
在包含的sector_config0_member.h中有如下定义
SECTORS_ENUM_MACRO(SECTOR_AFE_INIT, &gSector_AfeInit, sizeof(AFE_INIT_STRU), CRC_CHK)
表示：
SECTOR_AFE_INIT(802100H) 是gSector_AfeInit指定的ic内部寄存器的值

gSector_AfeInit则定义在AB1520S_SVN72747_Headset_OBJ/source/SECTOR/Config0/sector_afe_init.c中，具体如下， 在同一目录下，定义了gSector_SfrInit gSector_RfMiscCtl gSector_HwMiscCtl。

如下为gSector_AfeInit的定义片段， 每一项是三个byte， 第一个byte是寄存器地址，2，3是寄存器的值。c251是16bit的寄存器
#+BEGIN_SRC C
#elif (defined OPERATION_IN_RF_AB1520S)
SECTOR_AFE_INIT_STRU CODE gSector_AfeInit =
{
        {
            169, //NumOfAfeRegInit

            {
                                  //- MCU clock source=48M
                        {0x00, 0x99, 0x81},//1
                        {0x01, 0x00, 0x00},
                        {0x02, 0xDD, 0x2F},
                        {0x03, 0x55, 0x01},
                        {0x04, 0x21, 0x45},  //{0x04, 0x21, 0x65},  CML workaround for LO spur !!!
#+END_SRC
*** 总结
**** 基本情况
+ 内存部分
  0x8000~0x9607 共5639字节ROM和闭源部分使用的全局内存，其中还包含一些在ram中的patch代码，
  0xf000 开始的3690字节的内存，存放的主要是不开源部分，在flash上的代码使用的全局内存，比如充电，温度，fm以及蓝牙链路管理的一些数据结构。
  0x9607 开始的3584字节 开始的部分主要就是开源部分使用的内存，包括MMI，驱动，以及profile等。
  剩下的大约19k的内存，用作全局的heap， heap是按照多个pool管理的，
  一个典型的具体配置如下：
  | pool名称             | 大小（项数x大小） |
  | CallArrayEntries     | 16 * 4            |
  | TimerArrayEntries    | 50 * 4            |
  | OSMEM1ArrayEnties    | 40 *50            |
  | OSMEM2SmallTxEntries | 9 * 702           |
  | OSMEM2TinyRxEntries  | 3 * 62            |
  | OSMEM2SmallRxEntries | 3 * 1100          |
  | OSMEM2LargeRxEntries | 2 * 1100          |
  | UartDmaRxBufSize     | 380               |
+ Flash部分
  固化了1M的nor， 总共用了551,663字节， 其中代码289,118， DSP的代码是168，354，剩下的注释配置数据， 其中语音提示音配置数据54,893，包含了中英文， 一种语言的话大概27K
+ ROM部分
  从FE8000开始的96k是rom，大部分（75K左右）是蓝牙的链路控制（LC），主机控制（HC），以及链路控制切换（LCS），剩下的一些其他代码，主要是kernel，设备驱动，以及SDK的一些运行环境的代码。
+ DSP
  语音提示，语音命令，解码等都是通过dsp来完成的， mcu和dsp之间是通过一个mailbox来进行交互的。
  从DSP的配置文件中可以看到4路AEC的配置 AEC/NR/AVC， 接收和发送的噪声消除   VAD的配置， 双mic的配置，接收和发送的音效设置，还有一些PLC， PEQ等配置，以及不太看明白的其他配置。
  在SDK中有语音命令的配置数据以及处理流程。
**** 优点
+ 编译可配置
  可以做到大部分产品类型的可配置， 在一个sdk中，可以配置出耳机，音箱，soundbar等多种产品形态，tws，ble以及各个蓝牙profile都可以单独配置
+ 提供了非常丰富的运行可配置
  闭源的部分，都是通过可配置的方式完成的，配置信息很全。
+ profile定制比较容易
  对需要定制行为的profile都是开源的， 并且profile的模块拆分也相对比较独立，比较容易修改
+ 语音命令

+ 语音数据使用片段以及片段组合的方式来减少占用nor的大小
   提示音的定义是比较精巧的，分成两个部分， 一部分是提示音本身的data， 一部分是提示音的控制脚本scp，data是很小的语音单元， 比如“电话”  “取消”是两条单独的语音数据。 通过脚本可以组合出，“电话取消”四个字的语音数据。
   例子如下：（中文的电话取消的定义）
   #define VP_SCP_CALL_CANCELLED_C				VPD(CALL), VPD(CANCELLED)
   890052     2 OBJECT   LOCAL  vp_scp_CALL_CANCELLED_C
   8915CC   347 OBJECT   LOCAL  vp_dat_CALL_C
   891C55   422 OBJECT   LOCAL  vp_dat_CANCELLED_C
+ 内存堆管理使用多个预先配置的pool的方式，有如下好处
  提供了相对通用的内存分配的函数接口， 提高了内存使用率并避免由于内存碎片。
+ 尽量使用了const  data来减少data数据的使用
  比如L2CAP中一些常见的命令和请求
  84B025    14 OBJECT   LOCAL  signalling_command_reject
  84B033    12 OBJECT   LOCAL  signalling_connection_request
  84B03F    16 OBJECT   LOCAL  signalling_connection_response
  84B04F    16 OBJECT   LOCAL  signalling_config_req_with_MTU

*** 附录
**** Flash上详细的配置数据
***** 配置总的入口
802000    64 OBJECT   LOCAL  _FlashDescriptor
这个是总的flash descpritor信息， boot代码读取这个扇区的内容，来填充FLASH_DESCRIPTOR_STRU的结构。

在FLASH_DESCRIPTOR_STRU;定义了各类配信息的头部
#+BEGIN_SRC C
typedef struct stru_flash_descriptor
{
    VOID (*fFlashInitEntry)(VOID);
    BOOL (*fSectorsCheckFuncEntry)(VOID);
    OS_GENERIC_PTR pFlashCodeDescriptor;
    OS_GENERIC_PTR pSectorHdrConfig0;
    OS_GENERIC_PTR pSectorHdrConfig1;
    OS_GENERIC_PTR pSectorHdrDspData;
    OS_GENERIC_PTR pSectorHdrBoundary;
    OS_GENERIC_PTR pSectorHdrVoiceData;
    OS_GENERIC_PTR pSectorHdrRuntime;
    OS_GENERIC_PTR pSectorHdrToolMisc;
    U32 McuHcontEnd;
    OS_GENERIC_PTR pSectorHdrRuntime_1;
    OS_GENERIC_PTR pSectorHdrRuntime_2;
    OS_GENERIC_PTR reserved_dw52;
    OS_GENERIC_PTR reserved_dw56;
    U16 OtaUpgrateVersion;
    CRC16 CRC;
} FLASH_DESCRIPTOR_STRU;
#+END_SRC
***** 配置头部
配置头部是放在如下的存储段中的
| 802100H   | 8022FFH   | 0001D4H   | HCONST_CFGHEAD      |
各分类的头部指向，实际的配置信息是存放在如下存储段中的
| 880000H   | 88FFFFH   | 003DC8H   | HCONST_CONFIG       |

头部信息主要有如下几类
| .\output\AB1520S\Release_Flash\sector_config0_header.obj |0 |0 |48 |0|
802100    48 OBJECT   LOCAL  gSectorConfig0Header
| .\output\AB1520S\Release_Flash\sector_config1_header.obj |0 |0 |219 |0|
802130   219 OBJECT   LOCAL  gSectorConfig1Header
| .\output\AB1520S\Release_Flash\sector_boundary_header.obj |0 |0 |48 |0|
80220B    48 OBJECT   LOCAL  gSectorBoundaryHeader
| .\output\AB1520S\Release_Flash\sector_voice_data_header.obj |0 |0 |21 |0|
80223B    21 OBJECT   LOCAL  gSectorVoiceDataHeader
| .\output\AB1520S\Release_Flash\sector_runtime_header.obj |0 |0 |12 |0|
802250    12 OBJECT   LOCAL  gSectorRuntimeHeader
| .\output\AB1520S\Release_Flash\sector_tool_misc_header.obj |0 |0 |21 |0|
80225C    21 OBJECT   LOCAL  gSectorToolMiscHeader
| .\output\AB1520S\Release_Flash\sector_dsp_data_header.obj |0 |0 |21 |0|
802271    21 OBJECT   LOCAL  gSectorDspDataHeader
| .\output\AB1520S\Release_Flash\sector_merge_runtime_header_1.obj |0 |0 |39 |0|
802286    39 OBJECT   LOCAL  gSectorRuntimeHeader_1
| .\output\AB1520S\Release_Flash\sector_merge_runtime_header_2.obj |0 |0 |39 |0|
8022AD    39 OBJECT   LOCAL  gSectorRuntimeHeader_2
| .\output\AB1520S\Release_Flash\sector_gap_nvram_type.obj |0 |0 |11 |0|
****** gSectorConfig0Header
| .\output\AB1520S\Release_Flash\sector_afe_init.obj |0 |0 |513 |0|
880E33   513 OBJECT   LOCAL  gSector_AfeInit
包含了芯片寄存器的初始值
| .\output\AB1520S\Release_Flash\sector_sfr_init.obj |0 |0 |453 |0|
881034   453 OBJECT   LOCAL  gSector_SfrInit
定义了c251特殊寄存器的初始值
| .\output\AB1520S\Release_Flash\sector_rf_misc_ctl.obj |0 |0 |132 |0|
8811F9   132 OBJECT   LOCAL  gSector_RfMiscCtl
配置RF相关的参数
| .\output\AB1520S\Release_Flash\sector_hw_misc_ctl.obj |0 |0 |15 |0|
88127D    15 OBJECT   LOCAL  gSector_HwMiscCtl
RF矫正，电池等硬件杂项配置
| .\output\AB1520S\Release_Flash\sector_uart_parameter_eng.obj |0 |0 |16 |0|
881B2E    16 OBJECT   LOCAL  gSector_UartParameterEng
工程串口配置，波特率，校验位等
****** gSectorConfig1Header
| .\output\AB1520S\Release_Flash\sector_sys_local_device_info.obj |0 |0 |52 |0|
880D70    52 OBJECT   LOCAL  gSector_SysLocalDeviceInfo
配置蓝牙设备信息，hci信息，设备能力，名称，版本号，参数等

| .\output\AB1520S\Release_Flash\sector_sys_local_device_EIR.obj |0 |0 |54 |0|
880DA4    54 OBJECT   LOCAL  gSector_SysLocalDeviceEIR
配置设备的服务能力
//Service Class UUID
//- 0x1108: Headset
//- 0x110B: Audio_Sink
//- 0x110C: AVRCP Target
//- 0x110E: AVRCP Control
//- 0x110F: AVRCP ControlController

| .\output\AB1520S\Release_Flash\sector_sys_local_device_control_type.obj |0 |0 |95 |0|
880D11    95 OBJECT   LOCAL  gSector_SysLocalDeviceControl
根据设备类型(soundbar 耳机等)不同配置GPIO， LED显示，电源灯等。

| .\output\AB1520S\Release_Flash\sector_lc_misc_ctl.obj |0 |0 |43 |0|
8805C9    43 OBJECT   LOCAL  gMISC_ctl_init
根据设备类型(soundbar 耳机等)，配置master，slave模式sniffer，休眠等参数

| .\output\AB1520S\Release_Flash\sector_lm_parameter_type.obj |0 |0 |6 |0|
8805F4     6 OBJECT   LOCAL  gSector_LmParameter
根据设备类型(soundbar 耳机等)，是否支持TWS等，配置Link Manager的参数，

| .\output\AB1520S\Release_Flash\sector_hc_parameter_type.obj |0 |0 |143 |0|
88053A   143 OBJECT   LOCAL  gHC_parameter_init
蓝牙扫描，inquiry，page scan，pin类型等链路管理参数

| .\output\AB1520S\Release_Flash\sector_uart_parameter.obj |0 |0 |16 |0|
880E23    16 OBJECT   LOCAL  gSector_UartParameter
串口参数配置，是否支持流控，h5等

| .\source\SECTOR\sector_mcu_dsp_parameter_init.obj |0 |0 |22 |0|
8805FA    22 OBJECT   LOCAL  gMcu_dsp_parameter_init
未开源，应该是mcu和dsp交互的配置

| .\output\AB1520S\Release_Flash\sector_a2dp_nvram_ctl_type.obj |0 |0 |57 |0|
880000    57 OBJECT   LOCAL  gA2DP_nvram_ctl_init
a2dp profile的参数配， sbc和aac code的配置

| .\output\AB1520S\Release_Flash\sector_driver_led_data_type.obj |0 |0 |813 |0|
880063   813 OBJECT   LOCAL  gDriver_led_data_init
配置不同工作模式（低电，可连接，链接上等）下LED的闪烁方式

| .\output\AB1520S\Release_Flash\sector_driver_buzzer_data_type.obj |0 |0 |42 |0|
880039    42 OBJECT   LOCAL  gDriver_buzzer_data_init
蜂鸣器配置， 频率，长度，次数，重复窗口，重复次数等

| .\output\AB1520S\Release_Flash\sector_driver_ringtone_data_type.obj |0 |0 |426 |0|
880390     2 OBJECT   LOCAL  gDriver_ringtone_data_init
定义各种铃声，每个铃声按照如下方式定义
#define RTDAT_SHORT_1_NOTE_1		NOTE_ME4, METRONOME_1_16_100MS, VOL_BEGIN, VOL_END,

| .\output\AB1520S\Release_Flash\sector_mmi_driver_nvram_backup_type.obj |0 |0 |45 |0|
880DF0    45 OBJECT   LOCAL  gMMI_Driver_v_nvram_backup
MMI相关驱动的参数的非零的初始化值。

| .\output\AB1520S\Release_Flash\sector_mmi_nvram_type.obj |0 |0 |1,356 |0|
8807C5  1356 OBJECT   LOCAL  gMMI_nvram_init
MMI相关的配置，如下
#+BEGIN_SRC C
        typedef struct
        {
                PinCodeCtl pinCodeCtl;
                BuzzCtl buzzCtl[MMI_BUZZER_TRIGGERED_EVT_NO];
                PageScanWindowSize pageScanWindowSize;
                ScoPktPara scoPktPara;
                ChangePktTypePara changePktTypePara;
                SimplePairingPara simplePairingPara;
                MMI1IntInterval mmi1IntInterval;
                MMIBtnSeqInfo mmiBtnSeqInfo[MAX_BTN_SEQ_NO];
                SniffPara sniffPara;
                U8 retrySniffCnt;
                U8 rssiDefaultBoundry;
                LedSettingType defaultLedSetting[MMI_TOTAL_STATE_NO];
                LedSettingType maxLinkLedSetting;
                U8 lineInAutoDetectKeyIndex;
                KeypadGpioCtl keypadGpioCtl;
                ProductType productType;
                AirParaType airPara;
                U8 maxPageDevice;
                U8 missedCallRemindAttempt;
                U8 discoverableIfPdlLessThan;
                U8 actionAfterPairingModeTimeout;
                ReConnectInfo reConnectInfo;
                MMIFeatureCtl mmiFeatureCtl;
                SpkGainSet spkGainSet[SOUND_LEVEL_NO];
                MicGainSet micGainSet[SOUND_LEVEL_NO];
                VgsTable vgsTable[SOUND_LEVEL_NO];
                SoundLevel soundLevels[SOUND_LEVEL_NO];
                SoundLevel musicSoundLevels[SOUND_LEVEL_NO];
                SoundLevel lineInSoundLevels[SOUND_LEVEL_NO];
                MmiDecreaseVolWhenLowBatType scoDecreaseGainCtl;
                MmiDecreaseVolWhenLowBatType a2dpDecreaseGainCtl;
                MmiDecreaseVolWhenLowBatType lineinDecreaseGainCtl;
                U8 totalSoundLevel;
                U8 totalMusicSoundLevel;
                U8 totalLineInSoundLevel;
                U8 defaultA2DPSoundLevel;
                U8 reserved5;
                U8 defaultVCLevel;
                MMIVolumeSmallStepsType smallStepVolume;
                MMIPowerOnInLowBatCtlType powerOnLowBatAction;
                BatteryPara batteryPara;
                TimerCtl timerCtl;
                VoicePromptConfig vpConfig;
                EvtPara evtParaCtl[EVENT_TABLE_SIZE];
                U8 key1GpioIndex;
                LedFilterMap ledFilterMap[MAX_LED_FILTER_NO];
                MMIFCCInfo mmiFCCInfo;
                U8 storedLinkKeyCnt;
                U8 gpioAmpGeneral;
                U8 gpioAmpBtFm;
                MmiAvrcpSettings mmiAvrcpSettings;
                U8 mmiHfpCINDMask;
                U8 fmSeekTH;
                U32 reserved4[3];
                U8	audioPriorityExtra[4];
                TWS_PARA tws_para;
                AudioPriorityType audioPriority;
                // *************************** IMPORTANT************************************
                // flash code version: 001.62971.3204.0
                // NOTICE - structure definition above matches specified flash code version.
                //          DO NOT modify it. ONLY APPENDing fields is allowed.
                // *************************** IMPORTANT************************************
                PairCtl	pariCtl;
                U8 roleSwitchCnt;
                U8 mcuADCSource;
                U8 enlargedWaitDetachTime;	//unit: 0.5 sec
                U8 checkA2DPMediaChannelEstTimeActiveConn;//unit:0.1s
                U32 GENERIC_PTR sbcFlashAddress;
                U8 reserved6;
                U8 reserved7;
                U8 reserved8;
                U8 reserved9;
                U8 reserved10;
        } MMI_NVRAM_TYPE;
#+END_SRC
| .\output\AB1520S\Release_Flash\sector_mmi_nvram_keymap.obj |0 |0 |437 |0|
880610    15 OBJECT   LOCAL  gMMI_nvram_keymap_init
按键映射表配置， 长按等等

| .\output\AB1520S\Release_Flash\sector_sys_memory_config.obj |0 |0 |22 |0|
880DDA    22 OBJECT   LOCAL  gSector_SysMemoryConfig
定义系统的heap的内存分配，根据不同功能来配置不同的系统内存使用， 内存要应该是使用预分配的办法。
/* CallArrayEntries */          16,
/* CallArrayEntrySize */        4,
/* TimerArrayEntries */         50,
/* TimerArrayEntrySize */       4,
/* OSMEM1ArrayEnties */         40,
/* OSMEM1ArrayEntrySize */      50,

| .\output\AB1520S\Release_Flash\sector_sm_nvram_type.obj |0 |0 |6 |0|
880E1D     6 OBJECT   LOCAL  gSM_nvram_init
security manager的配置

| .\source\SECTOR\sector_driver_ctl_type.obj |0 |0 |49 |0|
88128C    11 OBJECT   LOCAL  gGAP_nvram_init
GAP的蓝牙地址配置

| .\output\AB1520S\Release_Flash\sector_application.obj |0 |0 |10 |0|
881B24    10 OBJECT   LOCAL  gApplication_init
应用类型和版本（应该是耳机，soudbar等典型应用吧）
****** gSectorBoundaryHeader
| .\output\AB1520S\Release_Flash\sector_mp_parameter.obj |0 |0 |366 |0|
801000   366 OBJECT   LOCAL  gSector_MpParameter
量产参数配置， bt qualification， 私钥等
#+BEGIN_SRC C
        MP_SYS_LOCAL_DEVICE_INFO_STRU   MP_SysLocalDeviceInfo;
        MP_AFE_INIT_STRU		MP_AfeInit;
        MP_SFR_INIT_STRU        MP_SfrInit;
        MP_RF_MISC_CTL_STRU		MP_RfMiscCtl;
        MP_BATTERY_PARA_STRU	MP_BatteryPara;
        MP_ChargerDiscountCtl	MP_ChargerDiscountCtl[CHARGING_EFF_STATE_NO];
        MP_ADC_FIELD_STRU       MP_AdcField;
        U8 CalibrationInfo[NUM_OF_CALIBRATION_INFO];
        U8 ManufacturingInfo[NUM_OF_MANUFACTURING_INFO];
#+END_SRC
| .\output\AB1520S\Release_Flash\sector_sys_patch_code_init.obj |0 |0 |136 |0|
881B3E   136 OBJECT   LOCAL  gSector_SeysPatchCodeInit
EXTERN SECTOR_MP_PARAMETER_F_STRU CODE gSector_MpParameter_F;

| .\output\AB1520S\Release_Flash\sector_mp_parameter_F.obj |0 |0 |0 |0|
80116E     0 OBJECT   LOCAL  gSector_MpParameter_F
保留给用户区的参数配置
#+BEGIN_SRC C
typedef struct stru_mp_parameter_f
{
        U8 rsvd;
        MP_AIO_RELATED_FIELD_STRU AioSet[AIO_TOTAL_SET_NUMBER];
        U8 reserved[90];
        U8 Customer_Reserved1[15][32];
        U8 Customer_Reserved2[30];
    #ifdef LE_SUPPORTED_HOST_FLASH
        LE_BD_ADDR_TYPE leBDAddr;           //LE BD address
        #endif
} MP_PARAMETER_F_STRU;
#+END_SRC
****** gSectorVoiceDataHeader
| .\output\AB1520S\Release_Flash\voice_prompt_ctl.obj | 0 | 0 | 741 | 0 |
890000    52 OBJECT   LOCAL  gVoiceLangCtl
890070    68 OBJECT   LOCAL  gVoicePromptScriptOffset_C
8900B4   212 OBJECT   LOCAL  gVoicePromptDataOffset_C
8901CD    68 OBJECT   LOCAL  gVoicePromptScriptOffset_E
890211   212 OBJECT   LOCAL  gVoicePromptDataOffset_E
提示音的索引，控制数据定义， 提示音的定义是比较精巧的，分成两个部分， 一部分是提示音本身的data， 一部分是提示音的控制脚本scp，
data是很小的语音单元， 比如“电话”  “取消”是两条单独的语音数据。 通过脚本可以组合出，“电话取消”四个字的语音数据。
例子如下：（中文的电话取消的定义）
#define VP_SCP_CALL_CANCELLED_C				VPD(CALL), VPD(CANCELLED)
890052     2 OBJECT   LOCAL  vp_scp_CALL_CANCELLED_C

| .\output\AB1520S\Release_Flash\voice_prompt_data_1.obj |0 |0 |27,316 |0|
中文语音数据本身的定义， 典型的单字的数据，比如0~9，电池，蓝牙模式等等
8902E5   377 OBJECT   LOCAL  vp_dat_0_C
89045E   377 OBJECT   LOCAL  vp_dat_1_C
8905D7   362 OBJECT   LOCAL  vp_dat_2_C
890741   362 OBJECT   LOCAL  vp_dat_3_C
8908AB   392 OBJECT   LOCAL  vp_dat_4_C
890A33   377 OBJECT   LOCAL  vp_dat_5_C
890BAC   362 OBJECT   LOCAL  vp_dat_6_C
890D16   377 OBJECT   LOCAL  vp_dat_7_C
890E8F   347 OBJECT   LOCAL  vp_dat_8_C
890FEA   392 OBJECT   LOCAL  vp_dat_9_C
891172   302 OBJECT   LOCAL  vp_dat_BATTERY_C
8912A0   812 OBJECT   LOCAL  vp_dat_BLUETOOTH_MODE_C
等等

| .\output\AB1520S\Release_Flash\voice_prompt_data_2.obj |0 |0 |26,836 |0|
英文的语音数据定义， 典型的单字的数据，比如0~9，电池，蓝牙模式等等
896D99   512 OBJECT   LOCAL  vp_dat_0_E
896F99   527 OBJECT   LOCAL  vp_dat_1_E
8971A8   527 OBJECT   LOCAL  vp_dat_2_E
8973B7   527 OBJECT   LOCAL  vp_dat_3_E
8975C6   527 OBJECT   LOCAL  vp_dat_4_E
8977D5   527 OBJECT   LOCAL  vp_dat_5_E
8979E4   527 OBJECT   LOCAL  vp_dat_6_E
897BF3   527 OBJECT   LOCAL  vp_dat_7_E
897E02   527 OBJECT   LOCAL  vp_dat_8_E
898011   527 OBJECT   LOCAL  vp_dat_9_E
898220   467 OBJECT   LOCAL  vp_dat_BATTERY_E
8983F3   542 OBJECT   LOCAL  vp_dat_BLUETOOTH_E
****** gSectorRuntimeHeader
| .\source\SECTOR\sector_app_callername_data.obj |0 |0 |1 |0|
8F8000     1 OBJECT   LOCAL  dummy
****** gSectorToolMiscHeader
| .\output\AB1520S\Release_Flash\sector_tool_info.obj |0 |0 |2,089 |0|
881297  2089 OBJECT   LOCAL  gSector_Tool_Info
工具版本信息，以及2k大小的dsp参数
| .\output\AB1520S\Release_Flash\sector_ae_info.obj |0 |0 |51 |0|
881AC0    51 OBJECT   LOCAL  gSector_AE_Info
工具配置的AE info
****** gSectorDspDataHeader
| .\output\AB1520S\Release_Flash\sector_dsp_func_para.obj |0 |0 |4,094 |0|
8F6000  4094 OBJECT   LOCAL  gSector_DspFuncParameter
#+BEGIN_SRC C
typedef struct
{
        DSP_FUNC_PARA_STRU      dsp_param_parameter;

    /* The order of sections should be same as DSP's */
    IC_BIST_RELATION      ic_bist_parameter;
    VP_RELATION           vp_parameter;
    PLC_RELATION          plc_parameter;
    SCENARIO_RELATION     scenario_parameter;
    I2S_DBG_RELATION      i2s_dbg_parameter;
    STEREO_RELATION       stereo_parameter;
        U16 I2S_BCLK_RATE;
    VOICE_RELATION        voice_parameter;

} DSP_FUNC_PARA_CTL_STRU;
#+END_SRC
DSP的功能参数配置， 音箱的定义在 "..\DSP\AB1520S_DSP\DSP_PARA_AB1520S_MUSICBOX_TARGET.txt"文件中，主要包含如下内容：
4路AEC的配置 AEC/NR/AVC， 接收和发送的噪声消除   VAD的配置， 双mic的配置，接收和发送的音效设置，还有一些PLC， PEQ等配置，以及不太看明白的其他配置。

| .\output\AB1520S\Release_Flash\sector_dsp_hpf_param_type.obj |0 |0 |543 |0|
8F7000   543 OBJECT   LOCAL  gSector_DspHpfParameter
#+BEGIN_SRC C
typedef struct stru_dsp_hpf_param
{
        U8							hpf_enable;
        HPF_CONFIG_SECTOR			a2dp_hpf_config_sector[NUM_OF_MAX_PEQ_CONFIG];
        HPF_CONFIG_SECTOR			linein_hpf_config_sector[NUM_OF_MAX_PEQ_CONFIG];

} DSP_HPF_PARAMETER_STRU;

| .\output\AB1520S\Release_Flash\sector_dsp_peq_param_type.obj |0 |0 |0 |0|
8F721F     0 OBJECT   LOCAL  gSector_DspPeqParameter
typedef struct stru_dsp_peq_param
{
        U8							num_of_a2dp_peq_config;
        U8							num_of_linein_peq_config;
        PEQ_CONFIG_SECTOR			a2dp_peq_config_sector[NUM_OF_MAX_PEQ_CONFIG];
        PEQ_CONFIG_SECTOR			linein_peq_config_sector[NUM_OF_MAX_PEQ_CONFIG];
#+END_SRC

| .\source\SECTOR\sector_dsp_vp_nb.obj |0 |0 |8,706 |0|
881BC6  8706 OBJECT   LOCAL  gSector_DspVpNb
****** gSectorRuntimeHeader_1
| .\output\AB1520S\Release_Flash\sector_mmi_driver_variation_nvram_type.obj |0 |0 |503 |0|
8FA000   503 OBJECT   LOCAL  gMMI_Driver_v_nvram_init
#+BEGIN_SRC C
typedef struct
{
        MMI_LINK_KEY_TYPE link_key_info[NVRAM_LINK_KEY_ITEMS];
        U8 current_key_index;
        U8 lastDevInd;
        MMI_NEW_DEVICE_PARA mmi_new_device_para;
        U8 auth_requirments;

} MMI_DRIVER_VARIATION_NVRAM_TYPE;
#+END_SRC
运行时的参数，用来做设备管理，存储不同设备的linkkey

| .\output\AB1520S\Release_Flash\sector_mmi_customize_v_nvram.obj |0 |0 |3 |0|
8FA600     3 OBJECT   LOCAL  gMMI_Customize_v_nvram_init
通过给用户使用的配置区域
****** gSectorRuntimeHeader_2
| .\output\AB1520S\Release_Flash\sector_mmi_driver_variation_nvram_type2.obj |0 |0 |503 |0|
8F9000   503 OBJECT   LOCAL  gMMI_Driver_v_nvram_init2
#+BEGIN_SRC C
typedef struct
{
        U8 CheckValid;
        MISC_PARA_TYPE  misc_para;
        LinkHistoryType air_link_history_info[NVRAM_AIR_LINK_KEY_NO];
        LinkHistoryType fast_dongle_link_history_info;
        LinkHistoryType link_history_info[NVRAM_LINK_KEY_ITEMS];
} MMI_DRIVER_VARIATION_NVRAM_TYPE;
#+END_SRC
运行配置，FM历史，连接历史，音量等

| .\output\AB1520S\Release_Flash\sector_mmi_customize_v_nvram2.obj |0 |0 |3 |0|
8F9600     3 OBJECT   LOCAL  gMMI_Customize_v_nvram_init2
保留给用户使用的其他配置

** 0927 WIFI性能资源需求
*** RTK模组需要的资源开销
使用stm32的板子， 使用realtek更新的FreeRTOS的SDK后， 可以正常的跑起来了，Wifi sta模式，驱动初始化完成，没做任何操作时heap内存使用，动态的heap加上静态内存大概80K左右， 在3503上， 南方硅谷的模组使用的内存不到30K，所以内存的差距在50K左右， 在3503或5118上很难再挤出来这么多的内存。
需要继续看下在zephyr上带起的情况
**** 静态资源
| module name           | code size | data size | rodata size |
 | 模组使用的AT命令 | 2,854     |       928 |           0 |
 | wpa_supplicant        | 16,606    |       208 |       2,763 |
 | wifi相关API | 11,800    |       796 |         119 |
 | WIFI驱动 | 136,598   |     7,331 |      63,216 |
 | lwip协议栈       | 23,452    |    21,380 |         148 |
 | freertos            | 3,736     |    85,448 |           0 |
 | stm32f4xx  | 2,184     |        16 |           0 |
 | 其他              | 5,054     |       542 |          10 |
**** 动态内存
Wifi sta模式，驱动初始化完成，没做任何操作时heap内存使用
| 任务stack占用             | 25832 |
| Wifi分配的动态内存        | 29770 |
| 小于100byte的分配占用内存 |  7406 |

*** 320Kbps的音频流需要的buffer情况
目前故事机使用的公众号资源服务器的音乐资源，以及百科问答中点播的歌曲，都是通过http方式来下载的mp3，aac等压缩格式的文件。

这种使用音频文件方式的音乐资源，不像网络通话一样的音频流，使用特别的编码方式，能够通过算法来做去抖，补偿的方式来消除一些网络抖动的影响，目前采用的策略，主要还是靠网络缓冲数据的办法来平滑网络抖动。

**** 3503使用psram做缓存的测试情况
所有测试连接的AP都是办公区的ap ACTZH-PAD-PMD
+--------------+--------------+-----------------------+------------+----------+----------------------------------------------------------------------+
| sram缓存大小 | 缓存时间(秒) | 测试时间段            | 时长(小时) | 卡顿次数 | 说明                                                                 |
+--------------+--------------+-----------------------+------------+----------+----------------------------------------------------------------------+
| 80K          | 2s           | 18:00 ~ 10:00         | 16h        |       10 | 在夜晚，干扰少，卡顿多为1、2秒内卡顿，早上10点一次出现10秒没数据     |
+--------------+--------------+-----------------------+------------+----------+----------------------------------------------------------------------+
| 120K         | 3s           | 13:00 ~ 16:00         | 3h         |       15 | 下午测试，卡顿也严重，多次连续数据量不足连续卡顿，出现一次10秒没数据 |
+--------------+--------------+-----------------------+------------+----------+----------------------------------------------------------------------+
| 240K         | 6s           | 13:30 ~ 17:00         | 3.5h       |        6 | 下午测试，都是长时间数据量不足卡顿                                   |
+--------------+--------------+-----------------------+------------+----------+----------------------------------------------------------------------+
| 360K         | 9s           | 9:00 ~ 12:00          | 3h         |       10 | 早上测试，长时间数据量不足卡顿                                       |
+--------------+--------------+-----------------------+------------+----------+----------------------------------------------------------------------+
| 512K         | 12s          | 9:30 ~ 13:30          | 4h         |       14 | 上班时间测试，长时间数据量不足卡顿                                   |
+--------------+--------------+-----------------------+------------+----------+----------------------------------------------------------------------+
| 1024K | 25s | 9/21 15:49 ~ 18:40,   | 17h | 5(12) | 上班时间及周六的测试，都是长时间数据量不足卡顿 |
|       |     | 9/23 10:16 ~ 16:59    |     |       |                                                |
|       |     | 9/25(sat) 9:8 ~ 17:24 |     |       |                                                |
+--------------+--------------+-----------------------+------------+----------+----------------------------------------------------------------------+

Note:
+ 公共AP PMD是办公区的一个AP，比测试组的环境稍好，但一般比家庭网络会差很多
+ 在夜晚网络情况较好的时候， 就算80K的buffer也不太容易遇到卡顿
+ 在上午网络性能比较恶劣的情况下， 只有加大到1024K的buffer，卡顿才会比较少
+ 长时间数据量不足卡顿
  长时间数据量不足（每秒接收数据不足320kbps）导致缓冲的数据全部消耗完以引起的卡顿
+ 1024K缓存的测试
  其中有12次在开始下载时就出现下载数据量不足导致卡顿，这种情况，即使使用卡缓存还是会出现卡顿, 上班时间及周六的测试，都是长时间数据量不足（每秒接收数据不足320kbps）导致连续卡顿 |
**** 其他对手样机测试情况
***** 愤怒的小鸟
机子tcp传输window：11200
机子内网络数据缓存量约：60~80Kbyte（从无卡时开始下载数据量估算）
点播：即使有卡，也不进行缓存，所以有卡与没卡，多点几首，卡顿效果一样的；
机子下载音乐到卡速率（不播放）：750kbps；
测试的码率是256Kbps

| 测试条件 | AP           | 测试结果                          |
| 无卡     | 单独搭建的ap | 无其他人使用该ap，播放不卡顿      |
| 无卡     | 单独搭建的ap | 无其他人使用该ap，播放出现2次卡顿 |
| 无卡     | 单独搭建的ap | 一台手机连上该ap，浏览网页或播放视频，多次卡顿 |
| 有卡     | 单独搭建的ap | 无其他人使用该ap，播放不卡顿      |
| 有卡     | 单独搭建的ap |  一台手机连上该ap，浏览网页或播放视频，多次卡顿 |

Note：
+ 单独搭建AP性能
  单独搭建的ap，网络条件算作比较好的ap
***** ASU WIFI音箱
+ Tcp window
  大小为size：21000
  网络缓存数据量：大于80Kbyte    （从一次最大缓存的数据量计算）
  按这个缓存量计算，可以缓存10s的数据，并且播放码率较低，不容易出现卡顿，而干扰较大的情况下，还是会出现卡顿。
+ 播放的音乐码率：64kbps
  公众号上见到的音乐、在线广播，码率都是64kbps
  连接公共AP ACTZH-PAD-PMD，播放音乐，用一个手机连接该ap，切换视频播放，ASUWIFI音箱还是有时会出现音声卡顿。
*** 几点思考
+ 在网络不太差的情况下， 资源比较丰富的IOT芯片，还是比较大的可能做到高码率不卡顿的
+ 需要想办法尽快找到市场能够接受的卡顿标准。如果标准较高的话， 大部分的iot芯片都应该不可以。
** 0905 方案研发三部会议报告
*** 标案项目相关
**** 3703
+ 支持android APK版本已经发布学习版
+ 第二轮送测
+ 联立为9月份试产
**** 360F
+ BSP开发工作基本完成
+ 正在开发应用层的测试用例
**** 3503
主要工作主要集中在客户试产问题解决和需求实现
+ sdio和wifi复用测试完成，读卡性能比usb读卡器好
+ 双系统已完成， 本周测试
+ psram后续测试
+ 蓝牙单系统已经做到WIFI+传统蓝牙， WIFI+BLE共存
**** s700
+ linux的GPU加速和视频解码支持
  显示已经可以到主界面，
  视频部分还未开始
+ 商显和KTV评估
  双屏异显，多路音频输出
  HDMI IN 1080p 60fps优化
**** 5601
+ 搭配5118做语音遥控器，功能已经通了，还有杂音问题在澄清
+ zephyr已经在cordio板上和5601evb跑起来了，待移植5601bank部分，从评估角度，使用cordio evb更方便一些。
+ 蓝牙的BQB测试，
  测试host controller的固件已经可以
  profile的PTS测试还未跑起来
*** 预研相关
**** 蓝牙mcu协议栈对比
对比了broadcom WICED BT， zephyr+IVT， 以及zephyr协议栈的情况。
从资源开销上看， zephyr自带的应该最好， 但传统蓝牙的成熟度最差
初步确定，5118B按照zephyr自带的协议栈来进行
**** realtek IOT WIFI
+ 型号为8189fm(FTV)
+ 代码大部分闭源，可移植还好
  提供了移植接口， 主要是SDIO驱动适配，和OS适配，移植层相对独立，可以考虑自己移植
  只有arm版本，需要找mips版本才行
+ 资源开销从看到的静态的情况，3503应该可以支持，但不确认动态内存需要多少
  | module name           | code size | data size | rodata size |
 | 模组使用的AT命令 | 2,854     |       928 |           0 |
 | wpa_supplicant        | 16,606    |       208 |       2,763 |
 | wifi相关API | 11,800    |       796 |         119 |
 | WIFI驱动 | 136,598   |     7,331 |      63,216 |
 | lwip协议栈       | 23,452    |    21,380 |         148 |
 | freertos            | 3,736     |    85,448 |           0 |
 | stm32f4xx  | 2,184     |        16 |           0 |
 | 其他              | 5,054     |       542 |          10 |
**** allwin 871
+ 采用的是FreeRTOS + LWIP协议栈
+ 使用2M nor， 支持OTA双备份
+ 估计大小和3503的主要差异的大头在
  解码库 3503要 400多k， 对方估计200k？
  提示音 放在卡上，没有放在nor上
+ 双核架构
  一个跑OS， 一个跑WIFI

***** 固件结构如下
NOR型号为PT25F16B， 容量为2MB。分区内容如下：
| 分区内容       | 分区偏移 | 分区大小 | 实际使用大小 | RAM地址 |
| BOOT           |      0x0 | 64KB     | 45KB         |  0x7000 |
| SYSTEM         |  0x10000 | 166KB    | 161KB        | 0x10000 |
| APP            |  0x39800 | 380KB    | 377KB        |     XIP |
| Wifi netos?    |  0x98800 | 240KB    | 238KB        |     0x0 |
| 升级相关？     |  0xd4800 | 5KB      | 3KB          |         |
| WiFI app?有cmd |  0xd5c00 | 130KB    | 127KB        |         |
| CONFIG         |  0xf6400 | 39KB     | 1KB          |         |

**** aihora AB1520S
+ cpu使用80251
+ ram 32K
+ 应该是单核架构，蓝牙的一些baseband协议是在ROM+ nor上跑的
待统计详细数据
**** Android 版本升级
+ android 8.0已经正式发布，后续安排时间去看

** 0831 庆科
http://developer.mico.io/developer/md/bWljby1oYW5kYm9vay8yLk1pQ09fdG9vbHMvTWlDT19DdWJlLm1k
http://www.mxchip.com/product/wifi_product/49
** 0728 代码质量会议
附件中有一个ppt中的一句话说得很到位：代码质量不能完全依靠人来保证，但最终还是依靠人来保证。
所以， 从不能完全依靠人来保证这个角度来说，是需要使用工具来帮忙的。

质量目标也要定得合理一些，做确实能够帮到我们的那些活动，优先做投入产出要合算的部分。

结合以前在做USDK的时候的经验教训， 先说下我的看法：
+ 静态检查工具QAC
  以前公司使用的代码静态检查工具QAC，使用的主要是汽车工业的MISRA标准,  这个QAC工具中检查规很多，报出来的warning非常多，很多都是无关紧要的warning，可修改也可以不修改的那种，有一些也不好修改，带来来很多的工作量，但从实际的效果来看，收益很小， 并没有通过QAC查出来有效的问题。

  Zephyr目前用的是Synopsis提供的Coverity Scan来静态检查代码
  https://scan.coverity.com/
  Coverity Scan是在线检查使用，针对开源代码使用免费。
  https://en.wikipedia.org/wiki/Coverity
  | Coverity Code Advisor           | is a static code analysis tool for C, C++, C#, Java, and JavaScript. It is derived from the Stanford Checker, a research tool for finding bugs through static analysis.      |
  | Coverity Code Advisor on Demand | was a cloud hosted version of Coverity Code Advisor.                                                                                                                         |
  | Coverity Scan                   | is a gratis static-analysis cloud-based service for the open source community. The tool analyzes over 3900 open-source projects and is integrated with GitHub and Travis CI. |
  | Coverity Test Advisor           | is a series of products aimed at identifying weaknesses in a project software testing.                                                                                       |

  如果继续使用原来的QAC，建议大幅简化QAC的规则， 只保留确实必要的几条。
  zephyr的项目的话，建议使用Coverity Scan，这个看怎么部署起来可以用。
+ 动态检查工具QAM
  公司在做usdk的时候， 使用的是klockwork这个工具。 这个工具在usdk开发的时候，确实使用这个工具查到了一些动态内存泄露的问题。 相对来说，投入产出比还是合算的。
  后来做linux和android项目的时候， 我们拿linux的内核代码去查（里面包含了内存泄露的bug），但实际并未查出来，还不如linux自带的内存泄露工具有效， 主要的原因是linux中非常广泛的使用了函数指针，这个对klocwork整个工具不够友好。 由于要花钱，所以在linux项目中就没有使用。
  在zephyr项目中，我们在sdk架构设计的时候， 就考虑来动态来检测内存泄露（但这个需要占用内存），能够解决部分问题。 但对很不常见的分支，可能不能查出来。
  如果可以继续使用Klocwork的话，应该可以帮忙一些忙，投入产出应该合算，主要看工具是否合算。
+ 代码走差
  代码质量不能完全依靠人来保证，但最终还是依靠人来保证的。 代码走查就是用人来保证代码的质量，代码走查除了能有效的保证每次代码提交的时候不犯明显的低级错误外， 还可以有效的保证设计的质量， 而后者是靠工具永远没法达到的。
  目前andorid项目和zephyr项目都使用了代码走查工具gerrit。
+ 代码规范
  代码规范的话， 如果是衍生的代码，建议采用原始项目的代码风格， 比如android项目的java代码，那么就采用google的java代码风格， Linux kernel的驱动代码就采用linux自己的风格。 不需针对这些代码应用公司的规范。
  如果是公司完全自研的代码，统一到统一的公司规范上。
  通过类似linux的checkpatch等工具，来检查是否符合规范， 在代码提交review的时候自动进行。
  总的来说，代码规范的执行如果可以做到工具自动化，工作量相对还好。
+ 自动化测试和持续集成
  3503的第二阶段中开始做public api的代码测试和自动化测试。
  主要还是针对平台提供的api来测试，暂时不做模块内部的api的单元测试，
  主要考虑：
  + 如果基于平台的视角来看，public的api是必须测试的。不然没法保证平台的质量，平台的质量可以使用标案，或者demo来测试，但仍不够直接，在没有标案的时候，测试用例是最直接的手段。
  + 单元测试的投入很大，从以前的历史看，投入产出比不好
  + 但由于是模块内部的api，会比较容易变化，一旦变化后，对应的测试用例也需要变化，也不容易积累有效的测试用例，
  + 稳定的测试用例可以用作回归测试，频繁变化的测试用例是不能有这个好处的。
  + 测试需要做到自动化，需要做到代码提交的时候，自动集成，烧写和测试。

** 0725 5120 review
杨哲：
下周请持续组织讨论关于以上两颗IC的策略调整。我要求主管能邀请关键人员参与。
1．5119已经进行了又一轮市场调研，仍然在进行中，我自己也在调研。基于杨哲和冯国荣的报告，以及龚建等的评测状况再一次详细讨论下一步计划。
在成本不挑格子的前提下，我个人还是强烈建议大家重点看功耗和品质。 原因如下。
1）在耳际这个行业功耗是一举三得的重中之众，它既是区别于对手的重要指标，也是成本（可以用更小的电池），又是品质。
2）炬芯/炬力在音频市场多年的积累创造的是音质和品质的美誉度，不能随便把自己的根据地扔掉，即便做地段，也要切实做到这一点。而不是反其道而行之。
3）老刘也反复在提醒大家，不要为进攻超低端过热。我们必须有持续的低端策略，但绝对不主动重兵进攻超低端，这个公司早有结论，目前并没有改变，我也不认为会改变。5119不能定位超低端纯粹杀价格。
4）富翰虽然由于自己的品质问题出局了，但是他的策略并不错，以低功耗加足够低的价格出手会收到市场热捧，试想，如果他没有自己的质量问题，他当时的定位杀伤力是不是很大？所以这个策略是没有问题的，但是必须真的能执行。有品质来支撑这个立题。

2 5120/5116C是时候从新定位了，尤其是针对以下几个点进行从新思考。
1）Paul反复在问的全兼容和替换策略的必要性，如果不必要允许放宽多少？换来的好处是啥？
2）5116C属于情急之下的匆忙之做，光CPU/DSP就三个，高端加着急加兼容迫使成本几乎不在考虑范围。
3）由于RF的限制，再加着急，只能放弃对耳机和运动耳机的支持。
除了26日我不能参加以外，其他时间我都OK
我再次提醒，我不喜欢主管们只是带着笔记和笔近来听，你们必须准备资料，包括收集的资料，和你们的想法，这些想法预先要整理好。
洪波和杨哲这方面一直做得比较好，其它主管要学习。
** 0810 5118B开发平台协议栈对比
*** 目的
为了评估后续5118B的mcu开发平台如何支持蓝牙协议栈，对比了如下几个协议栈：
+ Broadcom Wiced BT
  broadcom的Wiced BT是为IOT开发的一个蓝牙模块，可以做为主控使用，也可以作为模组配置主控使用，支持的功能和蓝牙协议非常丰富。
+ zephyr + IVT
  在3503目前的sdk上，移植了蓝牙的推歌功能， 主要是A2DP 和AVRCP以及核心的profile。
+ zephyr自带的蓝牙协议栈
  zephyr操作系统本身也有支持蓝牙协议栈，BLE相对支持比较完善，BR/EDR支持不完善
*** cypress wiced BT sdk
**** CYW20706
| Technology            | Bluetooth (BR + EDR + BLE)                        |
| Bluetooth Spec.       | Bluetooth 4.2                                     |
| RX Sensitivity        | -93.5 dBm                                         |
| Max. TX Power         | 12 dBm (Programmable TX Power)                    |
| Power-Class           | Class 1, Class 2                                  |
| CPU Core              | ARM Cortex M3                                     |
| Flash/EEPROM          | Ext. Flash/EEPROM support                         |
| Internal              | 848 KB ROM                                        |
| SRAM                  | 352 KB                                            |
| Coexistence Interface | GCI SECI (2-wire)                                 |
| Serial Interfaces     | 2 UART, 2 SPI, I2C, PCM, I2S                      |
| ADC                   | 10-bit @ 100 KHz (Static) 13-bit @ 16 KHz (Audio) |
| GPIOs                 | Up to 24                                          |
**** 特性
 1. Bluetooth application
    + RFCOMM/SPP
    + A2DP source and sink
    + AVRCP controller and target
    + Hands-free AG and HF
    + BR-EDR and BLE HID Device
    + BR-EDR HID Host
    + BLE Client and Server
    + BLE beacon
    + Apple ANCS, AMS
    + Apple HomeKit and iAP2 support (requires add-in package, contact Cypress support for details)
    + OBEX library and PBAP client profile.
    + Serial over GATT profile.
 2. Peripheral interfaces
    + GPIO
    + Timer (Software)
    + PWM
    + UART (two instances - one for application download and another for application use).
    + SPI (two instances - one for serial flash and another for  application use).
    + I2C (master only).
    + RTC (Real Time Clock)
    + Keyscan
    + ADC (12 bit)
 3. Generic profile level abstraction API
 4. API to access NV storage areas.
 5. WICED Bluetooth Designer to create BR-EDR/BLE sample applications
   (See WICED Studio menu -> File -> New -> WICED Bluetooth Designer)
    + Creating Single mode BR-EDR or BLE and Dual Mode applications
    + Built-in GATT database and BLE profiles (Heart rate monitor, blood pressure, cycling speed, etc.)
    + Built-in SDP records generation for BR-EDR profiles
    + Hardware peripherals and interfaces (UART, LED, timers, Battery,  etc.)
 6. WICED BT Application Framework
    + OTA firmware upgrade
    + Overlay support to load code from NV storage on demand (NV storage dependent latency and power).
 7. 可以做为模组使用
    作为模组使用的话， 也有两种模式：
    + hci controller模式
      在这个模式下hci之上的stack都跑在主控上，CYW207xx只跑hci命令
    + application模式
      应用和蓝牙的整个协议栈都跑在CYW207xx上，主控和应用通过uart 或 spi采用定制的hci协议交互
 8. tools
    + BTSpy application for viewing embedded BT application and
      HCI protocol traces.
    + Manufacturing tools to verify RF performance (mbt and wmbt).
    + WICED Bluetooth Designer wizard for quickly creating Bluetooth
      applications.
      (See Eclipse IDE menu -> File -> New -> WICED Bluetooth Designer)
    + Segger J-Link debugger using J-Link GDB server and GCC GDB client.
    + Test tool for automated testing.
    + low_power_sensor application on 20735B0 platform
**** 目录结构
| apps      | Example & Test Applications                                                                               |
| doc       | API & Reference Documentation, Eval Board & Module Schematics                                             |
| drivers   | Drivers for the USB serial converter                                                                      |
| include   | WICED API, constants, and defaults                                                                        |
| libraries | Bluetooth profile and protocol libraries                                                                  |
| platforms | Configuration files and information for supported  hardware platforms                                     |
| test      | Tools provided for automation testing tools, wiced_tools : Build tools, compilers, programming tools etc. |
| WICED     | Core WICED components                                                                                     |

其中：
apps中都是应用逻辑代码， 和蓝牙协议关系不大。
libraries中是蓝牙协议栈的一些上层的profile的实现代码，主要有：a2dp_sink_profile avrc_target hidh_lib ams_lib fw_upgrade_lib obex_lib ancs_lib gatt_utils_lib pbap_lib avrc_controller handsfree_profile spp_lib
WICED中就是bt的核心的协议栈和整个平台的实现，主要是一个rom或ram的镜像，以及平台提供的api的符号定义。
**** WICED BT的可配置方式
需要注意的是在WICED的cofig目录中有一个配置文件: Wiced-BT/config/A_20703A2.inc
可以明显的看出是采用的Kconfig的格式， 该文件定义的变量会在makefile的编译选项中作为预定义的宏来使用。 从这里也可以间接看出，他们的内部开发是使用Kconfig系统的，ram和rom的镜像只是特定的一个配置组合的编译输出。
**** A2DP sink例子的分析
***** 简述
A2DP的例子实现了一个demo，通过蓝牙建立一个a2dp的链接，实际接收到的数据只做了打印信息输出，并没有真正实现播放器的功能。
仅仅是演示如何使用a2dp的协议。
***** 相关各层接口
+----------+--------------------------------------+
| apps     | a2dp_sink_management_callback        |
|          | a2dp_sink_control_cback              |
|          | a2dp_sink_data_cback                 |
+----------+--------------------------------------+
| librarys | wiced_bt_a2dp_sink_init              |
+----------+--------------------------------------+
| ROM      | wiced_bt_avdt_register               |
+----------+--------------------------------------+
|          | wiced_bt_avdt_create_stream          |
|          | wiced_bt_avdt_connect_req            |
|          | wiced_audioe_sink_config_init        |
|          | wiced_audio_sink_register_data_cback |
+----------+--------------------------------------+

***** 工作过程
1. wiced_bt_stack_init
   参数1是bt的各种设置，设备名字，查询扫描参数，连接间隔，BLE的广播参数等
   另外一个参数就是a2dp_sink_management_callback回调函数
   该回调函数会在bt初始化完成后调用
2. a2dp_sink_management_callback
   bt协议栈的各种LMP等核心处理函数，主要配对，链路管理，加密等核心bt时间的处理函数
   bt底层协议栈初始化完成后，回调此函数，在BTM_ENABLED_EVT事件中来做ad2p的初始化
3. wiced_bt_a2dp_sink_init
   参数1是a2dp sink的各个参数，比如codec的参数
   参数2是一个回调函数 a2dp_sink_control_cback

   应用通过调用该函数来初始化a2dp的协议， a2dp协议的大部分代码都实现在libraries/a2dp_sink_profile/目录下，a2dp依赖的核心协议AVDTP（audio video distribution profile）是实现在ROM中的。比如：wiced_bt_avdt_register wiced_bt_avdt_create_stream wiced_bt_avdt_connect_req wiced_audioe_sink_config_init 等接口

   a2dp协议初始化后，会处理各种AVDTP的事件，把部分需要应用层处理的时间通过调用注册的回调a2dp_sink_control_cback传递给应用，主要包括：
   + WICED_BT_A2DP_SINK_CODEC_CONFIG_EVT
   + WICED_BT_A2DP_SINK_CONNECT_EVT
   + WICED_BT_A2DP_SINK_DISCONNECT_EVT
   + WICED_BT_A2DP_SINK_START_IND_EVT
   + WICED_BT_A2DP_SINK_START_CFM_EVT
   + WICED_BT_A2DP_SINK_SUSPEND_EVT
4. wiced_audio_sink_register_data_cback
   应用通过该函数注册a2dp的数据接收的回调， 当有音频数据来的时候就会回调该函数
***** 主要涉及的文件大小统计：
| file name                                                           | code size | data size | rodata size |
| Apps/a2dp_sink/a2dp_sink.c                                          |       488 |        24 |           0 |
| Apps/a2dp_sink/a2dp_sink_main.c                                     |       744 |         4 |          37 |
| Apps/a2dp_sink/wiced_bt_cfg.c                                       |         0 |        64 |         221 |
| libraries/a2dp_sink_profile/wiced_bt_a2dp_sbc.c                     |       122 |         0 |           0 |
| libraries/a2dp_sink_profile/wiced_bt_a2dp_sink_act.c                |     1,950 |         0 |          44 |
| libraries/a2dp_sink_profile/wiced_bt_a2dp_sink_api.c                |       192 |         0 |           0 |
| libraries/a2dp_sink_profile/wiced_bt_a2dp_sink_cfg.c                |       282 |         0 |           0 |
| libraries/a2dp_sink_profile/wiced_bt_a2dp_sink_main.c               |       920 |       508 |          16 |
| libraries/a2dp_sink_profile/wiced_bt_a2dp_sink_ssm.c                |       140 |         0 |         416 |
***** 总结
+ 应用开发是相对简单的， 并且都遵循一定的模式，
  主要就是完成配置参数，然后注册一些回调来处理感兴趣的事件就可以了，不需要关心蓝牙具体是如何实现的。
  蓝牙参数的配置，一是可以抄例子的，含义也是相对比较直观的
  配置确定后，事件的处理就完全是应用层自己的逻辑。
+ 在a2dp的协议实现中，处理了大部分的avdtp的事件，只传递必要的事件给应用层
  这部分也保持了开源，在遇到兼容性问题的时候，开发者还是可以通过修改这里的代码来解决的。
+ AVDTP， L2CAP ， SDP保持闭源
  核心的蓝牙协议栈，不大有兼容性问题的部分，保持了闭源，同时也封装了比较好的接口。
**** 各个例子的大小
除了A2DP的例子外，还提供很多其他的例子，其中有hci字样的都是作为蓝牙模组配合其他主控使用的。另外还提供了一些使用mcu的其他非蓝牙功能的例子。
具体如下：
+------------------------------------+-----------+-----------+-------------+
| module name                        | code size | data size | rodata size |
+------------------------------------+-----------+-----------+-------------+
| spp Apps                           |      1358 |      1102 |         354 |
| spp libraries                      |       368 |        66 |           0 |
+------------------------------------+-----------+-----------+-------------+
| a2dp_sink Apps                     |      1558 |        92 |         298 |
| a2dp_sink libraries                |      3966 |       564 |         476 |
+------------------------------------+-----------+-----------+-------------+
| handsfree Apps                     |      3786 |       244 |         495 |
| handsfree libraries                |     12278 |      3746 |         908 |
+------------------------------------+-----------+-----------+-------------+
| hal_adc_app Apps                   |       474 |        48 |          40 |
+------------------------------------+-----------+-----------+-------------+
| hal_gpio_app Apps                  |       438 |        52 |          40 |
+------------------------------------+-----------+-----------+-------------+
| hal_puart_app  Apps                |       478 |         0 |          40 |
+------------------------------------+-----------+-----------+-------------+
| hal_pwm_app   Apps                 |       366 |        48 |          41 |
+------------------------------------+-----------+-----------+-------------+
| hello_client Apps                  |      1940 |       121 |         494 |
+------------------------------------+-----------+-----------+-------------+
| hello_sensor Apps                  |      2028 |       144 |         459 |
+------------------------------------+-----------+-----------+-------------+
| hci_audio_gateway Apps             |     11294 |      1990 |         918 |
+------------------------------------+-----------+-----------+-------------+
| hci_audio_remote_control Apps      |      4864 |       194 |         442 |
| hci_audio_remote_control libraries |      7538 |      3098 |         139 |
+------------------------------------+-----------+-----------+-------------+
| hci_ble_hid_dev Apps               |      2398 |       401 |         497 |
+------------------------------------+-----------+-----------+-------------+
| hci_handsfree Apps                 |      4408 |        41 |         302 |
| hci_handsfree libraries            |      5710 |       890 |         305 |
+------------------------------------+-----------+-----------+-------------+
| hci_hid_device Apps                |      4932 |      1393 |         678 |
+------------------------------------+-----------+-----------+-------------+
| hci_hid_host Apps                  |      2782 |         9 |         283 |
| hci_hid_host libraries             |      4354 |       228 |           0 |
+------------------------------------+-----------+-----------+-------------+
| hci_pbap_client Apps               |      7864 |      9009 |         483 |
| hci_pbap_client libraries          |     26410 |      2109 |        2275 |
+------------------------------------+-----------+-----------+-------------+
| hci_raw_spp Apps                   |      1742 |        96 |         302 |
+------------------------------------+-----------+-----------+-------------+
| hci_serial_gatt_service Apps       |      6468 |       829 |         524 |
+------------------------------------+-----------+-----------+-------------+
| hci_uart_spi_bridge Apps           |      1960 |      4159 |         168 |
+------------------------------------+-----------+-----------+-------------+
| mybeacon Apps                      |       434 |         0 |         221 |
+------------------------------------+-----------+-----------+-------------+
| ota_firmware_upgrade Apps          |      1256 |        50 |         376 |
| ota_firmware_upgrade libraries     |      1648 |       282 |           0 |
+------------------------------------+-----------+-----------+-------------+
| watch Apps                         |     19666 |      2677 |         941 |
| watch libraries                    |      7682 |      3098 |         139 |
+------------------------------------+-----------+-----------+-------------+
**** 文档
博通的wiced bt sdk提供的相关文档如下
+ api 文档
  使用了一个整体的html索引文档， 来管理各个模块的文档，具体模块的api函数是直接通过头文件中的注释使用工具doxgen来生成的html的文档。
  除了api函数接口文档外， sdk还提供其他文档。
+ 硬件部分
    BCM920735WCDEVAL_REV03.pdf
    CYW92070xV3_EVAL-Hardware-User-Guide.pdf
    CYW920735WCDEVAL-Hardware-User-Manual.pdf
    CYW9207x9WCDEVAL-Schematic.pdf
+ 快速入门
    WICED-20719-BT-Quick-Start-Guide.pdf
    Debugging-Support-Using-J-Link.pdf
    Manufacturing-Bluetooth-Test-Tool.pdf
+ 组件部分：
    | WICED-AMS-Library.pdf                          | 访问苹果手机的Apple Media Service                 |   |
    | WICED-ANCS-Library.pdf                         | 访问苹果手机的Apple Notification Center Service   |   |
    | WICED-Application-Buffer-Pools.pdf             | 蓝牙协议栈的buffer管理                            |   |
    | WICED-Application-Filesystem.pdf               | 应用如何通过文件系统操作卡等                      |   |
    | WICED-BT-Designer-User-Manual.pdf              | 自动生成代码的快速开发蓝牙应用的ide工具           |   |
    | WICED-Firmware-Upgrade-Library.pdf             | 固件升级                                          |   |
    | WICED-HCI-Control-Protocol.pdf                 | 不做主控作为hci controller的协议, 通过hci下载应用 |   |
    | WICED-HCI-Test-System.pdf                      | 通过hci的测试工具                                 |   |
    | WICED-HID-Device-Library.pdf                   | BLE HID的实现                                     |   |
    | WICED-SPI-Implementation.pdf                   | 通过spi做hci controller                           |   |
    | WICED-Secure-Over-the-Air-Firmware-Upgrade.pdf | OTA固件升级                                       |   |

*** zephyr + IVT
**** A2DP sink例子的分析
***** 简述
A2DP的例子实现了一个demo，通过蓝牙建立一个a2dp的链接, 播放完整的sbc或aac解码
***** 相关各层接口
主要分为三层：
bt app：用来处理应用逻辑， 播放音乐，处理方案规格关心的bt事件
btmgr：适配ivt协议栈的bt管理层，结合ivt库实现profile的功能。在bt mgr中要要做跟平台相关的各种事务，比如bt协议栈的适配，设备管理，存储管理等。
IVT库：提供各种和平台无关的bt核心协议的解析。
+----------+--------+------------------------+
| bt app   |        |                        |
+----------+--------+------------------------+
|          | LOCAL  | btmgr_ready_cb         |
|          | LOCAL  | btplay_stream_opened   |
|          | LOCAL  | btplay_stream_closed   |
|          | LOCAL  | btplay_pcm_indicated   |
+----------+--------+------------------------+
| btmgr    | GLOBAL | btmgr_start            |
|          | LOCAL  | gap_indicate_cb        |
|          | LOCAL  | gap_set_local_name_cfm |
|          | LOCAL  | a2dp_indicate_cb       |
+----------+--------+------------------------+
| IVT GAP  |        |                        |
+----------+--------+------------------------+
|          | GLOBAL | GAP_SetLocalNameA      |
|          | GLOBAL | GAP_ResetHardwareA     |
|          | GLOBAL | GAP_RegisterIndCbk     |
+----------+--------+------------------------+
| IVT A2DP |        |                        |
+----------+--------+------------------------+
|          | GLOBAL | A2DP_StreamReconfigure |
|          | GLOBAL | A2DP_StreamSuspend     |
|          | GLOBAL | A2DP_StreamStart       |
|          | GLOBAL | A2DP_GetConfiguration  |
|          | GLOBAL | A2DP_Connect           |
|          | GLOBAL | A2DP_Register_SEP      |
|          | GLOBAL | A2DP_RegCbk            |
|          | GLOBAL | A2DP_RegisterService   |
+----------+--------+------------------------+

***** 工作流程
****** 初始化
+ 应用调用btmgr_start来初始化bt协议栈
  使用btmgr_ready_cb作为回调
+ btmgr_start
    在btmgr中会通过调用GAP的一系列函数完成btstack的初始化，初始化完成后，回调btmgr_ready_cb。
    从这里也可以看出IVT协议栈的典型特点，是通过一些列的回调穿起来的， 比如如下序列：
  + IVT使用者调用GAP_RegisterTransportLayerA设置回调gap_register_tl_cfm
  + GAP_RegisterTransportLayerA回调gap_register_tl_cfm
  + gap_register_tl_cfm调用GAP_ResetHardwareA并设置回调gap_reset_hardware_cfm
  + GAP_ResetHardwareA回调gap_reset_hardware_cfm
  + gap_reset_hardware_cfm调用GAP_SetLocalNameA并设置回调gap_set_local_name_cfm
  + gap_set_local_name_cfm 最后会调用btmgr_ready_cb
    | GAP_RegisterIndCbk          | 设置gap_indicate_cb为GAP的indication的处理函数   |
    | GAP_RegisterTransportLayerA | 设置协议栈使用的传输方式以及gap_register_tl_cfm  |
    | GAP_ResetHardwareA         |  复位并设置 gap_reset_hardware_cfm                |
    | GAP_SetLocalNameA          |  设置bt设备名字，并设置回调gap_set_local_name_cfm |
+ btmgr_ready_cb
  调用A2DP_RegisterService注册A2DP服务，设置a2dp_indicate_cb为A2DP事件的回调，同时记录应用层注册的回调
  调用A2DP_Register_SEP注册服务端点（sbc acc）
  最后调用GAP_SetVisualModeA设置GAP角色，让蓝牙变得可以被发现和连接。这样在有GAP相关的连接请求时就会会调用GAP_RegisterIndCbk设置的gap_indicate_cb回调函数
****** A2DP连接建立
+ gap_indicate_cb
  bt协议的基本处理都是通过GAP的事件回调开始的，在 gap_indicate_cb中处理GAP_IND_CONNECTION_EVENT事件来处理bt设备连接
+ a2dp_indicate_cb
  bt连接建立后， 会通过a2dp_indicate_cb来处理各种a2dp的时间，如A2DP_EV_STREAMOPEN，在该事件的处理中会通过回调应用层注册的处理函数btplay_stream_opened
+ btplay_stream_opened
  应用层的具体处理逻辑，比如播放提示音什么的。
***** 各模块大小
+---------------+------------------+-----------+-----------+-------------+
|               | module name      | code size | data size | rodata size |
+---------------+------------------+-----------+-----------+-------------+
| bt app        | btplay           |      1532 |         4 |          60 |
+---------------+------------------+-----------+-----------+-------------+
| bt mgr        |                  |     17144 |      4200 |         739 |
+---------------+------------------+-----------+-----------+-------------+
|               | actions/btdrv/   |     15676 |        69 |         712 |
|               | actions/btmgr/   |     12820 |      4127 |          27 |
|               | actions/btstack/ |      2348 |         4 |           0 |
+---------------+------------------+-----------+-----------+-------------+
| baseband      |                  |    285960 |      7118 |        5458 |
+---------------+------------------+-----------+-----------+-------------+
|               | core/lc/         |     65840 |      3112 |          16 |
|               | core/hc/         |     15104 |        28 |         680 |
|               | core/hw_rf/      |     30652 |       514 |        2144 |
|               | core/hw/         |      1212 |         0 |           0 |
|               | core/le/         |     44368 |       683 |          13 |
|               | core/lmp/        |     99688 |      1783 |        1585 |
|               | core/sys/        |      2716 |       902 |        1020 |
|               | core/bt          |      4232 |        30 |           0 |
|               | core/tc/         |     10182 |         0 |           0 |
|               | core/hcit/       |      2734 |         9 |           0 |
|               | core/transport/  |      9232 |        57 |           0 |
+---------------+------------------+-----------+-----------+-------------+
| core profiles |                  |     67416 |       159 |        1507 |
+---------------+------------------+-----------+-----------+-------------+
|               | hci_             |     19370 |        16 |        1003 |
|               | gap_             |     11136 |        44 |         144 |
|               | l2cap_           |     21176 |         5 |         224 |
|               | sdap_            |      6016 |        75 |           0 |
|               | sdp              |      9718 |        19 |         136 |
+---------------+------------------+-----------+-----------+-------------+
| profiles      |                  |     37446 |       628 |             |
+---------------+------------------+-----------+-----------+-------------+
|               | a2dp_            |      1692 |         8 |           0 |
|               | avctp_           |      3266 |         4 |           0 |
|               | avdtp_           |      9672 |         5 |           0 |
|               | avrcp_           |     10846 |         4 |           0 |
+---------------+------------------+-----------+-----------+-------------+
| others        |                  |           |           |             |
+---------------+------------------+-----------+-----------+-------------+
|               | others           |     11970 |       607 |           0 |
+---------------+------------------+-----------+-----------+-------------+
***** 总结
+ 应用开发是相对简单的，只需要注册关心的事件的回调就可以了。 但提供给应用开发的个性化的配置较少。
+ btmgr层中，需要按照IVT的接口，提供各个核心协议要求的回调，每一个profile的开发都需要严格按照协议处理各个层次的bt协议的内容，为了实现一个简单的profile就需要和各个核心的profile都做一些适配，不同核心协议需要通过多级的回调才可以串起来。相对比较啰嗦，需要的胶水代码较多。
+ 底层协议的很多配置信息都体现在这里的回调函数中，如果用户需要修改到配置，就需要在这里修改，而不是应该层修改。
+ IVT协议相对独立，规范性好，协议的完备性也都有。凡是需要用户处理的部分都通过回调的方式开放出来了。
+ 已经量产验证过，协议的兼容性相对有保证
+ 资源开销不好，IVT本身还要加上上层的管理层才是一个完整的整体，相对较大

*** zephyr bluetooth
#+OPTIONS: \n:t ^:nil  toc:nil
**** A2DP sink例子的分析
***** 简述
zephyr目前a2dp的实现还很不完全， 只是编译了一下相应文件，没有真正的功能的。
***** 相关各层接口
zephyr的bt的协议栈的结构是比较清晰的， 并且与IVT协议栈相比， 除了协议本身，设备管理等必须的功能也完成了。

zephyr的蓝牙协议的各层都遵循一定的模式有点类似linux的sock编程。
对固定的L2CAP通道，比如br/edr的信令通道， LE的ATT和信令通道，使用固定的server来处理，在hci的对应事件发生的时候，调用server的accept来建立和初始化通道。
对动态的或者使用psm来多路复用的信道，在l2cap上的每种协议都有一个bt_l2cap_server，每个server的accecpt方法会在有对应psm的链接请求的时候被调用。在accept方法中会负责初始化新建的channel的处理函数bt_l2cap_chan_ops。AVDTP就是这样的一个server。

a2dp协议和avdtp协议之间采用自定义的回调的方式来解耦。

在zephyr的蓝牙协议栈中，并没有明显的看到GAP协议的位置，这是因为GAP中定义的参数，角色等都是通过zephyr的编译配置等方式实现了。用户通过修改配置项来达成GAP的功能。

+-------+--------+---------------------------------+
| A2DP  |        |                                 |
+-------+--------+---------------------------------+
|       | GLOBAL | bt_a2dp_register_endpoint       |
|       | GLOBAL | bt_a2dp_init                    |
|       | GLOBAL | a2dp_accept                     |
|       | GLOBAL | get_new_connection              |
|       | GLOBAL | a2d_reset                       |
+-------+--------+---------------------------------+
| AVDTP |        |                                 |
+-------+--------+---------------------------------+
|       | GLOBAL | bt_avdtp_init                   |
|       | GLOBAL | bt_avdtp_register_sep           |
|       | GLOBAL | bt_avdtp_register               |
|       | GLOBAL | bt_avdtp_l2cap_recv             |
|       | GLOBAL | bt_avdtp_l2cap_connected        |
|       | GLOBAL | bt_avdtp_l2cap_accept           |
|       | GLOBAL | bt_avdtp_l2cap_disconnected     |
+-------+--------+---------------------------------+
| conn  |        |                                 |
+-------+--------+---------------------------------+
|       | GLOBAL | bt_conn_init                    |
|       | GLOBAL | bt_conn_process_tx              |
|       | GLOBAL | bt_conn_create_pdu              |
|       | GLOBAL | bt_conn_lookup_handle           |
|       | GLOBAL | bt_conn_prepare_events          |
|       | GLOBAL | bt_conn_recv                    |
|       | GLOBAL | bt_conn_identity_resolved       |
|       | GLOBAL | bt_enable                       |
|       | GLOBAL | bt_recv                         |
+-------+--------+---------------------------------+
| L2CAP |        |                                 |
+-------+--------+---------------------------------+
|       | GLOBAL | bt_le_conn_params_valid         |
|       | GLOBAL | bt_l2cap_br_init                |
|       | GLOBAL | bt_l2cap_br_fixed_chan_register |
|       | GLOBAL | bt_l2cap_br_recv                |
|       | GLOBAL | bt_l2cap_br_server_register     |
|       | GLOBAL | bt_l2cap_br_connected           |
|       | LOCAL  | l2cap_br_recv                   |
+-------+--------+---------------------------------+

***** 工作流程
****** 初始化
+ bt_a2dp_init
  应用调用bt_avdtp_register(& avdtp_cb );注册a2dp的回调a2dp_accept，之后调用bt_enable就可以了。
+ bt_enable
  用户首先调用bt_enable注册回调，该回调会在蓝牙初始化好后调用，蓝牙初始化会异步进行。
  后台启动蓝牙初始化
+ bt_init
  hci_init用来通过hci完成蓝牙的初始化，br_init用来初始化传统蓝牙
  bt_conn_init用来初始化协议栈的链接管理，会初始化att，smp， l2cap等核心协议，其中bt_l2cap_br_init初始化l2cap层
+ bt_l2cap_br_init
  bt_l2cap_br_fixed_chan_register为l2cap的信令通道注册处理函数
  然后为基于l2cap的各个协议（psm）注册处理函数，分别是bt_rfcomm_init，bt_avdtp_init，bt_sdp_init，bt_a2dp_init。
  bt_avdtp_init调用bt_l2cap_br_server_register注册bt_avdtp_l2cap_accept是avdtp的协议处理函数
+ bt_avdtp_l2cap_accept
  回调a2dp_accept来产生一个bt_avdtp的session，并设置对应的l2cap的channel的处理函数为 static struct bt_l2cap_chan_ops ops = {
                .connected = bt_avdtp_l2cap_connected,
                .disconnected = bt_avdtp_l2cap_disconnected,
                .recv = bt_avdtp_l2cap_recv,
******  A2dp链接建立
从中断程序开始到应用程序的回调流程大概如下：
hci_rx_thread
   bt_conn_recv
     bt_l2cap_recv
       l2cap_chan_recv
         bt_avdtp_l2cap_recv

***** 各模块大小

+----------------------+------------------------------+--------+-------+------+
| bluetooth host       |                              |  36812 |  6703 | 1439 |
+----------------------+------------------------------+--------+-------+------+
|                      | host/a2dp.c                  |    116 |    92 |    0 |
|                      | host/at.c                    |    102 |     0 |    0 |
|                      | host/att.c                   |  3,688 |   228 |  216 |
|                      | host/avdtp.c                 |    206 |     8 |    0 |
|                      | host/conn.c                  |  3,946 | 1,260 |   16 |
|                      | host/gatt.c                  |  1,284 |   332 |    0 |
|                      | host/hci_core.c              |  7,084 | 2,608 |    0 |
|                      | host/hfp_hf.c                |    276 |   392 |  300 |
|                      | host/keys.c                  |    264 |   104 |    0 |
|                      | host/keys_br.c               |     76 |   104 |    0 |
|                      | host/l2cap.c                 |  3,262 |   168 |    0 |
|                      | host/l2cap_br.c              |  3,236 |   212 |    0 |
|                      | host/rfcomm.c                |  3,282 |   208 |  256 |
|                      | host/sdp.c                   |  2,496 |   377 |  216 |
|                      | host/smp.c                   |  7,408 |   610 |  418 |
|                      | host/uuid.c                  |     86 |     0 |   17 |
|                      | common/rpa.c                 |    142 |     0 |    0 |
+----------------------+------------------------------+--------+-------+------+
| bluetooth controller |                              |  37890 |  5291 |   32 |
+----------------------+------------------------------+--------+-------+------+
|                      | controller/hal/nrf5/cntr.c   |    136 |     1 |    0 |
|                      | controller/hal/nrf5/ecb.c    |    142 |     0 |    0 |
|                      | controller/hal/nrf5/radio.c  |  1,610 |   535 |    0 |
|                      | controller/hal/nrf5/rand.c   |    252 |     4 |    0 |
|                      | controller/hci/hci.c         |  4,240 |   166 |    0 |
|                      | controller/hci/hci_driver.c  |    318 | 1,744 |   16 |
|                      | controller/ll_sw/crypto.c    |     64 |    20 |    0 |
|                      | controller/ll_sw/ctrl.c      | 23,888 |   392 |   16 |
|                      | controller/ll_sw/ll.c        |    560 | 1,308 |    0 |
|                      | controller/ll_sw/ll_adv.c    |  1,068 |    16 |    0 |
|                      | controller/ll_sw/ll_filter.c |  3,012 |   691 |    0 |
|                      | controller/ll_sw/ll_master.c |    156 |     0 |    0 |
|                      | controller/ll_sw/ll_scan.c   |    180 |     6 |    0 |
|                      | controller/ticker/ticker.c   |  1,262 |    88 |    0 |
|                      | controller/util/mayfly.c     |    580 |   320 |    0 |
|                      | controller/util/mem.c        |    246 |     0 |    0 |
|                      | controller/util/memq.c       |      0 |     0 |    0 |
|                      | controller/util/util.c       |     34 |     0 |    0 |
+----------------------+------------------------------+--------+-------+------+

***** 总结
+ 架构清晰，各个层次耦合较少，应用开发简单
+ 有很方便的可配置性，不要的功能可以很方便的配置掉
+ 资源开销很少，包含了BLE的核心协议栈只有30~40K
+ BLE的支持比较完善，
+ BR/EDR的支持，可以明显看到只完成了一部分工作，完成度不是太好
*** 协议栈对比
+-------------+-----------------------------+-----------------------+--------------------+
|             | Broadcom                    | IVT+zephyr            | zephyr             |
+-------------+-----------------------------+-----------------------+--------------------+
| 协议支持    | RFCOMM/SPP                  | a2dp_ui               | a2dp               |
+-------------+-----------------------------+-----------------------+--------------------+
|             | A2DP source and sink        | avdtp_ui              | gatt               |
|             | AVRCP controller and target | goep_ui               | hfp_hf             |
|             | Hands-free AG and HF        | l2cap_ui              | rfcomm             |
|             | BR-EDR and BLE HID Device   | rfcomm_ui             | att                |
|             | BR-EDR HID Host             | smp_ui                | hci                |
|             | BLE Client and Server       | att_ui                | l2cap              |
|             | BLE beacon                  | avrcp_ui              | sdp                |
|             | Apple ANCS, AMS             | hci_ui                | avdtp              |
|             | Apple HomeKit and iAP2      | obexui                |                    |
|             | OBEX library and PBAP       | sdap_ui               |                    |
|             | Serial over GATT profile.   | spp_app_ui            |                    |
|             |                             | avctp_ui              |                    |
|             |                             | gap_ui                |                    |
|             |                             | hfp_ui                |                    |
|             |                             | pbap_ui               |                    |
|             |                             | sdpui                 |                    |
|             |                             | spp_ui                |                    |
+-------------+-----------------------------+-----------------------+--------------------+
| profile开发 | 核心profile实现在ROM中      | IVT只负责协议解析相关 | hci之上开源        |
|             | 应用profile较齐全，并开源   | 开发相对相对繁琐      | profile开发简单    |
|             | 用户需要较少修改就可以      | IVT的相对不太容易理解 |                    |
+-------------+-----------------------------+-----------------------+--------------------+
| 应用开发    | 简单                        | 简单                  | 简单               |
|             | 不开源部分提供可配置性好    | 尚未提供太多可配置性  | 可配置通过代码完成 |
+-------------+-----------------------------+-----------------------+--------------------+
| 资源开销    | 848KB ROM 352K RAM          | 130k                  | 21K                |
+-------------+-----------------------------+-----------------------+--------------------+
| 完备性      | BR/EDR/BLE完善              | 支持了A2DP和AVRCP     | BR/EDR支持不完善   |
|             | 应用profile完善并有demo     |                       | BLE支持相对完善    |
+-------------+-----------------------------+-----------------------+--------------------+
| 兼容性      | 只提供协议demo，无考虑      |                       |                    |
|             | 协议本身估计是测试过PTS的   |                       |                    |
+-------------+-----------------------------+-----------------------+--------------------+

说明:
+ 协议支持
  从协议支持上来看， broadcom的支持非常丰富，ER/EDR/BLE支持都非常完善， 同时也支持了大部分常见的应用profile， 包括苹果的BLE的profile。 除了支持 音频，打电话，还支持电话本，hid等。 除此之外还可以支持通过usb，uart以及spi来作为外挂的模组来搭配别的主控使用。

  IVT库支持的协议相对也比较全，音频，打电话之外，也支持电话本等协议，

  zephyr的协议相对支持的会少一些，ble是比较完善的， BR/EDR的支持都是实验性质的，已经支持的几个有些也是半成品。

+ profile开发
  对常用的profile broadcom平台都提供了开源的基本实现，使用profile要做个性话的修改，或者解决兼容性问题的话，估计小修改就可以了。
  大部分核心的profile broadcom的实现是放在rom中的，对外提供封装好的借口。

  IVT库的特点是对蓝牙的协议解析规范支持比较完善，对所有在蓝牙协议上都通过回调的方式交给平台去实现，这样的选择就暴露了特别多的接口，开发一个profile经常需要从协议栈上各个依赖的profile都做好个性化的处理，也需要提供蓝牙设备管理，存储管理等才能够完成一个完整的profile开发， 开发相对繁琐，代码量也会多一些。同时，ivt协议的接口也需要较大的学习曲线。

  zephyr在hci之上都是开源的，并且对协议层也有比较好的分层，开发相对简单直接。整个协议栈是完整重写的，同时协议栈的解析也和平台相关的功能有机的结合起来了，写出的代码会明显小一些，应用profile开发一般只需要关注对应的profile即可， 不太需要关注底层的profile，相对会容易一些。

+ 应用开发
  在profie开发中，做好分层和抽象后，把应用和profile做好隔离后， 应用开发都相对比较简单。

+ 资源开销
  资源统计主要统计了代码的大小，主要是BR/EDR的核心profile(L2CAP  SDP HCI GAP)，加上A2DP 和 AVRCP这两个profile。 数据的统计没有放在这里，主要是因为不好统计动态内存。只统计全局变量意义不大。

  broadcom由于核心的profile都是在rom中，同时rom中除了蓝牙协议栈，还有非常多的其他功能，因此不太好统计实际大小
  IVT由于需要个性化东西太多，适配代码比较多，因此相对代码会多一些
  zephyr会明显小很多的，原因有如下几点：
  + 很多ivt需要代码完成的功能是通过编译可配置完成的， 比如GAP。
  + 协议的解析和对于的动作都是在一层完成的，模块化更好，没有使用ivt绕来绕去的流程，代码也简洁直接得多
  + profile还未完善，代码也会偏少一些
+ 兼容性的考虑
  从broadcom平台来看，提供的应用仅仅是demo协议栈使用，比如a2dp收到数据直接丢掉，事件处理仅仅是打印而已。
  而按照我们做产品的经验来看，很多的兼容性问题都是手机等设备不规范，需要应用层解决的，所以这部分的兼容性只能在使用平台的人在做产品的时候解决。
  profile本身的蓝牙协议的兼容性，可以考虑使用sig的协议测试工具来解决。
** 5118B
*** 平台主要优势
5118平台相对现在常见的mcu开发平台，主要的优势在于:
+ 蓝牙支持
+ 多格式解码支持
+ 音效，魔音，vad，录音等语音处理算法
目前的mcu开发平台大部分都不会提供这些组件，特别是蓝牙的协议栈，几乎没有看到开源的。
音频部分有一些开源的实现， 但开源的实现相对占用资源都比较大， 并且支持的格式也不多。
像wifi支持这些都不能算做优势，只是从侧面说明了我们平台的cpu和ram能够支持相对复杂的应用的例子。
*** 主要架构考虑
+ 基于开发板进行开发
  开发板需要满足主要
+ 使用统一的内存模型
  sdk不开源的部分， 比如蓝牙的hci之下的部分，音视频解码库都使用静态库的方式提供。
  整个应用，kernel，平台其他组件，采用统一链接的方式，生成一个可执行的文件。
  在链接文件中，用户可以统一的规划内存空间的使用， 可以把某些代码放在ram空间执行。
  sdk不会强制要求特别的地址空间，这样可以有利于客户程序的内存使用和规划。
+ 灵活的可配置选择
  对绝大部分的模块都采用可配置的方式，不需要的功能可以完全通过config的方式去掉代码和功能，去掉的内存不再占用空间。
+ 蓝牙协议栈选择
  倾向于选择zephyr的协议栈，主要有几点考虑：
  + zephyr的协议栈是开源的
    HCI层之上的所有协议用户都可以看到， 也就是说只要我们提供的hci层之下的baseband 和 链路管理层不出现问题，所有的兼容性问题，客户应该都有机会可以搞定。
    从目前了解的兼容性问题来看，比较大的部分不是协议本身的问题，更多是手机不规范需要再应用中workaround的问题。
    协议栈开源的话，用户想开发一些自有的蓝牙协议也是有机会的。
  + 使用zephyr协议栈可以更多利用社区的力量
    zephyr的协议栈，特别是BLE的部分，发展是比较快的。
  + zephyr相对于IVT体积更小，架构复杂性更低
    zephyr协议栈相对于IVT协议栈来说，封装较好，架构也更简洁一些，比容容易写上层应用， 不需要特别了解蓝牙协议栈的开发者都可以开发蓝牙应用。 深度定制的话，可能需要动到协议栈的代码。
    IVT协议栈提供了特别多的可能性，把几乎所有的协议中可以变化的部分都暴露出来给了上层，要写一个完整的蓝牙应用，一方面需要对蓝牙协议理解较深，另一方面还是要写比较多的代码才可以， 开发相对复杂。代码量也会比较大。就算是深度定制，也基本不需要改IVT协议栈本身的代码。
  + 避免重复做IVT的工作
    IVT协议栈以及上层的bt engine的工作蓝牙音箱重构完成后，可以直接porting过来。
    避免两边做重复的工作
  + 蓝牙兼容性的问题
    开发平台的话，思路主要是提供完善的底层平台支持，然后基于平台提供一些sample的应用，比如a2dp，hfp， avrcp， gatt等各种使用蓝牙协议的sample应用。
    提供sample应用的主要目的是为了演示如何使用蓝牙协议栈，针对这些sample做一下我们内部的兼容性是不是就够了。
    完整的兼容性是在最终的产品上来做的。
+ 应用开发和测试
  按照平台的思路来开发的话， 应用就是一些sample应用，整个平台可能有几十个sample的应用，比如：
  蓝牙：a2dp， avrcp，hfp，音频广播， beacon， hid等
  播放器:  播放mp3等格式， 播放pcm， pcm录制， amr录制
  系统相关：读写文件，读写card， led， gpio， usb 传输等
  如果有wifi：iperf，http client， http server， mqtt，ping等
  以及zephyr提供的其他的sample

  这部分sample的应用除了给客户展示如何基于平台开发应用外，也可以测试部的测试应用，测试部门可以基于这些应用来编写系统测试用例，兼容性测试也可以使用这些应用来测试。
+ 平台测试
  平台按照模块的测试采用自动化测试的方式进行， 这部分主要针对应用编程接口测试，类似android的cts测试。主要针对的是应用开发可见的编程接口。
  不测试模块内部自身的逻辑。
+ 文档
  文档整合的目标可以分阶段进行：
  + 基本开发文档
    开发板相关的硬件文档，IC的data sheet
    快速入门开发环境建立， api编程手册，工具使用文档
  + 各个模块的设计文档
    这部分根据实际的情况，逐步完成。
** 0810 WICED BT代码结构
*** a2dp sink
**** apps
***** APPLICATION_START()
+ wiced_bt_stack_init( a2dp_sink_management_callback , &a2dp_sink_cfg_settings, a2dp_sink_cfg_buf_pools);
***** a2dp_sink_management_callback
+ a2dp_sink_management_callback
  switch( event )
  + case BTM_ENABLED_EVT:
    + a2dp_sink_write_eir( );
      + pBuf = (uint8_t*)wiced_bt_get_buffer( WICED_HS_EIR_BUF_MAX_SIZE );
      + wiced_bt_dev_write_eir( pBuf, (uint16_t)(p - pBuf) );
    /* create SDP records */
    + wiced_bt_sdp_db_init( ( uint8_t * )a2dp_sink_sdp_db, sizeof( a2dp_sink_sdp_db ) );
    /* start the a2dp application */
    + av_app_init();
      + result = wiced_bt_a2dp_sink_init( &bt_audio_config,  a2dp_sink_control_cback );
        + wiced_bt_a2dp_sink_init_state_machine
          + static const wiced_bt_a2dp_sink_sst_tbl_entry_t wiced_bt_a2dp_sst_tbl[] =
        + wiced_bt_a2dp_sink_cb.p_config_data = p_config_data
        + wiced_bt_a2dp_sink_register()
          + wiced_bt_a2dp_sink_init_ccb();
            + wiced_bt_a2dp_sink_cb.ccb[idx].p_dt_cback = wiced_bt_a2dp_sink_ctrl_cback;
          + wiced_bt_avdt_register(&reg, wiced_bt_a2dp_sink_conn_cback);//rom
          + wiced_bt_a2dp_sink_reg_a2dp(&cs, p_scb);
        + wiced_audio_sink_config_init(&p_config_data->p_param)
      + wiced_bt_a2dp_sink_register_data_cback( a2dp_sink_data_cback );
    /* Making the sink device discoverable and connectable */
    wiced_bt_dev_set_discoverability( BTM_GENERAL_DISCOVERABLE, BTM_DEFAULT_DISC_WINDOW, BTM_DEFAULT_DISC_INTERVAL );
    wiced_bt_dev_set_connectability(  WICED_TRUE, BTM_DEFAULT_CONN_WINDOW, BTM_DEFAULT_CONN_INTERVAL );
  + case  BTM_PIN_REQUEST_EVT:
    wiced_bt_dev_pin_code_reply(*p_event_data->pin_request.bd_addr,result/*WICED_BT_SUCCESS*/,4, &pincode[0]);
  + case BTM_USER_CONFIRMATION_REQUEST_EVT:
    wiced_bt_dev_confirm_req_reply( WICED_BT_SUCCESS, p_event_data->user_confirmation_request.bd_addr );
  + case BTM_PASSKEY_NOTIFICATION_EVT:
  + case BTM_PAIRING_IO_CAPABILITIES_BR_EDR_REQUEST_EVT:
    p_event_data->pairing_io_capabilities_br_edr_request.local_io_cap = BTM_IO_CAPABILITIES_NONE;
    p_event_data->pairing_io_capabilities_br_edr_request.auth_req = BTM_AUTH_SINGLE_PROFILE_GENERAL_BONDING_NO;
  + case BTM_PAIRING_COMPLETE_EVT:
    p_pairing_cmpl = &p_event_data->pairing_complete;
    if( p_pairing_cmpl->transport == BT_TRANSPORT_BR_EDR )      {
     pairing_result = p_pairing_cmpl->pairing_complete_info.br_edr.status;      }
  + case BTM_ENCRYPTION_STATUS_EVT:
    p_encryption_status = &p_event_data->encryption_status;
  + case BTM_PAIRED_DEVICE_LINK_KEYS_UPDATE_EVT:
    a2dp_sink_write_nvram( A2DP_SINK_NVRAM_ID, sizeof( wiced_bt_device_link_keys_t ), &p_event_data->paired_device_link_keys_update );
  + case  BTM_PAIRED_DEVICE_LINK_KEYS_REQUEST_EVT:
    if ( a2dp_sink_read_nvram( A2DP_SINK_NVRAM_ID, &p_event_data->paired_device_link_keys_request, sizeof(wiced_bt_device_link_keys_t)) != 0 )      {
    result = WICED_BT_SUCCESS;
  + case BTM_POWER_MANAGEMENT_STATUS_EVT:
    p_power_mgmt_notification = &p_event_data->power_mgmt_notification;
    p_power_mgmt_notification->status, p_power_mgmt_notification->hci_status);
+ wiced_audio_buffer_initialize (a2dp_sink_audio_buf_config);

***** av_app_init
 + av_app_init();
   + result = wiced_bt_a2dp_sink_init( &bt_audio_config,  a2dp_sink_control_cback );
     + wiced_bt_a2dp_sink_init_state_machine
       + static const wiced_bt_a2dp_sink_sst_tbl_entry_t wiced_bt_a2dp_sst_tbl[] =
     + wiced_bt_a2dp_sink_cb.p_config_data = p_config_data
     + wiced_bt_a2dp_sink_register()
       + wiced_bt_a2dp_sink_init_ccb();
         + wiced_bt_a2dp_sink_cb.ccb[idx].p_dt_cback = wiced_bt_a2dp_sink_ctrl_cback;
       + wiced_bt_avdt_register(&reg, wiced_bt_a2dp_sink_conn_cback);//rom
       + wiced_bt_a2dp_sink_reg_a2dp(&cs, p_scb);
     + wiced_audio_sink_config_init(&p_config_data->p_param)
   + wiced_bt_a2dp_sink_register_data_cback( a2dp_sink_data_cback );
     + wiced_audio_sink_register_data_cback( p_cback );
***** a2dp_sink_control_cback
+ {WICED_BT_A2DP_SINK_API_START_EVT            , WICED_BT_A2DP_SINK_OPEN_SST       , wiced_bt_a2dp_sink_do_start},
  + wiced_bt_a2dp_sink_do_start
    + wiced_bt_a2dp_sink_start_ok
      + (*wiced_bt_a2dp_sink_cb.control_cb)(WICED_BT_A2DP_SINK_START_CFM_EVT, (wiced_bt_a2dp_sink_event_data_t *) &start);
      + a2dp_sink_control_cback
        + case WICED_BT_A2DP_SINK_CODEC_CONFIG_EVT:
        + case WICED_BT_A2DP_SINK_CONNECT_EVT
        + case WICED_BT_A2DP_SINK_START_IND_EVT
          + wiced_bt_a2dp_sink_send_start_response( p_data->start_ind.handle, p_data->start_ind.label, A2D_SUCCESS )
        + case WICED_BT_A2DP_SINK_START_CFM_EVT
        + av_app_cb.state = AV_STATE_STARTED
***** a2dp_sink_data_cback
+ WICED_BT_TRACE( "A2DP data %x, %d\n",p_a2dp_data, a2dp_data_len );
**** librarys
***** wiced_bt_a2dp_sink_init
   + result = wiced_bt_a2dp_sink_init( &bt_audio_config,  a2dp_sink_control_cback );
     + wiced_bt_a2dp_sink_init_state_machine
       + static const wiced_bt_a2dp_sink_sst_tbl_entry_t wiced_bt_a2dp_sst_tbl[] =
     + wiced_bt_a2dp_sink_cb.p_config_data = p_config_data
     + wiced_bt_a2dp_sink_cb.control_cb = control_cb;
     + wiced_bt_a2dp_sink_register()
       + p_scb = wiced_bt_a2dp_sink_cb.p_scb
       + wiced_bt_a2dp_sink_init_ccb();
         + wiced_bt_a2dp_sink_cb.ccb[idx].p_dt_cback = wiced_bt_a2dp_sink_ctrl_cback;
       + reg.ctrl_mtu = WICED_BT_A2DP_SINK_AVDT_SIG_CH_MTU;
         reg.ret_tout = WICED_BT_A2DP_SINK_RET_TOUT;
         reg.sig_tout = WICED_BT_A2DP_SINK_SIG_TOUT;
         reg.idle_tout= WICED_BT_A2DP_SINK_IDLE_TOUT;
       + wiced_bt_avdt_register(&reg, wiced_bt_a2dp_sink_conn_cback);//rom
       + wiced_bt_a2dp_sink_reg_a2dp(&cs, p_scb);
         + p_cs->cfg.psc_mask  = AVDT_PSC_TRANS;
           p_cs->media_type    = AVDT_MEDIA_AUDIO;
         + p_cs->p_ctrl_cback  = wiced_bt_a2dp_sink_ctrl_cback;
         + memcpy(&(p_scb[index].cfg), &p_cs->cfg, sizeof(wiced_bt_avdt_cfg_t));
         + ret = wiced_bt_a2dp_sink_cfg_init(&wiced_bt_a2dp_sink_cb.p_config_data->codec_capabilities.info[c_index],
           p_cs->cfg.codec_info,
           &p_cs->cfg.num_protect,
           p_cs->cfg.protect_info)
         + wiced_bt_avdt_create_stream(&(wiced_bt_a2dp_sink_cb.seps[sep_index].av_handle), p_cs)
         + wiced_bt_a2dp_sink_cb.seps[sep_index].codec_type =
           wiced_bt_a2dp_sink_cb.p_config_data->codec_capabilities.info[c_index].codec_id;
     + wiced_audioe_sink_config_init(&p_config_data->p_param)
******* wiced_bt_a2dp_sink_ctrl_cback
  + wiced_bt_a2dp_sink_ctrl_cback
    + wiced_bt_a2dp_sink_proc_stream_evt(handle, bd_addr, event, p_data);
      + memcpy(&p_msg->msg, p_data, sizeof (wiced_bt_avdt_ctrl_t));
      + case AVDT_CONFIG_IND_EVT:
      + memcpy(&p_msg->cfg, p_data->config_ind.p_cfg, sizeof(wiced_bt_avdt_cfg_t));
      + p_msg->hdr.event = wiced_bt_a2dp_sink_stream_evt_ok[event];
      + wiced_bt_a2dp_sink_hdl_event((BT_HDR*)p_msg);
        + p_ccb = wiced_bt_a2dp_sink_get_ccb(event, p_data)
          + p_ccb = wiced_bt_a2dp_sink_get_ccb_by_bd_addr(p_data->str_msg.bd_addr);
            + p_ccb = &wiced_bt_a2dp_sink_cb.ccb[idx];

***** wiced_bt_a2dp_sink_conn_cback
+ if (event == AVDT_CONNECT_IND_EVT || event == AVDT_DISCONNECT_IND_EVT)
  evt = WICED_BT_A2DP_SINK_SIG_CHG_EVT;
+ wiced_bt_a2dp_sink_hdl_event((BT_HDR*)&str_msg)
  + wiced_bt_a2dp_sink_get_ccb
    + case WICED_BT_A2DP_SINK_A一些PI_CONNECT_EVT:
    + p_ccb = wiced_bt_a2dp_sink_alloc_ccb(p_data);
      + wiced_bt_a2dp_sink_cb.ccb[idx].in_use     = WICED_TRUE;
      + wiced_bt_a2dp_sink_cb.ccb[idx].ccb_handle = idx;
      + wiced_bt_a2dp_sink_cb.ccb[idx].p_scb      = &(wiced_bt_a2dp_sink_cb.p_scb[idx]);
      + wiced_bt_a2dp_sink_cb.ccb[idx].p_dt_cback = wiced_bt_a2dp_sink_ctrl_cback;
    + case WICED_BT_A2DP_SINK_AVDT_CONNECT_EVT:
    + p_ccb = wiced_bt_a2dp_sink_get_ccb_by_bd_addr(p_data->str_msg.bd_addr);
    + case WICED_BT_A2DP_SINK_API_START_EVT:
    + p_ccb = wiced_bt_a2dp_sink_get_ccb_by_handle(p_data->api_data.handle);
  + wiced_bt_a2dp_sink_ssm_execute(p_ccb, p_data, p_msg->event);
    + state_table_entry = wiced_bt_a2dp_sst_tbl[p_ccb->state];
    + found = wiced_bt_a2dp_sink_search_event(state_table_entry, event, &next_state, &pfhandler);
    + p_ccb->state  = next_state;
    + pfhandler(p_ccb, p_data);
****** wiced_bt_a2dp_sink_connect_req
{WICED_BT_A2DP_SINK_SDP_DISC_OK_EVT          ,WICED_BT_A2DP_SINK_SIG_OPENING_SST,wiced_bt_a2dp_sink_connect_req},
+ wiced_bt_avdt_connect_req(p_ccb->peer_addr, 0/*Not Used*/, p_ccb->p_dt_cback);

**** ROM
wiced_bt_stack_init
wiced_bt_avdt_register
wiced_bt_avdt_create_stream
wiced_bt_avdt_connect_req(p_ccb->peer_addr, 0/*Not Used*/, p_ccb->p_dt_cback);
wiced_audioe_sink_config_init(&p_config_data->p_param)
wiced_audio_sink_register_data_cback( void* p_cback );

*** zephyr + IVT
  + btmgr_start(btmgr_ready_cb);
    + err = ivtmgr_rdm_init();
      + p_rdm = NEW(sizeof(struct ivtmgr_rdm_priv));
      + k_delayed_work_init(&p_rdm->auto_conn_work,
        _auto_connection_work_handler);
      + _paired_info_restore();
        + nvram_config_get(BTMGR_PAIRED_INFO_NVRAM_NAME,
      + _autoconn_info_restore();
        + nvram_config_get(BTMGR_AUTOCONN_INFO_NVRAM_NAME,
    + err = ivtmgr_drv_init(ivtmgr_drv_rx_cb);
      + init_con_env();
        + init_btrom_bss ();
        + load_func_tab();
        + load_btrom_data();
      + g_rx_cb = rx_cb;
      + btc_cfg.rf_txpower_adjust = 7;
        btc_cfg.uart_transport_en = 0;
        btc_cfg.feature_pkg=0;
        btc_cfg.low_freq_available = 1;
        btc_cfg.gpio_debug_mask = 0;
        btc_cfg.log_mask = CON_LOG_MASK_OUTPUT | CON_LOG_VIA_UART;
        btc_cfg.is_fpga = 0;
      + con_init(&btc_cfg);
      + con_general_register_cbk(hci_host_buf_req_cb,
        hci_host_buf_commit_cb,
      + k_thread_spawn(g_schedule_loop_stack, schedule_loop_thread,
      + k_thread_spawn(g_schedule_loop_low_stack,
        schedule_loop_low_thread,
    + g_ready_cb = cb;
    + err = btstack_init();
      + BtInit();
      + k_thread_spawn((void *)ScheduleLoop, NULL, NULL,
      + GAP_RegisterIndCbk(NULL, GAP_IND_ALL, gap_indicate_cb);
      + GAP_RegisterTransportLayerA((HANDLE)&g_tl_hdl,
        (TransportLayerStru *)&g_uart_tl_func,
        gap_register_tl_cfm);

  static const TransportLayerStru g_uart_tl_func = {
          uart_tl_get_type,
          uart_tl_startup,
          uart_tl_shutdown,
  + uart_tl_send,
    + ivtmgr_drv_send(data, len);
      + pbuf = con_buf_req(ptype, NULL, data_size);
      + memcpy(pbuf, data + (len - data_size), data_size);
      + con_buf_commit(ptype, pbuf, data_size);
          uart_tl_start_sco,
          uart_tl_stop_sco,
  };

  static const struct btmgr_a2dp_callbacks a2dp_cbs = {
          .stream_opened = btplay_stream_opened,
          .stream_closed = btplay_stream_closed,
          .pcm_indicated = btplay_pcm_indicated,
  };

  + btmgr_ready_cb
    + btmgr_a2dp_start(&a2dp_cbs);
      + p_a2dp = NEW(sizeof(struct ivtmgr_a2dp_priv));
      + p_a2dp->cbs = cbs;
      + in = NEW(sizeof(struct A2DP_RegCbkStru));
      + in->cbk = a2dp_indicate_cb;
      + A2DP_RegCbk(in);
      + p_a2dp->snk_svc_hdl = A2DP_RegisterService(A2DP_TSEP_SNK,
        A2DP_SPEAKER);
      + a2dp_snk_sep_register();
        + sep = List_NodeNew(sizeof(struct A2DP_SEPStru) + len);
        + sep->mask = AVDTP_SEPMASK_ISSNKSVC;
          sep->media_type = (A2DP_MEDIATYPE_AUDIO << 4) | (A2DP_TSEP_SNK
          << 3);
                  p = sep->sc.service_capability;
                  p[1] = A2DP_SC_MEDIA_TRANSPORT;
                  p[2] = 0;
                  p[3] = A2DP_SC_MEDIA_CODEC;
                  p[4] = 6;
                  p[5] = A2DP_MEDIATYPE_AUDIO << 4;
                  p[6] = A2DP_CODEC_SBC;
                  p[7] = A2DP_SBC_SF_ALL | A2DP_SBC_CHMODE_ALL; /* some
                  phone(XT319) need support all SF. */
                  p[8] = A2DP_SBC_BLOCK_ALL | A2DP_SBC_SUBBAND_ALL |
                  A2DP_SBC_ALLOCATION_ALL;
                  p[9] = 2;
                  p[10] = CONFIG_BTMGR_A2DP_BITPOOL;
        + A2DP_Register_SEP(sep);
      + audioout_hdl = audio_out_device_create();
    + btmgr_avrcp_start(NULL);
    + btmgr_br_set_discoverable(true);
      + GAP_SetVisualModeA((HANDLE)&g_tl_hdl, NULL, g_visual_mode,
        NULL);
    + btmgr_br_set_connnectable(true);
      + GAP_SetVisualModeA((HANDLE)&g_tl_hdl, NULL, g_visual_mode,
        NULL);

  + a2dp_indicate_cb
    + case A2DP_EV_REGSEP:
    + a2dp_sep_registerd(param);
    + case A2DP_EV_STREAMCREATE:
    + a2dp_stream_created(param);
    + case A2DP_EV_SETCONFIGURATION:
    + a2dp_stream_setconfig(param);
    + case A2DP_EV_OPENCODECINFO:
    + a2dp_stream_opencodecinfo(param);
    + case A2DP_EV_STREAMOPEN:
    + a2dp_stream_open(param);
    + case A2DP_EV_STREAMSTART:
    + a2dp_stream_start(param);
    + case A2DP_EV_DATAIND:
    + a2dp_data_ind(param);
      + sbc_info.input = BUFDATA(in->data);
        sbc_info.input_len = DATASIZE(in->data);
        sbc_info.output = NEW(512); /* TODO */
      + audio_decoder_ops_sbc(p_a2dp->decsbc_handle,
        SBC_CMD_FRAME_DECODE,
        (unsigned int)&sbc_info);
      + __pcm_data_out((uint16_t *)sbc_info.output, sbc_info.output_len
        / 2);
    + case A2DP_EV_STREAMSUSPEND:
    + FREE(param);
    + case A2DP_EV_STREAMDONE:
    + a2dp_stream_done(param);

  + gap_register_tl_cfm(HANDLE tl_hdl, UINT16 result, struct
    GAP_RegisterTLCfmStru *cfm_par)
    + GAP_ResetHardwareA(tl_hdl, NULL, gap_reset_hardware_cfm);
      + gap_reset_hardware_cfm
      + gap_start();
        + UINT8 class_of_device[4] = {0x04, 0x04, 0x24}; /* TODO */
        + UINT8 device_name[] = "zephyr-ivt"; /* TODO */
        + GAP_SetLocalDeviceClassA((HANDLE)&g_tl_hdl, NULL,
          class_of_device, NULL);
        + GAP_SetIOCapability((UINT8)HCI_IO_CAPABILITY_NOINPUTNOOUTPUT);
        + GAP_SetLocalNameA((HANDLE)&g_tl_hdl, NULL, device_name,
          sizeof(device_name), gap_set_local_name_cfm);
          + ivtmgr_rdm_auto_connection_start(true);
            + k_delayed_work_submit(&p_rdm->auto_conn_work,
              BTMGR_AUTOCONN_INTERVAL);
            + _auto_connection_work_handler
              + btmgr_a2dp_connect(false, p_rdm->auto_conn.addr);
              + btmgr_avrcp_connect(p_rdm->auto_conn.addr);
              +

  + gap_indicate_cb
      +switch (ind_type) {
    + case GAP_IND_INQUIRY_COMPLETE:
    + case GAP_IND_INQUIRY_RESULT:
    + case GAP_IND_CONNECTION_REQUEST:
    + case GAP_IND_CONNECTION_EVENT:
    + rmt_dev_connection_handle(param);
      + struct GAP_ConnectionEventStru *in = param;
      + ivtmgr_rdm_connected(in->addr.bd);
        + dev = _find_connected_dev(addr);
        + dev = NEW(sizeof(struct rdm_device));
        + memcpy(dev->bt_addr, addr, IVTMGR_BD_ADDR_LEN);
        + sys_slist_append(&p_rdm->dev_list, &dev->node);
    + case GAP_IND_PIN_CODE_REQ:
    + return rmt_dev_pincode_reply(param);
      + strcpy(reply.pin_code, CONFIG_BTMGR_DEV_FIX_PINCODE);
      + GAP_ExecuteCommandA((HANDLE)&g_tl_hdl, NULL,
    + case GAP_IND_LINK_KEY_NOTIFICATION:
    + rmt_dev_link_key_created(param);
      + ivtmgr_rdm_paired(in->remote_bd, in->link_key, in->key_type)
      + dev = _find_connected_dev(addr);
      + entry = _find_paired_entry_by_addr(addr);
      + memcpy(entry->remote_addr, addr, IVTMGR_BD_ADDR_LEN);
      + memcpy(entry->link_key, link_key, IVTMGR_LINKKEY_SIZE);
      + _paired_info_save();
        + nvram_config_set(BTMGR_PAIRED_INFO_NVRAM_NAME,
          (const void *)p_rdm->paired_list,
    + case GAP_IND_LINK_KEY_REQUEST:
    + return rmt_dev_link_key_reply(param);
      + struct HCI_Security_Link_Key_Request_ReplyStru cmd;
      + ivtmgr_rdm_get_link_key(in->remote_bd, cmd.link_key,
        &cmd.key_type)
      + GAP_LinkKeyReply((HANDLE)&g_tl_hdl, &cmd);
    + case GAP_IND_AUTHENTICATION_FAILURE:
    + case GAP_IND_REMOTE_DEVICE_NAME_UPDATED:
    + case GAP_IND_USER_CONFIRMATION_REQUEST:
    + case GAP_IND_USER_PASSKEY_REQUEST:
    + case GAP_IND_SIMPLE_PAIRING_COMPLETE:
    + case GAP_IND_USER_PASSKEY_NOTIFICATION:
    + case GAP_IND_AUTHORIZATION_REQUEST:
    + case GAP_IND_AUTHORIZATION_ABORT:


  + hci_host_buf_req_cb
    + mem_malloc(len);

  + hci_host_buf_commit_cb
    + g_rx_cb(buf, len, qType);
    + ivtmgr_drv_rx_cb
    + k_thread_spawn(btstack_schedule_loop_stack, (void *)ScheduleLoop,
    + GAP_RegisterIndCbk(NULL, GAP_IND_ALL, gap_indicate_cb);
    + GAP_RegisterTransportLayerA((HANDLE)&g_tl_hdl,
      (TransportLayerStru *)&g_uart_tl_func,
      gap_register_tl_cfm);


  + schedule_loop_thread
    + con_schedule_high_loop(255);

  + schedule_loop_low_thread
    + con_schedule_low_loop(255);

  + btmgr_ready_cb
    + btmgr_a2dp_start(&a2dp_cbs);
      + p_a2dp = NEW(sizeof(struct ivtmgr_a2dp_priv));
      + in = NEW(sizeof(struct A2DP_RegCbkStru));
      + in->media_type = A2DP_MEDIATYPE_AUDIO;
      + in->cbk = a2dp_indicate_cb;
      + A2DP_RegCbk(in);
      + p_a2dp->snk_svc_hdl = A2DP_RegisterService(A2DP_TSEP_SNK,
        A2DP_SPEAKER);
      + a2dp_snk_sep_register();
    + btmgr_avrcp_start(NULL)
    + btmgr_br_set_discoverable(true);
    + btmgr_br_set_connnectable(true);

  + a2dp_indicate_cb
  +

*** zephyr bt
**** bluetooth
***** doc
****** SSP
http://www.ellisys.com/technology/een_bt07.pdf
****** gatt
Bluetooth Low Energy 介绍 低功耗蓝牙介绍
http://www.cnblogs.com/cb168/articles/4844010.html
****** avdtp
http://blog.sina.com.cn/s/blog_69b5d2a50101elze.html
****** 蓝牙电话本
http://www.eefocus.com/majianhui/blog/09-12/182431_fe385.html
http://www.eefocus.com/majianhui/blog/cate_4037_0.html
****** bluedroid
http://source.android.com/devices/bluetooth.html
http://www.cnblogs.com/hzl6255/p/3887547.html
使用btproxy对蓝牙设备进行安全分析
http://www.freebuf.com/articles/wireless/77389.html
****** spec
http://oscar.iitb.ac.in/onsiteDocumentsDirectory/Bluetooth/Bluetooth/index.html
******* 蓝牙协议的命令和事件
http://blog.csdn.net/zhaohc_nj/article/details/7990695
http://blog.chinaunix.net/uid-21411227-id-2780269.html
http://blog.chinaunix.net/uid-21411227-id-2779815.html
******* baseband
http://www.cnblogs.com/hzl6255/p/3840641.html
The link control layer carries out higher-level operations such as inquiry and paging and manages multiple links with different devices and even different piconets. It does this through a set of state machines, which drive the baseband through the following stages to establish links:
1.      Host requests inquiry.
2.      Inquiry is sent using the inquiry hopping sequence.
3.      Inquiry scanning devices respond to the inquiry scan with FHS packets that contain all the information needed to connect with them.
4.      The contents of the FHS packets are passed back to the host.
5.      The host requests connection to one of the devices that responded to the inquiry.
6.      Paging is used to initiate a connection with the selected device.
7.      If the selected device is page scanning it responds to the page.
8.      If the page-scanning device accepts the connection it will begin hopping using the Master’s frequency hopping sequence and timing.
******* hci
http://www.cnblogs.com/hzl6255/p/3800257.html

Command分为六种类型(case OGF)
~0x01 链路控制命令(Link Control Commands)
~0x02 链路政策命令(Link Policy Commands)
~0x03 控制和基带命令(Control & Baseband Commands)
~0x04 信息命令(Informational Parameters)
~0x05 状态命令(Status Parameters)
~0x06 测试命令(Testing Commands)
~0x3F 厂商调试命令(Reserved)

******* l2cap
http://www.cnblogs.com/hzl6255/p/3801732.html
The Logical Link Control and Adaptation Protocol (L2CAP) takes data from the higher layers of the Bluetooth stack and from applications and sends it over the lower layers of the stack.  L2CAP passes packets either to the Host Controller Interface (HCI), or in a host-less system, L2CAP passes packets directly to the Link Manager.  The following figure shows the L2CAP’s position in the Bluetooth stack.
a)      Multiplexing between different higher layer protocols, allowing them to share lower layer links
b)      Segmentation and reassembly to allow transfer of larger packets than lower layers support
c)      Group management, providing one-way transmission to a group of other Bluetooth devices
d)     Quality of service management for higher layer protocols.
http://oscar.iitb.ac.in/onsiteDocumentsDirectory/Bluetooth/Bluetooth/Help/Logical%20Link%20Control%20and%20Adaptation%20Protocol_files/image008.gif
******* HFP
http://www.cnblogs.com/hzl6255/p/3819113.html
******* RFCOMM
http://www.cnblogs.com/hzl6255/p/3811013.html
******* sdp
http://www.cnblogs.com/hzl6255/p/3826558.html
******* lmp
http://www.cnblogs.com/hzl6255/p/3857353.html
http://article.yeeyan.org/view/jianermei/51468
http://oscar.iitb.ac.in/onsiteDocumentsDirectory/Bluetooth/Bluetooth/Help/Link%20Management%20Protocol.htm
1) Attaching slaves to piconets, and allocating their active member addresses.
2) Breaking connections to detach Slaves from a piconet.
3) Configuring the link including Master/Slave switches
4) Establishing ACL and SCO links.
5) Putting connections into Low Power modes: Hold, Sniff and Park.
6) Controlling test modes.
******* ble
http://www.cnblogs.com/hzl6255/p/4127138.html
******** ll
http://www.cnblogs.com/hzl6255/p/4127403.html
******** gap
http://www.cnblogs.com/hzl6255/p/4133596.html
GAP有如下四个目的
- Profile Role
- 可发现模式和过程
- 连接模式和过程
- 安全模式和过程
******** att
http://www.cnblogs.com/hzl6255/p/4141505.html
Attribute PDUs有六种类型
- Requests      : Client->Server, 请求回应
- Responses     : Server->Client, 响应请求.
- Commands      : Client->Server, 命令
- Notifications : Server->Client, 服务端通知
- Indications   : Server->Client, 请求确认
- Confirmations : Client->Server, Ind确认
******** gatt
http://www.cnblogs.com/hzl6255/p/4158363.html
GATT中最上层是Profile，Profile由一个或多个服务(Service)组成
服务是由Characteristics组成，或是其他服务的引用(Reference)
Characteristic包含一个值(Value)，可能包含该Value的相关信息

GATT中定义了11项Feature
1.  Server Configuration
2.  Primary Service Discovery
3.  Relationship Discovery
4.  Characteristic Discovery
5.  Characteristic Descriptor Discovery
6.  Reading a Characteristic Value
7.  Writing a Characteristic Value
8.  Notification of a Characteristic Value
9.  Indication of a Characteristic Value
10. Reading a Characteristic Descriptor
11. Writing a Characteristic Descriptor
每个Feature都有对应的过程和子过程，这些过程描述了如何使用ATT来实现各自的功能

***** a2dp
****** bt_a2dp_init
+ bt_avdtp_register(&avdtp_cb);
+ static struct bt_avdtp_event_cb avdtp_cb = {
        .ind = &cb_ind,
        .cfm = &cb_cfm
****** bt_avdtp_l2cap_accept
+ static struct bt_l2cap_chan_ops ops = {
  .connected = bt_avdtp_l2cap_connected,
  .disconnected = bt_avdtp_l2cap_disconnected,
  .recv = bt_avdtp_l2cap_recv,

***** handsfree
****** handsfree_enable();
+ static struct bt_hfp_hf_cb hf_cb = {
  .connected = connected,
  .disconnected = disconnected,
+ err = bt_hfp_hf_register(& hf_cb);
  + bt_hf = cb;
+ hfp_hf_init();
  + static struct bt_rfcomm_server chan = {
    .channel = BT_RFCOMM_CHAN_HFP_HF,
    .accept = bt_hfp_hf_accept,
  + bt_rfcomm_server_register(&chan);
    + (rfcomm_server_lookup_channel(server->channel)) {
    + server->_next = servers;
****** bt_hfp_hf_accept(struct bt_conn *conn, struct bt_rfcomm_dlc **dlc)
        + static struct bt_rfcomm_dlc_ops ops = {
          .connected = hfp_hf_connected,
          .disconnected = hfp_hf_disconnected,
          .recv = hfp_hf_recv,
        + struct bt_hfp_hf *hf = &bt_hfp_hf_pool[i];
          hf->at.buf = hf->hf_buffer;
          hf->at.buf_max_len = HF_MAX_BUF_LEN;
          hf->rfcomm_dlc.ops = &ops;
          hf->rfcomm_dlc.mtu = BLUETOOTH_HFP_MAX_MTU;
          *dlc = &hf->rfcomm_dlc;
******  rfcomm_dlc_connected(dlc);
      + dlc->state = BT_RFCOMM_STATE_CONNECTED;
      + rfcomm_send_msc(dlc, BT_RFCOMM_MSG_CMD_CR);
      + k_thread_spawn(dlc->stack, sizeof(dlc->stack), rfcomm_dlc_tx_thread,
      + dlc->ops->connected(dlc);
      + .connected = hfp_hf_connected,
        + struct bt_hfp_hf *hf = CONTAINER_OF(dlc, struct bt_hfp_hf, rfcomm_dlc);
        + hf_slc_establish(hf);
          + err = hfp_hf_send_cmd(hf, brsf_resp, brsf_finish, "AT+BRSF=%u",
            + at_register(&hf->at, resp, finish);
            + ret = bt_rfcomm_dlc_send(&hf->rfcomm_dlc, buf);
              + net_buf_put(&dlc->tx_queue, buf);
******  hfp_hf_recv
- at_parse_input(&hf->at, buf)
  + parser_cb[at->state](at, buf);
  + static handle_parse_input_t parser_cb[] = {
  + at_state_start, /* AT_STATE_START */
  + at_state_start_cr, /* AT_STATE_START_CR */
  + at_state_start_lf, /* AT_STATE_START_LF */
  + at_state_get_cmd_string, /* AT_STATE_GET_CMD_STRING */
  + at_state_process_cmd, /* AT_STATE_PROCESS_CMD */
  + at_state_get_result_string, /* AT_STATE_GET_RESULT_STRING */
  + at_state_process_result, /* AT_STATE_PROCESS_RESULT */
  + at_state_unsolicited_cmd /* AT_STATE_UNSOLICITED_CMD */

****** rfcomm_recv
  + struct bt_rfcomm_session *session = RFCOMM_SESSION(chan);
  + dlci = BT_RFCOMM_GET_DLCI(hdr->address);
  + frame_type = BT_RFCOMM_GET_FRAME_TYPE(hdr->control);
  + rfcomm_check_fcs(fcs_len, buf->data, fcs)
  + switch (frame_type) {
  + case BT_RFCOMM_SABM:
  + rfcomm_handle_sabm(session, dlci);
    + dlc = rfcomm_dlcs_lookup_dlci(session->dlcs, dlci);
    + dlc = rfcomm_dlc_accept(session, dlci);
      + channel = BT_RFCOMM_GET_CHANNEL(dlci);
      + server = rfcomm_server_lookup_channel(channel);
      + server->accept(session->br_chan.chan.conn, &dlc) < 0) {
      + static int bt_hfp_hf_accept(struct bt_conn *conn, struct bt_rfcomm_dlc **dlc)
        + static struct bt_rfcomm_dlc_ops ops = {
          .connected = hfp_hf_connected,
          .disconnected = hfp_hf_disconnected,
          .recv = hfp_hf_recv,
        + struct bt_hfp_hf *hf = &bt_hfp_hf_pool[i];
          hf->at.buf = hf->hf_buffer;
          hf->at.buf_max_len = HF_MAX_BUF_LEN;
          hf->rfcomm_dlc.ops = &ops;
          hf->rfcomm_dlc.mtu = BLUETOOTH_HFP_MAX_MTU;
          *dlc = &hf->rfcomm_dlc;
      + rfcomm_dlc_init(dlc, session, dlci, BT_RFCOMM_ROLE_ACCEPTOR);
        + dlc->dlci = dlci;
          dlc->session = session;
          dlc->rx_credit = RFCOMM_DEFAULT_CREDIT;
          dlc->state = BT_RFCOMM_STATE_INIT;
          dlc->role = role;
    + result = rfcomm_dlc_security(dlc);
    + rfcomm_send_ua(session, dlci) < 0) {
      + buf = bt_l2cap_create_pdu(&rfcomm_session_pool, K_FOREVER);
      + cr = BT_RFCOMM_RESP_CR(session->role);
        hdr->address = BT_RFCOMM_SET_ADDR(dlci, cr);
        hdr->control = BT_RFCOMM_SET_CTRL(BT_RFCOMM_UA,
        hdr->length = BT_RFCOMM_SET_LEN_8(0);
    + rfcomm_dlc_connected(dlc);
      + dlc->state = BT_RFCOMM_STATE_CONNECTED;
      + rfcomm_send_msc(dlc, BT_RFCOMM_MSG_CMD_CR);
      + k_thread_spawn(dlc->stack, sizeof(dlc->stack), rfcomm_dlc_tx_thread,
      + dlc->ops->connected(dlc);
      + .connected = hfp_hf_connected,
        + struct bt_hfp_hf *hf = CONTAINER_OF(dlc, struct bt_hfp_hf, rfcomm_dlc);
        + hf_slc_establish(hf);
          + err = hfp_hf_send_cmd(hf, brsf_resp, brsf_finish, "AT+BRSF=%u",
            + at_register(&hf->at, resp, finish);
            + ret = bt_rfcomm_dlc_send(&hf->rfcomm_dlc, buf);
              + net_buf_put(&dlc->tx_queue, buf);
  + case BT_RFCOMM_UIH:
    + rfcomm_handle_msg(session, buf);
    + rfcomm_handle_data(session, buf, dlci,
      + dlc = rfcomm_dlcs_lookup_dlci(session->dlcs, dlci);
      + dlc->ops->recv(dlc, buf);
      + static void hfp_hf_recv(struct bt_rfcomm_dlc *dlc, struct net_buf *buf)
  + case BT_RFCOMM_DISC:
    + rfcomm_handle_disc(session, dlci);
  + case BT_RFCOMM_UA:
    + rfcomm_handle_ua(session, dlci);
  + case BT_RFCOMM_DM:
    + rfcomm_handle_dm(session, dlci);
****** rfcomm_accept
+ session = rfcomm_session_new(BT_RFCOMM_ROLE_ACCEPTOR);
  + static struct bt_l2cap_chan_ops ops = {
    .connected = rfcomm_connected,
    .disconnected = rfcomm_disconnected,
    .recv = rfcomm_recv,
    .encrypt_change = rfcomm_encrypt_change,
  + struct bt_rfcomm_session *session = &bt_rfcomm_pool[i];
  + session->br_chan.chan.ops = &ops;
    session->br_chan.rx.mtu	= CONFIG_BLUETOOTH_RFCOMM_L2CAP_MTU;
    session->state = BT_RFCOMM_STATE_INIT;
    session->role = role;

****** bt_l2cap_br_connected
+ if (fchan->accept(conn, &chan) < 0) {
+ rfcomm_accept
  + session = rfcomm_session_new(BT_RFCOMM_ROLE_ACCEPTOR);
    + static struct bt_l2cap_chan_ops ops = {
      .connected = rfcomm_connected,
      .disconnected = rfcomm_disconnected,
      .recv = rfcomm_recv,
      .encrypt_change = rfcomm_encrypt_change,
    + struct bt_rfcomm_session *session = &bt_rfcomm_pool[i];
    + session->br_chan.chan.ops = &ops;
      session->br_chan.rx.mtu	= CONFIG_BLUETOOTH_RFCOMM_L2CAP_MTU;
      session->state = BT_RFCOMM_STATE_INIT;
      session->role = role;
  + l2cap_br_chan_add(conn, chan, NULL)
    + struct bt_l2cap_br_chan *ch = l2cap_br_chan_alloc_cid(conn, chan);
    + bt_l2cap_chan_add(conn, chan, destroy);
  + connect_fixed_channel(ch);
    + chan->chan.ops->connected(&chan->chan);
    + rfcomm_connected
      + rfcomm_send_sabm(session, 0);
******  bt_l2cap_br_recv(struct bt_conn *conn, struct net_buf *buf)
+ cid = sys_le16_to_cpu(hdr->cid);
+ chan = bt_l2cap_br_lookup_rx_cid(conn, cid);
+ check_fixed_channel(chan);
+ chan->ops->recv(chan, buf);
+ rfcomm_recv,
  + struct bt_rfcomm_session *session = RFCOMM_SESSION(chan);
  + dlci = BT_RFCOMM_GET_DLCI(hdr->address);
  + frame_type = BT_RFCOMM_GET_FRAME_TYPE(hdr->control);
  + rfcomm_check_fcs(fcs_len, buf->data, fcs)
  + switch (frame_type) {
  + case BT_RFCOMM_SABM:
  + rfcomm_handle_sabm(session, dlci);
    + dlc = rfcomm_dlcs_lookup_dlci(session->dlcs, dlci);
    + dlc = rfcomm_dlc_accept(session, dlci);
      + channel = BT_RFCOMM_GET_CHANNEL(dlci);
      + server = rfcomm_server_lookup_channel(channel);
      + server->accept(session->br_chan.chan.conn, &dlc) < 0) {
      + static int bt_hfp_hf_accept(struct bt_conn *conn, struct bt_rfcomm_dlc **dlc)
        + static struct bt_rfcomm_dlc_ops ops = {
          .connected = hfp_hf_connected,
          .disconnected = hfp_hf_disconnected,
          .recv = hfp_hf_recv,
        + struct bt_hfp_hf *hf = &bt_hfp_hf_pool[i];
          hf->at.buf = hf->hf_buffer;
          hf->at.buf_max_len = HF_MAX_BUF_LEN;
          hf->rfcomm_dlc.ops = &ops;
          hf->rfcomm_dlc.mtu = BLUETOOTH_HFP_MAX_MTU;
          *dlc = &hf->rfcomm_dlc;
      + rfcomm_dlc_init(dlc, session, dlci, BT_RFCOMM_ROLE_ACCEPTOR);
        + dlc->dlci = dlci;
          dlc->session = session;
          dlc->rx_credit = RFCOMM_DEFAULT_CREDIT;
          dlc->state = BT_RFCOMM_STATE_INIT;
          dlc->role = role;
    + result = rfcomm_dlc_security(dlc);
    + rfcomm_send_ua(session, dlci) < 0) {
      + buf = bt_l2cap_create_pdu(&rfcomm_session_pool, K_FOREVER);
      + cr = BT_RFCOMM_RESP_CR(session->role);
        hdr->address = BT_RFCOMM_SET_ADDR(dlci, cr);
        hdr->control = BT_RFCOMM_SET_CTRL(BT_RFCOMM_UA,
        hdr->length = BT_RFCOMM_SET_LEN_8(0);
    + rfcomm_dlc_connected(dlc);
      + dlc->state = BT_RFCOMM_STATE_CONNECTED;
      + rfcomm_send_msc(dlc, BT_RFCOMM_MSG_CMD_CR);
      + k_thread_spawn(dlc->stack, sizeof(dlc->stack), rfcomm_dlc_tx_thread,
      + dlc->ops->connected(dlc);
      + .connected = hfp_hf_connected,
        + struct bt_hfp_hf *hf = CONTAINER_OF(dlc, struct bt_hfp_hf, rfcomm_dlc);
        + hf_slc_establish(hf);
          + err = hfp_hf_send_cmd(hf, brsf_resp, brsf_finish, "AT+BRSF=%u",
            + at_register(&hf->at, resp, finish);
            + ret = bt_rfcomm_dlc_send(&hf->rfcomm_dlc, buf);
              + net_buf_put(&dlc->tx_queue, buf);
  + case BT_RFCOMM_UIH:
    + rfcomm_handle_msg(session, buf);
    + rfcomm_handle_data(session, buf, dlci,
  + case BT_RFCOMM_DISC:
    + rfcomm_handle_disc(session, dlci);
  + case BT_RFCOMM_UA:
    + rfcomm_handle_ua(session, dlci);
  + case BT_RFCOMM_DM:
    + rfcomm_handle_dm(session, dlci);

****** bt_rfcomm_init
+ static struct bt_l2cap_server server = {
               .psm       = BT_L2CAP_PSM_RFCOMM,
               .accept    = rfcomm_accept,
               .sec_level = BT_SECURITY_LOW,
+ bt_l2cap_br_server_register(&server);

***** gap/gatt
****** doc
Bluetooth Low Energy 介绍 低功耗蓝牙介绍
http://www.cnblogs.com/cb168/articles/4844010.html

|ANP| Alert Notification Profile|
| ANS| Alert Notification Service|
| BAS| Battery Service|
| BLP| Blood Pressure Profile|
| BLS| Blood Pressure Service|
| CPP| Cycling Power Profile|
| CPS| Cycling Power Service|
| CSCP| Cycling Speed and Cadence Profile|
| CSCS| Cycling Speed and Cadence Service|
| CTS| Current Time Service|
| DIS| Device Information Service|
| FMP| Find Me Profile|
| GLP| Glucose Profile|
|HIDS| HID Service|
| HOGP| HID over GATT Profile|
| HTP| Health Thermometer Profile|
| HTS| Health Thermometer Service|
| HRP| Heart Rate Profile|
| HRS| Heart Rate Service|
| IAS| Immediate Alert Service|
| LLS| Link Loss Service|
| LNP| Location and Navigation Profile|
| LNS| Location and Navigation Service|
| NDCS| Next DST Change Service|
| PASP| Phone Alert Status Profile|
| PASS| Phone Alert Status Service|
| PXP| Proximity Profile|
| RSCP| Running Speed and Cadence Profile|
| RSCS| Running Speed and Cadence Service|
|RTUS| Reference Time Update Service|
| ScPP| Scan Parameters Profile|
| ScPS| Scan Parameters Service|
| TIP| Time Profile|
| TPS| Tx Power Service |
****** peripheral_hids/main
+ gap_init(DEVICE_NAME, HOG_APPEARANCE);
  + gap_name = name;
  + gap_appearance = appearance;
  + bt_gatt_register(attrs, ARRAY_SIZE(attrs));
    + int bt_gatt_register(struct bt_gatt_attr *attrs, size_t count)
    + static struct bt_gatt_attr *db;
    + db = attrs;
    + attrs->handle = ++handle;
+ bas_init();
  + bt_gatt_register(attrs, ARRAY_SIZE(attrs));
+ dis_init(CONFIG_SOC, "Manufacturer");
  + bt_gatt_register(attrs, ARRAY_SIZE(attrs));
+ hog_init();
****** bt_att_accept
+       static struct bt_l2cap_chan_ops ops = {
   .connected = bt_att_connected,
   .disconnected = bt_att_disconnected,
   .recv = bt_att_recv,
+ for (i = 0; i < ARRAY_SIZE(bt_req_pool); i++) {
+ att->chan.chan.ops = &ops;
+ *chan = &att->chan.chan;
****** bt_att_connected
+ bt_gatt_connected(ch->chan.conn);
  + bt_gatt_foreach_attr(0x0001, 0xffff, connected_cb, conn);
    + for (attr = db; attr; attr = bt_gatt_attr_next(attr)) {
    + if (func(attr, user_data) == BT_GATT_ITER_STOP) {
      + static uint8_t connected_cb(const struct bt_gatt_attr *attr, void *user_data)
****** bt_att_recv
+ for (i = 0; i < ARRAY_SIZE(handlers); i++) {
+ err = handlers[i].func(att, buf);
******* handlers
static const struct {
        uint8_t  op;
        uint8_t  (*func)(struct bt_att *att, struct net_buf *buf);
        uint8_t  expect_len;
} handlers[] = {
+ { BT_ATT_OP_ERROR_RSP, att_error_rsp,
+ { BT_ATT_OP_MTU_REQ, att_mtu_req,
+ { BT_ATT_OP_MTU_RSP, att_mtu_rsp,
+ { BT_ATT_OP_FIND_INFO_REQ, att_find_info_req,
+ { BT_ATT_OP_FIND_INFO_RSP, att_handle_find_info_rsp,
+ { BT_ATT_OP_FIND_TYPE_REQ, att_find_type_req,
+ { BT_ATT_OP_FIND_TYPE_RSP, att_handle_find_type_rsp,
+ { BT_ATT_OP_READ_TYPE_REQ, att_read_type_req,
+ { BT_ATT_OP_READ_TYPE_RSP, att_handle_read_type_rsp,
******* { BT_ATT_OP_READ_REQ, att_read_req,
  + handle = sys_le16_to_cpu(req->handle);
  + att_read_rsp(att, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
  + struct read_data data;
  + data.buf = bt_att_create_pdu(conn, rsp, 0);
  + data.att = att;
    data.offset = offset;
  + bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    + static uint8_t read_cb(const struct bt_gatt_attr *attr, void *user_data)
    + data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
    + data->err = check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
    + read = attr->read(conn, attr, data->buf->data + data->buf->len,
    + net_buf_add(data->buf, read);
  + bt_l2cap_send(conn, BT_L2CAP_CID_ATT, data.buf);
+ { BT_ATT_OP_READ_RSP, att_handle_read_rsp,
+ { BT_ATT_OP_READ_BLOB_REQ, att_read_blob_req,
+ { BT_ATT_OP_READ_BLOB_RSP, att_handle_read_blob_rsp,
+ { BT_ATT_OP_READ_MULT_REQ, att_read_mult_req,
+ { BT_ATT_OP_READ_MULT_RSP, att_handle_read_mult_rsp,
+ { BT_ATT_OP_READ_GROUP_REQ, att_read_group_req,
+ { BT_ATT_OP_WRITE_REQ, att_write_req,
+ { BT_ATT_OP_WRITE_RSP, att_handle_write_rsp, 0 },
+ { BT_ATT_OP_PREPARE_WRITE_REQ, att_prepare_write_req,
+ { BT_ATT_OP_PREPARE_WRITE_RSP, att_handle_prepare_write_rsp,
+ { BT_ATT_OP_EXEC_WRITE_REQ, att_exec_write_req,
+ { BT_ATT_OP_EXEC_WRITE_RSP, att_handle_exec_write_rsp, 0 },
+ { BT_ATT_OP_NOTIFY, att_notify,
+ { BT_ATT_OP_INDICATE, att_indicate,
+ { BT_ATT_OP_CONFIRM, att_confirm, 0 },
+ { BT_ATT_OP_WRITE_CMD, att_write_cmd,
+ { BT_ATT_OP_SIGNED_WRITE_CMD, att_signed_write_cmd,
***** beacon
+ main
  + bt_enable(bt_ready);
  +

***** hci_core
****** doc
蓝牙核心技术概述（四）：蓝牙协议规范（HCI、L2CAP、SDP、RFOCMM）
http://blog.csdn.net/xubin341719/article/details/38305331
****** bt_enable
+ struct bt_dev bt_dev = {
        .ncmd_sem      = K_SEM_INITIALIZER(bt_dev.ncmd_sem, 1, 1),
        .cmd_tx_queue  = K_FIFO_INITIALIZER(bt_dev.cmd_tx_queue),
        .rx_queue      = K_FIFO_INITIALIZER(bt_dev.rx_queue),

+ bt_enable(bt_ready);
  + k_thread_spawn(cmd_tx_thread_stack, sizeof(cmd_tx_thread_stack),
                     (k_thread_entry_t)hci_cmd_tx_thread, NULL, NULL, NULL,
  + k_thread_spawn(rx_thread_stack, sizeof(rx_thread_stack),
                    (k_thread_entry_t)hci_rx_thread, cb, NULL, NULL,

****** bt_hci_cmd_send_sync
int bt_hci_cmd_send_sync(uint16_t opcode, struct net_buf *buf,
+ buf = bt_hci_cmd_create(opcode, 0);
  + buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
  + cmd(buf)->type = BT_BUF_CMD;
        cmd(buf)->opcode = opcode;
        cmd(buf)->sync = NULL;
        hdr = net_buf_add(buf, sizeof(*hdr));
        hdr->opcode = sys_cpu_to_le16(opcode);
        hdr->param_len = param_len;
+ k_sem_init(&sync_sem, 0, 1);
        cmd(buf)->sync = &sync_sem;
+ net_buf_put(&bt_dev.cmd_tx_queue, buf);
+ k_sem_take(&sync_sem, K_FOREVER);
****** bt_conn_init();
    + bt_att_init();
      + static struct bt_l2cap_fixed_chan chan = {
         .cid		= BT_L2CAP_CID_ATT,
         .accept		= bt_att_accept,
      + bt_l2cap_le_fixed_chan_register(&chan);
        + chan->_next = le_channels;
        + channels = chan;
    + bt_smp_init();
      + static struct bt_l2cap_fixed_chan chan = {
            .cid		= BT_L2CAP_CID_SMP,
            .accept		= bt_smp_accept,
      + bt_l2cap_le_fixed_chan_register(&chan);
      + static struct bt_l2cap_fixed_chan br_chan = {
                    .cid		= BT_L2CAP_CID_BR_SMP,
                    .accept		= bt_smp_br_accept,
      + bt_l2cap_br_fixed_chan_register(&br_chan);
      + static struct bt_pub_key_cb pub_key_cb = {
            .func           = bt_smp_pkey_ready,
      + bt_pub_key_gen(&pub_key_cb);
        + new_cb->_next = pub_key_cb;
        + pub_key_cb = new_cb;
        + bt_hci_cmd_send_sync(BT_HCI_OP_LE_P256_PUBLIC_KEY, NULL, NULL);
        + cb->func(NULL);
    + bt_l2cap_init();
      + static struct bt_l2cap_fixed_chan chan = {
            .cid	= BT_L2CAP_CID_LE_SIG,
            .accept	= l2cap_accept,
      + bt_l2cap_le_fixed_chan_register(&chan);
      + bt_l2cap_br_init();
        + static struct bt_l2cap_fixed_chan chan_br = {
                    .cid	= BT_L2CAP_CID_BR_SIG,
                    .accept = l2cap_br_accept,
        + bt_l2cap_br_fixed_chan_register(&chan_br);
        + bt_rfcomm_init();
          + static struct bt_l2cap_server server = {
           .psm       = BT_L2CAP_PSM_RFCOMM,
           .accept    = rfcomm_accept,
           .sec_level = BT_SECURITY_LOW,
          + bt_l2cap_br_server_register(&server);
            + l2cap_br_server_lookup_psm(server->psm)
            + server->_next = br_servers;
            + br_servers = server;
        + bt_avdtp_init();
          + static struct bt_l2cap_server avdtp_l2cap = {
             .psm = BT_L2CAP_PSM_AVDTP,
             .sec_level = BT_SECURITY_MEDIUM,
             .accept = bt_avdtp_l2cap_accept,
          + bt_l2cap_br_server_register(&avdtp_l2cap);
        + bt_sdp_init();
          + static struct bt_l2cap_server server = {
              .psm = SDP_PSM,
              .accept = bt_sdp_accept,
          + bt_l2cap_br_server_register(&server);
        + bt_a2dp_init();
          + bt_avdtp_register(& avdtp_cb);
            + event_cb = cb;
    + background_scan_init();
****** hci_rx_thread
  + static void hci_rx_thread(bt_ready_cb_t ready_cb)
    + ready_cb(bt_init());//用户回调
      + static int bt_init(void)
        + bt_hci_ecc_init();
        + err = drv->open();
          + static int h4_open(void)
        + err = hci_init();
          + common_init();
            + bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
            + hci_reset_complete(rsp);
              + atomic_set(bt_dev.flags, BIT(BT_DEV_ENABLE));
            + prng_init(&prng);
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
            + read_local_features_complete(rsp);
              + struct bt_hci_rp_read_local_features *rp = (void *)buf->data;
              + memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
            + read_local_ver_complete(rsp);
              + bt_dev.hci_version = rp->hci_version;
              + bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
              + bt_dev.lmp_version = rp->lmp_version;
              + bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
              + bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
            + read_bdaddr_complete(rsp);
              + bt_addr_copy(&bt_dev.id_addr.a, &rp->bdaddr);
              + bt_dev.id_addr.type = BT_ADDR_LE_PUBLIC;
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
            + set_flow_control();
              + bt_hci_cmd_create(BT_HCI_OP_HOST_BUFFER_SIZE,
              + struct bt_hci_cp_host_buffer_size *hbs;
              + hbs->acl_amtu = sys_cpu_to_le16(CONFIG_BLUETOOTH_L2CAP_IN_MTU +
              + hbs->acl_pkts = sys_cpu_to_le16(CONFIG_BLUETOOTH_ACL_IN_COUNT);
              + err = bt_hci_cmd_send_sync(BT_HCI_OP_HOST_BUFFER_SIZE, buf, NULL);
              + buf = bt_hci_cmd_create(BT_HCI_OP_SET_CTL_TO_HOST_FLOW, 1);
          + le_init();
            + bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
            + read_le_features_complete(rsp);
              + struct bt_hci_rp_le_read_local_features *rp = (void *)buf->data;
              + memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
            + bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE, NULL, &rsp);
            + le_read_buffer_size_complete(rsp);
              + bt_dev.le.mtu = sys_le16_to_cpu(rp->le_max_len);
              + k_sem_init(&bt_dev.le.pkts, rp->le_max_num, rp->le_max_num);
            + if (BT_FEAT_BREDR(bt_dev.features)) {
              + bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
            + bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
            + bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
              + struct bt_hci_cp_le_set_event_mask *cp_mask;
            + bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
          + br_init();
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &buf);
            + read_buffer_size_complete(buf);
              + bt_dev.br.mtu = sys_le16_to_cpu(rp->acl_max_len);
              + k_sem_init(&bt_dev.br.pkts, pkts, pkts);
            + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_SSP_MODE, buf, NULL);
            + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_INQUIRY_MODE, buf, NULL);
            + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_LOCAL_NAME, buf, NULL);
            + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_PAGE_TIMEOUT, buf, NULL);
            + if (BT_FEAT_SC(bt_dev.features)) {
              + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_SC_HOST_SUPP, buf,
          + set_static_addr();
            + bt_storage->read(NULL, BT_STORAGE_ID_ADDR,
            + bt_addr_le_create_static(&bt_dev.id_addr);
              + create_random_addr(addr);
              + BT_ADDR_SET_STATIC(&addr->a);
            + set_random_address(&bt_dev.id_addr.a);
              + bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
          + show_dev_info();
        + err = bt_conn_init();
          + bt_att_init();
            + static struct bt_l2cap_fixed_chan chan = {
               .cid		= BT_L2CAP_CID_ATT,
               .accept		= bt_att_accept,
            + bt_l2cap_le_fixed_chan_register(&chan);
              + chan->_next = le_channels;
              + channels = chan;
          + bt_smp_init();
            + static struct bt_l2cap_fixed_chan chan = {
                  .cid		= BT_L2CAP_CID_SMP,
                  .accept		= bt_smp_accept,
            + bt_l2cap_le_fixed_chan_register(&chan);
            + static struct bt_l2cap_fixed_chan br_chan = {
                          .cid		= BT_L2CAP_CID_BR_SMP,
                          .accept		= bt_smp_br_accept,
            + bt_l2cap_br_fixed_chan_register(&br_chan);
            + static struct bt_pub_key_cb pub_key_cb = {
                  .func           = bt_smp_pkey_ready,
            + bt_pub_key_gen(&pub_key_cb);
              + new_cb->_next = pub_key_cb;
              + pub_key_cb = new_cb;
              + bt_hci_cmd_send_sync(BT_HCI_OP_LE_P256_PUBLIC_KEY, NULL, NULL);
              + cb->func(NULL);
          + bt_l2cap_init();
            + static struct bt_l2cap_fixed_chan chan = {
                  .cid	= BT_L2CAP_CID_LE_SIG,
                  .accept	= l2cap_accept,
            + bt_l2cap_le_fixed_chan_register(&chan);
            + bt_l2cap_br_init();
              + static struct bt_l2cap_fixed_chan chan_br = {
                          .cid	= BT_L2CAP_CID_BR_SIG,
                          .accept = l2cap_br_accept,
              + bt_l2cap_br_fixed_chan_register(&chan_br);
              + bt_rfcomm_init();
                + static struct bt_l2cap_server server = {
                 .psm       = BT_L2CAP_PSM_RFCOMM,
                 .accept    = rfcomm_accept,
                 .sec_level = BT_SECURITY_LOW,
                + bt_l2cap_br_server_register(&server);
                  + l2cap_br_server_lookup_psm(server->psm)
                  + server->_next = br_servers;
                  + br_servers = server;
              + bt_avdtp_init();
                + static struct bt_l2cap_server avdtp_l2cap = {
                   .psm = BT_L2CAP_PSM_AVDTP,
                   .sec_level = BT_SECURITY_MEDIUM,
                   .accept = bt_avdtp_l2cap_accept,
                + bt_l2cap_br_server_register(&avdtp_l2cap);
              + bt_sdp_init();
                + static struct bt_l2cap_server server = {
                    .psm = SDP_PSM,
                    .accept = bt_sdp_accept,
                + bt_l2cap_br_server_register(&server);
              + bt_a2dp_init();
                + bt_avdtp_register(& avdtp_cb);
                  + event_cb = cb;
          + background_scan_init();
        + bt_monitor_send(BT_MONITOR_OPEN_INDEX, NULL, 0);
          + bt_le_scan_update(false);
    + while (1) {
      + buf = net_buf_get(&bt_dev.rx_queue, K_FOREVER);
      + case BT_BUF_ACL_IN:
        + hci_acl(buf);
          + handle = sys_le16_to_cpu(hdr->handle);
          + conn = bt_conn_lookup_handle(acl(buf)->handle);
            + for (i = 0; i < ARRAY_SIZE(conns); i++) {
              + return bt_conn_ref(&conns[i]);
          + bt_conn_recv(conn, buf, flags);
            + memcpy(net_buf_add(conn->rx, buf->len), buf->data, buf->len);
                conn->rx_len -= buf->len;
            + bt_l2cap_recv(conn, buf);
              + if (conn->type == BT_CONN_TYPE_BR) {
                bt_l2cap_br_recv(conn, buf);
              + cid = sys_le16_to_cpu(hdr->cid);
              + chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
              + l2cap_chan_recv(chan, buf);
                + if (L2CAP_LE_CID_IS_DYN(ch->rx.cid)) {
                  + l2cap_chan_le_recv(ch, buf);
                + chan->ops->recv(chan, buf);
      + case BT_BUF_EVT:
        + hci_event(buf);
****** l2cap_chan_le_recv
+ chan->_sdu = chan->chan.ops->alloc_buf(&chan->chan);
+ bt_l2cap_chan_disconnect(&chan->chan);
+ chan->chan.ops->recv(&chan->chan, chan->_sdu);
****** hci_acl
 + hci_acl(buf);
   + handle = sys_le16_to_cpu(hdr->handle);
     + conn = bt_conn_lookup_handle(acl(buf)->handle);
       + for (i = 0; i < ARRAY_SIZE(conns); i++) {
         + return bt_conn_ref(&conns[i]);
     + bt_conn_recv(conn, buf, flags);
       + memcpy(net_buf_add(conn->rx, buf->len), buf->data, buf->len);
           conn->rx_len -= buf->len;
       + bt_l2cap_recv(conn, buf);
         + if (conn->type == BT_CONN_TYPE_BR) {
         + bt_l2cap_br_recv(conn, buf);
           + check_fixed_channel(chan);
             + if (br_chan->rx.cid < L2CAP_BR_CID_DYN_START) {
             + connect_fixed_channel(br_chan);
               + chan->chan.ops->connected(&chan->chan);
           + chan->ops->recv(chan, buf);
         + cid = sys_le16_to_cpu(hdr->cid);
         + chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
         + l2cap_chan_recv(chan, buf);
           + if (L2CAP_LE_CID_IS_DYN(ch->rx.cid)) {
             + l2cap_chan_le_recv(ch, buf);
           + chan->ops->recv(chan, buf);
             + .recv = l2cap_recv,
****** le_conn_req
  + le_conn_req(l2cap, hdr->ident, buf);
    + psm = sys_le16_to_cpu(req->psm);
      scid = sys_le16_to_cpu(req->scid);
      mtu = sys_le16_to_cpu(req->mtu);
      mps = sys_le16_to_cpu(req->mps);
      credits = sys_le16_to_cpu(req->credits);
    + server = l2cap_server_lookup_psm(psm);
    + if (conn->sec_level < server->sec_level) {
    + if (server->accept(conn, &chan) < 0) { //server
    + l2cap_chan_add(conn, chan, l2cap_chan_destroy)
      + struct bt_l2cap_le_chan *ch = l2cap_chan_alloc_cid(conn, chan);
      + bt_l2cap_chan_add(conn, chan, destroy);
    + l2cap_chan_tx_init(ch);
        ch->tx.cid = scid;
        ch->tx.mps = mps;
        ch->tx.mtu = mtu;
        l2cap_chan_tx_give_credits(ch, credits);
        l2cap_chan_rx_init(ch);
        l2cap_chan_rx_give_credits(ch, L2CAP_LE_MAX_CREDITS);
        chan->psm = server->psm;
    + bt_l2cap_chan_set_state(chan, BT_L2CAP_CONNECTED);
      + chan->state = state;
    + if (chan->ops && chan->ops->connected) {
                        chan->ops->connected(chan); //server
    + bt_l2cap_send(conn, BT_L2CAP_CID_LE_SIG, buf);

****** l2cap_recv(struct bt_l2cap_chan *chan, struct net_buf *buf)
+ case BT_L2CAP_CONN_PARAM_RSP:
  + le_conn_param_rsp(l2cap, buf);
+ case BT_L2CAP_CONN_PARAM_REQ:
  + le_conn_param_update_req(l2cap, hdr->ident, buf);
+ case BT_L2CAP_LE_CONN_REQ:
  + le_conn_req(l2cap, hdr->ident, buf);
    + psm = sys_le16_to_cpu(req->psm);
      scid = sys_le16_to_cpu(req->scid);
      mtu = sys_le16_to_cpu(req->mtu);
      mps = sys_le16_to_cpu(req->mps);
      credits = sys_le16_to_cpu(req->credits);
    + server = l2cap_server_lookup_psm(psm);
    + if (conn->sec_level < server->sec_level) {
    + if (server->accept(conn, &chan) < 0) {
    + l2cap_chan_add(conn, chan, l2cap_chan_destroy)
      + struct bt_l2cap_le_chan *ch = l2cap_chan_alloc_cid(conn, chan);
      + bt_l2cap_chan_add(conn, chan, destroy);
    + l2cap_chan_tx_init(ch);
        ch->tx.cid = scid;
        ch->tx.mps = mps;
        ch->tx.mtu = mtu;
        l2cap_chan_tx_give_credits(ch, credits);
        l2cap_chan_rx_init(ch);
        l2cap_chan_rx_give_credits(ch, L2CAP_LE_MAX_CREDITS);
        chan->psm = server->psm;
    + bt_l2cap_chan_set_state(chan, BT_L2CAP_CONNECTED);
      + chan->state = state;
    + if (chan->ops && chan->ops->connected) {
                        chan->ops->connected(chan); //server
    + bt_l2cap_send(conn, BT_L2CAP_CID_LE_SIG, buf);
+ case BT_L2CAP_LE_CONN_RSP:
  + le_conn_rsp(l2cap, hdr->ident, buf);
+ case BT_L2CAP_DISCONN_REQ:
  + le_disconn_req(l2cap, hdr->ident, buf);
+ case BT_L2CAP_DISCONN_RSP:
  + le_disconn_rsp(l2cap, hdr->ident, buf);
+ case BT_L2CAP_LE_CREDITS:
  + le_credits(l2cap, hdr->ident, buf);
+ case BT_L2CAP_CMD_REJECT:
  + reject_cmd(l2cap, hdr->ident, buf);
****** le_conn_complete
     + le_conn_complete(buf);
       + id_addr = find_id_addr(&evt->peer_addr);
       + conn = bt_conn_lookup_state_le(id_addr, BT_CONN_CONNECT);
       + atomic_clear_bit(bt_dev.flags, BT_DEV_ADVERTISING);
       + conn->handle   = handle;
         bt_addr_le_copy(&conn->le.dst, id_addr);
         conn->le.interval = sys_le16_to_cpu(evt->interval);
         conn->le.latency = sys_le16_to_cpu(evt->latency);
         conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
         conn->role = evt->role;
       + if (conn->role == BT_HCI_ROLE_SLAVE) {
         bt_addr_le_copy(&conn->le.init_addr, &evt->peer_addr);
         bt_addr_le_copy(&conn->le.resp_addr, &bt_dev.id_addr);
       + bt_conn_set_state(conn, BT_CONN_CONNECTED);
         + case BT_CONN_CONNECTED:
         + k_fifo_init(&conn->tx_queue);
         + k_thread_spawn(conn->stack, sizeof(conn->stack), conn_tx_thread,
         + bt_l2cap_connected(conn);
           + fchan = le_channels;
           + if (fchan->accept(conn, &chan) < 0) {
             + .accept	= l2cap_accept,// channel
               + static struct bt_l2cap_chan_ops ops = {
                 .connected = l2cap_connected,
                 .disconnected = l2cap_disconnected,
                 .recv = l2cap_recv,
               + l2cap->chan.chan.ops = &ops;
                 *chan = &l2cap->chan.chan;
           + l2cap_chan_add(conn, chan, NULL)
             + struct bt_l2cap_le_chan *ch = l2cap_chan_alloc_cid(conn, chan);
             + bt_l2cap_chan_add(conn, chan, destroy);
           + chan->ops->connected(chan);
             + l2cap_connected(struct bt_l2cap_chan *chan)
         + notify_connected(conn);
           + for (cb = callback_list; cb; cb = cb->_next) {
             + cb->connected(conn, conn->err);
****** hci_event
        + br/edr
          + case BT_HCI_EVT_CONN_REQUEST:
                  conn_req(buf);
          + case BT_HCI_EVT_CONN_COMPLETE:
                  conn_complete(buf);
          + case BT_HCI_EVT_PIN_CODE_REQ:
                  pin_code_req(buf);
          + case BT_HCI_EVT_LINK_KEY_NOTIFY:
                  link_key_notify(buf);
          + case BT_HCI_EVT_LINK_KEY_REQ:
                  link_key_req(buf);
          + case BT_HCI_EVT_IO_CAPA_RESP:
                  io_capa_resp(buf);
          + case BT_HCI_EVT_IO_CAPA_REQ:
                  io_capa_req(buf);
          + case BT_HCI_EVT_SSP_COMPLETE:
                  ssp_complete(buf);
          + case BT_HCI_EVT_USER_CONFIRM_REQ:
                  user_confirm_req(buf);
          + case BT_HCI_EVT_USER_PASSKEY_NOTIFY:
                  user_passkey_notify(buf);
          + case BT_HCI_EVT_USER_PASSKEY_REQ:
                  user_passkey_req(buf);
          + case BT_HCI_EVT_INQUIRY_COMPLETE:
                  inquiry_complete(buf);
          + case BT_HCI_EVT_INQUIRY_RESULT_WITH_RSSI:
                  inquiry_result_with_rssi(buf);
          + case BT_HCI_EVT_EXTENDED_INQUIRY_RESULT:
                  extended_inquiry_result(buf);
          + case BT_HCI_EVT_REMOTE_NAME_REQ_COMPLETE:
                  remote_name_request_complete(buf);
          + case BT_HCI_EVT_AUTH_COMPLETE:
                  auth_complete(buf);
          + case BT_HCI_EVT_REMOTE_FEATURES:
                  read_remote_features_complete(buf);
          + case BT_HCI_EVT_REMOTE_EXT_FEATURES:
                  read_remote_ext_features_complete(buf);
          + case BT_HCI_EVT_ROLE_CHANGE:
                  role_change(buf);
        case BT_HCI_EVT_DISCONN_COMPLETE:
                hci_disconn_complete(buf);
        + smp/br
          + case BT_HCI_EVT_ENCRYPT_CHANGE:
                  hci_encrypt_change(buf);
          + case BT_HCI_EVT_ENCRYPT_KEY_REFRESH_COMPLETE:
                  hci_encrypt_key_refresh_complete(buf);
        + le
          + case BT_HCI_EVT_LE_META_EVENT:
            + hci_le_meta_event(buf);
              + case BT_HCI_EVT_LE_CONN_COMPLETE:
                + le_conn_complete(buf);
                  + id_addr = find_id_addr(&evt->peer_addr);
                  + conn = bt_conn_lookup_state_le(id_addr, BT_CONN_CONNECT);
                  + atomic_clear_bit(bt_dev.flags, BT_DEV_ADVERTISING);
                  + conn->handle   = handle;
                    bt_addr_le_copy(&conn->le.dst, id_addr);
                    conn->le.interval = sys_le16_to_cpu(evt->interval);
                    conn->le.latency = sys_le16_to_cpu(evt->latency);
                    conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
                    conn->role = evt->role;
                  + if (conn->role == BT_HCI_ROLE_SLAVE) {
                    bt_addr_le_copy(&conn->le.init_addr, &evt->peer_addr);
                    bt_addr_le_copy(&conn->le.resp_addr, &bt_dev.id_addr);
                  + bt_conn_set_state(conn, BT_CONN_CONNECTED);
                    + case BT_CONN_CONNECTED:
                    + k_fifo_init(&conn->tx_queue);
                    + k_thread_spawn(conn->stack, sizeof(conn->stack), conn_tx_thread,
                    + bt_l2cap_connected(conn);
                      + fchan = le_channels;
                      + if (fchan->accept(conn, &chan) < 0) {
                        + .accept	= l2cap_accept,
                          + static struct bt_l2cap_chan_ops ops = {
                            .connected = l2cap_connected,
                            .disconnected = l2cap_disconnected,
                            .recv = l2cap_recv,
                          + l2cap->chan.chan.ops = &ops;
                            *chan = &l2cap->chan.chan;
                      + l2cap_chan_add(conn, chan, NULL)
                        + struct bt_l2cap_le_chan *ch = l2cap_chan_alloc_cid(conn, chan);
                        + bt_l2cap_chan_add(conn, chan, destroy);
                      + chan->ops->connected(chan);
                        + l2cap_connected(struct bt_l2cap_chan *chan)
                    + notify_connected(conn);
                      + for (cb = callback_list; cb; cb = cb->_next) {
                        + cb->connected(conn, conn->err);
              + case BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE:
                + le_conn_update_complete(buf);
              + case BT_HCI_EV_LE_REMOTE_FEAT_COMPLETE:
                + le_remote_feat_complete(buf);
              + case BT_HCI_EVT_LE_CONN_PARAM_REQ:
                + le_conn_param_req(buf);
              + case BT_HCI_EVT_LE_LTK_REQUEST:
                + le_ltk_request(buf);
              + case BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE:
                + le_pkey_complete(buf);
              + case BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE:
                + le_dhkey_complete(buf);
              + case BT_HCI_EVT_LE_ADVERTISING_REPORT:
                + le_adv_report(buf);
                  + check_pending_conn(addr, &info->addr, info->evt_type);
****** bt_le_adv_start
+ set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
+ bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
+ set_advertise_enable(true);
  + bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
+ atomic_set_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING);

***** monitor.c
SYS_INIT(bt_monitor_init, PRE_KERNEL_1, MONITOR_INIT_PRIORITY);
使用串口来做debug monitor， bluetooht的时间命令都会发往这个串口
config BLUETOOTH_DEBUG_MONITOR
config BLUETOOTH_MONITOR_ON_DEV_NAME
string "Device Name of Bluetooth monitor logging UART"

+ void bt_log(int prio, const char *fmt, ...)
  + bt_monitor_send(BT_MONITOR_SYSTEM_NOTE, buf, len);
    + monitor_send(&hdr, sizeof(hdr));
      + uart_poll_out(monitor_dev, *buf++);
***** h4.c
****** init
static struct bt_hci_driver drv = {
        .name		= "H:4",
        .bus		= BT_HCI_DRIVER_BUS_UART,
        .open		= h4_open,
        .send		= h4_send,
};
+ SYS_INIT(_bt_uart_init, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEVICE);
  + h4_dev = device_get_binding(CONFIG_BLUETOOTH_UART_ON_DEV_NAME);
    + bt_hci_driver_register(&drv);
      + bt_dev.drv = drv;
        + bt_monitor_new_index(BT_MONITOR_TYPE_PRIMARY, drv->bus,
                                     BT_ADDR_ANY, drv->name ? drv->name : "bt0");
          + bt_monitor_send(BT_MONITOR_NEW_INDEX, &pkt, sizeof(pkt));
****** isr
+ static int h4_open(void)
  + uart_irq_callback_set(h4_dev, bt_uart_isr);
  + uart_irq_rx_enable(h4_dev);

+ static void bt_uart_isr(struct device *unused)
  + read = h4_read(h4_dev, &type, sizeof(type), 0);
    + int h4_read(struct device *uart, uint8_t *buf,  size_t len, size_t min)
      + rx = uart_fifo_read(uart, buf, len);
  + case H4_EVT:
  + buf = h4_evt_recv(&remaining);
    + struct bt_hci_evt_hdr hdr;
    + h4_read(h4_dev, (void *)&hdr, sizeof(hdr), sizeof(hdr));
    + *remaining = hdr.len;
    + buf = bt_buf_get_evt(hdr.evt, K_NO_WAIT);
  + case H4_ACL:
  + buf = h4_acl_recv(&remaining);
    + struct bt_hci_acl_hdr hdr;
    + h4_read(h4_dev, (void *)&hdr, sizeof(hdr), sizeof(hdr));
    + buf = bt_buf_get_acl(K_NO_WAIT);
    + *remaining = sys_le16_to_cpu(hdr.len);
  + read = h4_read(h4_dev, net_buf_tail(buf), remaining, 0);
  + bt_recv(buf);
    + bt_monitor_send(bt_monitor_opcode(buf), buf->data, buf->len);
    + if (bt_buf_get_type(buf) == BT_BUF_ACL_IN) {
      + net_buf_put(&bt_dev.rx_queue, buf);
        + return 0;
    + case BT_HCI_EVT_CMD_COMPLETE:
      net_buf_pull(buf, sizeof(*hdr));
      + hci_cmd_complete(buf);
        + struct bt_hci_evt_cmd_complete *evt = (void *)buf->data;
        + hci_cmd_done(opcode, status, buf);
        + if (cmd(sent)->sync) {        k_sem_give(sem);
    + case BT_HCI_EVT_CMD_STATUS:
      net_buf_pull(buf, sizeof(*hdr));
      + hci_cmd_status(buf);
    + case BT_HCI_EVT_NUM_COMPLETED_PACKETS:
      net_buf_pull(buf, sizeof(*hdr));
      + hci_num_completed_packets(buf);

***** nble
+ DEVICE_INIT(bt_nble, "", _bt_nble_init, NULL, NULL, POST_KERNEL,
            CONFIG_KERNEL_INIT_PRIORITY_DEVICE);
+ _bt_nble_init(struct device *unused)
  + nble_dev = device_get_binding(CONFIG_NBLE_UART_ON_DEV_NAME);

+ bt_enable(bt_ready_cb_t cb)
  + nble_open(void)
    + k_thread_spawn(rx_thread_stack, sizeof(rx_thread_stack),
                        (k_thread_entry_t)rx_thread,
      + uart_irq_callback_set(nble_dev, bt_uart_isr);

+ bt_uart_isr(struct device *unused)
  + hdr_bytes += uart_fifo_read(nble_dev,
  + buf = net_buf_alloc(&rx_pool, K_NO_WAIT);
  + read = uart_fifo_read(nble_dev, net_buf_tail(buf), hdr.len);
  + net_buf_put(&rx_queue, buf);

+ static void rx_thread(void)
  + rpc_deserialize(buf);
    + case SIG_TYPE_S:
    + deserialize_s(uint8_t fn_index, struct net_buf *buf)
      + deserialize_struct(buf, &struct_ptr, &struct_length);
      + m_fct_s[fn_index](struct_data);

***** android bluedroid

*** android bluedroid
http://blog.csdn.net/xubin341719/article/details/40378205

** 0802 研发会议
1 20170802研发三部SRD例会报告
1.1 标案项目相关
1.1.1 3703
•	支持android APK
实现基本完成，本周送测， 8月22号学习版，9月6号发布
1.1.2 LS360F
•	已经立项，
立项会议上达成协议，测试轮次不严格按照5轮来计划， 而是按照合理的方式计划，以控制和计划的偏差为目标，而不是测试轮次。
•	计划实施平台的测试方法
1.1.3 3503
•	去掉usb 读卡器芯片，以节省功耗和成本
目前3503即使增加了wifi模组的功耗优化，仍然不如3603，主要原因是读卡器功耗，现在尝试让卡和wifi复用卡控制器来解决功耗问题。
目前基本的功能通了，但wifi有遇到问题，正在澄清中，
•	psram 和 spi nand
功能已经调通， nand的逻辑层功能还需要继续完成
•	双系统支持蓝牙
由于单系统蓝牙的时间点太晚，为了满足PM的推广需求，仍需要上一个双系统的版本
争取能够在4M nor上完成， 目前的固件情况：代码 750k， 提示音470K， wifi固件 180k，解码库和中文码表 220k， 预计蓝牙固件700k， ota的时候，提示音和蓝牙固件只放一份，有机会做到4M nor
需要paul部门把蓝牙推歌的功能porting到3503板子上。
•	单系统的蓝牙在开发分支上，a2dp avrcp基本功能已有， 后续合并到主分支上，使用的是ivt协议栈
1.1.4 蓝牙 mcu
•	蓝牙协议栈调研
看了broadcom的IOT BT的SDK情况，后续整理报告，
broadcom的iot的蓝牙支持双模，同时可以作为模组通过uart，spi，usb等多种方式和主控结合，
传统蓝牙支持除了推歌，打电话，还支持联系人，文件传输等。
BLE部分支持mesh，支持苹果的相关协议
应用开发简单，一般的profile是开源的， 核心的协议栈是rom，开发的示例都是demo性质，主要靠打印等来表示流程，有较完整的蓝牙流程，但没有实际产品功能。
继续调研其他协议栈
1.1.5 5601
•	testchip验证
休眠唤醒问题已经解决
•	语音遥控器
使用5118做前端来搭建语音遥控器方案
•	arm cordio stack
EEPROM的版本只能使用cordio的sdk
nor flash的版本，目前有cordio的sdk， 后续计划支持zephyr的sdk
•	zephyr ble协议栈
主分支上最近刚刚提交了BLE mesh的支持， 后续nor方案考虑使用zephyr os和协议栈。
** 20170706 周总关于产品规划和研发过程中的几大问题
各位管理团队成员：
在炬芯今年上半年的工作中发生了一些重大事情，也挖出来一些事情，觉得在我们管理团队的思维中有一些根深蒂固的问题和行为方式，如果不解决，炬芯不是可以用“危险”两个简单的字来解释的。

先流水账式的列举我们上半年看到的一些问题：
１．我们老人机市占大幅下滑，下滑后有很多的解释，但下滑前我们非常专门的为这个市场开了一颗ＩＣ　５００９Ｇ。
２．我们对５１１８销量的高度乐观情绪被现实浇了一桶冰水，这以前我们发疯一样的备库存，这以后的总结居然是我们的业务主管没有投入，我们的体系没有积极推广，或者靠我们体系推广根本不行，我们的产品竞争力不够，或者ＩＣ的接口不够，所以要立刻花上百万美元再开一颗加接口的５１１８Ｂ。　
３．今年我们要ＴＯ四颗ＩＣ，两颗在７月１日ＴＯ了Ｔｅｓｔｃｈｉｐ，　但是这四颗ＩＣ在ＳＰＩ这样的接口不要说啥像国际大厂看齐，我们的四颗ＩＣ用的都不是同样的ＩＰ。研发主管顾左右而言他，啥一个是从某某项目继承的，另一个是从另一个项目继承的，云云。
４．５００９Ｇ中间一个Ｆｅａｔｕｒｅ被莫名的砍了，环顾左右，无人应答是乍砍的，是谁决定的，哪一个研发主管和ＰＭ批准的？　回答为不知道，只能用历史故事来回答，说我们定义芯片经常是问一句，这个Ｆｅａｔｕｒｅ有人用不？无人回答，就砍了，不需要任何人负责，也没有研发主管承担责任。
５．昨天我进入５１１９增强版会议晚了一点，发现研发主管正热烈的在讨论一个全ＲＯＭ版的耳机芯片，也就是说一个所有配置都固定，未来配置的ＭＩＣ，扬声器，模具，按键，灯，ＰＥＱ设置，手机兼容性等等的超级大公模芯片，当然在市场面的强烈反对下，昙花一现，转为使用ＯＴＰ的讨论。但是这样的议题在内部居然有一定的市场。
６．我们梦想进入耳机成为大玩家，但我们没有持续分析对手，连样机都是现在才开始收集。
７．	。。。。。。

分析和解剖几个麻雀。　
一．５００９Ｇ的经验教训
　　２０１５年在我们对老人机最得意的时间点，市场部拍板两个结论１。老人机会持续现有趋势三年或者以上，２。我们如果成本做到和对手一样有信心以平均一年４－５Ｍ的出货量坚持三年。
所以，为老人机专门开一颗ＩＣ是值得的。　于是５００９Ｇ明确定位专门服务老人机同时耕耘广告机，不打故事机及需要解Ｆｌａｓｈ和带摄像头的方案。于是研发进行了大幅度的砍规格，包括砍掉ＶＣＥ，Ｇ２Ｄ和ＣＭＯＳ　Ｓｅｎｓｏｒ接口，还有很多其他。同时后来也发生了以上４里面的情景，在不知不觉中随性的砍掉了一个调节音量的小Ｆｅａｔｕｒｅ。

　　最近我去拜访王国奇时，老王要我明确炬芯到底是不是会坚决地耕耘老人机，我想一个刚刚为老人机开了一颗５５ｎｍ专用ＩＣ的公司，为啥他唯一的客户却在问你是否要坚持打老人机呢？这是啥情况。但事实上是，我们的业务市场部在连自己的新ＩＣ成本都搞错（我不知道这个的影响程度）的前提下操盘，就是给了客户我们有时想坚持，有时不想坚持的印象，前几个月我们的市场占有率下滑到２０％甚至以下。　２０１７年初的这个状况，和２０１５年的拍板距离实在太悬殊了。

有幸另一个创新发生了，老赵部门的贡献，这个明确定位了不打故事机的ＩＣ可以打故事机了，于是市场定位乾坤大挪移，５００９Ｇ定位故事机了，一系列的紧急项目做故事机。

同时我们的市场部对砍掉了ＣＭＯＳ　ｓｅｎｓｏｒ接口有切肤之痛。可惜原因是不知道砍掉不那么影响成本。这个除了可惜，可能还可以有很多教训要吸收，很多词语去形容。

实际上２０１６年老人机市场就开始大幅下滑了，我们是否好好总结过，一年前的市场定位是否草率了。　
我们有没有思考过，如果老赵部门没有这个贡献，我们仅仅在执行５００９Ｇ的原始使命，这颗ＩＣ的投入会变成怎样的窘境？

以限制市场区隔，限制使用场景的Ｃｏｓｔｄｏｗｎ和砍规格很可能是“伪创新”　这个思维模式，这个产品规划思路和研发习惯很可能在根本上伤害了我们的市场机会。

而针对那个莫名其妙被砍掉的Ｆｅａｔｕｒｅ则同样一体两面的，一方面老人机的确不用这个Ｆｅａｔｕｒｅ，所以基于原来的市场定位，这个Ｆｅａｔｕｒｅ被砍貌似不为过。
但是这个Ｆｅａｔｕｒｅ被砍却没有文档，没有人知道，不需要经过严谨的评审，这个是极其危险的。说到底，我们的研发管理，我们的研发流程，我们的研发主管是干啥吃的？

二．５１１８的经验教训
　５１１８定位最低目标培育我们自己RF和通信的整合开发，制造和测试能力，最高目标在标准低端蓝牙音箱（主要是公模市场）咬下一个角。于是研发认真扣了每一个角落的成本，砍掉每一点冗余的Feature和接口，公平的说这是研发最深度的扣成本的一颗ＩＣ，但是不幸的是我们也砍了比我们成本更低的低端对手都支持的接口。砍过头了么？以原有的市场定位并没有砍过头阿。

结果：5118总体结果实际比预期好，但是这种比预期在杰里BK缺货的虚假繁荣促进下走向另一个极端。 冷静之后发现其实现在的结果和我们的真实面实际是非常一致和合理的。我们的初衷就没有想过要耕耘很多差异化案子，甚至在我们的理解里模糊的觉得我们的对手就是只能做标准案，很阳春，没有啥弹性的。是现实重重的打了我们一巴掌，我们才意识到现实不是我们所想象的。

这个过程中反映出来的三个问题非常值得深思。
１．我们是否尊重对手？，我们有没有认真地分析对手的产品？ 作为一个后进者，有没有一个谦虚地态度，谦逊的去做竞争者分析，有根据的制定自己的应对，耕耘每一个细节。
２．我们有没有认真地思考和对待砍掉得那几个接口，现在我们又仓促的要花一百万美元加回这几个接口，这里的经验教训有多深刻？是不是市场定位其实一开始就错了？既不符合市场状况也不符合自己的情况？
３．当我们开始立5118B以后，立项中已经明确了是要针对拓展性市场的，可以说市场定位的确发生了乾坤大挪移，但是我们的研发主管们思维有没有依据这样的市场定位去调整，从5118定位狭窄的最底端标准蓝牙音箱中间拔出来，真正的把思维和可以进行拓展性市场的定位一致？从我抓的ROM代码与OS深度耦合的问题，到接口问题，我们是不是依然深陷在基于固定的使用场景砍规格的固有思维里？

三．５１１９目前的定位和其危险。
我们都对５１１９抱以厚望，但是我们的工作方式已经让５１１９存有巨大的风险。
１．我们根本还不十分了解耳机市场，但是我们没有花大力气去学习和分析耳机对手。　我们有没有收集齐对手的ｄａｔａｓｈｅｅｔ，样机，ＳＤＫ，　配置和量产工具，全面分析其Ｐｒｏ　ａｎｄ　Ｃｏｎ，然后来制定自己的策略。
２．当我们发现对手的配置项非常多的时候，我们是否脚踏实地的去分析过如何应对？还是完全闭门造车的拍脑袋？
３．昨天关于纯ROM版（完全不做任何配置）的讨论，是否是我们基于通过限制应用场景来砍规格以求成本勉强能没有劣势的思维发展到了极端的一种表现？　对于一个我们还不完全了解的市场是否可以走这条路，也许，但必须是要在花极大大力气学习对手的做法，和市场客户的行为之后才能做的事情，我认为这个不是ＰＭ的事情，这是研发主导的事情。我们坐在家里想象未来耳机会完全标准化，未来只有一种磨具，一种按键和灯的配置，仅仅配同一类外围器件，手机兼容性一劳永逸，ＰＥＱ不需要配置，这样的耳机芯片是市场最大量的，　做这样的想象是标准的闭门造车，静态思维和“伪创新”，　危害极大。认真评估是否可以用ＯＴＰ来替代ＥＥＰＲＯＭ和合理的，但必须全面认真的做大量调查分析工作，拍脑袋的做纯ＲＯＭ版是不可取的。

总结一下：
１．既然都为某个市场开了专用ＩＣ了就要锲而不舍，坚持到底。
２．我们必须认清自己手上没有水晶球这个事实，承认初始市场定位发生乾坤大挪移是高概率事件。产品定位和研发必须给自己留有合理的弹性。
３．艺高才能人胆大，不了解和无知不能作为竞争力和砍规格的根据，砍规格应该是一个非常谨慎的行为，是基于高把握度反复琢磨以后的行为，需要有严谨的纪录和签核，不是任何两个工程师就可以决定的大事。研发主管必须看紧，砍是必要的，但必须是谨慎的，有人明确承担功过的。砍规格不能太随意随性。
４．必须非常尊重对手，强化竞争对手分析，我们的市场和研发主管ＧＰＬ必须做到都读过对手的资料，评测过对手的样机，对对手的规格和优劣滚瓜烂熟。不分析对手就做得决策是脱离实际的。不能接受的。要砍掉对手有的接口和Ｆｅａｔｕｒｅ，同样需要艺高人胆大，必须花大力气让自己非常了解市场和客户需求的前提下进行。
５．知己知彼，首先要知己，我们必须要化时间真正了解自己的产品，了解增减某些ＦＥａｔｕｒｅ带来的后果，才能做出合理的决策。

一切皆在细节中，这是ＩＣ设计业不变的真理。　不能重视细节就不可能在这个行业生存。

目前的任务：
  请收集齐全主要耳机对手的各种资料和样机，越全越好，我们需要既安排，也亲自学习和评估，然后组织系列报告和讨论来分析对手制订策略，落实每一个细节，只有这样我们才有赢得可能。

** 20170704研发三部SRD例会报告
*** 标案项目相关
**** 3703
***** 支持android APK
****** 需求
PM明确需要在放开资源限制的要求下支持android apk
****** 技术路线
+ 使用先启动到linux下，再后台加载andoird的方式，来保证快速启动的体验， apk加载慢在一定程度上可以缓解
+ 使用双系统相互沟通的方式来进入和退出android的apk
+ 解决双系统并存的资源共享和互斥问题，主要是wifi，以及media server， surface flinger等
****** 工作量
预估 2个人 1.5个月的时间，
**** 3605
***** 标案规格
+ 技术路线选择使用openWRT
+ 音视频框架，采用裁剪3703使用的stage fright方式，
  + 可以充分利用积累的和稳定的codec
  + 从目前裁剪看，原始数据4M， 压缩后2M， 基本可以满足要求， 后续需要继续压缩
***** 火百灵客户案
客户案的支持工作比预期的要多不少，后续可能会和标案抢资源
**** 3503
***** 支持wifi蓝牙combo功能
****** ROM版本情况
  + BR/EDR版本的patch需要26k的的ram
  + BLE功能的patch需要20k左右的ram
  + 固定使用的ram 需要 7k + 3k
****** 蓝牙针对3503功能RAM需求裁剪
+ 只做蓝牙音箱功能，只需要支持a2dp avrcp两个profile
+ 不支持双链路，sniffer等功能的话， BR/EDR的patch应该可以减少到17K
+ BLE 和 BR/EDR 不同时使用
+ 总的RAM需求，控制在17K + 7K + 3K  30K左右。
****** 目前情况
+ 移植了IVT协议栈， 可以通过A2DP播放音乐
+ 利用ROM的版本，老麦初步跑起来了。
****** 需要决策的
上层蓝牙profile的选择，需要讨论和确定
******* IVT库
+ 有比较多的分层和抽象，代码逻辑比较复杂，需要写很多的上层代码适配后，才能实现一个profile功能
+ 有测试过完整的兼容性， IVT库本身问题不多
+ IVT库代码加上上层service会有比较多的代码， 代码size是不太好的
******* zephyr的蓝牙协议栈
+ BLE 支持比较完备，3503 测试Airsync兼容性也没发现问题
+ BR/EDR 缺少一些profile支持，对3503而言， 主要缺少AVRCP  和 SDP
+ 代码精简紧凑，除了实现了IVT部分的功能外， 很大一部分上层适配需要的功能都有框架，不需要像IVT库一样，开发那么多代码
+ 代码大小，相对于使用IVT库，应该会有显著的减少。
+ 缺点是没有测试过相关兼容性，可能有兼容性问题要解决。
******* 总结
从长期来看， 倾向采用补全zephyr的proflie的方式，逐渐完善需要的profile。
****** 需要其他部门配合
需要SD和无线部门，评估下硬件支持蓝牙wifi combo是否可以。
****** 总结
目前初步看，支持蓝牙wifi combo是可行的

***** 支持ASR的其他格式
目前和我们配合的语音识别的提供上，认为我们使用的amr 8k的是不太适合的格式， 最好支持speex-ogg格式，需要算法部分尽快评估
**** Android 版本升级
***** 以往版本相对于原生版本改动
相对于android原生版本的改动，主要集中在以下方面（工作量由高到低）：
1. CTS 和CTS verify失败项解决
   + 音视频
   + camera
   + 512M内存
2. GMS apk兼容性解决
3. 系统测试apk兼容性解决
4. 音视频支持硬解码
5. 音视频兼容性问题解决
6. selinux相关的策略修改和支持
7. 支持HDMI以及多显示设备相关功能
8. modify工具支持
9. 媒体扫描，包含卡分组， u盘，media分区
10. vold 相关磁盘分区调整
    + media 分区
    + usb多分区
    + 外置卡 支持多分区
11. 图片硬件码适配
12. mini charge支持单口， 双口充电规格以及电池曲线
13. 支持mass storage设备
    android默认支持mtp设备，不支持mass storage设备
14. 3g dongle 支持
15. usb host支持，
16. vendor apk
17. 支持WIFI驱动的加载和卸载方式
18. 文件系统支持 exfat ntfs等规格
19. 个性化的规格支持
***** android版本升级步骤:
****** 全功能带起以及适配我们改动的规格（4~6周1
+ 先带起软解  1周
+ 带起GPU UI （取决于android 改动大小 一周）
+ 带起音视频硬解 （2~4周，取决于音视频框架改动大小）
+ 适配android新特性（2~4周，取决于android版本的改动大小）
+ 适配我们个性化规格（2~3周）
****** 系统测试和DEBUG （8周）
****** 主要风险
+ 原生架构变化带来风险， 比如虚拟机架构变化带来的风险。
  在4.4到5.1上带来很多问题，都比较花时间。
***** android O的建议做法：
+ 适配硬解码视频（可以考虑支持全格式）
+ 适配GPU
+ 原生规格，只支持重点规格， 一些不必要或难以支持的暂不支持
+ CTS 测试分析一下报告，非必要问题不解决
+ 原生bug不解决
+ 不测试apk兼容性
+ 个性化规格暂不支持，等有需求逐步增加
***** 音视频支持规格
****** 原生视频容器：
mpeg2ps
mpeg2ts
matroska
Mp4
方案新增容器：flv,wmv,rm,avi,
另外mpeg2ps替换成了我们自己的parser
****** 原生视频格式：
avc(h264,只支持baseline)
hevc
h263
mpeg2
vp9

方案新增视频格式：
与IC有关，以s700为例。avc hevc h263 mpeg2 都替换为我们的硬件解码。
除此之外，增加了vp6,vp8,vc1,mpeg4,rv34,flv1,mjpg,msm4等硬件解码格式。
另外还有avs和wmv8纯软件解码
****** 原生音频容器和音频格式：
mp3,amr,aac,flac,g711,gsm.mp3,raw,vorbis,opus。
方案新增音频容器和音频格式：
wmalsl,wmapro,wmastd,ac3,acelp,dts,pcm,mp3, flac, ape
***** 总的来说
+ 就算只做必要的工作， 还是有不少的工作量的
+ 只做基本的功能
+ 音视频的全格式可以考虑去掉一些有风险和权利金的的格式，
  带起需要的格式工作量相对还好。
  音视频主要的工作量在于解决GMS问题， 以及解决中的各种兼容性问题。

*** 老刘邮件
昨天晚上开完珠海研发会议, 我意识到市场部和研发部门之间的项目太多了.    项目很轻易的就立起来了.   这样会造成珠海研发团队失焦, 也会事实上造成研发资源浪费且效率低下.   我分析产生这个现象的几个原因如下：　
1:   市场部同事和研发主管，互相之间感情深厚，很容易就沟通．所以，谈着谈着就立项了
2:   珠海的研发主管对销售业绩渴盼, 很希望通过自己或自己部门的努力, 多做几个客户案, 以期望销售业绩成长
3: 市场部同事在和珠海研发主管探讨项目可行性的时候，发现某项研发工作恰好也是另一个市场部项目所需要的，就以这个为托词（或心理安慰），心里想，反正另一个项目也需要用到这个技术积累，那我这个项目先做了，在这个技术上的投入，不完全算是我这个项目成本．　
4: 研发部主管(及／或市场部同事)把市场部想当然认为是研发部门的主管或者资源调动方．而忘记了研发部门必须要有自己的一些研发技术路线图和自己独立支配的研发资源．　
5: 市场部核算投入产出不合理或者不严谨．要么是想着配合某个感情好的客户，要么是粗略计算一下，觉得值得投入，就想当然的调集了珠海的研发资源．而没有考虑利用行业内的资源整合．没有考虑如何以四两拨千斤(公司内部资源的四两，拨行业内的千斤)
6: 市场部／研发部门，谈着谈着某个项目就偷跑了．研发偷跑可以．但应该算是预研．研发主管不能把偷跑／预研混淆了．还说自己人力不够用．
7: 市场部同事在找研发主管，讨论某个项目可行性的时候，研发主管就”误以为”项目要开工了．然后就指挥人力开干了．市场部同事对这个事情有时候是不知情，有时候是知情也不拦着，半推半就就把项目推下去了．　　　
综上种种，目前的状态是　研发主管／市场部同事　都有天然的立项冲动．就导致了现在这个样子，项目就不清不楚进到珠海了．然后珠海的研发主管在完成某个必须的研发项目的时候（例如芯片项目），就有可能感觉到人力不足．　
请研发主管，尤其是珠海的研发主管，务必要保持住自己的技术主线．不可以被客户项目一时的假繁荣假热情迷住了双眼．那都是假象．很多客户案也是对方一时热情．不能随便让一个客户案就进入珠海．
请市场部　务必遵守工作原则，正式立项的项目，当然可以调集珠海的资源．未立项的项目，可以找珠海评估可行性．但是客户案，必须走一个立项流程．哪怕是邮件立项也可以．不能把客户案当作个体户的方式去经营．　
请珠海的研发主管，把你们手上所从事的项目，列一列，让对应的市场经理来认领．如果无人认领的，立刻停工(或者不计算为客户项目，只算是预研)．　　
请市场部同事，在你认领项目之前，先与我和业务主管讨论．这个项目有没有四两拨千斤？　
*** 目前正在做的项目整理
| 名称      | 类别         | PM     | 阶段     | 描述                                                                                                                                            |
| ZS350A    | 标案项目     | 肖凯平 | 第二阶段 | + SPI NAND支持，用来支持卡缓存 + 蓝牙音箱规格支持，需要支持avrcp a2dp + 蓝牙WIFI combo + 魔音支持 + VAD支持 + speex-ogg + 触摸按键 + WIFI省功耗 |
| LS370A    | 标案项目     | 肖凯平 | 第二阶段 | + 支持andorid 正版视频apk + ios 视频聊天apk测试                                                                                                 |
| LS360F    | 准备立项标案 | 肖凯平 |          | + 规范化bsp （kernel boot config） + kernel升级到3.10 + 支持16M nor方案 + 整合openWRT发型版 + 移植音视频框架 + 支持camera                       |
| 5601      | IC项目       | 张天益 | testchip | + 方案验证 + SDK开发                                                                                                                            |
| AD700A    | 标案项目     | 何建雄 | 第二阶段 | + LInux发型版支持 + linux版本视频硬解码支持 + GPU硬加速支持 + Android项目的需要珠海支持需求                                                     |
| 火百灵/KT | 未立项客案   | 张洪波 |          | + 支持火百灵/KT，基于LS360F完成一个智能音箱客案 + 最早是计划做为WIFI音箱的beta客户导入的                                                        |

** 半年BP会议
*** 邝建涛
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B53353@srv-mail-02.actions.com.cn][2017 年中BP会 -- 智慧计算 ]]
**** 上半年（1-5月）的主要工作：
收敛S500客户，开发中项目落地，完成开发评估板CB6的开发，完善资料文档、
外设、LINUX；
S700开发评估板（CB7）的第一阶段开发完成；
S700 Beta客户车机（头枕）项目启动；
VR客户项目的落地，工程收敛，业务持续关注；
平板保持一定出货量，7059C出货进度不如预期；
**** 现在及下半年（6-10月）主要工作：
S500评估板批量开始销售，业务配合方糖客户推广，承接项目，核心板开发完成，
准备批量出货；
S700的CB7完成批量，核心板完成开发，7月下旬开始批量销售，预计到8月底完
成第二阶段软件开发（完善外设，文档，LINUX，论坛建设）；
7月份S700头枕小批量，8月份车机试产；
8月初7013小批量；
8月底开始保持一定密度进行S700的宣传活动到年底：发布S700车机，开发板的
推广活动，香港电子展；
9月初开始预研S700升级安卓系统O可行性，如果可行，应在10月以前开始，可以
适当拉长时间分阶段完成；
9月开始S900开发评估板（CB9）第一阶段开发，预计年底前完成批量，同时完成
文档；
平板持续保持一定出货量，VR业务保持关注，业务关注跟进当期市场热点（如近
期的王者荣耀游戏机S900，迷你KTV）;
**** 年底到明年上半年：（11---）
随着S500有一定的客户基础及技术积累，业务和方糖主导开始5206（39S、39ST）
在特定市场或订单的清货动作，可能包括部分7059C在非平板市场出货；
低端平板保持持续出货；
到年底，已经完成S700/S900 基本平台的积累，工具及配套资料的准备，此时应
该逐渐回归市场业务的角色定位及分工，加强业务客户推广；
**** 业务
1.经销商，核心方案商的建设，为新进客户提供技术及商务服务（保证基本生存，
改善经营）；
2.寻找一家有配合意愿，在不同地区有丰富客户基础，渠道能力的分销商（类似
大联大），以我们目前AP的现状，从某类行业客户或特定市场开始会比较容易找
到共同利益点切入；（业绩突破）
3.重点、标杆客户的攻关；（稳步成长）
4.从既有客户项目，产品发现可以以点带面的方向；（稳步成长）
5.抓住当期市场热点，不一定是中长期可耕耘方向，特定订单；（意外惊喜）
**** 市场
1.及时发现新兴热点产品，组织内外部资源快速导入，预判是否中长期可耕耘方
向；
2.寻找预判传统行业可能的智能化趋势，看好方向主动提前布局；
3.关注外围一些核心算法，应用；
4.关注核心配套资源动态趋势；
5.平台各主次分支的同步管理，平台的持续完善（比如DDR模板，板型，外设，
系统）工作的规划;
6.外围生态，论坛的建设，宣传；
**** 工程
1.客户FAE的支持工作；
2.协助PM持续完善平台，同步主次分支；
3.协助核心客户或重点项目的开发；
4.持续提升客户服务的效率，包括支持系统，工具，开发文档优化，服务流程，
新客户工程培训；
5.学习，积累，自身综合能力的提升；
**** 几个关键词：
聚焦：我们是推平台，卖IC的，不是推方案的（至少一段时间）
收敛：我们的平台是S700/S900
库存：我们目前仍有一定的库存风险，需要降低盘活库存（5201:480K，
5202:2.5M，5206:1M）
生存：我们的首要任务是先养活自己
**** FCST
PAD：
上半年：出货600K，ASP:USD2.35
下半年：100K-150K/M，ASP:USD2.35
AP:单位：K套
　                    Q1   Q2    Q3    Q4
S500/7059/V500        13   47    60    80
ASP                   $4.2 $4.2  $4.5  $4.5
S700/V700             2    8     10    30
ASP                   $4.8 $4.8  $4.8  $4.8
S900                  2    10    10    10
ASP                   $12.5$12.5 $12.5 $12.5
Others（39/39ST/7013）5    5     20    80
ASP                   $2.0 $2.0  $2.0  $2.0
Total(数量）          22   70    100   200
Total(金额）          $99.2$370.8$483.0$789.0
注：7013数量暂共估70K，要到8月份会相对准一些；
**** 需要的支持：
公司的理解支持，给予时间；
关键节点的工程人力投入（火上浇油）；
*** Android 版本升级
**** 相对于原生版本改动
相对于android原生版本的改动，主要集中在以下方面（工作量由高到低）：
1. CTS 和CTS verify失败项解决
   + 音视频
   + camera
   + 512M内存
2. GMS apk兼容性解决
3. 系统测试apk兼容性解决
4. 音视频支持硬解码
5. 音视频兼容性问题解决
6. selinux相关的策略修改和支持
7. 支持HDMI以及多显示设备相关功能
8. modify工具支持
9. 媒体扫描，包含卡分组， u盘，media分区
10. vold 相关磁盘分区调整
    + media 分区
    + usb多分区
    + 外置卡 支持多分区
11. 图片硬件码适配
12. mini charge支持单口， 双口充电规格以及电池曲线
13. 支持mass storage设备
    android默认支持mtp设备，不支持mass storage设备
14. 3g dongle 支持
15. usb host支持，
16. vendor apk
17. 支持WIFI驱动的加载和卸载方式
18. 文件系统支持 exfat ntfs等规格
19. 个性化的规格支持
**** android版本升级步骤:
***** 全功能带起以及适配我们改动的规格（4~6周1
+ 先带起软解  1周
+ 带起GPU UI （取决于android 改动大小 一周）
+ 带起音视频硬解 （2~4周，取决于音视频框架改动大小）
+ 适配android新特性（2~4周，取决于android版本的改动大小）
+ 适配我们个性化规格（2~3周）
***** 系统测试和DEBUG （8周）

***** 主要风险
+ 原生架构变化带来风险， 比如虚拟机架构变化带来的风险。
  在4.4到5.1上带来很多问题，都比较花时间。
**** android O的建议做法：
+ 适配硬解码视频（可以考虑支持全格式）
+ 适配GPU
+ 原生规格，只支持重点规格， 一些不必要或难以支持的暂不支持
+ CTS 测试分析一下报告，非必要问题不解决
+ 原生bug不解决
+ 不测试apk兼容性
+ 个性化规格暂不支持，等有需求逐步增加

** 20170630：IC项目增加软件架构师
*** 会议目的
后续的ic项目， 需要补强软件架构评估这一个工作。主要目的如下：
+ 能够满足公司内部的标案开发需求外，
+ 也可以比较容易的支持客户的二次开发。
+ 可以比较容易的支持多种软件架构
尽可能避免出现IC的硬件不必要的限制软件的扩展性，尽可能避免IC硬件和软件做不必要的耦合。
*** 达成协议
+ 设立新的角色，软件架构师  5119 周晓磊   5118B  5116C(5120) 刘炜 5601 魏华铭
+ GPL会提供IC主要的市场需求给到软件架构师
+ 软件架构师需要参加spec的评审会议，如果对spec有异议，不能在会议中解决时，需要GPL来协调解决
+ IP需要标准化， 和保持延续性，尽可能保持接口（寄存器）的一致性，
+ 软件架构师需要输出软件架构评估文档
*** 待办：
+ review一下IC项目开发流程，看是否需要修改流程，加入相关活动 （蔡青）
+ review下几个IC项目，看必须的ip的规范程度是否需要改进  （
  + 5116C 刘炜  吴玉凡
  + 5118B  刘炜  蔡李镇
  + 5119  周晓磊
** 20170606 ATS3605D带camera的无屏方案
*** 需求
+ 按照产品规格需求， 需要能够单向显示视频，双向语音聊天。
+ 要能做到16M的nor
+ 使用64M的ddr
*** 可选方案
**** LS3703平台 + 地平线通话
+ 统计了3703的各个文件的情况
  + 裁掉不必要的视频，显示，GPU，以及各个应用。保留camera，播放框架，播放器，网络以及 uc适配框架。 此时需要的空间为11.5M大小
  + stageFright本身占用给的空间为 1.7M， 播放器依赖2M   camear 1M
  + 地平线的通话部分总共需要13M的空间（没有计算地平线的图像识别的）
  + 总共需要大概25M的空间， 使用squash fs的方式压缩率按照60%计算的话，需要15M的nor才够
+ 如果在加上微信故事机需要的功能，内核3M大小，百科问答这部分（我记得这部分有几兆大小，主要是tts库大，以及提示音什么的），16M的nor是不够放的。
**** 3703 BSP + 故事机规格 + qq物联
这个技术路线是按照nor最小的方式来做的， 如果这个也不能做到16M的话， 意义就不大，还是回到3703的平台
*** 关于平台的讨论
+ 只所以这次比较纠结的原因，就是我们没有一个足够小的， 整合了音视频，GUI显示的nor的平台，其他这个就是3605D平台规划完成的任务
+ 3703平台在使用SLC nand的时候，功能是足够强大的， 相对来说，资源使用也比较紧凑。
  在使用128M DDR的时候，可以支持播放1080P视频（参考帧11）的时候，还可以录像800*600
  支持双向视频通话
  整合同样的功能， android的实现还是相对比较紧凑的，并没有过多浪费， 使用Linux不做特别深度优化，并不会更小。
+ 开发方式上看， 3703 支持两种方式:
  android NDK的开发(地平线的功能使用的这种方式）
  UC的应用框架开发（机器人的各个应用功能使用的这种方式）
+ 初步简单估计，使用UC的音视频框架相对stagefright + openMax的音视频框架预计能够节省的的空间估计小于5M， 在nor上应该小于3M。
*** 后续3605D
+ 设计之初就考虑以16M的nor为主要考虑
+ 整合音视频， camera，GUI，和显示框架，一切以nor空间，和ram空间为主要考虑
+ 音视频框架目前比较看比较成熟的，size比较好的， 仍然是stagefright + OpenMax IL的框架
  但需要进一步优化，去除掉对android的一些底层机制的依赖， 来进一步压缩size。
  去除掉一些不必要支持的功能，
+ uc目前使用的那套框架可以作为add on的方式整合进来， uc的音视频从大小上看，应该仍是最优的，再空间非常紧张的时候，是可以作为另外一个替代使用的。
  从单纯size这个维度看，uc的音视频框架还是有较大价值的
+ uc的应用框架，GUI框架，和音视频框架需要再整合进来的时候，做一定的分割， 应该允许只使用比如音视频框架，而不使用其他部分。
+ SDK希望能够做到通过配置来使用不同的音视频底层。 可以考虑通过不同安装包的方式来add on
+ 3605D的目标至少要做到音频+camera + QQ物联不能超过16M的nor。
***  姚& 周总意见
[[mu4e:msgid:DB539A2A09F34D4B9989A23D1D3BF4FE016F5394@srv-mail-02.actions.com.cn][答复: 关于3605d 平台方案规格的一些讨论]]
有两件事情我们要尽可能杜绝

１．开发一个标案，开发完再接下一个案子的时候自己都不愿意基于上一个标案
开发了，这是一种犯罪啊。基于这样的方式做研发的公司，不死上帝都觉得不公
平啊。

２．一个开发平台也好，一个标案平台也好，随着时间的推移不能简单地是功能
越来越多，但越来越不健康，三年以后平台不是变好了而是变差了。如果有崭新
的需求来旧平台不堪重负就应该果断重构，让旧平台健康的留在原来的领域。平
台的健康很重要，不断的乱打ｐａｔｃｈ和优化应付当前的紧急任务，回头不整
理，放任自流，这样的研发结果一定不会让公司发展的好。
** 20170602研发三部SRD例会报告
*** 标案项目相关
**** 3703
+ 兼容性测试中测试出一个nand的问题， 补测兼容性，已经证实解决
+ 发布文档都已经准备完成
+ 确定是用0527tag发布，开始走发布流程
+ ios app地平想本周提供，但还需要更新库，应用流程也有修改，发布后继续
+ 客户试产样机，LCD需要拉伸，也需要改版
+ 目前客户试产尚缺少在线教育和点播的规格，发布后按照新需求进行
**** 3503
+ 第四轮要点测试，今天完成，测试仍有20多个bug，需要再增加1轮要点测试。
  预计的发布时间预计在16号左右，较原计划有接近2周的delay
+ 目前已经开始导入试产客户
**** 3605
+ 上层准备使用openWRT的发型版，这个文件系统会很小，基本的只有3M多，
+ 目前上层比较明确的需求有
  + alsa lib支持
  + wifi bt支持
  + 播放器支持
  + AVS支持
+ 底层BSP后续会在S700 S900的BSP上来支持3605D
  这样考虑的主要原因是S700的BSP比较规范一些，包括kernel本身， uboot， dts， 分区表等
  另外，kernel版本也新一些
  后续维护的工作也会好一些，有kernel升级要求的话，也容易支持一些
**** 5601
+ 示例开发
  同时具有central和peripheral角色的示例
+ OTA机制开发
+ 加密流程验证
+ 分析airoha语音遥控器性能和耗电
  使用的标准的hid 协议
  传输语音时6.4KB/s， 每个包20个byte， 一个周期4个包， 12.5ms的链接周期
  在语音操作的时候好点8.8ma， 无广播时好点 8.3ua，广播时5.4ma ~7ma， tx峰值13.9ma
+ 5601两个对传
  使用合适的连接周期，和最大包长251，可以达到40kB/s

*** 预研相关
**** 有进展
***** 5118B ROM独立
已经初步讨论了做法，主要由以下几点：
+ rom中的baseband代码， 目前需要的延时，关中断，以及memcpy memset等常用函数，可以通过自己实现的方式来完成， 延时不再使用cpu counter，而是保留一个timer给rom用
  初步看ROM中的代码没有依赖OS的其他系统原语
+ rom的工程需要独立于SDK编译， 与SDK的直接的接口通过提供独立的符号表
+ ROM中使用的RAM，需要集中到一起，定位到整个RAM空间的开始，或者末尾，不要把RAM空间割裂，这样会便于开发和LInk的处理。
+ nor上的baseband代码和ROM中的baseband代码直接是通过一个函数表来交互的， nor上的部分，有依赖os相关以及SDK部分相关的接口， 不同的OS需要适配这部分
+ rom中的代码的patch机制是通过固定的函数表来实现的， 这个不同的os都比较容易支持
+ rom中需要的malloc接口，由于是在中断中调用的，同时还不清楚最高使用的内存大小，这个接口的实现建议在sdk中实现
+ ROM代码调整后，需要在zephyr和gl5118 sdk中都需要验证， 前者可以使用ic来验证，后者需要使用fpga验证，并且需要送测
+ 时间上， zephyr这边先开始，预计2周时间可以提供rom版本，之后就可以两边并行修改和验证
***** 亚马逊AVS
AVS部分，3503上由于其他任务打断工作暂停，后续转其他人先在3605D上来支持。
目前还在看amazon提供的树莓派的参考实现
***** 双系统支持快速倒车
增加了DE叠加的功能，目前雷达叠加的效果已经可以出来，基本已经可以满足瑞泰的要求
***** Linux 发行版
****** OpenWRT
研究了OpenWRT，后续3605可以使用这个linux的发行版， size比较小， 比较适合音频平台
***** 第三方sdk和云服务
****** broadcom Wiced SDK
SDK已经更新到5.0， 支持了更多的组件
+ 支持 FreeRTOS Nuttx  ThreadX，抽象了一个wiced_rtos的抽象层
+ 支持蓝牙（蓝牙部分未开源）
+ WIFI支持部分，除了wifi模组内部的firmware是一个二进制外，sdio驱动，  wifi driver，soft ap， wifi p2p，WDS， wpa suplicant等都是开源的， 对RTOS os的依赖，没有直接依赖，主要依赖RTOS抽象层的 mutex， 信号量，延时以及timer等接口， 使用zephyr也比较容易实现， 所以后续可以我们自己来porting wifi的支持到zephyr上。
  相对于南方硅谷的WIFI，我们可以学到更多东西。
+ 支持音频解码，
+ 支持多个网络协议栈 lwip  Netx(未开源) Nuttx_ns
+ 支持比较丰富的上层协议，mqtt， coap，http2等
***** AS216B
已经提供环境，科胜讯的数据通路已经通了，目前还有问题
**** 未有进展部分
***** android O 已经发布预览版，还未安排看
***** 3703 Linux平台，支持android 版本的爱奇艺apk，暂停
***** 5601 支持zephyr， 后续安排
***** BLE mesh规范已经发布，暂停
*** 支持工作
**** V700`
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEAA68@srv-mail-02.actions.com.cn][答复: 【V700】泽迪分体机沟通]]
**** 7051
***** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0503DFC1@srv-mail-02.actions.com.cn][答复: 【酷哭】7051 USB 摄像头使用异常]]
***** [[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791903@srv-mail-02.actions.com.cn][ATS3703-LS370A-ISS 工业级产品专项]]
***** [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C348@srv-mail-02.actions.com.cn][答复: 7051 sensor抓图时间确认]]
***** [[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEA95E@srv-mail-02.actions.com.cn][705B晨芯儿童机项目USB大口U盘不能挂载问题]]
***** [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B040FDBC8@srv-mail-02.actions.com.cn][答复: 7051晨芯儿童机硬件开关调试]]
***** 7051 领芯以太网支持
**** s900
***** 陀螺漂移问题
***** TODO  [[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D5CBB@srv-mail-02.actions.com.cn][S900 APK 主界面反应迟钝]]
***** s900 申报项目支持
***** s900 显示黑色效果差
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103465A7A@srv-mail-02.actions.com.cn][答复: S900 VR样机显示黑色资源q效果差]]
***** openMaxIL
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D592D@srv-mail-02.actions.com.cn][答复: OpenMaxIL]]
**** 7059
mipi屏支持
上海7059 GPU问题
**** 瑞泰
+ 1080P LVDS屏
+ OTA 升级uboot
+ CVBS IN 被裁掉
+ HDMI IN
+ 倒车支持叠加
**** S700
***** DONE [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0503DD58@srv-mail-02.actions.com.cn][答复: 700H265解码 ]]
CLOSED: [2017-06-02 Fri 13:47]
***** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C393@srv-mail-02.actions.com.cn][答复: 【AD700A】【图库】图库应用裁剪usb中的图片保存时报错]]
***** TODO [[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10353B88B@srv-mail-02.actions.com.cn][答复: S700 bugreview记录-----------HDMI输出开机logo转到开机动画过程中必现花屏现象]]
***** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0503D883@srv-mail-02.actions.com.cn][答复: 方糖关于S700 CB7 HDMI目前使用的问题]]
***** TODO [[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEADC5@srv-mail-02.actions.com.cn][答复: CB7（S700）网络丢包问题]]
***** 方糖USB3.0驱动
***** 双屏异显性能确认
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103465B94@srv-mail-02.actions.com.cn][答复: S700 双屏异显DEMO及性能确认]]
***** 开机logo花屏问题

** 20170601：平台方向后续规划
*** IC情况
平台的规划主要考虑如下ic平台
+ AP类IC  5202  5211 5209
+ 5116C  5118B  3503 带cache架构的蓝牙IC
+ 5601 BLE IC
+ 耳朵IC  cortex M3 + DSP
+ camera + WIFI小系统
+ cortex A5 + DSP的眼睛IC
*** 平台状况
**** RTOS MIPS平台
***** 主要适配IC
+ 3503，后续考虑 5118B，  5116C， 以及将来camera + wifi IC
***** IC特点
+ nor base
+ cache 架构，可以XIP来执行代码
+ soc内部有限SRAM
***** 主要SDK诉求
+ 方便应用开发和debug
+ Nor 和RAM空间占用要小
+ 功能方便裁剪以节省NOR和内存
***** 主要设计决策
+ kernel使用Zephyr OS，zephyr OS具有以下特点：
  + 有的代码编译成一个二进制
     系统中不存在重复代码，可以节省nor的空间
     没有动态加载的二进制，可以更好防网络攻击
  + 提供了完整的IOT相关协议栈
    蓝牙BLE支持
    WIFI以及网络协议栈支持
    支持zigbee和路由
    支持TLS等安全加密库
  + 提供和很精细的功能可配置
    可以去除不需要的功能，来减少ram和nor代码占用
  + 提供驱动模型
    可以比较好的隔离应用和驱动
  + 有较好的社区支持，社区开发比较活跃
+ 全新设计的应用框架
  + 设计了服务模型，对常见的系统功能（播放，录音，mqtt服务）做成独立的服务，服务独立于应用，可以被多种不同的应用使用
  + 产品整个功能按照场景进行进行合理划分多个应用，故事机划分成多个功能独立的子模块，由应用管理器来管理，主要应用模块有：播放音乐，后台下载 网络配对  百科问答  微信留言 播放tts  PCBA
  + 应用，服务，系统之间使用消息传递的通信方式来实现松耦合
  + 使用steam来封装网络流，文件等数据源，简化应用开发。
+ 系统级的设计优化
  + 设计zero copy技术在驱动，网络协议栈，解码，播放共享同一份数据，极大的减少了内存开销。
  + 设计了避免内存碎片的内存管理方法，从机制上解决碎片问题
  + 设计overlay机制来让不同的解码格式共享同一块内存
  + 应用都是互斥运行的，不同的应用实现复用内存。
  + 精心处理网络策略来在保证网络稳定性的情况下，减少内存占用
    1. tcp 延迟回复ACK来避免重发
    2. 发送数据包使用small buffer避免占用更大buffer
+ 性能和调试的便利性
  + 支持最新的GCC工具链
  + 支持标准JTAG工具
    可以使用业界通用的JTAG调试工具，以及常见的JTAG调试软件，比如gdb， eclipse
  + 提供功能丰富的串口命令行工具
    可以通过串口来做系统系能优化，现场debug等，可以查看系统
    + 设置系统的运行参数
    + 查看cpu负载
    + 统计cache miss情况
    + 查看各个任务的线程栈
    + 查看内存分配情况，任务栈的使用情况
    + 网络相关的各个内存buffer情况。
    + 其他常用的功能
  + 增加了运行期监控
    + 检查堆栈溢出
    + 检查应用的内存泄露
    + 检查系统的最大关中断时间
    + 系统panci时，提供调用栈的完整backtrace，并提供符号支持
***** 不足之处
+ 由于是mips架构， 目前只能支持GCC编译工具链。
  不太容易支持Keil，IAR等集成开发，调试的IDE环境
+ JTAG目前只支持5PIN的，不支持2PIN的SWD
+ MIPS相对ARM对栈的消耗更多一些，内存需求好高一些
+ 社区和生态，相对于arm会差比较大，比如不能支持arm mbed OS以及CMSIS DAP等现在更主流的调试方式。
***** 后续计划
+ 持续跟踪zephyr的版本跟新和动态
+ 目前平台已经整合了wifi， BLE 后续需要整合传统l蓝牙功能
+ 目前应用框架和协议栈都还有一些优化工作需要继续完成
**** RTOS ARM 平台
***** 主要适配IC
+ 5601 耳朵ic， 这里暂时只考虑5601
***** IC特点
+ ROM中固化了协议栈，应用框架以及典型的beacon，数传应用
+ 外挂EEPROM作为规模较小的个性化开发
+ 外挂Nor来支持更复杂的协议栈和应用场景
+ 目前TestChip使用了bank架构，后续正式版建议改成cache架构。
+ Bank架构和cache架构在可开发性上有如下缺点
  + RODATA 不能够放在nor上，需要占用ram空间
  + 程序中一些small literals不能放在nor上，需要占用ram空间
  + 在使用调试器的时候，会看到bank切换这个动作，不能做到完全透明。
***** 主要SDK诉求
+ 方便应用开发和debug
+ EEPROM方案程序需要尽可能的小
+ Nor方案需要尽可能方便开发
***** 主要设计决策
****** EEPROM方案
+ 尽可能的固化更多代码，固化代码包括：各种驱动，蓝牙协议栈，应用框架。
+ ROM中固化了了cordio的代码，以降低风险
+ EEPROM开发只需要编写应用本身逻辑代码，其他部分通过调用ROM中的函数实现。
****** 外挂NOR 方案
+ 在优先考虑开放式开发的时候， 可以不使用ROM中固化的代码
+ 程序代码较大的时候使用bank机制
+ 可以支持更多的OS平台，比如zephyr，mbed OS
****** 开发便利性
+ 支持gcc编译，和标准的jtag调试
+ 支持KEIL等业界常见的IDE环境，可以支持标准的烧写flash，单步调试等操作
+ 支持arm的CMSIS DAP调试规范，可以通过一个usb接口同时支持串口，U盘，以及jtag
+ 使用统一编译的方式，
  整个程序，包括ROM中的patch代码，蓝牙controller的patch代码都在一个工程内可以编译出来，实现所见即所得的开发模式
+ 提供了EEPROM和nor上应用开发的样板工程，简化客户应用程序开发
+ 提供类似业界的主流开发板，以及相应的调试接口
+ 可以使用keil工具增加我们开发的插件，即可完善支持KEIL IDE
***** 不足之处
+ 由于bank架构，所以在程序代码较大的时候， 需要使用bank的时候， 在调试器中能够看到bank切换的过程，从而和真正的EFLASH的调试方式有一些不同
***** 后续计划
+ 完善sdk文档
+ 完善开发板支持
+ nor方案支持zephyr OS
+ nor方案支持mbed OS
**** Linux 音频平台
***** 主要适配IC
+ ATS3605 (GL5202E)
***** IC特点
+ 4核A5， 55nm， 256M DDR
+ SLC NAND 或 Nor base
***** 主要SDK诉求
+ 可以给算法类公司提供一个比较好的开发平台，比较容易的验证算法
+ 可以提供给方案公司，可以开发基于音频播放，录音，以及支持网络的类似WIFI音箱的产品
+ 可以对接比较常见的智能云平台，比如amazon的AVS服务
***** 主要设计决策
+ 需要支持标准的linux工具链，以利于算法公司整合第三方开源库
+ 整合一个标准的比较适合音频的Linux发行版，openWRT
+ 支持alsa lib等linux比较常用的音频相关库
+ 支持一个常用的Linux的音频播放框架
+ 开发一个示例的音频播放程序
+ 对接上amazon的avs云，以及其他元
+ 支持WIFI BT等无线功能
+ BSP尽量规范化，考虑和S700 S900整合到同一个BSP中以方便维护
***** 后续计划
标案立项，分两步走：
1. 基于现有BSP（3703 BSP），整合openWRT，以及支持alsa lib，可以提供给算法公司使用
2. BSP整合到S700，同时完善需要的其他功能，然后发布
**** Linux 视频平台
***** 主要适配IC
+ ATS3703 (GL5202E)
***** IC特点
+ 4核A5， 55nm， 256M DDR
+ SLC NAND 或 Nor base
***** 主要SDK诉求
+ 由于客户熟悉uc平台的开发方式，所以需要api和应用框架都兼容uc
+ 需要支持SWF格式播放
+ 支持视频聊天和图像识别
***** 主要设计决策
+ 保持和7051同一个BSP
  不采用LS360X原来的音视频框架和显示框架，原来框架对bsp改动太多，增加了很多非标准的ioctl
+ 裁剪Android 只剩下NDK中必要的部分，没有java部分。 这样可以复用android平台已经稳定和兼容性没有问题的底层。
+ 使用andriod NDK的开发方式，适配uc平台原有的应用框架
+ UI图层叠加仍然只能使用GPU
+ 移植Android平台的浏览器的FLASH插件，在NDK环境跑起来支持SWF播放
***** 不足之处
+ 需要熟悉android NDK的开发或者熟悉我们uc平台的开发方式
+ 由于使用了android的工具链，不太容易整合标准的Linux的第三方应用程序
  整合第三方应用库的时候， 需要做一些调整才行。虽然大部分的调整并不大，但也是一个障碍
***** 后续计划
+ 会基于这个平台做一些差异化，比如音频+camera类的应用
+ 后续会转给小姚部分做差异化开发
**** Linux桌面版
***** 主要适配IC
+ 5211 5209
***** IC特点
+ 4核A53， 28nm， >512M DDR
+ emmc或nand base
***** 主要SDK诉求
+ 支持Ubuntu或debian等主流系统
+ 支持音视频的硬解码
+ 支持GPU硬件加速
+ LInux版本需要及时更新
***** 主要设计决策
+ 使用S700，S900的android版本同一个bsp来支持多个linux发行版
+ 使用uboot和dts配置
+ kernel 版本支持3.10.57
+ boot中使用arm trust firmware保证及时有频率映射，也能够保证kernel开源
+ Kernel有关SOC的部分采用标准的子系统框架，比如pin ctrl，dma engine，clk framework，以利于将来的upstream的操作
***** 不足之处
+ kernel版本已经偏低
+ 尚未支持视频硬解码加速
+ 尚未支持GPU硬加速
***** 后续计划
+ 升级内核版本到一个比较主流的版本
+ 支持视频硬件加速
**** Android平台
***** 主要适配IC
 + 5211 5209
***** IC特点
+ 4核A53， 28nm， >512M DDR
+ emmc或nand base
***** 主要SDK诉求
+ 支持512M DDR
+ android新版本支持
***** 主要设计决策
+ 和LInux 桌面版使用同一个BSP
***** 后续计划
+ 支持更新的Android版本
*** 人员情况
**** 人员在平台项目间分配情况
|--------+------------+-----------------+--------+------------------------|
| 人员   | 职称       | 平台            |   项目 | 负责模块               |
|--------+------------+-----------------+--------+------------------------|
| 刘炜   | 高级工程师 | RTOS            |   3503 | SDK TL                 |
| 汪辉   | 高级工程师 | RTOS            |   3503 | CASE TL                |
| 李鹏   | 资深工程师 | RTOS            |   3503 | 蓝牙                   |
| 李钊军 | 工程师     | RTOS            |   3503 | 网络 wifi              |
| 蒋斌   | 工程师     | RTOS            |   3503 | 应用开发               |
| 吕锦昂 | 工程师     | RTOS            | 3503 | USB 文件系统               |
|--------+------------+-----------------+--------+------------------------|
| 魏华铭 | 高级工程师 | RTOS            |   5601 | SDK TL                 |
| 刘世军 | 资深工程师 | RTOS            |   5601 | CASE TL                |
|--------+------------+-----------------+--------+------------------------|
| 宋智宁 | 高级工程师 | Android &Linux  |   3605 | CASE TL                |
| 廖田养 | 资深工程师 | Android &Linux  |   3605 | SDK TL                 |
| 孙成志 | 资深工程师 | Android &Linux  |   3605 | 音视频框架，播放器           |
| 荣幸   | 工程师     | Android & Linux |   3605 | 音频，alexa AVS        |
| 刘燚光 | 工程师     | Android & Linux |   3605 | camera&boot&nand flash |
| 刘新旭 | 工程师     | Android & LInux |   3605 | WIFI/BT                |
|--------+------------+-----------------+--------+------------------------|
| 黄俊敏 | 资深工程师 | Android &Linux  |   S700 | GPU，显示， 双系统     |
| 黄海宇 | 工程师     | Andriod & Linux |   S700 | 显示，LCD，HDMI          |
|--------+------------+-----------------+--------+------------------------|
| 蒲进   | 高级工程师 | All             | 无特定 | 项目管理，3503 ota     |
| 张东风 | 经理       | All             | 无特定 | 架构决策，内存管理     |
|--------+------------+-----------------+--------+------------------------|
**** 目前人员状况的一些考虑
+ android/Linux平台
  没有新IC和新的大的标案，人员基本上都需要兼顾原来负责的模块
  同时也需要学习和掌握更多新的模块
+ 在RTOS这边需要更多人员的时候，会从Andoid LInux这边继续抽调
+ 从android/LInux抽调过来的人员在原来维护模块没人接手时，需要继续维护
+ 根据项目需求，需要动态在不同项目间协调人力，
  比如5601项目，目前两个人，实际上后续还是需要做比较多的事情的，现在主要是由于优先级不高，同时市场要求的time to market不特别看重，所以才持续维持在两个人力
+ 资深人员发展问题
  目前部门人员数目小于20人，同时也有经常需要在不同项目间去调整人力，所以目前不适合把不同工作性质的人员划分到不同的团队中去。
  而是通过设立SDK TL 或 CASE TL，以及具体的技术小组来让资深人员发挥更多的影响力。
  资深人员的发展希望继续沿着 资深->高级->主任 工程师的方向发展，我觉得，目前比较可能的人选是 刘炜 和 魏华铭。可以找合适的时机来授予相应的技术职称。
*** 平台部门和方案部门的合作
**** 平台要求
+ 目前以及后续规划的平台，除了需要支持本部门的使用外， 还需要支持 方案开发一部，方案开发二部，合肥 深圳炬才开发部以及有可能的上海的公司
+ 支持外部客户有效率的进行二次开发
+ 平台的是否好用取决于内部客户和外部客户的评价，以及可以基于平台长出多少差异化的方案
**** 其他方案部门合作
在平台开发过程中，需要紧密的和其他部门进行合作开发， 主要有如下几点考量：
+ 平台重构，本身不是一个新的产品方向，而更多是原有技术的积累和重构，此时积累的经验对项目成败很关键
  比如5118B，如果后续需要基于zephyr来进行一次平台开发，那么CASE TL是建议由5118项目组的核心研发人员来担任的，除非实在是抽不出对应的人手，才由部分出这个人，但同时也需要5118核心人员承担顾问的角色。
  SDK TL的角色可以由我们部门承担，也可以借用5118原来比较合格的核心研发人员。
+ 新的平台开发，是新的产品品类，比如3503的wifi
  这个原则上 SDK TL和CASE TL都可以由我们部门承担，如果能比较确定后续那个团队会继续使用该平台做更多的方案，也可以由对应的方案团队出合适的人员来承担CASE TL
+ 在项目开发的过程中，我希望抽调过来的承担TL角色的人员，不再负责原有方案的任务，而专心做平台的案子，在开发的过程中，对我负责。
  之所以这样考虑的原因，主要是由于在决定一些技术问题的，特别是当两个不同的解决不能简单的说那个好，那个不好的情况下，是需要有人能够做一个技术决策的。
+ 项目开发完成后，抽调的人员继续回原来的部门。
**** 平台案的质量保证
关于如何保证平台案的质量，而尽量避免出现临时的修改，导致SDK的架构不好，难于二次开发，目前是如下考虑的：
+ Android Linux 平台相对比较容易下判断，有原生框架的使用原生框架，存在多个框架的时候，选择主流的框架，修改原生框架需要慎重考虑
+ RTOS平台，天然应用，驱动，和内核本身没有非常强的分隔，容易出现划分不清晰的问题
+ BSP开发，应用框架的开发和应用开发由不同的人员承担，尽量避免从上到下都是一个人
+ 开始开发前，会对主要的架构设计做初步的讨论，有初步结论后才会开展
+ 代码提交的时候，使用了gerrit来做代码review，review过的代码才可以集成进来，由CASE TL和SDK TL做初步把关。
+ 项目到一定阶段后，会安排整体的代码review。
+ RTOS系统的代码，由于代码量不算太大，单个人花一些时间也可以看完，我也会看一遍，架构上的不合理和优化点还是比较容易发现的。
+ 目前测试方面，主要还是依赖于研发人员自测，以及系统集成测试这两部分测试。
  对嵌入式系统，还没找到行之有效的单元测试方法。
  在做视频PMP的时代，有尝试过单元测试的方法，投入巨大，但收效很小。
  后续，android和Linux项目中的经验表明，代码review相对来说投入和收益是合适的。

**** 回复
***** 以Zepha为主要决策点主要风险是第三方驱动支持,我不反对这个决策,认为这个决策是有勇气的,但是我们是否需要一个退路? 例如也提供一个FreeROTS的开发平台?

第三方驱动支持这里是不是指的WIFI驱动这部分， WIFI驱动的话， 我这两天又去读了一下broadcom的Wiced WIFI的SDK（现在属于cypress了）
****** 主要情况如下：
+ SDK已经更新到5.0， 支持了更多的组件
+ 支持 FreeRTOS Nuttx ThreadX，抽象了一个wicedrtos的抽象层
+ 支持蓝牙（蓝牙部分未开源）
+ WIFI支持部分，除了wifi模组内部的firmware是一个二进制外，sdio驱动， wifi driver，soft ap， wifi p2p，WDS， wpa suplicant等都是开源的， 对RTOS os的依赖，没有直接依赖，主要依赖RTOS抽象层的 mutex， 信号量，延时以及timer等接口， 使用zephyr也比较容易实现， 所以后续可以我们自己来porting wifi的支持到zephyr上。
  相对于南方硅谷的WIFI，我们可以学到更多东西。
+ 支持音频解码，
+ 支持多个网络协议栈 lwip Netx(未开源) Nuttxns
+ 支持比较丰富的上层协议，mqtt， coap，http2等

但就WIFI而言，我们后续可以安排移植， 只要移植能够通过， 应该就可以排除这个风险。

FreeRTOS平台如果确实有比较强烈的需求，是可以再整理一份的， 主要的点：
+ 由于zephyr的整个系统中，从上到下都是一个比较严密的整体（驱动，协议栈）， 要插入FreeRTOS的支持，会改动比较大一些， 工作量会大一些， 也同时会破坏原生结构，不建议这种方式
+ FreeRTOS 可以做为WIFI平台的一个候选整合FreeRTOS， 驱动， 以及LWIP协议栈
+ 蓝牙平台目前没有看到有好的开源实现， 所以保持zephyr应该不太影响。

****** FreeRTOS与zephyr平台相比的特点：
+ FreeRTOS只是一个单纯的OS的core， 提供基本的操作系统原语，比如，调度，信号量，锁，线程等
+ 使用FreeRTOS的话， 我们还需要整合一些其他组件进来
+ zephyr除了是一个OS的core外， 还提供了IOT需要的协议栈的支持，尤其是蓝牙部分，基本没有找到其他开源的实现
+ zephyr大部分的协议栈是重新开发的，所以是比较为zephyr优化的， 但可能会有不成熟的情况。就目前的使用看，zephyr的核心稳定性还好，网络部分确实有一些不够完善的地方

***** 根据你的分析,是否未来在可以承担的范围内,我们应该尽可能用ARM的M0和M3而不要再用MIPS的M4K了.
从可开发性，和生态上看， 我认为是这样的

***** 3605D Linux音频和3703Linux 视频，是否需要维持两个平台? 是否可以是一个平台。
这个主要还是由两个不同平台的诉求决定的。
****** 3703LInux平台：
+ 支持 SWF播放以及支持讯飞的离线TTS，这个在sayhello规格中需要这两个规格的实现都是从android版本的apk中抠出so来使用的, 因此不能脱离andrid的基本NDK的环境
+ PM需要3703的应用开发的api等用户可见的部分， 需要和3603 uc的保持一致，这个主要是为了客户切换方便，但这个同时也就决定了这个平台不是一个通用的Linux开发平台
+ 在Linux平台， 就没有一个相对比较好的播放器和UI配合的框架，相对于Android平台不管性能还是兼容性都会差不少， 这个是Linux架构的原因， Android本身是做了很多整合的工作的。
+ 由于要支持的规格相对于音频复杂太多， 所以需要的nor 和 Ram的空间都比音频平台大比较多，3703是128M的Nand + 128M的DDR
+ 在3703项目中，在开发中，都一直坚持一个原则， 保持和平板7051使用同一个BSP，差异和适配都是在上层完成的， 所以从维护角度上来说， 不会增加太多的工作量。

****** 3605LInux音频平台：
+ 以标准的LInux开发为主要诉求， 方便客户整合第三方资源，这个确定了不能使用andrioid的环境
+ 音频平台的话，需要把nor和ddr的使用裁剪到最小，nor应该在16M~32M就够了，DDR应该是32M~64M， 规格简单的话应该16M Nor + 32M DDR就够了。这个和视频就没不会完全兼容。
+ 3605D 为了标准化和长期维护的考虑，会采用S700/s900同一个BSP底层
+ 3605音频平台，会考虑扩展支持视频和LCD， 这个是分阶段做的事情，加上视频后可以认为变成了视频平台了，加的方式会是可裁剪和可配置的。

所以长远看， 3605D会支持视频和屏， 但不会支持uc的那一套框架， 那一套只保
留在3703上。

***** 管理上，我立即为啥还是以项目驱动的动因，但我希望决策由几个人做出，所以我建议还是成立一个三到五人的SDK架构部门，任命你为总架构师，其他人为架构师，关键点由这个组产生，项目团队执行。你看看是否合理。

成立一个架构部门我觉得是好的，这样可以集中公司的优势资源，为各个项目服务，做出的决定相互的一致性也会好。

我现在想不清楚的还是架构的决策如何能够被项目开发中真正执行下去，如果项目主要在我这边的这个团队，问题不大，因为我是他们的直接主管。如果项目不在我这边的话，做出的架构决策，我觉得执行起来不会那么顺利，有的时候自己的决定在执行的时候都会反复问自己， 执行其他部门或项目团队外的人的决定相信会更加困难一些。

这部分还是要两位老大多给指导才行

团队的话，主要应该还是RTOS的架构，我们这边考虑如下人员：
刘炜 优势在 zephyr+mips+wifi
魏华铭 优势在 arm+ mbeded + BLE
在加上其他方案部分的一些资深人员就好了，不需要多。
** 2017.5.17 方案团队分工规划
*** 工作分工
**** paul
+ 无线音频
**** 姚
**** 张
** 20170510 研发三部SRD例会报告
*** 标案项目相关
**** 3703
   地平线相关的问题已经解决， 第5轮测试本周完成， 比预期delay 4天，报bug较少，不排除是测试力度的原因。
   目前测试资源特别紧张， 一轮测试要排期2周以上，还会delay， 是最大的风险。
**** 3503
+ 继续调整优化系统的内存管理方式，以及内存使用方式， 解决各个场景下内存紧张的情况。
+ 增加了边下边播功能，在有插卡的情况下， 可以很快下载完成， 避免网络的影响。
+ 在没有卡存在的情况，调整网络策略， 尽可能的开更过的buffer给网络使用。
+ 目前有发现WIFI场景长时间老化，WIFI会断线重连，还在和南方硅谷协调解决中
+ BLE已经调通，争取下轮测试整合测试
+ 蓝牙音箱的功能，目前只能采用双系统的方式来支持
+ 传统蓝牙的支持，要整合到zephyr中有两种可能：
  1. 使用rom的baseband代码，外围构造适配层，模拟5118的环境， 这个合肥团队可能会做
  2. 构造比较独立一些的baseband代码，让baseband不要和sdk绑定那么紧， 关键时序的代码放在ram中执行，不关键的部分放在nor上执行。 这部分预计在10月份之后方亮这边才有人力配合。
  3. 5118 Plus建议考虑一下baseband更独立一些的做法
**** 3605
+ 支持medai win 以及火百灵的一些alsa的需求，
+ 目前来看, 3605D需要提供一个类似X1000 的linux原生上层会比较好一些，客户需要编译和使用linux的第三方库。有一些和android的上层和工具链是不兼容的。
+ bsp（bootloader + kernel + driver），也有两条路线
  + 沿用370a的bsp， 这样最快，但有一些不是很规范的东西， 比如没有使用uboot，dts，以及clk tree 和 dma 框架都没有使用通用的框架， 其中uboot和dts影响稍大。
  + 考虑到3605只做音频部分， 可以在目前s700/s900的sdk上支持7051， 这样的话， 后续一个bsp可以支持更多ic， 长远看是有利的。
**** 5601
+ 使用nxp的支持CMSIS DAP的芯片，已经可以和我们5601的板子配合起来， 可以实现通过usb连接电脑
  + jtag开发调试
  + 串口打印
  + 像使用U盘一些， 通过drag & drop的方式烧写固件
+ 整理sdk应用开发文档
+ 整理SDK架构和使用文档
+ 规划开发板
*** 预研相关
**** 有进展
***** 亚马逊 IOT，AVS
   + 在3503上try通aws IOT的小设备，并可以被echo控制，已经try通， 还未整合到sdk中。
***** 双系统支持快速倒车， 已经可以demo， 下周
***** 第三方sdk和云服务
****** microsoft Azure
是一个类似google 和亚马逊的通用云计算平台， 有小的iot支持和机器学习， 没有看到语音相关支持
****** 华为 liteos
只开放了kernel部分， 上层协议和其他组件没有开源，可能后续会开源
****** 京东
开放了完整的sdk， 有小系统的接口， 还没有跑起来， 据称
ram:4-6K
rom:184K
里面定义的api有适合局域网控制的 。
有比较多的内容是跟菜谱等小家电内容相关的
****** 庆科 WIFI iot 的sdk
主要是基于broadcom的wiced WIFI的sdk上增加一些服务开发出来的，
相对于wiced wifi 增加了一些网络协议， 但同时闭源一些核心的内容。
**** 未有进展部分
***** android O 已经发布预览版，还未安排看
***** 3703 Linux平台，支持android 版本的爱奇艺apk，已经抽时间开始评估, 但预期工作量会比较大
***** 亚马逊 IOT，AVS
   + 使用 3503 实现alexa AVS设备
   这两部分将来都作为sample整合到SDK中（保持zephyr的架构），在一个SDK中整合各种各样的samle，故事机算一个，avs和IOT也算另外的两个， 将来可以继续整合百度等其他的sample。
***** 5601 支持zephyr， 后续安排
***** BLE mesh规范已经发布，目前还未有开源实现，预计过一段时间在zephyr上会有，是否需要投入精力去搞。
*** 支持工作
**** S700
***** 瑞泰
****** TODO U盘升级
****** 瑞泰cvbs in
****** 卡量产
******  双系统倒车
****** 蓝牙slave
****** sofia资料
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A246B5@srv-mail-02.actions.com.cn][答复: 瑞泰项目未来几个需要做的事情]]
***** V700 泽迪
****** TODO  v700 泽迪分体机hdmi输出
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8FCE9@srv-mail-02.actions.com.cn][V700泽迪分体机hdmi输出竖屏信号问题]]
****** 泽迪V700 双屏
****** TODO 泽迪V700 usb支持nanoc的陀螺仪
***** AD700A
****** S700 QCB
****** s700 以太网支持
****** S700 蓝牙支持slave模式  李钊军
****** S700 蓝牙支持pcm
****** S700 revovery老化
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A9008C@srv-mail-02.actions.com.cn][答复: 答复: S700 recovery老化卡死在Android动画问题]]
****** s700 绿屏
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103465020@srv-mail-02.actions.com.cn][答复: 答复: S700 多任务操作下小机出现绿屏]]
****** TODO S700 usb otg
***** wilinko debian
客户自己使用我们的sdk， 自己编译了新的initrd， 新的debian jessie可以完整跑起来。
***** ubuntu linux 支持 S700
**** S500
***** TODO 点创车机老化 camera问题
***** 文晟
[[mu4e:msgid:0E3AB831E505F842818BA4F9798C30A4016F11D3@srv-mail-02.actions.com.cn][答复: 【S500】文晟 USB通信20170425]]
ov5460 camera倒立
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F37DC2@srv-mail-02.actions.com.cn][答复: 文晟7059 ov5640 camera拍照后照片放到PC上倒立180°]]
***** 方糖 ubuntu支持旋转（竖屏）
**** 7059
***** 凯硕达
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F37853@srv-mail-02.actions.com.cn][答复: 【7059】铠硕达200WmipiCamera调试]]
psdio wifi死机， 主要是sdio的max block大小原因
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103464E9E@srv-mail-02.actions.com.cn][答复: KSD死机打印]]
ksd 性能相关问题调试
***** 7059 以太网台湾支持
[[mu4e:msgid:45C9CD6E9A1F8E40A999E51EF137BF15324A1B@srv-mail-02.actions.com.cn][RE: 答复: About ATM7059 /S500 RTL8201 相關眼圖測試_初版]]
***** 通文达屏问题
***** 7059 mipi屏幕调试
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103464ED5@srv-mail-02.actions.com.cn][答复: 7059C 7寸MIPI调试资料]]
**** S900
***** s900 项目申报
***** 领芯EDP屏支持
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB8B5@srv-mail-02.actions.com.cn][答复: 领芯S900工控板子的eDP屏的调试]]
***** 900c youtube 问题
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8FE69@srv-mail-02.actions.com.cn][【v700】【YouTube】v700 nibiru海外版固件使用YouTube tv版播放搜索视频报错]]r
***** 900c 电池 FCC未更新
**** 3605
***** media Win
mediaWin alsa 支持， 编译环境， tinyalsa支持
***** 火百灵
提供sdk给对方
tinyalsa 提供
alsa lib调试
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB7DC@srv-mail-02.actions.com.cn][RE: 深圳广佳乐新智能的ATS3605的远场语音识别的方案]]
***** 3605 linux 环境
** 5118B ROM独立
已经初步讨论了做法，主要由以下几点：
+ rom中的baseband代码， 目前需要的延时，关中断，以及memcpy memset等常用函数，可以通过自己实现的方式来完成， 延时不再使用cpu counter，而是保留一个timer给rom用
  初步看ROM中的代码没有依赖OS的其他系统原语
+ rom的工程需要独立于SDK编译， 与SDK的直接的接口通过提供独立的符号表
+ ROM中使用的RAM，需要集中到一起，定位到整个RAM空间的开始，或者末尾，不要把RAM空间割裂，这样会便于开发和LInk的处理。
+ nor上的baseband代码和ROM中的baseband代码直接是通过一个函数表来交互的， nor上的部分，有依赖os相关以及SDK部分相关的接口， 不同的OS需要适配这部分
+ rom中的代码的patch机制是通过固定的函数表来实现的， 这个不同的os都比较容易支持
+ rom中需要的malloc接口，由于是在中断中调用的，同时还不清楚最高使用的内存大小，这个接口的实现建议在sdk中实现
+ ROM代码调整后，需要在zephyr和gl5118 sdk中都需要验证， 前者可以使用ic来验证，后者需要使用fpga验证，并且需要送测
+ 时间上， zephyr这边先开始，预计2周时间可以提供rom版本，之后就可以两边并行修改和验证
** 业务工程配合
*** 梅利
+ 业务会分成产品线业务， 不在按照客户来区分
+ 业务信息分两类
  + 一些客户面消息，可能会跟预研方向相关
  + 具体需要，基本就是3~5个月就需要完成的
+ 业务工程会议可以试行
+ 工程需要更重视项目完成的时间准确性
+
** 0418FAE支持方式
*** rk的方式
+ rk的支持方式，WIKI多人编辑
+ 不通过qq交互， 而听过wiki交互
+ 通过ticket交互
+ 有简报
+ 所有的版本发布和历史都在论坛有体现
*** actions
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8F9B3@srv-mail-02.actions.com.cn][答复: FAE支持方式改善探讨]]
** 20170405 研发三部SRD例会报告
*** 项目相关
1. 3703
   标案我们负责的部分基本完成， 回归和发布测试即可， 目前地平线部分还有较多问题， 预计会因为这个原因delay
   重点的几个：
   视频聊天，license验证，ota升级，其中在线视频质量是最大的问题， 但目前进展不是很好。
2. 3503
   主要规格已经开发完成，未完成的规格不影响送测， 目前还在完善缺少的规格： 序列号烧写，pcba等
   目前有发现WIFI场景长时间老化，系统会崩溃的问题，在debug中。
   送测样机有delay， 暂时使用内部的dvp来做冒烟测试来送测。
   BLE支持整合的zephyr中
3. 3605
   提供了SDK给link play，但对方应该没动
   提供了SDK给media win， 对方已经使用起来， 目前提了新一些需求， 在跟进解决中
4. 5601
   ROM代码已经freeze
   开发方式已经请paul这边的工程师做了试用，反馈情况还好，从开发方式上和EFLASH基本没有差别。编程模型等都比较好用。 由于时间有限，没有能做完一个profile的开发。
   从技术角度而言：
   E2prom的开发方式， 不需要使用到bank机制， 但需要使用很多rom中的代码，客户开发需要熟悉我们较多接口， 同时，在debug调试的时候， 遇到rom中的代码的时候，客户会无法有debug。
   Spi nor方式的开发，没有E2Prom方式开发的限制， 客户开发和和EFLASH的方案基本相同，调试的时候在使用断点和单步调试的时候， 与ELASH有不同， 单步的时候会单步到我们的bank miss代码中， 断点需要停两次，第一次是引起缺页的E800指令，第二次才是page miss后的代码。这一点是硬件架构决定，无法解决。
   能够做到完全和EFLASH相同的nor flash方案，需要使用cache架构才行，必须让软件使用透明 这样调试器会看不到这个差异。
   Page Miss的架构要做到这一点，需要完全做到IC的内部，不能让软件实时处理。但可以让软件配置。（比如像MMU的页表）。
*** 预研相关
1. GMS 7.0 的要求
   1. Play Store 的Settings 菜单里面会显示这款机器是否有通过GMS认证，现在已经实施；
   2. 针对没有通过GMS认证的7.0机器，系统会通过Play store推送信息给使用者，大概内容为：该设备不合法，请退回给零售商。预计2017年4月初开始实施；
   3. 从2017年8月份开始，所有使用安卓系统的机器，不管是什么版本，如果没有通过GMS认证，谷歌会让机器停止使用谷歌所有的应用；
   4. 针对出货量超过100K的机器，谷歌强制要求每3个月做一次安全补丁的更新并提交谷歌报备，每3年做一次系统更新并提交谷歌报备，如果每3个月没有更新安全补丁导致安全补丁版本过低，谷歌会取消这款机器的GMS认证。
   5. 谷歌对mada的规划
       目前拿到MADA的OEM/ODM一共有66家（不含品牌商），但是谷歌现在要砍掉46家，只保留20家，具体哪20家厂商能续签MADA应用在4月份有 确定消息。
   6. 关于指纹机器，Andriod 7.0 对于TEE的要求，在CDD文件的7.3.10 中Google 明确要求指纹信息存放在TEE环境下
   7. 鉴于没有按照Google CDD要求的情况，用非正常手段测过CTS所带来的风险
      + 如果Google 抽查到客户样机没有把指纹信息放在TEE里，可能会终止MADA协议
      + 如果方案商/品牌商借用其他厂商的MADA，那么终止MADA协议，会导致这个提供MADA
      + 如果测试机构（3PL）没有检测出手机里的指纹放在TEE里， 一旦google查出来后，有可能对测试机构采取措施，也有可能取消测试机构的官方测试资格。
   8. 使用硬件支持的密钥库，可更安全地在 Android 设备上创建、存储和使用加密密钥。它们可保护密钥免受 Linux 内核、潜在的 Android 漏洞的攻击，也可防止从已取得根权限的设备提取密钥。
   9. 为了让硬件支持的密钥库使用起来更简单和更安全，Android N 引入了密钥认证。应用和关闭的设备可使用密钥认证以坚决地确定 RSA 或 EC 密钥对是否受硬件支持、密钥对的属性如何，以及其使用和有效性有何限制。应用和关闭的设备服务可以通过 X.509 认证证书（必须由有效的认证密钥签署）请求有关密钥对的信息。认证密钥是一个 ECDSA 签署密钥，其在出厂时被注入设备的硬件支持的密钥库。因此，有效的认证密钥签署的认证证书可确认硬件支持的密钥库是否存在，以及该密钥库中密钥对的详细信息。为确保设备使用安全的官方 Android 出厂映像，密钥认证要求设备 bootloader向可信执行环境(TEE)提供以下信息：设备上安装的操作系统版本和补丁级别  ● 验证的启动公钥和锁定状态。  ● 除密钥认证外，Android N 还推出了指纹绑定密钥，在指纹注册时不会撤销。
2. Aandroid O 已经发布预览版，还未安排看
3. 3703 Linux平台，支持android 版本的爱奇艺apk，已经抽时间开始评估, 但预期工作量会比较大
4. 亚马逊 IOT，AVS
   + 在3503上try通aws IOT的小设备，并可以被echo控制，正在进行
   + 使用 3503 实现alexa AVS设备
   这两部分将来都作为sample整合到SDK中（保持zephyr的架构），在一个SDK中整合各种各样的samle，故事机算一个，avs和IOT也算另外的两个， 将来可以继续整合百度等其他的sample。
5. 百度云
   百度语音识别，以及TTS的接口都有开放， 都是http+jason的方式来访问， 跟操作系统无关，已经可以在3503上使用。
   目前3503使用的roboo智能管家也是使用百度后台，讯飞已经不再支持故事机等嵌入式
   Duer OS目前已经开了发布会， 目前支持的是RDA的模组，包含语义对话等功能，这部分目前还没有开源， 预计6月份开源。
   Duer OS目前使用的arm mbed OS，但对OS没有偏好，使用其他OS也可以。等开源后再看
6. 96 board
   5118 目前要支持96 board还缺少一些硬件规格，一组I2C，一组Uart和GPIO个数。
   5118 plus倒是可以满足要求，但有一点不方便操作的是mips平台。
   目前linaro也在推动百度zephyr的事情， 比较有兴趣和我们一起去推动和百度语音的对接
7. 阿里云
   简单看了下， 语音识别的接口开发http API的只有一个文件识别的接口，需要先录制好语音文件，并把文件上传到阿里云，然后再调用语音识别接口
   其他实时识别，以及语义聊天等功能，只提供了linux， android 的c++ 和 java的sdk，没有开放http的接口
   语义聊天等主要场景还是集中的跟ali的业务接近的区域，并不是家庭以及儿童的方向。
8. 5601 支持zephyr， 后续安排
9. BLE mesh规范已经发布，目前还未有开源实现，预计过一段时间在zephyr上会有，是否需要投入精力去搞。
10. 双系统支持快速倒车， 未开始
** 20070301SRD会议
*** Android项目
+ S700带起了方糖CB6版型， 发给瑞泰做车机方案第一阶段
+ 使用GS900增加96 board版型（TAG 0227）， 使用该分支和版型做后续S900推广。
+ 瑞泰第一阶段需求评估完成， 第二阶段主要工作在双系统和U盘量产。
+ 拜访了视美泰，了解多很多商显的需求， 初步看工作量比较大。
+ Google DayDream中的APK从手机上抠出来，经过debug可以在5209上跑起来，IMG GPU的部分VR扩展还不能用，沟通中，进展较慢。
+ Android 7.0 GMS，目前了解到的情况需要A53等Arm V8架构的cpu才可以支持TEE。 A5 A7 A9的CPU应该不能过。
+ 差异化和VR的支持工作。（Linux X11选择， HDMI IN，KODI小窗口等需求）	支持S700
***  5601项目
GL5601_FPGA方案
+ 方案进度
  Beacon和数传（module）功能开发和测试已完成。
  Rom固化代码大部分完成。
  Eeprom/spinor方案SDK开发已开始进行。

*** 5119
IVT第一阶段代码完成， IVT库从130K压缩到110，第二阶段的工作， 需要从应用，IVT库以及控制器各方代码一起联动， 后续由柯海涛接手。
+ Rom固化代码预计在3/10前整合完成。之后安排代码review。
+ Eeprom方案SDK预计在在3/10提供，外部开发人员可进入。
+ Spinor方案开发SDK预计在3/17提供。

*** 3703儿童机器人
        1.       标案进度
1）第一轮完整测试送测，功能测试本周一完成，限于测试人力和测试内容全部测试完成在3月4号。
2）视频通话demo已联调通过，人脸贴图跟应用的联调还未完成。视频通话和人脸注册的应用UI已完成初步设计，规格确认后可切图提供开发。该部分整体进度偏慢，要加快赶上下一轮的要点测试（3月8号）。
2	主要问题
1）	多场景卡死：包括卡拉ok返回主界面、视频返回列表界面等出现卡死，主要是
内存不够问题。
3	规格风险
   目前视频点播看来是wifi视频类必须的规格，还在想办法解决视频点播的技术路线。	1．	第三方功能整合
2．	内存优化
3．	视频点播功能技术路线
3503 WIFI 微信故事机	1	播放在线MP3的功能已经调通， 低码率的流畅，高码率的320Kbps，偶尔有卡顿， 还在澄清。
2	内存MP3场景已经使用130多K， 还在整合WMA格式，预计内存基本够用。留给算法的预计可以到70~80K内存。
3	系统播放mp3场景，cache miss在1%左右，网络开销大概20M CPU（这个跟网络带宽需求有关，越高的带宽需求，需要的CPU越高，1M cpu基本等于20kbps）， 可以留给解码部分有100M左右以上的运算能力。
4	在调试过程中，需要调整解码库的内存使用方式， 以及消除不同解码库中的重复代码。
5	US281a SDK的蓝牙controller ROM代码和SDK的其他部分（驱动，C库，profile等）都有很强耦合，很难脱离us281a的环境， 需要重新剥离一份controller代码适配到zephyr上。
6	主要的技术风险已经排除	1．	按照项目计划开发功能
2．	继续优化内存
3．	解码库部分也需要做调整来优化内存使用， 和节省代码空间来减少cache miss。
4．	蓝牙功能整合
3605 WIFI音箱	1	拜访了乐韵瑞，了解清楚了软件需求， 剩下较多的工作主要在nor方案支持， 以及linux的蓝牙功能支持， 这部分有一些工作量， 有人力冲突。
2	已经准备了板子和初步的软件sdk环境提供给对方， 乐韵瑞本周培训，预计下周有结果	继续完成蓝牙和NOR方案
预研	研究了amazon avs设备，以及alexa平台平台的实现， 搭建了实验环境，基本弄清楚了实现原理。 Alexa avs的sdk已经提供了开源的参考实现。
** 愿景规划
*** 20170401 远景
[[mu4e:msgid:DB539A2A09F34D4B9989A23D1D3BF4FE016F4D91@srv-mail-02.actions.com.cn][关于愿景规划和产品规划]]
*** 0405公司后面主线
**** 无线通信仍然是主线
+ 蓝牙音频， 市场是很清楚的， 5.1 继续投入， RF和modem自己做， baseband可以考虑ceva升级
+ BLE   5.1 目前市场看不清楚，研发端可以考虑第一版外购，第二版开始自己研发
**** WIFI只需要整合的机会， 不自己做
**** 规避NbIOT，但需要继续关注对主线影响
**** 低功耗是系统级技术
+ 近期需要努力去耕耘的，有机会就耕耘，提升质量标准
+ 切入角度可以从蓝牙音频开始
**** 音频前处理
+ VUI void user interface，新世代
+ 凡是受到VUI影响的市场都需要跟进， 类似触摸屏的革命
+ 直接服务VUI的， 比如前处理， 5315， 多mic处理
**** 智能语音jr
  + 近场 + 按键
  + 近场 + 命令词
    唤醒词检测 VAD一定是加分项，sensory算法
    目前主要都是使用DSP做的
  + 远场 + 3m + 双mic
    DSP可以搞定
  + 5119， 5118plus仅仅是噱头， 有核高基就有，没有就没有
  + 5116， 5116c
    must 近场命令词唤醒
    最好支持双mic
  + 规划新IC
    双mic或三mic，需要和科胜讯竞争
    强烈建议 m3 + DSP
**** 图像识别+图像处理
不做消费类产品
* 代码笔记
** btstack
*** port/nrf5_zephyr/main
+ void main(void)
  + btstack_memory_init();//each list is a single linked list pool, if define HAVE_MALLOC
    + btstack_memory_pool_create
      (&hci_connection_pool, hci_connection_storage,
      MAX_NR_HCI_CONNECTIONS,
      sizeof(hci_connection_t));
  + btstack_run_loop_init(btstack_run_loop_zephyr_get_instance());
    + the_run_loop->init();
    + btstack_run_loop_zephyr_btstack_run_loop_init,
      static const btstack_run_loop_t btstack_run_loop_wiced = {
      & btstack_run_loop_zephyr_btstack_run_loop_init,
      NULL,
      NULL,
      NULL,
      NULL,
      & btstack_run_loop_zephyr_set_timer,
      & btstack_run_loop_zephyr_add_timer,
      & btstack_run_loop_zephyr_remove_timer,
      & btstack_run_loop_zephyr_execute,
         btstack_run_loop_remove_timer(ts);
         ts->process(ts);
         net_buf_get(&rx_queue, timeout_ticks);
         transport_deliver_controller_packet(buf);
            transport_packet_handler(HCI_ACL_DATA_PACKET, packet, size);
            transport_packet_handler(HCI_EVENT_PACKET, packet, size);
      & btstack_run_loop_zephyr_dump_timer,
      & btstack_run_loop_zephyr_get_time_ms,};
   // enable full log output while porting
   hci_dump_open(NULL, HCI_DUMP_STDOUT);
   // init HCI
  + hci_init(transport_get_instance(), NULL);
    static const hci_transport_t transport = {
    /* const char * name; */                                        "nRF5-Zephyr",
    /* void   (*init) (const void *transport_config); */            &transport_init,
    /* int    (*open)(void); */                                     & transport_open,
    /* int    (*close)(void); */                                    &transport_close,
    /* void   (*register_packet_handler)(void (*handler)(...); */   & transport_register_packet_handler,
            transport_packet_handler = handler;
    /* int    (*can_send_packet_now)(uint8_t packet_type); */       NULL,
    /* int    (*send_packet)(...); */                               & transport_send_packet,
        buf = net_buf_alloc(&cmd_tx_pool, K_NO_WAIT);
              bt_buf_set_type(buf, BT_BUF_CMD);
        memcpy(net_buf_add(buf, size), packet, size);
              bt_send(buf);

    /* int    (*set_baudrate)(uint32_t baudrate); */                NULL,
    /* void   (*reset_link)(void); */                               NULL,
  + btstack_hci_init(const hci_transport_t *transport, const void *config){
    + transport->register_packet_handler(&packet_handler);
    + packet_handler(uint8_t packet_type, uint8_t *packet, uint16_t size){
      event_handler(packet, size);
      acl_handler(packet, size);
      sco_handler(packet, size);
    + hci_state_reset();

   // nRF5 chipsets don't have an official public address
   // Instead, a Static Random Address is assigned during manufacturing
   // let's use it as well
   big_endian_store_16(static_address, 0, NRF_FICR->DEVICEADDR[1] | 0xc000);
   big_endian_store_32(static_address, 2, NRF_FICR->DEVICEADDR[0]);
   gap_random_address_set(static_address);

   // inform about BTstack state
   hci_event_callback_registration.callback = &packet_handler;
   hci_add_event_handler(&hci_event_callback_registration);

   // hand over to btstack embedded code
   btstack_main();

   // go
   btstack_run_loop_execute();

   while (1){};
}

** zephyr
*** storyapp
**** sairapp_main_loop
***** _start_sair();
+ netstream = stream_create(TYPE_NET_STREAM,&sair->request);
  + stream = netstream_create(type,parama);
    + stream = mem_malloc(sizeof(struct __stream));
    + k_fifo_init(&stream->netinfo.netbuffifo);
    + http_ctx = &stream->netinfo.http_ctx;
    + http_init(http_ctx);
      + http_ctx->settings.on_body = on_body;
        http_ctx->settings.on_chunk_complete = on_chunk_complete;
        http_ctx->settings.on_chunk_header = on_chunk_header;
        http_ctx->settings.on_headers_complete = on_headers_complete;
        http_ctx->settings.on_header_field = on_header_field;
        http_ctx->settings.on_header_value = on_header_value;
        http_ctx->settings.on_message_begin = on_message_begin;
        http_ctx->settings.on_message_complete = on_message_complete;
        http_ctx->settings.on_status = on_status;
        http_ctx->settings.on_url = on_url;
    + iface = net_if_get_default();
    + rc = tcp_set_local_addr(&http_ctx->tcp_ctx,
    + stream->netinfo.request = request;
      stream->open = netstream_open;
      stream->read = netstream_read;
      stream->seek = netstream_seek;
      stream->tell = netstream_tell;
      stream->write = netstream_write;
      stream->close = netstream_close;
      stream->destroy = netstream_destroy;
+ res = stream_open(netstream, MODE_OUT);
  + http_ctx = &handle->netinfo.http_ctx;
  + http_reset_ctx(http_ctx);
  + rc = http_send_post(http_ctx,handle->netinfo.request);
  + int http_send_request
    + rc = http_parse_url(&parser,request->url,temp_buffer, &port);
      + ret = http_parser_parse_url(url, strlen(url), false,u);
      + net_dns_resolve(ip_addr,&in_addr_t);
        + struct dns_context ctx;
        + dns_init(&ctx);
        + rc = net_context_get(AF_INET, SOCK_DGRAM, IPPROTO_UDP, &net_ctx);
        + iface = net_if_get_default();
        + net_ipaddr_copy(&local_addr.sin_addr, &iface->ipv4.unicast[0].address.in_addr);
        + rc = net_context_bind(net_ctx, (struct sockaddr *)&local_addr,
        + ctx.net_ctx = net_ctx;
          ctx.timeout = APP_SLEEP_MSECS;
          ctx.dns_server = (struct sockaddr *)&dns_server_addr;
          ctx.elements = MAX_ADDRESSES;
          ctx.query_type = DNS_QUERY_TYPE_A;
          ctx.address.ipv4 = addresses;
          ctx.name = name;
        + rc = dns_resolve(&ctx);
          + net_context_recv(ctx->net_ctx, cb_recv, K_NO_WAIT, ctx);
          + rc = dns_msg_pack_qname(&dns_qname->len, dns_qname->data,
          + rc = dns_write(ctx, dns_data, dns_id, dns_qname);
      + net_addr_ntop(AF_INET, &in_addr_t, ip_addr, NET_IPV4_ADDR_LEN);
    + rc = tcp_connect(&http_ctx->tcp_ctx, temp_buffer,port);
      + rc = net_context_get(family, SOCK_STREAM, IPPROTO_TCP, &ctx->net_ctx);
      + rc = net_context_bind(ctx->net_ctx, &ctx->local_sock, addr_len);
      + rc = set_addr(&server_sock, server_addr, server_port);
      + rc = net_context_connect(ctx->net_ctx, &server_sock, addr_len, NULL,
      + net_context_recv(ctx->net_ctx, recv_cb, K_NO_WAIT, ctx))
    + tx = net_nbuf_get_tx(http_ctx->tcp_ctx.net_ctx, K_FOREVER);
    + net_nbuf_append(tx, strlen(request->http_head), (uint8_t *)request->http_head,
    + rc = net_context_send(tx, NULL, http_ctx->tcp_ctx.timeout,
+ audio_recoder_start(netstream,ECODE_TYPE_AMR,8);
  + recordservice_init(stream,enc_type,sample_rate_khz))
    + recorder = (struct record_service_t *)record_service->private_data;
    + recorder->outputstream = stream;
    + recorder->encoder = _encoder_init();
      + struct audio_encoder_t* encoder = create_audio_encoder();
        + encoder->open = encoder_open;
          encoder->generate_head_info = encoder_generate_head_info;
          encoder->frame_encode = encoder_frame_encode;
          encoder->close = encoder_close;
      + res = encoder->open(encoder);
      + static int encoder_open(void* handle)
        + overlay_section_init(OVERLAY_ID_LIBENCAMR);
        + ret = audio_encoder_ops(&encoder->libhandle, AE_CMD_OPEN, (uint32_t)param);
    + recorder->out_buf = mem_malloc(ENCODE_BUFFER_SIZE);
    + recorder->audioin = _audioin_init(sample_rate_khz);
      + struct audioin_handle * audioin = audioin_device_open(sample_rate_khz);
        + audio_in_enable(handle->dev, &ain_setting, &adc_setting);
          + audio_in_init_clk();
          + audio_in_set_gain(adc_setting->gain);
          + audio_in_set_rate(adc_setting->sample_rate);
          + audio_in_enable_ain(ain_setting);
        + audio_in_pcmbuf_config(handle->dev, &pcmbuf_setting);
  + srv_manager_register_service(record_service)
  + record_service->tid = k_thread_spawn(music_share_stack_area, sizeof(music_share_stack_area), recordservice_main_loop,
  + msg.type = MSG_START_RECORD;
  + send_async_msg(APP_ID_eRECORD_SERVICE, &msg);
***** recordservice_main_loop
+ case MSG_START_RECORD:
+ audio_record();
  + struct record_service_t * recorder = (struct record_service_t *)record_service->private_data;
  + struct audioin_handle * audioin = (struct audioin_handle *)recorder->audioin;
  + ret = audioin_start_record(audioin);
    + audio_in_input(audioin->dev,(uint16_t *)audioin->pcm_buf, INTTERN_PCM_BUFFER_SIZE/2);
      + start_adc_dma(pcm_buf, data_cnt);
  + ret = recorder->encoder->generate_head_info(recorder->encoder,recorder->outputstream);
  + while(recorder->running)
  + ret = audioin_get_pcm_data(audioin,&recorder->in_buf,ENCODE_PCM_SIZE);
  + ret = recorder->encoder->frame_encode(recorder->encoder,
  + ret = stream_write(recorder->outputstream,recorder->out_buf,bytes_used);
  + audioin_stop_record(audioin);
  + audioin_device_close(audioin);
+ case MSG_EXIT_APP:
+ recordservice_exit();
***** _stop_and_send_sair();
+ audio_recoder_stop();
  + app_manager_exit_app(APP_ID_RECORD_SERVICE);
+ res = stream_close(netstream);
***** _play_sair_response(&msg);
**** mqtt
***** mqtt_service_start
+ case MSG_WIFI_CONNECT_FINISHED:
+ mqtt_service_start
  + _mqtt_service_init
  + mqtt_service->tid = k_thread_spawn(mqtt_service_stack_area, sizeof(mqtt_service_stack_area), mqttservice_main_loop,
***** mqttservice_main_loop
  + res = get_mqtt_client_id(client_id);
  + get_mqtt_server_addr(server_addr);
  + res = mqtt_open(client_id, server_addr, SRV_PORT);
    + rc = reconnect_mqtt_tcp(&client_ctx.mqtt_ctx.net_ctx, srv_addr, server_port);
    + client_ctx.mqtt_ctx.connect = connect_cb;
      client_ctx.mqtt_ctx.disconnect = disconnect_cb;
      client_ctx.mqtt_ctx.malformed = malformed_cb;
      client_ctx.mqtt_ctx.pingresp = ping_respond_cb;
      client_ctx.mqtt_ctx.publish_tx = publish_tx_cb;
      client_ctx.mqtt_ctx.publish_rx = publish_rx_cb;
    + rc = mqtt_init(&client_ctx.mqtt_ctx, MQTT_APP_PUBLISHER_SUBSCRIBER);
      + (void)net_context_recv(ctx->net_ctx, mqtt_recv, K_NO_WAIT, ctx);
      + case MQTT_APP_PUBLISHER_SUBSCRIBER:
        + ctx->rcv = mqtt_publisher_subscriber_parser;
      + case MQTT_APP_PUBLISHER:
        + ctx->rcv = mqtt_publisher_parser;
      + case MQTT_APP_SUBSCRIBER:
        + ctx->rcv = mqtt_subscriber_parser;
    + k_delayed_work_init(&client_ctx.mqtt_ping_timeout, mqtt_ping_timeout);
      k_delayed_work_init(&client_ctx.mqtt_keep_timeout, mqtt_keep_timeout);
    + rc = try_to_connect(&client_ctx);
      + rc = mqtt_tx_connect(&client_ctx->mqtt_ctx, &client_ctx->connect_msg);
        + rc = mqtt_pack_connect(data->data, &data->len, MSG_SIZE, msg);
        + tx = net_nbuf_get_tx(ctx->net_ctx, ctx->net_timeout);
        + rc = net_context_send(tx, NULL, ctx->net_timeout, NULL, NULL);
  + while switch(msg.type)
    + case MSG_MQTT_MESSAGE_RECEIVED:
    + res = _mqtt_on_message_received(&msg);
    + case MSG_MQTT_MESSAGE_CONNECT:
    + mqtt_on_connect();
    + case MSG_MQTT_SEND_PINGREQ:
    + mqtt_send_ping_request();
    + case MSG_MQTT_SERVICE_RESTART:
***** mqtt_recv
+ mqtt->rcv(mqtt, buf);
+ int mqtt_publisher_subscriber_parser(struct mqtt_ctx *ctx, struct net_buf *rx)
  + data = rx;
  + pkt_type = MQTT_PACKET_TYPE(data->data[0]);
  + switch (pkt_type) {
  + case MQTT_CONNACK:
  + rc = mqtt_rx_connack(ctx, data, ctx->clean_session);
  + case MQTT_PUBLISH:
  + rc = mqtt_rx_publish(ctx, data);
    + rc = mqtt_unpack_publish(rx->data, rx->len, &msg);
    + rc = ctx->publish_rx(ctx, &msg, msg.pkt_id, MQTT_PUBLISH);
    + int publish_rx_cb(struct mqtt_ctx *mqtt_ctx, struct mqtt_publish_msg *msg,
    + notiyf_msg.type = MSG_MQTT_MESSAGE_RECEIVED;
    + send_async_msg(APP_ID_MQTT_SERVICE,&notiyf_msg);
  + case MQTT_PUBREL:
  + rc = mqtt_rx_pubrel(ctx, data);
  + case MQTT_PINGRESP:
  + rc = mqtt_rx_pingresp(ctx, data);
  + case MQTT_SUBACK:
  + rc = mqtt_rx_suback(ctx, data);
  + case MQTT_PUBACK:
  + rc = mqtt_rx_puback(ctx, data);
  + case MQTT_PUBREC:
  + rc = mqtt_rx_pubrec(ctx, data);
  + case MQTT_PUBCOMP:
  + rc = mqtt_rx_pubcomp(ctx, data);
***** _mqtt_on_message_received
+ unpack_message(mqtt_msg->msg, mqtt_msg->msg_len);
  + if (!strcmp(cmd, "playTrack")){
                unpack_play_track(data,length);
        } else if (!strcmp(cmd, "pause")){
                on_receive_command(Pause, (void *)NULL);
        } else if (!strcmp(cmd, "resume")){
                on_receive_command(Resume, (void *)NULL);
        } else if (!strcmp(cmd, "forward")){
                on_receive_command(Next, (void *)NULL);
        } else if (!strcmp(cmd, "backward")){
                on_receive_command(Prev, (void *)NULL);
        } else if (!strcmp(cmd, "setVolume")){
                unpack_set_volume(data, length);
        } else if (!strcmp(cmd, "getVolume")){
                on_receive_command(GetVolume, (void *)NULL);
        } else if (!strcmp(cmd, "setMode")){
                unpack_set_mode(data,length);
        } else if (!strcmp(cmd, "getMode")){
                on_receive_command(GetLoopMode, (void *)NULL);
        } else if (!strcmp(cmd, "getTrack")){
                on_receive_command(GetCurrentTrack, (void *)NULL);
        } else if (!strcmp(cmd, "getBoxInfo")){
                on_receive_command(GetSysInfo, (void *)NULL);
        } else if (!strcmp(cmd, "setPoweroff")){
                on_receive_command(SetPowerOff, (void *)NULL);
        } else if (!strcmp(cmd, "getPlayStatus")){
                on_receive_command(GetPlayStatus, (void *)NULL);
        } else if (!strcmp(cmd, "getOnlineStatus")){
                on_receive_command(GetOnlineStatus, (void *)NULL);
        } else if (!strcmp(cmd, "setPlayTrackLists")){
                unpack_play_list_id(data,length);
        } else if (!strcmp(cmd, "getPlayTrackListId")){
                on_receive_command(GetPlayTrackListId, (void *)NULL);
        } else if (!strcmp(cmd, "playVoice")){
                unpack_play_voice(data, length);
        } else if (!strcmp(cmd, "demandMusic")){
                unpack_demand_music(data, length);
        } else if (!strcmp(cmd, "demandMusicOnline")){
                unpack_demandonline_music(data, length);
        } else if (!strcmp(cmd, "trackInfo")){
                unpack_track_info(data, length);
        } else if (!strcmp(cmd, "trackInfoArray")){
                unpack_track_info_array(data, length);
        } else if (!strcmp(cmd, "initret")){
                unpack_predefine_list_id(data, length);
        } else if (!strcmp(cmd, "setList")){
                unpack_track_list(data, length);
        } else if (!strcmp(cmd, "setUpdateListId")){
                unpack_update_list_id(data, length);
        } else if (!strcmp(cmd, "addList")){
                unpack_add_list_id(data, length);
        } else if (!strcmp(cmd, "delList")){
                unpack_delete_list_id(data, length);
        } else if (!strcmp(cmd, "listAddTrack")){
                unpack_add_track_by_id(data, length);
        } else if (!strcmp(cmd, "listRemoveTrack")){
                unpack_delete_track_by_id(data, length);
        } else if (!strcmp(cmd, "playVoiceEmoji")){
                unpack_play_voice_emoji(data, length);
        } else if (!strcmp(cmd, "upgrade")){
                unpack_upgrade_firmware(data, length);
        } else if (!strcmp(cmd, "trackInfoForCollector")){
                unpack_track_info_for_collector(data, length);
        } else if (!strcmp(cmd, "startTestMode")){
                unpack_test_command(data, length);
        } else if (!strcmp(cmd, "getInitialTrackList")) {
                unpack_get_initial_track_list(data, length);
        } else if (!strcmp(cmd, "playTracks")) {
                unpack_play_tracks(data, length);
        } else if (!strcmp(cmd, "getTracks")){
                unpack_get_tracks_command(data, length);


***** async_publish(char *msg, int len)
+ struct mqtt_publish_msg *pub_msg = &client_ctx.pub_msg;
+ pub_msg->msg = msg;
        pub_msg->msg_len = len;
        pub_msg->qos = client_ctx.qos;
        pub_msg->topic = client_ctx.pub_topic;
        pub_msg->topic_len = strlen(client_ctx.pub_topic);
        pub_msg->pkt_id = sys_rand32_get();
+ rc = mqtt_tx_publish(&client_ctx.mqtt_ctx, &client_ctx.pub_msg);
  + rc = mqtt_pack_publish(data->data, &data->len, data->size, msg);
  + tx = net_nbuf_get_tx(ctx->net_ctx, ctx->net_timeout);
  + rc = net_context_send(tx, NULL, ctx->net_timeout, NULL, NULL);
*** bluetooth
**** doc
***** gatt
Bluetooth Low Energy 介绍 低功耗蓝牙介绍
http://www.cnblogs.com/cb168/articles/4844010.html
***** avdtp
http://blog.sina.com.cn/s/blog_69b5d2a50101elze.html
***** 蓝牙电话本
http://www.eefocus.com/majianhui/blog/09-12/182431_fe385.html
http://www.eefocus.com/majianhui/blog/cate_4037_0.html
***** bluedroid
http://source.android.com/devices/bluetooth.html
http://www.cnblogs.com/hzl6255/p/3887547.html
使用btproxy对蓝牙设备进行安全分析
http://www.freebuf.com/articles/wireless/77389.html
***** spec
http://oscar.iitb.ac.in/onsiteDocumentsDirectory/Bluetooth/Bluetooth/index.html
****** 蓝牙协议的命令和事件
http://blog.csdn.net/zhaohc_nj/article/details/7990695
http://blog.chinaunix.net/uid-21411227-id-2780269.html
http://blog.chinaunix.net/uid-21411227-id-2779815.html
****** baseband
http://www.cnblogs.com/hzl6255/p/3840641.html
The link control layer carries out higher-level operations such as inquiry and paging and manages multiple links with different devices and even different piconets. It does this through a set of state machines, which drive the baseband through the following stages to establish links:
1.      Host requests inquiry.
2.      Inquiry is sent using the inquiry hopping sequence.
3.      Inquiry scanning devices respond to the inquiry scan with FHS packets that contain all the information needed to connect with them.
4.      The contents of the FHS packets are passed back to the host.
5.      The host requests connection to one of the devices that responded to the inquiry.
6.      Paging is used to initiate a connection with the selected device.
7.      If the selected device is page scanning it responds to the page.
8.      If the page-scanning device accepts the connection it will begin hopping using the Master’s frequency hopping sequence and timing.
****** hci
http://www.cnblogs.com/hzl6255/p/3800257.html

Command分为六种类型(case OGF)
~0x01 链路控制命令(Link Control Commands)
~0x02 链路政策命令(Link Policy Commands)
~0x03 控制和基带命令(Control & Baseband Commands)
~0x04 信息命令(Informational Parameters)
~0x05 状态命令(Status Parameters)
~0x06 测试命令(Testing Commands)
~0x3F 厂商调试命令(Reserved)

****** l2cap
http://www.cnblogs.com/hzl6255/p/3801732.html
The Logical Link Control and Adaptation Protocol (L2CAP) takes data from the higher layers of the Bluetooth stack and from applications and sends it over the lower layers of the stack.  L2CAP passes packets either to the Host Controller Interface (HCI), or in a host-less system, L2CAP passes packets directly to the Link Manager.  The following figure shows the L2CAP’s position in the Bluetooth stack.
a)      Multiplexing between different higher layer protocols, allowing them to share lower layer links
b)      Segmentation and reassembly to allow transfer of larger packets than lower layers support
c)      Group management, providing one-way transmission to a group of other Bluetooth devices
d)     Quality of service management for higher layer protocols.
http://oscar.iitb.ac.in/onsiteDocumentsDirectory/Bluetooth/Bluetooth/Help/Logical%20Link%20Control%20and%20Adaptation%20Protocol_files/image008.gif
****** HFP
http://www.cnblogs.com/hzl6255/p/3819113.html
****** RFCOMM
http://www.cnblogs.com/hzl6255/p/3811013.html
****** sdp
http://www.cnblogs.com/hzl6255/p/3826558.html
****** lmp
http://www.cnblogs.com/hzl6255/p/3857353.html
http://article.yeeyan.org/view/jianermei/51468
http://oscar.iitb.ac.in/onsiteDocumentsDirectory/Bluetooth/Bluetooth/Help/Link%20Management%20Protocol.htm
1) Attaching slaves to piconets, and allocating their active member addresses.
2) Breaking connections to detach Slaves from a piconet.
3) Configuring the link including Master/Slave switches
4) Establishing ACL and SCO links.
5) Putting connections into Low Power modes: Hold, Sniff and Park.
6) Controlling test modes.
****** ble
http://www.cnblogs.com/hzl6255/p/4127138.html
******* ll
http://www.cnblogs.com/hzl6255/p/4127403.html
******* gap
http://www.cnblogs.com/hzl6255/p/4133596.html
GAP有如下四个目的
- Profile Role
- 可发现模式和过程
- 连接模式和过程
- 安全模式和过程
******* att
http://www.cnblogs.com/hzl6255/p/4141505.html
Attribute PDUs有六种类型
- Requests      : Client->Server, 请求回应
- Responses     : Server->Client, 响应请求.
- Commands      : Client->Server, 命令
- Notifications : Server->Client, 服务端通知
- Indications   : Server->Client, 请求确认
- Confirmations : Client->Server, Ind确认
******* gatt
http://www.cnblogs.com/hzl6255/p/4158363.html
GATT中最上层是Profile，Profile由一个或多个服务(Service)组成
服务是由Characteristics组成，或是其他服务的引用(Reference)
Characteristic包含一个值(Value)，可能包含该Value的相关信息

GATT中定义了11项Feature
1.  Server Configuration
2.  Primary Service Discovery
3.  Relationship Discovery
4.  Characteristic Discovery
5.  Characteristic Descriptor Discovery
6.  Reading a Characteristic Value
7.  Writing a Characteristic Value
8.  Notification of a Characteristic Value
9.  Indication of a Characteristic Value
10. Reading a Characteristic Descriptor
11. Writing a Characteristic Descriptor
每个Feature都有对应的过程和子过程，这些过程描述了如何使用ATT来实现各自的功能

**** a2dp
***** bt_a2dp_init
+ bt_avdtp_register(&avdtp_cb);
+ static struct bt_avdtp_event_cb avdtp_cb = {
        .ind = &cb_ind,
        .cfm = &cb_cfm
***** bt_avdtp_l2cap_accept
+ static struct bt_l2cap_chan_ops ops = {
  .connected = bt_avdtp_l2cap_connected,
  .disconnected = bt_avdtp_l2cap_disconnected,
  .recv = bt_avdtp_l2cap_recv,

**** handsfree
***** handsfree_enable();
+ static struct bt_hfp_hf_cb hf_cb = {
  .connected = connected,
  .disconnected = disconnected,
+ err = bt_hfp_hf_register(& hf_cb);
  + bt_hf = cb;
+ hfp_hf_init();
  + static struct bt_rfcomm_server chan = {
    .channel = BT_RFCOMM_CHAN_HFP_HF,
    .accept = bt_hfp_hf_accept,
  + bt_rfcomm_server_register(&chan);
    + (rfcomm_server_lookup_channel(server->channel)) {
    + server->_next = servers;
***** bt_hfp_hf_accept(struct bt_conn *conn, struct bt_rfcomm_dlc **dlc)
        + static struct bt_rfcomm_dlc_ops ops = {
          .connected = hfp_hf_connected,
          .disconnected = hfp_hf_disconnected,
          .recv = hfp_hf_recv,
        + struct bt_hfp_hf *hf = &bt_hfp_hf_pool[i];
          hf->at.buf = hf->hf_buffer;
          hf->at.buf_max_len = HF_MAX_BUF_LEN;
          hf->rfcomm_dlc.ops = &ops;
          hf->rfcomm_dlc.mtu = BLUETOOTH_HFP_MAX_MTU;
          *dlc = &hf->rfcomm_dlc;
*****  rfcomm_dlc_connected(dlc);
      + dlc->state = BT_RFCOMM_STATE_CONNECTED;
      + rfcomm_send_msc(dlc, BT_RFCOMM_MSG_CMD_CR);
      + k_thread_spawn(dlc->stack, sizeof(dlc->stack), rfcomm_dlc_tx_thread,
      + dlc->ops->connected(dlc);
      + .connected = hfp_hf_connected,
        + struct bt_hfp_hf *hf = CONTAINER_OF(dlc, struct bt_hfp_hf, rfcomm_dlc);
        + hf_slc_establish(hf);
          + err = hfp_hf_send_cmd(hf, brsf_resp, brsf_finish, "AT+BRSF=%u",
            + at_register(&hf->at, resp, finish);
            + ret = bt_rfcomm_dlc_send(&hf->rfcomm_dlc, buf);
              + net_buf_put(&dlc->tx_queue, buf);
*****  hfp_hf_recv
- at_parse_input(&hf->at, buf)
  + parser_cb[at->state](at, buf);
  + static handle_parse_input_t parser_cb[] = {
  + at_state_start, /* AT_STATE_START */
  + at_state_start_cr, /* AT_STATE_START_CR */
  + at_state_start_lf, /* AT_STATE_START_LF */
  + at_state_get_cmd_string, /* AT_STATE_GET_CMD_STRING */
  + at_state_process_cmd, /* AT_STATE_PROCESS_CMD */
  + at_state_get_result_string, /* AT_STATE_GET_RESULT_STRING */
  + at_state_process_result, /* AT_STATE_PROCESS_RESULT */
  + at_state_unsolicited_cmd /* AT_STATE_UNSOLICITED_CMD */

***** rfcomm_recv
  + struct bt_rfcomm_session *session = RFCOMM_SESSION(chan);
  + dlci = BT_RFCOMM_GET_DLCI(hdr->address);
  + frame_type = BT_RFCOMM_GET_FRAME_TYPE(hdr->control);
  + rfcomm_check_fcs(fcs_len, buf->data, fcs)
  + switch (frame_type) {
  + case BT_RFCOMM_SABM:
  + rfcomm_handle_sabm(session, dlci);
    + dlc = rfcomm_dlcs_lookup_dlci(session->dlcs, dlci);
    + dlc = rfcomm_dlc_accept(session, dlci);
      + channel = BT_RFCOMM_GET_CHANNEL(dlci);
      + server = rfcomm_server_lookup_channel(channel);
      + server->accept(session->br_chan.chan.conn, &dlc) < 0) {
      + static int bt_hfp_hf_accept(struct bt_conn *conn, struct bt_rfcomm_dlc **dlc)
        + static struct bt_rfcomm_dlc_ops ops = {
          .connected = hfp_hf_connected,
          .disconnected = hfp_hf_disconnected,
          .recv = hfp_hf_recv,
        + struct bt_hfp_hf *hf = &bt_hfp_hf_pool[i];
          hf->at.buf = hf->hf_buffer;
          hf->at.buf_max_len = HF_MAX_BUF_LEN;
          hf->rfcomm_dlc.ops = &ops;
          hf->rfcomm_dlc.mtu = BLUETOOTH_HFP_MAX_MTU;
          *dlc = &hf->rfcomm_dlc;
      + rfcomm_dlc_init(dlc, session, dlci, BT_RFCOMM_ROLE_ACCEPTOR);
        + dlc->dlci = dlci;
          dlc->session = session;
          dlc->rx_credit = RFCOMM_DEFAULT_CREDIT;
          dlc->state = BT_RFCOMM_STATE_INIT;
          dlc->role = role;
    + result = rfcomm_dlc_security(dlc);
    + rfcomm_send_ua(session, dlci) < 0) {
      + buf = bt_l2cap_create_pdu(&rfcomm_session_pool, K_FOREVER);
      + cr = BT_RFCOMM_RESP_CR(session->role);
        hdr->address = BT_RFCOMM_SET_ADDR(dlci, cr);
        hdr->control = BT_RFCOMM_SET_CTRL(BT_RFCOMM_UA,
        hdr->length = BT_RFCOMM_SET_LEN_8(0);
    + rfcomm_dlc_connected(dlc);
      + dlc->state = BT_RFCOMM_STATE_CONNECTED;
      + rfcomm_send_msc(dlc, BT_RFCOMM_MSG_CMD_CR);
      + k_thread_spawn(dlc->stack, sizeof(dlc->stack), rfcomm_dlc_tx_thread,
      + dlc->ops->connected(dlc);
      + .connected = hfp_hf_connected,
        + struct bt_hfp_hf *hf = CONTAINER_OF(dlc, struct bt_hfp_hf, rfcomm_dlc);
        + hf_slc_establish(hf);
          + err = hfp_hf_send_cmd(hf, brsf_resp, brsf_finish, "AT+BRSF=%u",
            + at_register(&hf->at, resp, finish);
            + ret = bt_rfcomm_dlc_send(&hf->rfcomm_dlc, buf);
              + net_buf_put(&dlc->tx_queue, buf);
  + case BT_RFCOMM_UIH:
    + rfcomm_handle_msg(session, buf);
    + rfcomm_handle_data(session, buf, dlci,
      + dlc = rfcomm_dlcs_lookup_dlci(session->dlcs, dlci);
      + dlc->ops->recv(dlc, buf);
      + static void hfp_hf_recv(struct bt_rfcomm_dlc *dlc, struct net_buf *buf)
  + case BT_RFCOMM_DISC:
    + rfcomm_handle_disc(session, dlci);
  + case BT_RFCOMM_UA:
    + rfcomm_handle_ua(session, dlci);
  + case BT_RFCOMM_DM:
    + rfcomm_handle_dm(session, dlci);
***** rfcomm_accept
+ session = rfcomm_session_new(BT_RFCOMM_ROLE_ACCEPTOR);
  + static struct bt_l2cap_chan_ops ops = {
    .connected = rfcomm_connected,
    .disconnected = rfcomm_disconnected,
    .recv = rfcomm_recv,
    .encrypt_change = rfcomm_encrypt_change,
  + struct bt_rfcomm_session *session = &bt_rfcomm_pool[i];
  + session->br_chan.chan.ops = &ops;
    session->br_chan.rx.mtu	= CONFIG_BLUETOOTH_RFCOMM_L2CAP_MTU;
    session->state = BT_RFCOMM_STATE_INIT;
    session->role = role;

***** bt_l2cap_br_connected
+ if (fchan->accept(conn, &chan) < 0) {
+ rfcomm_accept
  + session = rfcomm_session_new(BT_RFCOMM_ROLE_ACCEPTOR);
    + static struct bt_l2cap_chan_ops ops = {
      .connected = rfcomm_connected,
      .disconnected = rfcomm_disconnected,
      .recv = rfcomm_recv,
      .encrypt_change = rfcomm_encrypt_change,
    + struct bt_rfcomm_session *session = &bt_rfcomm_pool[i];
    + session->br_chan.chan.ops = &ops;
      session->br_chan.rx.mtu	= CONFIG_BLUETOOTH_RFCOMM_L2CAP_MTU;
      session->state = BT_RFCOMM_STATE_INIT;
      session->role = role;
  + l2cap_br_chan_add(conn, chan, NULL)
    + struct bt_l2cap_br_chan *ch = l2cap_br_chan_alloc_cid(conn, chan);
    + bt_l2cap_chan_add(conn, chan, destroy);
  + connect_fixed_channel(ch);
    + chan->chan.ops->connected(&chan->chan);
    + rfcomm_connected
      + rfcomm_send_sabm(session, 0);
*****  bt_l2cap_br_recv(struct bt_conn *conn, struct net_buf *buf)
+ cid = sys_le16_to_cpu(hdr->cid);
+ chan = bt_l2cap_br_lookup_rx_cid(conn, cid);
+ check_fixed_channel(chan);
+ chan->ops->recv(chan, buf);
+ rfcomm_recv,
  + struct bt_rfcomm_session *session = RFCOMM_SESSION(chan);
  + dlci = BT_RFCOMM_GET_DLCI(hdr->address);
  + frame_type = BT_RFCOMM_GET_FRAME_TYPE(hdr->control);
  + rfcomm_check_fcs(fcs_len, buf->data, fcs)
  + switch (frame_type) {
  + case BT_RFCOMM_SABM:
  + rfcomm_handle_sabm(session, dlci);
    + dlc = rfcomm_dlcs_lookup_dlci(session->dlcs, dlci);
    + dlc = rfcomm_dlc_accept(session, dlci);
      + channel = BT_RFCOMM_GET_CHANNEL(dlci);
      + server = rfcomm_server_lookup_channel(channel);
      + server->accept(session->br_chan.chan.conn, &dlc) < 0) {
      + static int bt_hfp_hf_accept(struct bt_conn *conn, struct bt_rfcomm_dlc **dlc)
        + static struct bt_rfcomm_dlc_ops ops = {
          .connected = hfp_hf_connected,
          .disconnected = hfp_hf_disconnected,
          .recv = hfp_hf_recv,
        + struct bt_hfp_hf *hf = &bt_hfp_hf_pool[i];
          hf->at.buf = hf->hf_buffer;
          hf->at.buf_max_len = HF_MAX_BUF_LEN;
          hf->rfcomm_dlc.ops = &ops;
          hf->rfcomm_dlc.mtu = BLUETOOTH_HFP_MAX_MTU;
          *dlc = &hf->rfcomm_dlc;
      + rfcomm_dlc_init(dlc, session, dlci, BT_RFCOMM_ROLE_ACCEPTOR);
        + dlc->dlci = dlci;
          dlc->session = session;
          dlc->rx_credit = RFCOMM_DEFAULT_CREDIT;
          dlc->state = BT_RFCOMM_STATE_INIT;
          dlc->role = role;
    + result = rfcomm_dlc_security(dlc);
    + rfcomm_send_ua(session, dlci) < 0) {
      + buf = bt_l2cap_create_pdu(&rfcomm_session_pool, K_FOREVER);
      + cr = BT_RFCOMM_RESP_CR(session->role);
        hdr->address = BT_RFCOMM_SET_ADDR(dlci, cr);
        hdr->control = BT_RFCOMM_SET_CTRL(BT_RFCOMM_UA,
        hdr->length = BT_RFCOMM_SET_LEN_8(0);
    + rfcomm_dlc_connected(dlc);
      + dlc->state = BT_RFCOMM_STATE_CONNECTED;
      + rfcomm_send_msc(dlc, BT_RFCOMM_MSG_CMD_CR);
      + k_thread_spawn(dlc->stack, sizeof(dlc->stack), rfcomm_dlc_tx_thread,
      + dlc->ops->connected(dlc);
      + .connected = hfp_hf_connected,
        + struct bt_hfp_hf *hf = CONTAINER_OF(dlc, struct bt_hfp_hf, rfcomm_dlc);
        + hf_slc_establish(hf);
          + err = hfp_hf_send_cmd(hf, brsf_resp, brsf_finish, "AT+BRSF=%u",
            + at_register(&hf->at, resp, finish);
            + ret = bt_rfcomm_dlc_send(&hf->rfcomm_dlc, buf);
              + net_buf_put(&dlc->tx_queue, buf);
  + case BT_RFCOMM_UIH:
    + rfcomm_handle_msg(session, buf);
    + rfcomm_handle_data(session, buf, dlci,
  + case BT_RFCOMM_DISC:
    + rfcomm_handle_disc(session, dlci);
  + case BT_RFCOMM_UA:
    + rfcomm_handle_ua(session, dlci);
  + case BT_RFCOMM_DM:
    + rfcomm_handle_dm(session, dlci);

***** bt_rfcomm_init
+ static struct bt_l2cap_server server = {
               .psm       = BT_L2CAP_PSM_RFCOMM,
               .accept    = rfcomm_accept,
               .sec_level = BT_SECURITY_LOW,
+ bt_l2cap_br_server_register(&server);

**** gap/gatt
***** doc
Bluetooth Low Energy 介绍 低功耗蓝牙介绍
http://www.cnblogs.com/cb168/articles/4844010.html

|ANP| Alert Notification Profile|
| ANS| Alert Notification Service|
| BAS| Battery Service|
| BLP| Blood Pressure Profile|
| BLS| Blood Pressure Service|
| CPP| Cycling Power Profile|
| CPS| Cycling Power Service|
| CSCP| Cycling Speed and Cadence Profile|
| CSCS| Cycling Speed and Cadence Service|
| CTS| Current Time Service|
| DIS| Device Information Service|
| FMP| Find Me Profile|
| GLP| Glucose Profile|
|HIDS| HID Service|
| HOGP| HID over GATT Profile|
| HTP| Health Thermometer Profile|
| HTS| Health Thermometer Service|
| HRP| Heart Rate Profile|
| HRS| Heart Rate Service|
| IAS| Immediate Alert Service|
| LLS| Link Loss Service|
| LNP| Location and Navigation Profile|
| LNS| Location and Navigation Service|
| NDCS| Next DST Change Service|
| PASP| Phone Alert Status Profile|
| PASS| Phone Alert Status Service|
| PXP| Proximity Profile|
| RSCP| Running Speed and Cadence Profile|
| RSCS| Running Speed and Cadence Service|
|RTUS| Reference Time Update Service|
| ScPP| Scan Parameters Profile|
| ScPS| Scan Parameters Service|
| TIP| Time Profile|
| TPS| Tx Power Service |
***** peripheral_hids/main
+ gap_init(DEVICE_NAME, HOG_APPEARANCE);
  + gap_name = name;
  + gap_appearance = appearance;
  + bt_gatt_register(attrs, ARRAY_SIZE(attrs));
    + int bt_gatt_register(struct bt_gatt_attr *attrs, size_t count)
    + static struct bt_gatt_attr *db;
    + db = attrs;
    + attrs->handle = ++handle;
+ bas_init();
  + bt_gatt_register(attrs, ARRAY_SIZE(attrs));
+ dis_init(CONFIG_SOC, "Manufacturer");
  + bt_gatt_register(attrs, ARRAY_SIZE(attrs));
+ hog_init();
***** bt_att_accept
+       static struct bt_l2cap_chan_ops ops = {
   .connected = bt_att_connected,
   .disconnected = bt_att_disconnected,
   .recv = bt_att_recv,
+ for (i = 0; i < ARRAY_SIZE(bt_req_pool); i++) {
+ att->chan.chan.ops = &ops;
+ *chan = &att->chan.chan;
***** bt_att_connected
+ bt_gatt_connected(ch->chan.conn);
  + bt_gatt_foreach_attr(0x0001, 0xffff, connected_cb, conn);
    + for (attr = db; attr; attr = bt_gatt_attr_next(attr)) {
    + if (func(attr, user_data) == BT_GATT_ITER_STOP) {
      + static uint8_t connected_cb(const struct bt_gatt_attr *attr, void *user_data)
***** bt_att_recv
+ for (i = 0; i < ARRAY_SIZE(handlers); i++) {
+ err = handlers[i].func(att, buf);
****** handlers
static const struct {
        uint8_t  op;
        uint8_t  (*func)(struct bt_att *att, struct net_buf *buf);
        uint8_t  expect_len;
} handlers[] = {
+ { BT_ATT_OP_ERROR_RSP, att_error_rsp,
+ { BT_ATT_OP_MTU_REQ, att_mtu_req,
+ { BT_ATT_OP_MTU_RSP, att_mtu_rsp,
+ { BT_ATT_OP_FIND_INFO_REQ, att_find_info_req,
+ { BT_ATT_OP_FIND_INFO_RSP, att_handle_find_info_rsp,
+ { BT_ATT_OP_FIND_TYPE_REQ, att_find_type_req,
+ { BT_ATT_OP_FIND_TYPE_RSP, att_handle_find_type_rsp,
+ { BT_ATT_OP_READ_TYPE_REQ, att_read_type_req,
+ { BT_ATT_OP_READ_TYPE_RSP, att_handle_read_type_rsp,
****** { BT_ATT_OP_READ_REQ, att_read_req,
  + handle = sys_le16_to_cpu(req->handle);
  + att_read_rsp(att, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
  + struct read_data data;
  + data.buf = bt_att_create_pdu(conn, rsp, 0);
  + data.att = att;
    data.offset = offset;
  + bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    + static uint8_t read_cb(const struct bt_gatt_attr *attr, void *user_data)
    + data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
    + data->err = check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
    + read = attr->read(conn, attr, data->buf->data + data->buf->len,
    + net_buf_add(data->buf, read);
  + bt_l2cap_send(conn, BT_L2CAP_CID_ATT, data.buf);
+ { BT_ATT_OP_READ_RSP, att_handle_read_rsp,
+ { BT_ATT_OP_READ_BLOB_REQ, att_read_blob_req,
+ { BT_ATT_OP_READ_BLOB_RSP, att_handle_read_blob_rsp,
+ { BT_ATT_OP_READ_MULT_REQ, att_read_mult_req,
+ { BT_ATT_OP_READ_MULT_RSP, att_handle_read_mult_rsp,
+ { BT_ATT_OP_READ_GROUP_REQ, att_read_group_req,
+ { BT_ATT_OP_WRITE_REQ, att_write_req,
+ { BT_ATT_OP_WRITE_RSP, att_handle_write_rsp, 0 },
+ { BT_ATT_OP_PREPARE_WRITE_REQ, att_prepare_write_req,
+ { BT_ATT_OP_PREPARE_WRITE_RSP, att_handle_prepare_write_rsp,
+ { BT_ATT_OP_EXEC_WRITE_REQ, att_exec_write_req,
+ { BT_ATT_OP_EXEC_WRITE_RSP, att_handle_exec_write_rsp, 0 },
+ { BT_ATT_OP_NOTIFY, att_notify,
+ { BT_ATT_OP_INDICATE, att_indicate,
+ { BT_ATT_OP_CONFIRM, att_confirm, 0 },
+ { BT_ATT_OP_WRITE_CMD, att_write_cmd,
+ { BT_ATT_OP_SIGNED_WRITE_CMD, att_signed_write_cmd,
**** beacon
+ main
  + bt_enable(bt_ready);
  +

**** hci_core
***** doc
蓝牙核心技术概述（四）：蓝牙协议规范（HCI、L2CAP、SDP、RFOCMM）
http://blog.csdn.net/xubin341719/article/details/38305331
***** bt_enable
+ struct bt_dev bt_dev = {
        .ncmd_sem      = K_SEM_INITIALIZER(bt_dev.ncmd_sem, 1, 1),
        .cmd_tx_queue  = K_FIFO_INITIALIZER(bt_dev.cmd_tx_queue),
        .rx_queue      = K_FIFO_INITIALIZER(bt_dev.rx_queue),

+ bt_enable(bt_ready);
  + k_thread_spawn(cmd_tx_thread_stack, sizeof(cmd_tx_thread_stack),
                     (k_thread_entry_t)hci_cmd_tx_thread, NULL, NULL, NULL,
  + k_thread_spawn(rx_thread_stack, sizeof(rx_thread_stack),
                    (k_thread_entry_t)hci_rx_thread, cb, NULL, NULL,

***** bt_hci_cmd_send_sync
int bt_hci_cmd_send_sync(uint16_t opcode, struct net_buf *buf,
+ buf = bt_hci_cmd_create(opcode, 0);
  + buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
  + cmd(buf)->type = BT_BUF_CMD;
        cmd(buf)->opcode = opcode;
        cmd(buf)->sync = NULL;
        hdr = net_buf_add(buf, sizeof(*hdr));
        hdr->opcode = sys_cpu_to_le16(opcode);
        hdr->param_len = param_len;
+ k_sem_init(&sync_sem, 0, 1);
        cmd(buf)->sync = &sync_sem;
+ net_buf_put(&bt_dev.cmd_tx_queue, buf);
+ k_sem_take(&sync_sem, K_FOREVER);
***** bt_conn_init();
    + bt_att_init();
      + static struct bt_l2cap_fixed_chan chan = {
         .cid		= BT_L2CAP_CID_ATT,
         .accept		= bt_att_accept,
      + bt_l2cap_le_fixed_chan_register(&chan);
        + chan->_next = le_channels;
        + channels = chan;
    + bt_smp_init();
      + static struct bt_l2cap_fixed_chan chan = {
            .cid		= BT_L2CAP_CID_SMP,
            .accept		= bt_smp_accept,
      + bt_l2cap_le_fixed_chan_register(&chan);
      + static struct bt_l2cap_fixed_chan br_chan = {
                    .cid		= BT_L2CAP_CID_BR_SMP,
                    .accept		= bt_smp_br_accept,
      + bt_l2cap_br_fixed_chan_register(&br_chan);
      + static struct bt_pub_key_cb pub_key_cb = {
            .func           = bt_smp_pkey_ready,
      + bt_pub_key_gen(&pub_key_cb);
        + new_cb->_next = pub_key_cb;
        + pub_key_cb = new_cb;
        + bt_hci_cmd_send_sync(BT_HCI_OP_LE_P256_PUBLIC_KEY, NULL, NULL);
        + cb->func(NULL);
    + bt_l2cap_init();
      + static struct bt_l2cap_fixed_chan chan = {
            .cid	= BT_L2CAP_CID_LE_SIG,
            .accept	= l2cap_accept,
      + bt_l2cap_le_fixed_chan_register(&chan);
      + bt_l2cap_br_init();
        + static struct bt_l2cap_fixed_chan chan_br = {
                    .cid	= BT_L2CAP_CID_BR_SIG,
                    .accept = l2cap_br_accept,
        + bt_l2cap_br_fixed_chan_register(&chan_br);
        + bt_rfcomm_init();
          + static struct bt_l2cap_server server = {
           .psm       = BT_L2CAP_PSM_RFCOMM,
           .accept    = rfcomm_accept,
           .sec_level = BT_SECURITY_LOW,
          + bt_l2cap_br_server_register(&server);
            + l2cap_br_server_lookup_psm(server->psm)
            + server->_next = br_servers;
            + br_servers = server;
        + bt_avdtp_init();
          + static struct bt_l2cap_server avdtp_l2cap = {
             .psm = BT_L2CAP_PSM_AVDTP,
             .sec_level = BT_SECURITY_MEDIUM,
             .accept = bt_avdtp_l2cap_accept,
          + bt_l2cap_br_server_register(&avdtp_l2cap);
        + bt_sdp_init();
          + static struct bt_l2cap_server server = {
              .psm = SDP_PSM,
              .accept = bt_sdp_accept,
          + bt_l2cap_br_server_register(&server);
        + bt_a2dp_init();
          + bt_avdtp_register(& avdtp_cb);
            + event_cb = cb;
    + background_scan_init();
***** hci_rx_thread
  + static void hci_rx_thread(bt_ready_cb_t ready_cb)
    + ready_cb(bt_init());//用户回调
      + static int bt_init(void)
        + bt_hci_ecc_init();
        + err = drv->open();
          + static int h4_open(void)
        + err = hci_init();
          + common_init();
            + bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
            + hci_reset_complete(rsp);
              + atomic_set(bt_dev.flags, BIT(BT_DEV_ENABLE));
            + prng_init(&prng);
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
            + read_local_features_complete(rsp);
              + struct bt_hci_rp_read_local_features *rp = (void *)buf->data;
              + memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
            + read_local_ver_complete(rsp);
              + bt_dev.hci_version = rp->hci_version;
              + bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
              + bt_dev.lmp_version = rp->lmp_version;
              + bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
              + bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
            + read_bdaddr_complete(rsp);
              + bt_addr_copy(&bt_dev.id_addr.a, &rp->bdaddr);
              + bt_dev.id_addr.type = BT_ADDR_LE_PUBLIC;
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
            + set_flow_control();
              + bt_hci_cmd_create(BT_HCI_OP_HOST_BUFFER_SIZE,
              + struct bt_hci_cp_host_buffer_size *hbs;
              + hbs->acl_amtu = sys_cpu_to_le16(CONFIG_BLUETOOTH_L2CAP_IN_MTU +
              + hbs->acl_pkts = sys_cpu_to_le16(CONFIG_BLUETOOTH_ACL_IN_COUNT);
              + err = bt_hci_cmd_send_sync(BT_HCI_OP_HOST_BUFFER_SIZE, buf, NULL);
              + buf = bt_hci_cmd_create(BT_HCI_OP_SET_CTL_TO_HOST_FLOW, 1);
          + le_init();
            + bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
            + read_le_features_complete(rsp);
              + struct bt_hci_rp_le_read_local_features *rp = (void *)buf->data;
              + memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
            + bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE, NULL, &rsp);
            + le_read_buffer_size_complete(rsp);
              + bt_dev.le.mtu = sys_le16_to_cpu(rp->le_max_len);
              + k_sem_init(&bt_dev.le.pkts, rp->le_max_num, rp->le_max_num);
            + if (BT_FEAT_BREDR(bt_dev.features)) {
              + bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
            + bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
            + bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
              + struct bt_hci_cp_le_set_event_mask *cp_mask;
            + bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
          + br_init();
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &buf);
            + read_buffer_size_complete(buf);
              + bt_dev.br.mtu = sys_le16_to_cpu(rp->acl_max_len);
              + k_sem_init(&bt_dev.br.pkts, pkts, pkts);
            + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_SSP_MODE, buf, NULL);
            + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_INQUIRY_MODE, buf, NULL);
            + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_LOCAL_NAME, buf, NULL);
            + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_PAGE_TIMEOUT, buf, NULL);
            + if (BT_FEAT_SC(bt_dev.features)) {
              + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_SC_HOST_SUPP, buf,
          + set_static_addr();
            + bt_storage->read(NULL, BT_STORAGE_ID_ADDR,
            + bt_addr_le_create_static(&bt_dev.id_addr);
              + create_random_addr(addr);
              + BT_ADDR_SET_STATIC(&addr->a);
            + set_random_address(&bt_dev.id_addr.a);
              + bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
          + show_dev_info();
        + err = bt_conn_init();
          + bt_att_init();
            + static struct bt_l2cap_fixed_chan chan = {
               .cid		= BT_L2CAP_CID_ATT,
               .accept		= bt_att_accept,
            + bt_l2cap_le_fixed_chan_register(&chan);
              + chan->_next = le_channels;
              + channels = chan;
          + bt_smp_init();
            + static struct bt_l2cap_fixed_chan chan = {
                  .cid		= BT_L2CAP_CID_SMP,
                  .accept		= bt_smp_accept,
            + bt_l2cap_le_fixed_chan_register(&chan);
            + static struct bt_l2cap_fixed_chan br_chan = {
                          .cid		= BT_L2CAP_CID_BR_SMP,
                          .accept		= bt_smp_br_accept,
            + bt_l2cap_br_fixed_chan_register(&br_chan);
            + static struct bt_pub_key_cb pub_key_cb = {
                  .func           = bt_smp_pkey_ready,
            + bt_pub_key_gen(&pub_key_cb);
              + new_cb->_next = pub_key_cb;
              + pub_key_cb = new_cb;
              + bt_hci_cmd_send_sync(BT_HCI_OP_LE_P256_PUBLIC_KEY, NULL, NULL);
              + cb->func(NULL);
          + bt_l2cap_init();
            + static struct bt_l2cap_fixed_chan chan = {
                  .cid	= BT_L2CAP_CID_LE_SIG,
                  .accept	= l2cap_accept,
            + bt_l2cap_le_fixed_chan_register(&chan);
            + bt_l2cap_br_init();
              + static struct bt_l2cap_fixed_chan chan_br = {
                          .cid	= BT_L2CAP_CID_BR_SIG,
                          .accept = l2cap_br_accept,
              + bt_l2cap_br_fixed_chan_register(&chan_br);
              + bt_rfcomm_init();
                + static struct bt_l2cap_server server = {
                 .psm       = BT_L2CAP_PSM_RFCOMM,
                 .accept    = rfcomm_accept,
                 .sec_level = BT_SECURITY_LOW,
                + bt_l2cap_br_server_register(&server);
                  + l2cap_br_server_lookup_psm(server->psm)
                  + server->_next = br_servers;
                  + br_servers = server;
              + bt_avdtp_init();
                + static struct bt_l2cap_server avdtp_l2cap = {
                   .psm = BT_L2CAP_PSM_AVDTP,
                   .sec_level = BT_SECURITY_MEDIUM,
                   .accept = bt_avdtp_l2cap_accept,
                + bt_l2cap_br_server_register(&avdtp_l2cap);
              + bt_sdp_init();
                + static struct bt_l2cap_server server = {
                    .psm = SDP_PSM,
                    .accept = bt_sdp_accept,
                + bt_l2cap_br_server_register(&server);
              + bt_a2dp_init();
                + bt_avdtp_register(& avdtp_cb);
                  + event_cb = cb;
          + background_scan_init();
        + bt_monitor_send(BT_MONITOR_OPEN_INDEX, NULL, 0);
          + bt_le_scan_update(false);
    + while (1) {
      + buf = net_buf_get(&bt_dev.rx_queue, K_FOREVER);
      + case BT_BUF_ACL_IN:
        + hci_acl(buf);
          + handle = sys_le16_to_cpu(hdr->handle);
          + conn = bt_conn_lookup_handle(acl(buf)->handle);
            + for (i = 0; i < ARRAY_SIZE(conns); i++) {
              + return bt_conn_ref(&conns[i]);
          + bt_conn_recv(conn, buf, flags);
            + memcpy(net_buf_add(conn->rx, buf->len), buf->data, buf->len);
                conn->rx_len -= buf->len;
            + bt_l2cap_recv(conn, buf);
              + if (conn->type == BT_CONN_TYPE_BR) {
                bt_l2cap_br_recv(conn, buf);
              + cid = sys_le16_to_cpu(hdr->cid);
              + chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
              + l2cap_chan_recv(chan, buf);
                + if (L2CAP_LE_CID_IS_DYN(ch->rx.cid)) {
                  + l2cap_chan_le_recv(ch, buf);
                + chan->ops->recv(chan, buf);
      + case BT_BUF_EVT:
        + hci_event(buf);
***** l2cap_chan_le_recv
+ chan->_sdu = chan->chan.ops->alloc_buf(&chan->chan);
+ bt_l2cap_chan_disconnect(&chan->chan);
+ chan->chan.ops->recv(&chan->chan, chan->_sdu);
***** hci_acl
 + hci_acl(buf);
   + handle = sys_le16_to_cpu(hdr->handle);
     + conn = bt_conn_lookup_handle(acl(buf)->handle);
       + for (i = 0; i < ARRAY_SIZE(conns); i++) {
         + return bt_conn_ref(&conns[i]);
     + bt_conn_recv(conn, buf, flags);
       + memcpy(net_buf_add(conn->rx, buf->len), buf->data, buf->len);
           conn->rx_len -= buf->len;
       + bt_l2cap_recv(conn, buf);
         + if (conn->type == BT_CONN_TYPE_BR) {
         + bt_l2cap_br_recv(conn, buf);
           + check_fixed_channel(chan);
             + if (br_chan->rx.cid < L2CAP_BR_CID_DYN_START) {
             + connect_fixed_channel(br_chan);
               + chan->chan.ops->connected(&chan->chan);
           + chan->ops->recv(chan, buf);
         + cid = sys_le16_to_cpu(hdr->cid);
         + chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
         + l2cap_chan_recv(chan, buf);
           + if (L2CAP_LE_CID_IS_DYN(ch->rx.cid)) {
             + l2cap_chan_le_recv(ch, buf);
           + chan->ops->recv(chan, buf);
             + .recv = l2cap_recv,
***** le_conn_req
  + le_conn_req(l2cap, hdr->ident, buf);
    + psm = sys_le16_to_cpu(req->psm);
      scid = sys_le16_to_cpu(req->scid);
      mtu = sys_le16_to_cpu(req->mtu);
      mps = sys_le16_to_cpu(req->mps);
      credits = sys_le16_to_cpu(req->credits);
    + server = l2cap_server_lookup_psm(psm);
    + if (conn->sec_level < server->sec_level) {
    + if (server->accept(conn, &chan) < 0) { //server
    + l2cap_chan_add(conn, chan, l2cap_chan_destroy)
      + struct bt_l2cap_le_chan *ch = l2cap_chan_alloc_cid(conn, chan);
      + bt_l2cap_chan_add(conn, chan, destroy);
    + l2cap_chan_tx_init(ch);
        ch->tx.cid = scid;
        ch->tx.mps = mps;
        ch->tx.mtu = mtu;
        l2cap_chan_tx_give_credits(ch, credits);
        l2cap_chan_rx_init(ch);
        l2cap_chan_rx_give_credits(ch, L2CAP_LE_MAX_CREDITS);
        chan->psm = server->psm;
    + bt_l2cap_chan_set_state(chan, BT_L2CAP_CONNECTED);
      + chan->state = state;
    + if (chan->ops && chan->ops->connected) {
                        chan->ops->connected(chan); //server
    + bt_l2cap_send(conn, BT_L2CAP_CID_LE_SIG, buf);

***** l2cap_recv(struct bt_l2cap_chan *chan, struct net_buf *buf)
+ case BT_L2CAP_CONN_PARAM_RSP:
  + le_conn_param_rsp(l2cap, buf);
+ case BT_L2CAP_CONN_PARAM_REQ:
  + le_conn_param_update_req(l2cap, hdr->ident, buf);
+ case BT_L2CAP_LE_CONN_REQ:
  + le_conn_req(l2cap, hdr->ident, buf);
    + psm = sys_le16_to_cpu(req->psm);
      scid = sys_le16_to_cpu(req->scid);
      mtu = sys_le16_to_cpu(req->mtu);
      mps = sys_le16_to_cpu(req->mps);
      credits = sys_le16_to_cpu(req->credits);
    + server = l2cap_server_lookup_psm(psm);
    + if (conn->sec_level < server->sec_level) {
    + if (server->accept(conn, &chan) < 0) {
    + l2cap_chan_add(conn, chan, l2cap_chan_destroy)
      + struct bt_l2cap_le_chan *ch = l2cap_chan_alloc_cid(conn, chan);
      + bt_l2cap_chan_add(conn, chan, destroy);
    + l2cap_chan_tx_init(ch);
        ch->tx.cid = scid;
        ch->tx.mps = mps;
        ch->tx.mtu = mtu;
        l2cap_chan_tx_give_credits(ch, credits);
        l2cap_chan_rx_init(ch);
        l2cap_chan_rx_give_credits(ch, L2CAP_LE_MAX_CREDITS);
        chan->psm = server->psm;
    + bt_l2cap_chan_set_state(chan, BT_L2CAP_CONNECTED);
      + chan->state = state;
    + if (chan->ops && chan->ops->connected) {
                        chan->ops->connected(chan); //server
    + bt_l2cap_send(conn, BT_L2CAP_CID_LE_SIG, buf);
+ case BT_L2CAP_LE_CONN_RSP:
  + le_conn_rsp(l2cap, hdr->ident, buf);
+ case BT_L2CAP_DISCONN_REQ:
  + le_disconn_req(l2cap, hdr->ident, buf);
+ case BT_L2CAP_DISCONN_RSP:
  + le_disconn_rsp(l2cap, hdr->ident, buf);
+ case BT_L2CAP_LE_CREDITS:
  + le_credits(l2cap, hdr->ident, buf);
+ case BT_L2CAP_CMD_REJECT:
  + reject_cmd(l2cap, hdr->ident, buf);
***** le_conn_complete
     + le_conn_complete(buf);
       + id_addr = find_id_addr(&evt->peer_addr);
       + conn = bt_conn_lookup_state_le(id_addr, BT_CONN_CONNECT);
       + atomic_clear_bit(bt_dev.flags, BT_DEV_ADVERTISING);
       + conn->handle   = handle;
         bt_addr_le_copy(&conn->le.dst, id_addr);
         conn->le.interval = sys_le16_to_cpu(evt->interval);
         conn->le.latency = sys_le16_to_cpu(evt->latency);
         conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
         conn->role = evt->role;
       + if (conn->role == BT_HCI_ROLE_SLAVE) {
         bt_addr_le_copy(&conn->le.init_addr, &evt->peer_addr);
         bt_addr_le_copy(&conn->le.resp_addr, &bt_dev.id_addr);
       + bt_conn_set_state(conn, BT_CONN_CONNECTED);
         + case BT_CONN_CONNECTED:
         + k_fifo_init(&conn->tx_queue);
         + k_thread_spawn(conn->stack, sizeof(conn->stack), conn_tx_thread,
         + bt_l2cap_connected(conn);
           + fchan = le_channels;
           + if (fchan->accept(conn, &chan) < 0) {
             + .accept	= l2cap_accept,// channel
               + static struct bt_l2cap_chan_ops ops = {
                 .connected = l2cap_connected,
                 .disconnected = l2cap_disconnected,
                 .recv = l2cap_recv,
               + l2cap->chan.chan.ops = &ops;
                 *chan = &l2cap->chan.chan;
           + l2cap_chan_add(conn, chan, NULL)
             + struct bt_l2cap_le_chan *ch = l2cap_chan_alloc_cid(conn, chan);
             + bt_l2cap_chan_add(conn, chan, destroy);
           + chan->ops->connected(chan);
             + l2cap_connected(struct bt_l2cap_chan *chan)
         + notify_connected(conn);
           + for (cb = callback_list; cb; cb = cb->_next) {
             + cb->connected(conn, conn->err);
***** hci_event
        + br/edr
          + case BT_HCI_EVT_CONN_REQUEST:
                  conn_req(buf);
          + case BT_HCI_EVT_CONN_COMPLETE:
                  conn_complete(buf);
          + case BT_HCI_EVT_PIN_CODE_REQ:
                  pin_code_req(buf);
          + case BT_HCI_EVT_LINK_KEY_NOTIFY:
                  link_key_notify(buf);
          + case BT_HCI_EVT_LINK_KEY_REQ:
                  link_key_req(buf);
          + case BT_HCI_EVT_IO_CAPA_RESP:
                  io_capa_resp(buf);
          + case BT_HCI_EVT_IO_CAPA_REQ:
                  io_capa_req(buf);
          + case BT_HCI_EVT_SSP_COMPLETE:
                  ssp_complete(buf);
          + case BT_HCI_EVT_USER_CONFIRM_REQ:
                  user_confirm_req(buf);
          + case BT_HCI_EVT_USER_PASSKEY_NOTIFY:
                  user_passkey_notify(buf);
          + case BT_HCI_EVT_USER_PASSKEY_REQ:
                  user_passkey_req(buf);
          + case BT_HCI_EVT_INQUIRY_COMPLETE:
                  inquiry_complete(buf);
          + case BT_HCI_EVT_INQUIRY_RESULT_WITH_RSSI:
                  inquiry_result_with_rssi(buf);
          + case BT_HCI_EVT_EXTENDED_INQUIRY_RESULT:
                  extended_inquiry_result(buf);
          + case BT_HCI_EVT_REMOTE_NAME_REQ_COMPLETE:
                  remote_name_request_complete(buf);
          + case BT_HCI_EVT_AUTH_COMPLETE:
                  auth_complete(buf);
          + case BT_HCI_EVT_REMOTE_FEATURES:
                  read_remote_features_complete(buf);
          + case BT_HCI_EVT_REMOTE_EXT_FEATURES:
                  read_remote_ext_features_complete(buf);
          + case BT_HCI_EVT_ROLE_CHANGE:
                  role_change(buf);
        case BT_HCI_EVT_DISCONN_COMPLETE:
                hci_disconn_complete(buf);
        + smp/br
          + case BT_HCI_EVT_ENCRYPT_CHANGE:
                  hci_encrypt_change(buf);
          + case BT_HCI_EVT_ENCRYPT_KEY_REFRESH_COMPLETE:
                  hci_encrypt_key_refresh_complete(buf);
        + le
          + case BT_HCI_EVT_LE_META_EVENT:
            + hci_le_meta_event(buf);
              + case BT_HCI_EVT_LE_CONN_COMPLETE:
                + le_conn_complete(buf);
                  + id_addr = find_id_addr(&evt->peer_addr);
                  + conn = bt_conn_lookup_state_le(id_addr, BT_CONN_CONNECT);
                  + atomic_clear_bit(bt_dev.flags, BT_DEV_ADVERTISING);
                  + conn->handle   = handle;
                    bt_addr_le_copy(&conn->le.dst, id_addr);
                    conn->le.interval = sys_le16_to_cpu(evt->interval);
                    conn->le.latency = sys_le16_to_cpu(evt->latency);
                    conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
                    conn->role = evt->role;
                  + if (conn->role == BT_HCI_ROLE_SLAVE) {
                    bt_addr_le_copy(&conn->le.init_addr, &evt->peer_addr);
                    bt_addr_le_copy(&conn->le.resp_addr, &bt_dev.id_addr);
                  + bt_conn_set_state(conn, BT_CONN_CONNECTED);
                    + case BT_CONN_CONNECTED:
                    + k_fifo_init(&conn->tx_queue);
                    + k_thread_spawn(conn->stack, sizeof(conn->stack), conn_tx_thread,
                    + bt_l2cap_connected(conn);
                      + fchan = le_channels;
                      + if (fchan->accept(conn, &chan) < 0) {
                        + .accept	= l2cap_accept,
                          + static struct bt_l2cap_chan_ops ops = {
                            .connected = l2cap_connected,
                            .disconnected = l2cap_disconnected,
                            .recv = l2cap_recv,
                          + l2cap->chan.chan.ops = &ops;
                            *chan = &l2cap->chan.chan;
                      + l2cap_chan_add(conn, chan, NULL)
                        + struct bt_l2cap_le_chan *ch = l2cap_chan_alloc_cid(conn, chan);
                        + bt_l2cap_chan_add(conn, chan, destroy);
                      + chan->ops->connected(chan);
                        + l2cap_connected(struct bt_l2cap_chan *chan)
                    + notify_connected(conn);
                      + for (cb = callback_list; cb; cb = cb->_next) {
                        + cb->connected(conn, conn->err);
              + case BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE:
                + le_conn_update_complete(buf);
              + case BT_HCI_EV_LE_REMOTE_FEAT_COMPLETE:
                + le_remote_feat_complete(buf);
              + case BT_HCI_EVT_LE_CONN_PARAM_REQ:
                + le_conn_param_req(buf);
              + case BT_HCI_EVT_LE_LTK_REQUEST:
                + le_ltk_request(buf);
              + case BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE:
                + le_pkey_complete(buf);
              + case BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE:
                + le_dhkey_complete(buf);
              + case BT_HCI_EVT_LE_ADVERTISING_REPORT:
                + le_adv_report(buf);
                  + check_pending_conn(addr, &info->addr, info->evt_type);
***** bt_le_adv_start
+ set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
+ bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
+ set_advertise_enable(true);
  + bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
+ atomic_set_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING);

**** monitor.c
SYS_INIT(bt_monitor_init, PRE_KERNEL_1, MONITOR_INIT_PRIORITY);
使用串口来做debug monitor， bluetooht的时间命令都会发往这个串口
config BLUETOOTH_DEBUG_MONITOR
config BLUETOOTH_MONITOR_ON_DEV_NAME
string "Device Name of Bluetooth monitor logging UART"

+ void bt_log(int prio, const char *fmt, ...)
  + bt_monitor_send(BT_MONITOR_SYSTEM_NOTE, buf, len);
    + monitor_send(&hdr, sizeof(hdr));
      + uart_poll_out(monitor_dev, *buf++);
**** h4.c
***** init
static struct bt_hci_driver drv = {
        .name		= "H:4",
        .bus		= BT_HCI_DRIVER_BUS_UART,
        .open		= h4_open,
        .send		= h4_send,
};
+ SYS_INIT(_bt_uart_init, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEVICE);
  + h4_dev = device_get_binding(CONFIG_BLUETOOTH_UART_ON_DEV_NAME);
    + bt_hci_driver_register(&drv);
      + bt_dev.drv = drv;
        + bt_monitor_new_index(BT_MONITOR_TYPE_PRIMARY, drv->bus,
                                     BT_ADDR_ANY, drv->name ? drv->name : "bt0");
          + bt_monitor_send(BT_MONITOR_NEW_INDEX, &pkt, sizeof(pkt));
***** isr
+ static int h4_open(void)
  + uart_irq_callback_set(h4_dev, bt_uart_isr);
  + uart_irq_rx_enable(h4_dev);

+ static void bt_uart_isr(struct device *unused)
  + read = h4_read(h4_dev, &type, sizeof(type), 0);
    + int h4_read(struct device *uart, uint8_t *buf,  size_t len, size_t min)
      + rx = uart_fifo_read(uart, buf, len);
  + case H4_EVT:
  + buf = h4_evt_recv(&remaining);
    + struct bt_hci_evt_hdr hdr;
    + h4_read(h4_dev, (void *)&hdr, sizeof(hdr), sizeof(hdr));
    + *remaining = hdr.len;
    + buf = bt_buf_get_evt(hdr.evt, K_NO_WAIT);
  + case H4_ACL:
  + buf = h4_acl_recv(&remaining);
    + struct bt_hci_acl_hdr hdr;
    + h4_read(h4_dev, (void *)&hdr, sizeof(hdr), sizeof(hdr));
    + buf = bt_buf_get_acl(K_NO_WAIT);
    + *remaining = sys_le16_to_cpu(hdr.len);
  + read = h4_read(h4_dev, net_buf_tail(buf), remaining, 0);
  + bt_recv(buf);
    + bt_monitor_send(bt_monitor_opcode(buf), buf->data, buf->len);
    + if (bt_buf_get_type(buf) == BT_BUF_ACL_IN) {
      + net_buf_put(&bt_dev.rx_queue, buf);
        + return 0;
    + case BT_HCI_EVT_CMD_COMPLETE:
      net_buf_pull(buf, sizeof(*hdr));
      + hci_cmd_complete(buf);
        + struct bt_hci_evt_cmd_complete *evt = (void *)buf->data;
        + hci_cmd_done(opcode, status, buf);
        + if (cmd(sent)->sync) {        k_sem_give(sem);
    + case BT_HCI_EVT_CMD_STATUS:
      net_buf_pull(buf, sizeof(*hdr));
      + hci_cmd_status(buf);
    + case BT_HCI_EVT_NUM_COMPLETED_PACKETS:
      net_buf_pull(buf, sizeof(*hdr));
      + hci_num_completed_packets(buf);

**** nble
+ DEVICE_INIT(bt_nble, "", _bt_nble_init, NULL, NULL, POST_KERNEL,
            CONFIG_KERNEL_INIT_PRIORITY_DEVICE);
+ _bt_nble_init(struct device *unused)
  + nble_dev = device_get_binding(CONFIG_NBLE_UART_ON_DEV_NAME);

+ bt_enable(bt_ready_cb_t cb)
  + nble_open(void)
    + k_thread_spawn(rx_thread_stack, sizeof(rx_thread_stack),
                        (k_thread_entry_t)rx_thread,
      + uart_irq_callback_set(nble_dev, bt_uart_isr);

+ bt_uart_isr(struct device *unused)
  + hdr_bytes += uart_fifo_read(nble_dev,
  + buf = net_buf_alloc(&rx_pool, K_NO_WAIT);
  + read = uart_fifo_read(nble_dev, net_buf_tail(buf), hdr.len);
  + net_buf_put(&rx_queue, buf);

+ static void rx_thread(void)
  + rpc_deserialize(buf);
    + case SIG_TYPE_S:
    + deserialize_s(uint8_t fn_index, struct net_buf *buf)
      + deserialize_struct(buf, &struct_ptr, &struct_length);
      + m_fct_s[fn_index](struct_data);

*** mem
k_mem_pool_alloc(struct k_mem_pool *pool, struct k_mem_block *block,
  offset = compute_block_set_index(pool, size);
  found_block = get_block_recursive(pool, offset, offset);
    found = get_existing_block(&(fr_table[index]), &i);
      *unused_block_index = i;
    defrag(pool, pool->nr_of_block_sets - 1, start_index);
    larger_block = get_block_recursive(pool, index - 1, start_index);

defrag(pool, pool->nr_of_block_sets - 1, start_index);
*** net
**** net_conn_input
**** net_rx_thread
+ net_if_init();
+ while (1) {
+ buf = net_buf_get(&rx_queue, K_FOREVER);
+ processing_data(buf, false);
  + process_data(buf, is_loopback)
    + process_ipv4_pkt(buf);
      + net_nbuf_set_ip_hdr_len(buf, sizeof(struct net_ipv4_hdr));
      + case IPPROTO_ICMP:
        verdict = process_icmpv4_pkt(buf, hdr);
      + case IPPROTO_UDP:
        verdict = net_conn_input(IPPROTO_UDP, buf);
      + case IPPROTO_TCP:
        verdict = net_conn_input(IPPROTO_TCP, buf);
+ k_yield();

**** net_init
+ net_shell_init();
  + SHELL_REGISTER(NET_SHELL_MODULE, net_commands);
+ net_nbuf_init();
+ net_context_init();
+ l2_init();
  + net_arp_init();
+ l3_init();
  + net_conn_init();
  + net_udp_init();
  + net_tcp_init();
    + k_sem_init(&tcp_lock, 0, UINT_MAX);
  + net_route_init();
+ net_mgmt_event_init();
  + k_thread_spawn(mgmt_stack, sizeof(mgmt_stack),
  + (k_thread_entry_t)mgmt_thread, NULL, NULL, NULL,
  + K_PRIO_COOP(CONFIG_NET_MGMT_EVENT_THREAD_PRIO), 0, 0);
+ init_rx_queue();
  + k_fifo_init(&rx_queue);
  + rx_tid = k_thread_spawn(rx_stack, sizeof(rx_stack),
  + (k_thread_entry_t)net_rx_thread,

SYS_INIT(net_init, POST_KERNEL, CONFIG_NET_INIT_PRIO);
**** eth_callback
  eth_rx(iface);
    ENET_ReadFrame(ENET, &context->enet_handle, NULL, 0);
    src = context->frame_buf;
    pkt_buf = net_nbuf_get_reserve_data(0);
    net_buf_frag_insert(prev_frag, pkt_buf);
    frag_len = net_buf_tailroom(pkt_buf);
    memcpy(pkt_buf->data, src, frag_len);
    net_buf_add(pkt_buf, frag_len);
    net_recv_data(context->iface, buf);
      net_nbuf_set_iface(buf, iface);
      net_buf_put(&rx_queue, buf);

struct eth_context {
        struct net_if *iface;
        enet_handle_t enet_handle;
        struct k_sem tx_buf_sem;
        uint8_t mac_addr[6];
        uint8_t frame_buf[1500];
};
**** net_if
ENET_SetCallback(&context->enet_handle, eth_callback, dev);
ENET_ReceiveIRQHandler(ENET, &context->enet_handle);

NET_DEVICE_INIT(eth_ksdk_0, CONFIG_ETH_KSDK_0_NAME,
                eth_0_init, &eth_0_context,
                NULL, CONFIG_ETH_INIT_PRIORITY, &api_funcs_0,
                ETHERNET_L2, NET_L2_GET_CTX_TYPE(ETHERNET_L2), 1500);

#define NET_IF_GET_NAME(dev_name, sfx) (__net_if_##dev_name##_##sfx)
#define NET_IF_GET(dev_name, sfx)					\
        ((struct net_if *)&NET_IF_GET_NAME(dev_name, sfx))

#define NET_IF_INIT(dev_name, sfx, _l2, _mtu)				\
        static struct net_if (NET_IF_GET_NAME(dev_name, sfx)) __used	\
        __attribute__((__section__(".net_if.data"))) = {		\
                .dev = &(__device_##dev_name),				\
                .l2 = &(NET_L2_GET_NAME(_l2)),				\
                .l2_data = &(NET_L2_GET_DATA(dev_name, sfx)),		\
                .mtu = _mtu,						\
        };								\
        NET_STACK_INFO_ADDR(TX,						\
                            dev_name,					\
                            CONFIG_NET_TX_STACK_SIZE,			\
                            CONFIG_NET_TX_STACK_SIZE,			\
                            NET_IF_GET(dev_name, sfx)->tx_stack,	\
                            sfx)


/* Network device initialization macros */

#define NET_DEVICE_INIT(dev_name, drv_name, init_fn,		\
                        data, cfg_info, prio, api, l2,		\
                        l2_ctx_type, mtu)			\
        DEVICE_AND_API_INIT(dev_name, drv_name, init_fn, data,	\
                            cfg_info, POST_KERNEL, prio, api);	\
        NET_L2_DATA_INIT(dev_name, 0, l2_ctx_type);		\
        NET_IF_INIT(dev_name, 0, l2, mtu)

struct net_if *net_if_lookup_by_dev(struct device *dev);
struct net_if *net_if_get_default(void);
struct net_if_addr *net_if_ipv4_addr_lookup(const struct in_addr *addr,
struct net_if_addr *net_if_ipv4_addr_add(struct net_if *iface,
struct net_if_router *net_if_ipv4_router_lookup(struct net_if *iface,
struct net_if_router *net_if_ipv4_router_add(struct net_if *iface,
static inline void net_if_ipv4_set_netmask(struct net_if *iface,
static inline void net_if_ipv4_set_gw(struct net_if *iface,
void net_if_register_link_cb(struct net_if_link_cb *link,



NET_L2_INIT(ETHERNET_L2, ethernet_recv, ethernet_send, ethernet_reserve);

#define NET_L2_GET_NAME(_name) (__net_l2_##_name)
#define NET_L2_INIT(_name, _recv_fn, _send_fn, _reserve_fn)		\
        const struct net_l2 const (NET_L2_GET_NAME(_name)) __used	\
        __attribute__((__section__(".net_l2.init"))) = {		\
                .recv = (_recv_fn),					\
                .send = (_send_fn),					\
                .reserve = (_reserve_fn),				\
        }

#define NET_L2_DATA_INIT(name, sfx, ctx_type)				\
        static ctx_type NET_L2_GET_DATA(name, sfx) __used		\
        __attribute__((__section__(".net_l2.data")));
**** net_buf
NET_BUF_POOL_DEFINE(rx_buffers, NBUF_RX_COUNT, 0, sizeof(struct net_nbuf),
                    free_rx_bufs_func);
NET_BUF_POOL_DEFINE(tx_buffers, NBUF_TX_COUNT, 0, sizeof(struct net_nbuf),
                    free_tx_bufs_func);

/* The data fragment pool is for storing network data. */
NET_BUF_POOL_DEFINE(data_buffers, NBUF_DATA_COUNT, NBUF_DATA_LEN,
                    NBUF_USER_DATA_LEN, free_data_bufs_func);



NET_BUF_POOL_DEFINE(pool_name, buf_count, buf_size, user_data_size, NULL);
#define NET_BUF_POOL_DEFINE(_name, _count, _size, _ud_size, _destroy)        \
        static struct {                                                      \
                struct net_buf buf;                                          \
                uint8_t data[_size] __net_buf_align;                         \
                uint8_t ud[ROUND_UP(_ud_size, 4)] __net_buf_align;           \
        } _net_buf_pool_##_name[_count] __noinit;                            \
        static struct net_buf_pool _name =                                   \
                NET_BUF_POOL_INITIALIZER(_name, _net_buf_pool_##_name,       \
                                         _count, _size, _ud_size, _destroy)

#define NET_BUF_POOL_INITIALIZER(_pool, _bufs, _count, _size, _ud_size,      \
                                 _destroy)                                   \
        {                                                                    \
                .free = K_LIFO_INITIALIZER(_pool.free),                      \
                .__bufs = (struct net_buf *)_bufs,                           \
                .buf_count = _count,                                         \
                .uninit_count = _count,                                      \
                .buf_size = _size,                                           \
                .user_data_size = _ud_size,                                  \
                .destroy = _destroy,                                         \
        }



struct net_buf {
        union {
                /** FIFO uses first 4 bytes itself, reserve space */
                int _unused;

                /** Fragments associated with this buffer. */
                struct net_buf *frags;
        };

        /** List pointer used for TCP retransmit buffering */
        sys_snode_t sent_list;

        /** Reference count. */
        uint8_t ref;

        /** Bit-field of buffer flags. */
        uint8_t flags;

        /** Where the buffer should go when freed up. */
        struct net_buf_pool *pool;

        /* Union for convenience access to the net_buf_simple members, also
         * preserving the old API.
         */
        union {
                /* The ABI of this struct must match net_buf_simple */
                struct {
                        /** Pointer to the start of data in the buffer. */
                        uint8_t *data;

                        /** Length of the data behind the data pointer. */
                        uint16_t len;

                        /** Amount of data that this buffer can store. */
                        uint16_t size;
                };

                struct net_buf_simple b;
        };

        /** Start of the data storage. Not to be accessed directly
         *  (the data pointer should be used instead).
         */
        uint8_t __buf[0] __net_buf_align;
};

struct net_buf_pool {
        /** LIFO to place the buffer into when free */
        struct k_lifo free;

        /** Number of buffers in pool */
        const uint16_t buf_count;

        /** Number of uninitialized buffers */
        uint16_t uninit_count;

        /** Data size of each buffer in the pool */
        const uint16_t buf_size;

        /** Size of the user data associated with each buffer. */
        const uint16_t user_data_size;

        /** Optional destroy callback when buffer is freed. */
        void (*const destroy)(struct net_buf *buf);

        /** Helper to access the start of storage (for net_buf_pool_init) */
        struct net_buf * const __bufs;
};


struct net_nbuf {
        /** Network connection context */
        struct net_context *context;

        /** Network context token that user can set. This is passed
         * to user callback when data has been sent.
         */
        void *token;

        /** Network interface */
        struct net_if *iface;

        /** @cond ignore */
        uint8_t *appdata;	/* application data starts here */
        uint8_t *next_hdr;	/* where is the next header */

        /* Filled by layer 2 when network packet is received. */
        struct net_linkaddr lladdr_src;
        struct net_linkaddr lladdr_dst;

        uint16_t appdatalen;
        uint16_t reserve;	/* length of the protocol headers */
        uint8_t ll_reserve;	/* link layer header length */
        uint8_t family;		/* IPv4 vs IPv6 */
        uint8_t ip_hdr_len;	/* pre-filled in order to avoid func call */
        uint8_t ext_len;	/* length of extension headers */
        uint8_t ext_bitmap;

#if defined(CONFIG_NET_IPV6)
        uint8_t ext_opt_len; /* IPv6 ND option length */
#endif

#if defined(CONFIG_NET_TCP)
        bool buf_sent; /* Is this net_buf sent or not */
#endif
        /* @endcond */
};


buf = net_buf_alloc(&pool_name, timeout);
   buf = k_lifo_get(&pool->free, timeout);

net_if_ipv6_addr_add(net_if_get_default(), &in6addr_my,
net_context_get(AF_INET6, SOCK_DGRAM, IPPROTO_UDP, &context);
net_context_bind(context, (struct sockaddr *)&my_addr6);

net_context_recv
  recv_udp(context, cb, timeout, user_data);
    context->recv_cb = cb;
    net_conn_register(net_context_get_ip_proto(context),

context->recv_cb = cb;
  udp_received(struct net_context *context,struct net_buf *buf,
    reply_buf = net_nbuf_get_tx(context);
    header_len = net_nbuf_appdata(buf) - tmp->data;
    frag = net_nbuf_get_data(context);
   net_nbuf_unref(buf);
*** shell

static struct shell_cmd net_commands[] = {
        /* Keep the commands in alphabetical order */
        { "conn", shell_cmd_conn, NULL },
        { "help", shell_cmd_help, NULL },
        { "iface", shell_cmd_iface, NULL },
        { "mem", shell_cmd_mem, NULL },
        { "ping", shell_cmd_ping, NULL },
        { "route", shell_cmd_route, NULL },
        { "stacks", shell_cmd_stacks, NULL },
        { "stats", shell_cmd_stats, NULL },
        { NULL, NULL, NULL }
}


net_shell_init
  SHELL_REGISTER(NET_SHELL_MODULE, net_commands);

shell
  cmd = k_fifo_get(&cmds_queue, K_FOREVER);
  argc = line2argv(cmd->line, argv, ARRAY_SIZE(argv));
  cb = get_cb(argc, argv);
        shell_module = &__shell_cmd_start[module];
        for (i = 0; shell_module->commands[i].cmd_name; i++) {
                if (!strcmp(command, shell_module->commands[i].cmd_name)) {
                        return shell_module->commands[i].cb;
  cb(argc, argv) < 0



void shell_init(const char *str)
  k_thread_spawn(stack, STACKSIZE, shell, NULL, NULL, NULL,
  uart_register_input(&avail_queue, &cmds_queue, completion)
    console_input_init()
      uart_irq_rx_disable(uart_console_dev);
      uart_irq_tx_disable(uart_console_dev);
      uart_irq_callback_set(uart_console_dev, uart_console_isr);


uart_console_init,
  uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  uart_console_hook_install();
    __stdout_hook_install(console_out);
    __printk_hook_install(console_out);


void uart_console_isr(struct device *unused)
  read_uart
    rx = uart_fifo_read(uart, buf, size);
    cmd = k_fifo_get(avail_queue, K_NO_WAIT);
    k_fifo_put(lines_queue, cmd);
** Android
*** vold
fs_mgr_mount_all//init.rc
    fs_mgr_setup_verity(&fstab->recs[i]);
        read_verity_metadata(fstab->blk_device,
        fd = open("/dev/device-mapper", O_RDWR)
        create_verity_device(io, mount_point, fd)
        get_verity_device_name(io, mount_point, fd, &verity_blk_name)
        verify_table(verity_table_signature,
        load_verity_table(io, mount_point, fstab->blk_device, fd, verity_table) < 0)
        resume_verity_table(io, mount_point, fd)

NetlinkListener::onDataAvailable
    NetlinkEvent *evt = new NetlinkEvent();
    evt->decode(mBuffer, count, mFormat)
    onEvent(evt);
        evt->getSubsystem();
        if (!strcmp(subsys, "block")) {
            vm->handleBlockEvent(evt);
                case NetlinkEvent::Action::kAdd:
                    disk = new android::vold::Disk(eventPath, device,
                        CreateDeviceNode(mDevPath, mDevice);
                            mknod(cpath, mode, dev)
                    disk->create();
                        notifyEvent(ResponseCode::DiskCreated, StringPrintf("%d", mFlags));
                            VolumeManager::Instance()->getBroadcaster()->sendBroadcast(event,
                                CommandListener
                                SocketListener::sendBroadcast
                                    for (i = mClients->begin(); i != mClients->end();
                                        c->sendMsg(code, msg, addErrno, false)
                        readMetadata();
                        readPartitions();
                            ForkExecvp(cmd, output);
                            createPublicVolume(partDevice);
                                new PublicVolume(device)
                                mVolumes.push_back(vol);
                                vol->setDiskId(getId());
                                vol->create();
                                    PublicVolume::doCreate(
                                        CreateDeviceNode(mDevPath, mDevice);
                                            mknod(cpath, mode, dev)
                    mDisks.push_back(std::shared_ptr<android::vold::Disk>(disk));

FrameworkListener::onDataAvailable
    dispatchCommand(c, buffer + offset);
        c->runCommand(cli, argc, argv)
        CommandListener::VolumeCmd::runCommand

main
    cl = new CommandListener();
             FrameworkListener("vold", true)
                    SocketListener(socketName, true, false)
                init(socketName, false);

        registerCmd(new DumpCmd());
        registerCmd(new VolumeCmd());
        registerCmd(new AsecCmd());
        registerCmd(new ObbCmd());
        registerCmd(new StorageCmd());
        registerCmd(new CryptfsCmd());
        registerCmd(new FstrimCmd());
    vm->setBroadcaster((SocketListener *) cl);
    nm->setBroadcaster((SocketListener *) cl);
    vm->start()
         unmountAll();
         new android::vold::EmulatedVolume("/data/media")
         mInternalEmulated->create();
    process_config(vm)
    nm->start()
        mSock = socket(PF_NETLINK, SOCK_DGRAM | SOCK_CLOEXEC,
            NETLINK_KOBJECT_UEVENT))
        bind(mSock, (struct sockaddr *) &nladdr, sizeof(nladdr)
        mHandler = new NetlinkHandler(mSock);
            NetlinkListener(listenerSocket)
                 SocketListener(socket, false)
        mHandler->start()
            this->startListener();
                mClients->push_back(new SocketClient(mSock, false, mUseCmdNum));
                SocketListener::threadStart
                    SocketListener::runListener
                        select(max + 1, &read_fds, NULL, NULL, NULL)
                    onDataAvailable
                        NetlinkListener::onDataAvailable
                            NetlinkEvent *evt = new NetlinkEvent();
                            evt->decode(mBuffer, count, mFormat)
                            onEvent(evt);
                                evt->getSubsystem();
                                if (!strcmp(subsys, "block")) {
                                    vm->handleBlockEvent(evt);
        fd = openat(dfd, "uevent", O_WRONLY);
        write(fd, "add\n", 4);
    cl->startListener()//dev/socket/vold
        SocketListener::startListener
        mSock = android_get_control_socket(mSocketName)
        listen(mSock, backlog)
        pthread_create(&mThread, NULL, SocketListener::threadStart
            SocketListener::runListener
            accept4(mSock, addrp, &alen, SOCK_CLOEXEC);
            mClients->push_back(new SocketClient(c, true, mUseCmdNum));
            onDataAvailable
                FrameworkListener::onDataAvailable
                    dispatchCommand(c, buffer + offset);
                        c->runCommand(cli, argc, argv)
                        CommandListener::VolumeCmd::runCommand
    coldboot("/sys/block");
    usbmond_main();
*** Surface
SurfaceView
        Surface::Surface
        init
                setWillNotDraw(true);

signalLayerUpdate

Surface::dequeueBuffer
        //ATRACE_CALL();
        mGraphicBufferProducer->dequeueBuffer(&buf, &fence, swapIntervalZero,
                BufferQueueProducer::dequeueBuffer

        *fenceFd = fence->dup();

sw_sync_pt_create
    sync_pt_create
        sync_timeline_add_pt(parent, pt);
            list_add_tail(&pt->child_list, &obj->child_list_head);
    pt->value = value;


static struct sync_timeline_ops sw_sync_timeline_ops = {
    .driver_name = "sw_sync",
    .dup = sw_sync_pt_dup,
    .has_signaled = sw_sync_pt_has_signaled,
    .compare = sw_sync_pt_compare,
    .fill_driver_data = sw_sync_fill_driver_data,
    .timeline_value_str = sw_sync_timeline_value_str,
    .pt_value_str = sw_sync_pt_value_str,
};
sw_sync_timeline_create
    sync_timeline_create

static const struct file_operations sync_fence_fops = {
    .release = sync_fence_release,
    .poll = sync_fence_poll,
    .unlocked_ioctl = sync_fence_ioctl,
    .compat_ioctl = sync_fence_ioctl,
};

pvr_sync_fops
    pvr_sync_ioctl_create_fence
        fd = get_unused_fd();
        pvr_sync_alloc_fence_fdget(data.iAllocFenceFd)
        sync_pt = (struct sync_pt *)
            pvr_sync_create_sync(timeline, sync_data);
                sync_pt_create
                    sync_timeline_add_pt(parent, pt);
                        list_add_tail(&pt->child_list, &obj->child_list_head);
                pvr_pt->sync_data = sync_data;
        fence = sync_fence_create(data.szName, sync_pt);
            fence = sync_fence_alloc(name);
                fence->file = anon_inode_getfile("sync_fence", &sync_fence_fops
                list_add_tail(&fence->sync_fence_list, &sync_fence_list_head);
            list_add(&pt->pt_list, &fence->pt_list_head);
            sync_pt_activate(pt);
                _sync_pt_has_signaled
                    pt->parent->ops->has_signaled(pt);
                list_add_tail(&pt->active_list, &obj->active_list_head);
            sync_fence_signal_pt(pt);
                status = sync_fence_get_status(fence);
                    list_for_each(pos, &fence->pt_list_head) {
                list_for_each_safe(pos, n, &signaled_waiters)
                    waiter->callback(fence, waiter);
                wake_up(&fence->wq);
        data.iFenceFd = fd;
        sync_fence_install(fence, fd);
            fd_install(fd, fence->file);

static struct sync_timeline_ops pvr_sync_timeline_ops = {
    .driver_name        = PVRSYNC_MODNAME,
    .dup                = pvr_sync_dup,
    .has_signaled       = pvr_sync_has_signaled,
    .compare            = pvr_sync_compare,
    .free_pt            = pvr_sync_free_sync,
    .release_obj        = pvr_sync_release_timeline,
    .print_obj          = pvr_sync_print_obj,
    .print_pt           = pvr_sync_print_pt,
};

pvr_sync_open
    sync_timeline_create

doGLFenceWaitLocked

syncForReleaseLocked

syncForReleaseLocked(mEglDisplay);
    sync = eglCreateSyncKHR(dpy, EGL_SYNC_NATIVE_FENCE_ANDROID, NULL);
        IMGeglCreateSyncKHR
            psDpy = GetKEGLDisplay(psTls, eglDpy);
            psSysContext = &psDpy->sSysContext;
            psSync = EGLCalloc(sizeof(KEGL_SYNC));
            InsertEglSyncFenceToGC(psSysContext, psSync->psContext, psTls, psSync, &psSync->iNativeFd)
                psGlobalData->spfnOGLES3.pfnGLESInsertFenceSyncGC(ctx->hClientContext,
                //sGLES3FunctionTable
                GLES3InsertFenceSyncGC
                    GLES3FlushBuffersGC(gc, NULL, IMG_TRUE, IMG_FALSE, IMG_FALSE, NULL
                    SyncCreateCommand(&gc->psSysContext->sSyncInterface, SYNC_EGL_FENCESYNC, NULL);
                    SyncInsertFence(&gc->psSysContext->sSyncInterface, SYNC_UPDATE_TQ,
                    SyncInsertFence(&gc->psSysContext->sSyncInterface, SYNC_UPDATE_RENDER,
                    SyncPrepareCommitCommand(&gc->psSysContext->sSyncInterface, psCommand,
                    RGXKickSync(gc->psDevConnection,
                    SyncCommitCommand(&gc->psSysContext->sSyncInterface, psCommand, NU
    glFlush();
    fenceFd = eglDupNativeFenceFDANDROID(dpy, sync);
        IMGeglDupNativeFenceFDANDROID
            dup(psSync->iNativeFd);


    eglDestroySyncKHR(dpy, sync);
    sp<Fence> fence(new Fence(fenceFd));
    addReleaseFenceLocked(mCurrentTexture,mCurrentTextureImage->graphicBuffer(), fence);
        mSlots[slot].mFence = fence;


SurfaceControl()
        mNativeObject = nativeCreate(session, name, w, h, format, flags)//jni
        client(android_view_SurfaceSession_getClient(env, sessionObj));
        client->createSurface

DisplayEventReceiver::DisplayEventReceiver
        mEventConnection = sf->createDisplayEventConnection()
                SurfaceFlinger::createDisplayEventConnection
                                mEventThread->createEventConnection();
                                        new Connection(const_cast<EventThread*>(this));
                                                mEventThread(eventThread), mChannel(new BitTube()
                                        EventThread::Connection::onFirstRef
                                                mEventThread->registerDisplayEventConnection(this)
                                                mDisplayEventConnections.add(connection);
                        mDataChannel = mEventConnection->getDataChannel();


SurfaceComposerClient::createSurface
        Client::createSurface
                flinger->createLayer
                        createNormalLayer
                                *outLayer = new Layer(this, client, name, w, h, flags);
                                        mFlinger->getRenderEngine().genTextures(1, &mTextureName);
                                                return mRenderEngine
                                                glGenTextures(count, names);
                                mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);
                                        mTextureName = textureName;
                                        mTextureTarget = textureTarget;
                        flinger->getHwComposer().getRefreshPeriod(HWC_DISPLAY_PRIMARY);
                                mFrameTracker.setDisplayRefreshPeriod(displayPeriod);
                                Layer::onFirstRef
                                        BufferQueue::createBufferQueue(&producer, &consumer);
                                            mProducer = new MonitoredProducer(producer, mFlinger);
                                            mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName);
                                            mSurfaceFlingerConsumer->setConsumerUsageBits(getEffectiveUsage(0));
                                            mSurfaceFlingerConsumer->setContentsChangedListener(this);
                                            mSurfaceFlingerConsumer->setName(mName);
                                            mSurfaceFlingerConsumer->setDefaultMaxBufferCount(3);
                                            hw(mFlinger->getDefaultDisplayDevice());
                                            updateTransformHint(hw);
                                (*outLayer)->setBuffers(w, h, format, flags);
                                        maxSurfaceDims = min(
                                mFlinger->getMaxTextureSize(), mFlinger->getMaxViewportDims());
                                        mSurfaceFlingerConsumer->setDefaultBufferSize(w, h);
                                mSurfaceFlingerConsumer->setDefaultBufferFormat(format);
                                mSurfaceFlingerConsumer->setConsumerUsageBits(getEffectiveUsage(0));
                                *handle = (*outLayer)->getHandle();
                                        new Handle(mFlinger, this);
                                                mOwner(layer)
                        *gbp = (*outLayer)->getProducer();
                                return mProducer
                addClientLayer(client, *handle, *gbp, layer);
                        mCurrentState.layersSortedByZ.add(lbc);
                        mGraphicBufferProducerList.add(IInterface::asBinder(gbc));
                        client->attachLayer(handle, lbc);
                                mLayers.add(handle, layer);
        new SurfaceControl(this, handle, gbp);

public Surface(SurfaceTexture surfaceTexture)
        setNativeObjectLocked(nativeCreateFromSurfaceTexture(surfaceTexture));
        nativeCreateFromSurfaceTexture
                producer(SurfaceTexture_getProducer(env, surfaceTextureObj));
                        env->GetLongField(thiz, fields.producer)
                surface(new Surface(producer, true));
                        mGraphicBufferProducer(bufferProducer),
                        ANativeWindow::setSwapInterval  = hook_setSwapInterval;
                    ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;
                    ANativeWindow::cancelBuffer     = hook_cancelBuffer;
                    ANativeWindow::queueBuffer      = hook_queueBuffer;
                    ANativeWindow::query            = hook_query;
                    ANativeWindow::perform          = hook_perform;
                    ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;
                    ANativeWindow::cancelBuffer_DEPRECATED  = hook_cancelBuffer_DEPRECATED;
                    ANativeWindow::lockBuffer_DEPRECATED    = hook_lockBuffer_DEPRECATED;
                    ANativeWindow::queueBuffer_DEPRECATED   = hook_queueBuffer_DEPRECATED;


onMessageReceived
    case MessageQueue::INVALIDATE
        SurfaceFlinger::handleMessageInvalidate
            SurfaceFlinger::handlePageFlip
                layer->hasQueuedFrame()
                layer->shouldPresentNow(mPrimaryDispSync)
                    mSurfaceFlingerConsumer->computeExpectedPresent(dispSync);
                        nextRefresh = dispSync.computeNextRefresh(hwcLatency);
                        extraPadding = 1000000;        // 1ms (6% of 60Hz)
                        return nextRefresh + extraPadding;
                layersWithQueuedFrames.push_back(layer.get());
                layer->latchBuffer(visibleRegions)
                    mSurfaceFlingerConsumer->updateTexImage(&r,
                                    mFlinger->mPrimaryDispSync, maxFrameNumber);
                        acquireBufferLocked(&item, computeExpectedPresent(dispSync),
                            GLConsumer::acquireBufferLocked(item, presentWhen,
                                ConsumerBase::acquireBufferLocked(item, presentWhen,
                                mEglSlots[slot].mEglImage = new EglImage(item->mGraphicBuffer);
                        updateAndReleaseLocked(item);
                            checkAndUpdateEglStateLocked();
                            mEglSlots[buf].mEglImage->createIfNeeded(mEglDisplay, item.mCrop);
                                mEglImage = createImage(mEglDisplay, mGraphicBuffer, mCropRect);
                            syncForReleaseLocked(mEglDisplay);
                                sync = eglCreateSyncKHR(dpy, EGL_SYNC_NATIVE_FENCE_ANDROID, NULL);
                                glFlush();
                                fenceFd = eglDupNativeFenceFDANDROID(dpy, sync);
                                eglDestroySyncKHR(dpy, sync);
                                sp<Fence> fence(new Fence(fenceFd));
                                addReleaseFenceLocked(mCurrentTexture,mCurrentTextureImage->graphicBuffer(), fence);
                                    mSlots[slot].mFence = fence;
                            releaseBufferLocked(
                                            mCurrentTexture, mCurrentTextureImage->graphicBuffer(),
                                            mEglDisplay, mEglSlots[mCurrentTexture].mEglFence);
                                 ConsumerBase::releaseBufferLocked(
                                    mConsumer->releaseBuffer(
                            mCurrentTexture = buf;
                            mCurrentTextureImage = mEglSlots[buf].mEglImage;
                            mCurrentCrop = item.mCrop;
                            mCurrentTransform = item.mTransform;
                            mCurrentScalingMode = item.mScalingMode;
                            mCurrentTimestamp = item.mTimestamp;
                            mCurrentFence = item.mFence;
                            mCurrentFrameNumber = item.mFrameNumber;
                         bindTextureImageLocked();
                    mActiveBuffer = mSurfaceFlingerConsumer->getCurrentBuffer();
                layer->useSurfaceDamage();
                signalLayerUpdate();
        signalRefresh();
            mEventQueue.refresh();
                mHandler->dispatchRefresh();



SurfaceFlinger::onMessageReceived
        handleMessageRefresh();
                preComposition();
                        layers[i]->onPreComposition()
        rebuildLayerStacks();
                LayerVector& layers(mDrawingState.layersSortedByZ)
                DisplayDevice hw(mDisplays[dpy]
                Transform& tr(hw->getTransform())
                Rect bounds(hw->getBounds())
                SurfaceFlinger::computeVisibleRegions(layers,
                        hw->getLayerStack(), dirtyRegion, opaqueRegion)
                hw->setVisibleLayersSortedByZ(layersSortedByZ);
            hw->undefinedRegion.set(bounds);
            hw->undefinedRegion.subtractSelf(tr.transform(opaqueRegion));
            hw->dirtyRegion.orSelf(dirtyRegion);
        setUpHWComposer();
                mDisplays[dpy]->beginFrame(mustRecompose);
                id = hw->getHwcDisplayId()
                currentLayers(hw->getVisibleLayersSortedByZ())
                hwc.createWorkList(id, count)
                HWComposer::LayerListIterator cur = hwc.begin(id)
                for (size_t i=0 ; cur!=end &
                        layer(currentLayers[i]);
                        layer->setGeometry(hw, *cur)
                        layer->setPerFrameData(hw, *cur);
                hwc.prepare();
                hw->prepareFrame(hwc);
                        mDisplaySurface->prepareFrame(compositionType);
        doDebugFlashRegions();
        doComposition();
                doDisplayComposition(hw, dirtyRegion);
                        doComposeSurfaces(hw, dirtyRegion)
                                hwc.hasGlesComposition(id)
                                hw->makeCurrent(mEGLDisplay, mEGLContext)
                                hasHwcComposition = hwc.hasHwcComposition(id);
                                if (hasHwcComposition) {
                                        engine.clearWithColor(0, 0, 0, 0);
                                else
                                        Region bounds(hw->getBounds());
                                        letterbox(bounds.subtract(hw->getScissor()));
                                        region(hw->undefinedRegion.merge(letterbox));
                                        region.andSelf(dirty);
                                layers(hw->getVisibleLayersSortedByZ());
                                tr = hw->getTransform()
                                for (size_t i=0 ; i<count && cur!=end
                                        switch (cur->getCompositionType())
                                                case HWC_OVERLAY
                                                case HWC_FRAMEBUFFER: {
                                layer->draw(hw, clip);
                                        onDraw
                                                ATRACE_CALL();
                                                mSurfaceFlingerConsumer->bindTextureImage();
                                                        bindTextureImageLocked
                                                                glBindTexture(mTexTarget, mTexName);
                                                                mCurrentTextureImage->bindToTextureTarget(mTexTarget)
                                                                        glEGLImageTargetTexture2DOES(texTarget,
                                                                                        static_cast<GLeglImageOES>(mEglImage));
                                                                doGLFenceWaitLocked
                                                fenceFd = mCurrentFence->dup();
                                                EGLSyncKHR sync = eglCreateSyncKHR(dpy,
                                                fenceFd = mCurrentFence->dup();
                                                eglWaitSyncKHR(dpy, sync, 0);
                                                eglDestroySyncKHR(dpy, sync);
                                                drawWithOpenGL(hw, clip, useIdentityTransform);
                                                        computeGeometry(hw, mMesh, useIdentityTransform);
                                                        Mesh::VertexArray<vec2> texCoords(mMesh.getTexCoordArray<vec2>());
                                                                            texCoords[0] = vec2(left, 1.0f - top);
                                                                            texCoords[1] = vec2(left, 1.0f - bottom);
                                                                            texCoords[2] = vec2(right, 1.0f - bottom);
                                                                            texCoords[3] = vec2(right, 1.0f - top);
                                                                            engine.setupLayerBlending(mPremultipliedAlpha, isOpaque(s), s.alpha);
                                                                            engine.drawMesh(mMesh);
                                                                            engine.disableBlending();
                                                                engine.disableTexturing();
                        layer->setAcquireFence(hw, *cur);
                            fence = mSurfaceFlingerConsumer->getCurrentFence()
                            fenceFd = fence->dup();
                            layer.setAcquireFenceFd(fenceFd);
                                getLayer()->acquireFenceFd = fenceFd;
                        hw->swapRegion.orSelf(dirtyRegion);
                        hw->swapBuffers(getHwComposer());
                    eglSwapBuffers(mDisplay, mSurface);
                        FramebufferSurface::onFrameAvailable
                            nextBuffer(buf, acquireFence);
                                acquireBufferLocked(&item, 0)
                                mCurrentBufferSlot = item.mBuf;
                                mCurrentBuffer = mSlots[mCurrentBufferSlot].mGraphicBuffer;
                                outFence = item.mFence;
                                outBuffer = mCurrentBuffer;
                            mHwc.fbPost(mDisplayType, acquireFence, buf);
                                setFramebufferTarget(id, acquireFence, buffer);

                                mDisplaySurface->advanceFrame()

            hw->flip(hw->swapRegion);

                hw->compositionComplete();
                        mDisplaySurface->compositionComplete();
                                mHwc.fbCompositionComplete();
                postFramebuffer();
                        hwc.commit();
                    mHwc->set(mHwc, mNumDisplays, mLists);
                        hw->onSwapBuffersCompleted(hwc);
                    mDisplaySurface->onFrameCommitted
                        fence = mHwc.getAndResetReleaseFence(mDisplayType);
                            disp.framebufferTarget->releaseFenceFd;
                        addReleaseFence(mCurrentBufferSlot,
                        currentLayers[i]->onLayerDisplayed(hw, &*cur)
                    layer->onDisplayed();
                        getLayer()->acquireFenceFd = -1;
                    mSurfaceFlingerConsumer->setReleaseFence(layer->getAndResetReleaseFence());
                        addReleaseFence(mCurrentTexture,
                                    mCurrentTextureImage->graphicBuffer(), fence)
        postComposition();
                layers[i]->onPostComposition();
                hwc = getHwComposer();
                presentFence = hwc.getDisplayFence(HWC_DISPLAY_PRIMARY)
                mPrimaryDispSync.addPresentFence(presentFence)
                enableHardwareVsync();

SurfaceTexture_init
        BufferQueue::createBufferQueue(&producer, &consumer);
                core(new BufferQueueCore(allocator)
                        sp<ISurfaceComposer> composer(ComposerService::getComposerService());
                        mAllocator = composer->createGraphicBufferAlloc();

                producer(new BufferQueueProducer(core)
                consumer(new BufferQueueConsumer(core)
                *outProducer = producer;
            *outConsumer = consumer;
        surfaceTexture = new GLConsumer(consumer, texName,GL_TEXTURE_EXTERNAL_OES
        surfaceTexture->setName(String8::format("SurfaceTexture-%d-%d-%d",
        SurfaceTexture_setSurfaceTexture(env, thiz, surfaceTexture);
        SurfaceTexture_setProducer(env, thiz, producer);
        ctx(new JNISurfaceTextureContext(env, weakThiz,
        surfaceTexture->setFrameAvailableListener(ctx);
        SurfaceTexture_setFrameAvailableListener(env, thiz, ctx);
*** surfaceFlinger
main
        flinger = new SurfaceFlinger()
                DispSync::DispSync
                        mThread(new DispSyncThread())
                        mThread->run("DispSync", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);
                        reset();
                beginResync();
                onFirstRef
                        mEventQueue.init(this);
                                mFlinger = flinger;
                                mLooper = new Looper(true);
                                mHandler = new Handler(*this);
        flinger->init();

SurfaceFlinger::init
        mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
                egl_init_drivers
                        egl_init_drivers_locked
                                Loader& loader(Loader::getInstance());
                                cnx = &gEGLImpl
                                cnx->hooks[egl_connection_t::GLESv1_INDEX] =
                        &gHooks[egl_connection_t::GLESv1_INDEX];
                        cnx->hooks[egl_connection_t::GLESv2_INDEX] =
                        &gHooks[egl_connection_t::GLESv2_INDEX];
                        cnx->dso = loader.open(cnx);
                                dso = load_driver("GLES", cnx, EGL | GLESv1_CM | GLESv2)
                                // /system/lib/egl/
                                        init_api(dso, gl_names,
                                cnx->libEgl   = load_wrapper("/system/lib/libEGL.so");
                                cnx->libGles2 = load_wrapper("/system/lib/libGLESv2.so");
                                cnx->libGles1 = load_wrapper("/system/lib/libGLESv1_CM.so")
                egl_display_t::getFromNativeDisplay
                        sDisplay[uintptr_t(disp)].getDisplay(disp)
    eglInitialize(mEGLDisplay, NULL, NULL);
        egl_display_t::initialize
                cnx->egl.eglInitialize(
        sp<VSyncSource> vsyncSrc = new DispSyncSource(&mPrimaryDispSync,
            vsyncPhaseOffsetNs, true, "app");
    mEventThread = new EventThread(vsyncSrc);
        mVSyncSource(src),
        se.sigev_notify = SIGEV_THREAD;
        se.sigev_value.sival_ptr = this;
        se.sigev_notify_function = vsyncOffCallback;
        se.sigev_notify_attributes = NULL;
        timer_create(CLOCK_MONOTONIC, &se, &mTimerId);
        onFirstRef
                run("EventThread", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);
                        EventThread::threadLoop
    sp<VSyncSource> sfVsyncSrc = new DispSyncSource(&mPrimaryDispSync,
            sfVsyncPhaseOffsetNs, true, "sf");
    mSFEventThread = new EventThread(sfVsyncSrc);
    mEventQueue.setEventThread(mSFEventThread);
        mEventThread = eventThread;
            mEvents = eventThread->createEventConnection();
                new Connection(const_cast<EventThread*>(this))
                        mEventThread(eventThread), mChannel(new BitTube()
                        EventThread::Connection::onFirstRef
                                mEventThread->registerDisplayEventConnection(this)
                                        mDisplayEventConnections.add(connection);
            mEventTube = mEvents->getDataChannel();
            mLooper->addFd(mEventTube->getFd(), 0, Looper::EVENT_INPUT,
                    MessageQueue::cb_eventReceiver, this);
                                queue->eventReceiver(fd, events);
                                        DisplayEventReceiver::getEvents(mEventTube, buffer, 8)
                                        mHandler->dispatchInvalidate();
                                                mQueue.mLooper-se>sendMessage(this, Message(MessageQueue::INVALIDATE));
                                                        MessageQueue::Handler::handleMessage
                                                                mQueue.mFlinger->onMessageReceived(message.what);
    mHwc = new HWComposer(this,
            *static_cast<HWComposer::EventHandler *>(this));
        property_get("debug.sf.no_hw_vsync", value, "0");
        int fberr = loadFbHalModule();
                hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module);
                framebuffer_open(module, &mFbDev);
                        module->methods->open(module, GRALLOC_HARDWARE_FB0,
        loadHwcModule();
                hw_get_module(HWC_HARDWARE_MODULE_ID, &module)
                hwc_open_1(module, &mHwc);
        mCBContext->hwc = this;
        mCBContext->procs.invalidate = &hook_invalidate;
        mCBContext->procs.vsync = &hook_vsync;
        mHwc->registerProcs(mHwc, &mCBContext->procs)
        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0);
        queryDisplayProperties(i);
                mHwc->getDisplayConfigs(mHwc, disp, configs, &numConfigs)
                mHwc->getDisplayAttributes(mHwc, disp, configs[c],
                mDisplayData[disp].configs.push_back(config);

    mRenderEngine = RenderEngine::create(mEGLDisplay, mHwc->getVisualID());
        config = chooseEglConfig(display, hwcFormat);
        contextClientVersion = 2;
        EGLint contextAttributes[] = {
            EGL_CONTEXT_CLIENT_VERSION, contextClientVersion,      // MUST be first
        EGLContext ctxt = eglCreateContext(display, config, NULL, contextAttributes);
        EGLSurface dummy = eglCreatePbufferSurface(display, dummyConfig, attribs);
        eglMakeCurrent(display, dummy, dummy, ctxt);
        engine = new GLES20RenderEngine();
        eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\
        engine->setEGLHandles(config, ctxt);
    mEGLContext = mRenderEngine->getEGLContext();
    createBuiltinDisplayLocked(type);
        mBuiltinDisplays[type] = new BBinder();
    wp<IBinder> token = mBuiltinDisplays[i];
    BufferQueue::createBufferQueue(&producer, &consumer, new GraphicBufferAlloc());
    fbs = new FramebufferSurface(*mHwc, i, consumer);
        ConsumerBase(consumer),
        mDisplayType(disp),
    hwcId = allocateHwcDisplayId(type);
         mHwc->allocateDisplayId()
    hw = new DisplayDevice(this,
                    type, hwcId, mHwc->getFormat(hwcId), isSecure, token,
                    fbs, producer,
                    mRenderEngine->getEGLConfig());
        mNativeWindow = surface = new Surface(producer, false);
        eglSurface = eglCreateWindowSurface(display, config, window, NULL);
        mDisplayName = "Built-in Screen";
        setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
                frame = Rect(w, h);
                viewport = Rect(w, h);
                DisplayDevice::orientationToTransfrom(orientation, w, h, &R)
                mGlobalTransform = R * TP * S * TL;
                mScissor = mGlobalTransform.transform(viewport);
    mDisplays.add(token, hw);
    getDefaultDisplayDevice()->makeCurrent(mEGLDisplay, mEGLContext);
        sur = eglGetCurrentSurface(EGL_DRAW);
        eglMakeCurrent(dpy, mSurface, mSurface, ctx);
        setViewportAndProjection();
                mFlinger->getRenderEngine().setViewportAndProjection(w, h, sourceCrop, h,
                false, Transform::ROT_0);
                glViewport(0, 0, vpw, vph);
                mState.setProjectionMatrix(m);
    mEventControlThread = new EventControlThread(this);
    mEventControlThread->run("EventControl", PRIORITY_URGENT_DISPLAY);
        mFlinger->eventControl(HWC_DISPLAY_PRIMARY,
                    SurfaceFlinger::EVENT_VSYNC, mVsyncEnabled);
    initializeDisplays();
        flinger->onInitializeDisplays();
                setPowerModeInternal(getDisplayDevice(d.token), HWC_POWER_MODE_NORMAL);
                hw->setPowerMode(mode);
                mEventThread->onScreenAcquired();
                        mUseSoftwareVSync = false
                        mCondition.broadcast();
                resyncToHardwareVsync(true);
                        mPrimaryDispSync.beginResync();
                        mEventControlThread->setVsyncEnabled(true);
                                mFlinger->eventControl(HWC_DISPLAY_PRIMARY
                                        ATRACE_CALL();
                                        getHwComposer().eventControl(disp, event, enabled);
                                                mHwc->eventControl(mHwc, disp, event, enabled)
                repaintEverything();
    startBootAnim();

handle_adf_event
        dev->event_cb->vsync(dev->event_cb_data, disp, vsync->timestamp);
                HWComposer::vsync
                         snprintf(tag, sizeof(tag), "HW_VSYNC_%1u", disp);
                         ATRACE_INT(tag, ++mVSyncCounts[disp] & 1);
                         mEventHandler.onVSyncReceived(disp, timestamp);
                                SurfaceFlinger::onVSyncReceived
                                        needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);
                                                DispSync::addResyncSample
                                                        updateModelLocked();
                                                                mPeriod = durationSum / (mNumResyncSamples - 1);
                                                                sampleAvgX /= double(mNumResyncSamples);
                                                        sampleAvgY /= double(mNumResyncSamples);
                                                        mPhase = nsecs_t(atan2(sampleAvgY, sampleAvgX) / scale);
                                                                ATRACE_INT64("DispSync:Period", mPeriod);
                                                        ATRACE_INT64("DispSync:Phase", mPhase);
                                                        mThread->updateModel(mPeriod, mPhase);
                                                                mPeriod = period;
                                                                mPhase = phase;
                                                                mCond.signal();

mThread->run("DispSync", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);
DispSyncThread::threadLoop
        nextEventTime = computeNextEventTimeLocked(now);
                t = computeListenerNextEventTimeLocked
    targetTime = nextEventTime;
    mCond.waitRelative(mMutex, targetTime - now);
    now = systemTime(SYSTEM_TIME_MONOTONIC);
        callbackInvocations = gatherCallbackInvocationsLocked(now);
                 mEventListeners[i].mCallback
        fireCallbackInvocations(callbackInvocations);
                callbacks[i].mCallback->onDispSyncEvent(callbacks[i].mEventTime);
                DispSyncSource::onDispSyncEvent
                        ATRACE_INT(mVsyncEventLabel.string(), mValue);
                        callback->onVSyncEvent(when);
                        EventThread::onVSyncEvent
                                mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;
                            mVSyncEvent[0].header.id = 0;
                            mVSyncEvent[0].header.timestamp = timestamp;
                            mVSyncEvent[0].vsync.count++;
                            mCondition.broadcast();
                            EventThread::threadLoop
                                signalConnections = waitForEvent(&event);
                                sp<Connection>& conn(signalConnections[i]);
                                conn->postEvent(event);
                                        MessageQueue::cb_eventReceiver, this);
                                                queue->eventReceiver(fd, events);
                                                        DisplayEventReceiver::getEvents(mEventTube, buffer, 8)
                                                        mHandler->dispatchInvalidate();
                                                                mQueue.mLooper-se>sendMessage(this, Message(MessageQueue::INVALIDATE));
                                                                        MessageQueue::Handler::handleMessage
                                                                                mQueue.mFlinger->onMessageReceived(message.what);


// count >= 1 : continuous event. count is the vsync rate
// count == 0 : one-shot event that has not fired
// count ==-1 : one-shot event that fired this round / disabled
EventThread::waitForEvent
        size_t count = mDisplayEventConnections.size();
    for (size_t i=0 ; i<count ; i++) {
        connection(mDisplayEventConnections[i].promote());
        if (connection->count >= 0)
                waitForVSync = true;
                if (timestamp) {
                        if (connection->count == 0) {
                                connection->count = -1;
                    signalConnections.add(connection);
    if (timestamp && !waitForVSync) {
                disableVSyncLocked();
    } else if (!timestamp && waitForVSync) {
            enableVSyncLocked();
                        EventThread::enableVSyncLocked();
                                        mVSyncSource->setCallback(static_cast<VSyncSource::Callback*>(this));
                                                mCallback = callback;
                                mVSyncSource->setVSyncEnabled(true);
                                        mDispSync->addEventListener(mPhaseOffset,
                                                static_cast<DispSync::Callback*>(this));
                                                mThread->addEventListener(phase, callback);
                                                        mEventListeners.push(listener);

EventThread::requestNextVsync
        if (connection->count < 0) {
        connection->count = 0;
        mCondition.broadcast();
    }


SurfaceFlinger::postComposition
        DispSync::addPresentFence
                for (size_t i = 0; i < NUM_PRESENT_SAMPLES
                        nsecs_t t = f->getSignalTime();
                        mPresentTimes[i] = t + kPresentTimeOffset;
                updateErrorLocked();
                        nsecs_t sampleErr = (sample - mPhase) % period;
                        mError = sqErrSum / numErrSamples;
*** SensorService
SensorService
        SensorService::onFirstRef
                SensorDevice:: getInstance
                        hw_get_module(SENSORS_HARDWARE_MODULE_ID,
                                mSensorModule->get_sensors_list(mSensorModule, &list);
                                mActivationCount.add(list[i].handle, model);
                mSensorDevice->activate(
        dev.initCheck
        dev.getSensorList(&list);
        registerSensor( new HardwareSensor(list[i]) );
                Sensor sensor(s->getSensor());
                // add to the sensor list (returned to clients)
                mSensorList.add(sensor);
                // add to our handle->SensorInterface mapping
                mSensorMap.add(sensor.getHandle(), s);
        SensorFusion::getInstance());
        registerVirtualSensor( new RotationVectorSensor
        registerVirtualSensor( new N(lis
        registerVirtualSensor( new LinearAccelerationS
                if (virtualSensorsNeeds & (1<<SENSOR_TYPE_ROTATION_VECTOR\|{
                   mUserSensorList.replaceAt(aSensor, orientationIndex);
               }
        registerVirtualSensor( new CorrectedGyroSensor
        mLooper = new Looper(false);

SensorService::threadLoop
        device.poll(mSensorEventBuffer, numEventMax);
        recordLastValue(buffer, count);
        fusion.process(event[i]);
        activeConnections[i]->sendEvents(mSensorEventBuffer,
        //SensorService::SensorEventConnection::sendEvents
                // filter out events not for this connection
                sendPendingFlushEventsLocked();
                findWakeUpSensorEventLocked(scratch, count);
                SensorEventQueue::write(mChannel,
                        BitTube::sendObjects(tube, events, numEvents);

SensorManager::getInstanceForPackage  //android N


ANDROID_SINGLETON_STATIC_INSTANCE(SensorManager)
        SensorManager::SensorManager()
                assertStateLocked();
                        getService("sensorservice", &mSensorServer);
                        mSensors = mSensorServer->getSensorList();

gBaseEventQueueClassInfo.dispatchSensorEvent = GetMethodIDOrDie(env,
            gBaseEventQueueClassInfo.clazz, "dispatchSensorEvent"


class Receiver : public LooperCallback {
        handleEvent
                q = reinterpret_cast<SensorEventQueue *>(data)
                q->read(buffer, 16)
                receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal));
                env->CallVoidMethod(receiverObj.get(),gBaseEventQueueClassInfo.dispatchSensorEvent,
                        SensorEventQueue::dispatchSensorEvent(int handle, float[] values, int inAccuracy,
                                final Sensor sensor = mManager.mHandleToSensor.get(handle);
                                 mListener.onSensorChanged(t);

public boolean registerListener(SensorEventListener listener, Sensor sensor,
        return registerListener(listener, sensor, samplingPeriodUs, null);
                queue = new SensorEventQueue(listener, looper, this);
                        static final class SensorEventQueue extends BaseEventQueue
                                super(looper, manager, OPERATING_MODE_NORMAL, packageName);
                                 nativeInitBaseEventQueue(manager.mNativeInstance,
                                            new WeakReference<>(this), looper.getQueue(), mScratch,
                                            packageName, mode, manager.mContext.getOpPackageName());
                                        JNINativeMethod gBaseEventQueueMethods[] = {
                                            {"nativeInitBaseEventQueue",                                                |
                                                    "(Landroid/hardware/SystemSensorManager$BaseEventQueue;Landroid/os/MessageQueue;[F)J",
                                                        (void*)nativeInitSensorEventQueue },
                                        nativeInitSensorEventQueue
                                                sp<SensorEventQueue> queue(mgr.createEventQueue());
                                                         mSensorServer->createSensorEventConnection();
                                                                 SensorService::createSensorEventConnection
                                                                        new SensorEventConnection(this, uid)
                                                                                mChannel = new BitTube(mService->mSocketBufferSize);
                                                                                        BitTube::init
                                                                                                socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)
                                                                                                mReceiveFd = sockets[0];
                                                                                        mSendFd = sockets[1];
                                                                                SensorService::SensorEventConnection::onFirstRef()
                                                                                        LooperCallback::onFirstRef()
                                                         new SensorEventQueue(connection);
                                                                 mSensorChannel = mSensorEventConnection->getSensorChannel();
                                                                 mRecBuffer = new ASensorEvent[MAX_RECEIVE_BUFFER_EVENT_COUNT];
                                                messageQueue = android_os_MessageQueue_getMessageQueue(e
                                                receiver = new Receiver(queue, messageQueue, eventQ, scratch);
                                                        onFirstRef
                                                                mMessageQueue->getLooper()->addFd(mSensorQueue->getFd(),
                                                                         SensorEventQueue::getFd()
                                                                                mSensorChannel->getFd();
                queue.addSensor(sensor, delayUs, maxBatchReportLatencyUs, reservedFlags)
                         addSensorEvent(sensor);
                                SensorEvent t = new SensorEvent(Se
                                mSensorsEvents.put(sensor.getHandle(), t);
                         enableSensor(sensor, delayUs, maxBatchReportLatencyUs, reservedFlags)
                                nativeEnableSensor(nSensorEventQueue, sensor.getHandle(), rateU
                                        receiver->getSensorEventQueue()->enableSensor(han
                                                // SensorEventQueue::enableSensor
                                                mSensorEventConnection->enableDisable(sensor->getHandle(), true,
                                                        mService->enable(this, handle, samplingPeriodNs
                                                                 rec = new SensorRecord(connection);
                                                                 mActiveSensors.add(handle, rec);
                                                                 connection->addSensor(handle)
                                                                 //SensorService::SensorEventConnection::addSensor
                                                                        verifyCanAccessSensor(mService->getSensorFromHandle(handle)
                                                                                mSensorMap.valueFor(handle)->getSensor();



SensorEventQueue::read
        BitTube::recvObjects(mSensorChannel,
                tube->read(vaddr, count*objSize)
                        ::recv(mReceiveFd, vaddr, size, MSG_DONTWAIT);

         TYPE_ORIENTATION
         TYPE_GAME_ROTATION_VECTOR
         TYPE_GYROSCOPE_UNCALIBRATED

SensorBase::SensorBase(
        data_fd = openInput(data_name);

SurfaceTexture_init //gSurfaceTextureMethods

static const JNINativeMethod displayServiceMethods[] = {
        { "_init", "()Z",(void*) actions_server_DisplayService_init
                //device/actions/common/frameworks/services/jni/com_actions_server_DisplayService.cpp:
                hw_get_module(DM_HARDWARE_MODULE_ID, (const hw_module_t**) &module)
                owldisp_manager_open(&module->common, &mDisplayManager)

        { "_setHdmiEnable", "(Z)V",(void*) actions_server_DisplayService_setHdmiEnable }
                actions_server_DisplayService_setHdmiEnable
                        mDisplayManager->set_hdmi_enable(mDisplayManager,enable)
*** GVR
CardboardViewNativeImpl
TreasureHuntActivity extends GvrActivity implements GvrView.StereoRenderer
        initializeGvrView
                GvrView gvrView = (GvrView) findViewById(R.id.gvr_view);
                        init(context);
                        this.cardboardViewApi = ImplementationSelector.createCardboardViewApi(context);
                                new CardboardViewNativeImpl(context);

                        addView(this.cardboardViewApi.getRootView(), 0);
                        GLSurfaceView glSurfaceView = this.cardboardViewApi.getGLSurfaceView();

                setGvrView(gvrView);
                        gvrView.setOnCardboardTriggerListener(new Runnable() GvrActivity.this.onCardboardTrigger();
                                this.cardboardViewApi.setOnCardboardTriggerListener(listener);
                        NdefMessage tagContents = this.sensorConnection.getNfcSensor().getTagContents();
                        updateGvrViewerParams(GvrViewerParams.createFromNfcContents(tagContents));
                                createFromUri
                                        cardboardV1ViewerParams
                                                deviceParams.distortion = Distortion.cardboardV1Distortion();
                                                        params.coefficients = ((float[])CARDBOARD_V1_COEFFICIENTS.clone());
                        gvrView.setConvertTapIntoTrigger(this.convertTapIntoTriggerEnabled);

GvrView
        setScanlineRacingEnabled (boolean enabled)
        setOnTransitionViewDoneListener
        setNeckModelEnabled
        setElectronicDisplayStabilizationEnabled
                CardboardViewNativeImpl.this.nativeSetElectronicDisplayStabilizationEnabled
        setOnCardboardTriggerListener
        setDistortionCorrectionEnabled
                CardboardViewNativeImpl.this.nativeSetDistortionCorrectionEnabled(CardboardViewNativeImpl.this.nativeCardboardView, enabled);
        getInterpupillaryDistance

GvrViewerParams
        setDefaultValues
                this.vendor = "Google, Inc.";
/* 622 */     this.model = "Default Cardboard";
/* 623 */     this.interLensDistance = 0.064F;
/* 624 */     this.verticalAlignment = CARDBOARD_V2_2_VERTICAL_ALIGNMENT;
/* 625 */     this.verticalDistanceToLensCenter = 0.035F;
/* 626 */     this.screenToLensDistance = 0.039F;
/* 627 */     this.leftEyeMaxFov = new FieldOfView();
/* 628 */     this.hasMagnet = false;
/*     */
/* 630 */     this.distortion = new Distortion();
ScreenParams
Distortion
        private static final float[] CARDBOARD_V2_2_COEFFICIENTS = { 0.34F, 0.55F };
        private static final float[] CARDBOARD_V1_COEFFICIENTS = { 0.441F, 0.156F };

HeadMountedDisplayManager
        this.paramsProvider = VrParamsProviderFactory.create(context);
                new Intent("android.content.action.VR_SETTINGS_PROVIDER");
                providerResolveInfos = pm.queryIntentContentProviders(providerIntent, 0);
                ContentProviderClient client = context.getContentResolver().acquireContentProviderClient(authority);
                new ContentProviderVrParamsProvider(client, authority);
        this.hmd = new HeadMountedDisplay(createScreenParams(), createGvrViewerParams());
                createScreenParams
                        Display display = getDisplay();
                        ScreenParams params = ScreenParams.fromProto(display, this.paramsProvider.readPhoneParams());
                createGvrViewerParams
                        new GvrViewerParams(this.paramsProvider.readDeviceParams());
StereoRenderer
        onDrawEye(Eye eye)
        onFinishFrame(Viewport viewport)
        onNewFrame(HeadTransform headTransform)
        onRendererShutdown()
        onSurfaceChanged(int width, int height)
        onSurfaceCreated(EGLConfig config)
** weave + brillo
curl -k  -d  '{ "authentication": {"anonymousMaxScope": "viewer","mode": "anonymous" }}' -H "Authorization:Privet anonymous"  https://ac-Latitude-E6430.local.:7781/privet/v3/auth

curl -k  -d '{"componet": "led1","name":"onOff.setConfig", "parameters": {"state": "on"}}'   -H "Content-Type: application/json" -H 'Authorization:Privet WCuFRggaHsa3j0IBDkQJQjEAQgpARgUaHsbFn1BCFwW9x4g40hTyRx+42zr6' https://ac-Latitude-E6430.local.:7781/privet/v3/commands/execute

sudo out/Debug/weave_daemon_sample --registration_ticket=93019287-6b26-04a0-22ee-d55ad23a4226
main
        Daemon daemon{opts}
                task_runner_{new weave::examples::EventTaskRunner},
        config_store_{new weave::examples::FileConfigStore(opts.model_id,
        http_client_{new weave::examples::CurlHttpClient(task_runner_.get())},
        network_{new weave::examples::EventNetworkImpl(task_runner_.get())},
                 UpdateNetworkState();
                        connectivity_probe_.reset(bufferevent_socket_new
                                bufferevent_setcb(
                                        [](struct bufferevent* buf, short events, void* ctx) {
                                                if (events & BEV_EVENT_CONNECTED) {
                                                network->UpdateNetworkStateCallback(State::kOnline);
        bluetooth_{new weave::examples::BluetoothImpl} {
                dns_sd_.reset(new weave::examples::AvahiClient);
                // LOG(INFO) << "connecting to avahi-daemon";
                new weave::examples::HttpServerImpl{task_runner_.get()});
                                 SSL_library_init();
                                 httpd_.reset(evhtp_new(task_runner_->GetEventBase(), nullptr));
                                 evhtp_bind_socket(httpd_.get(), "0.0.0.0", GetHttpPort(), -1) //7780


                device_ = weave::Device::Create(config_store_.get(), task_runner_.get(),
                        new DeviceManager{config_store, task_runner, http_client, network, dns_sd,
                                new Config{config_store
                                        CreateDefaultSettings(config_store)
                                                config_store->LoadDefaults(&result)
                                        Transaction change{this};
                                        change.LoadState();
                                                config_->config_store_->LoadSettings(kConfigName);
                                                //Loading settings from /var/lib/weave/weave_settings_AAAAA_config.json
                                                config_->config_store_->LoadSettings();
                                                //Loading settings from /var/lib/weave/weave_settings_AAAAA.json
                                        Config::Transaction::~Transaction()
                                                Commit();
                                                        config_->Save();
                                                                config_store_->SaveSettings(
                                                        //Saving settings to /var/lib/weave/weave_settings_AAAAA_config.json
                                new ComponentManagerImpl{task_runner}
                                new AccessApiHandler{this, access_revocation_manager_.get()}
                    new AccessRevocationManagerImpl{config_store});
                                        Load();
                                                store_->LoadSettings(kConfigFileName)
                                                //Loading settings from /var/lib/weave/weave_settings_AAAAA_black_list.json
                        new privet::AuthManager(config_.get(), access_revocation_manager_.get(),
                                http_server->GetHttpsCertificateFingerprint()));
                        new AccessApiHandler{this, access_revocation_manager_.get()});
                                new DeviceRegistrationInfo(
                                        component_manager_->AddTraitDefChangedCallback(base::Bind(
                                        &DeviceRegistrationInfo::OnTraitDefsChanged, weak_factory_.GetWeakPtr()));
                                        on_trait_changed_.push_back(callback);
                                                //callback.Run();
                                                DeviceRegistrationInfo::OnTraitDefsChanged
                                                        // VLOG(1) << "CommandDefinitionChanged notification received";
                                                        UpdateDeviceResource(base::Bind(&IgnoreCloudError));
                                        component_manager_->AddComponentTreeChangedCallback(
                                        base::Bind(&DeviceRegistrationInfo::OnComponentTreeChanged,
                                                //device_registration_info.cc(1276)] ComponentTreeChanged notification received
                        component_manager_->AddStateChangedCallback(base::Bind(
                                        &DeviceRegistrationInfo::OnStateChanged, weak_factory_.GetWeakPtr()));
                                        //device_registration_info.cc(1267)] StateChanged notification received
                                 device_info_->Start();
                                 //LOG(INFO) << "Starting notification channel";

                                StartPrivet();
                                        new privet::Manager{task_runner_}
                                        privet_->Start(network_
                                                device_ = DeviceDelegate::CreateDefault(
                                                cloud_ = CloudDelegate::CreateDefault(task_runner_, device, component_manager);
                                                        new CloudDelegateImpl{task_runner, device, component_manager}};
                                                                device_->AddGcdStateChangedCallback(base::Bind(
                                                                &CloudDelegateImpl::OnRegistrationChanged, weak_factory_.GetWeakPtr()));
                                                            component_manager_->AddCommandAddedCallback(base::Bind(
                                                                &CloudDelegateImpl::OnCommandAdded, weak_factory_.GetWeakPtr()));
                                                            component_manager_->AddCommandRemovedCallback(base::Bind(
                                                                 &CloudDelegateImpl::OnCommandRemoved, weak_factory_.GetWeakPtr()));
                                            network->AddConnectionChangedCallback(
                                              base::Bind(&Manager::OnConnectivityChanged, base::Unretained(this)));
                                                // VLOG(1) << "Enabling WiFi bootstrapping.";
                                            new WifiBootstrapManager(
                                            wifi_bootstrap_manager_->Init();
                                                 UpdateConnectionState();
                                                 //VLOG(3) << "New network state: " << EnumToString(service_state);
                                                 EventNetworkImpl->AddConnectionChangedCallback(
                                                        base::Bind(&WifiBootstrapManager::OnConnectivityChange,
                                                StartMonitoring(
                                                        base::TimeDelta::FromSeconds(kMonitoringWithSsidTimeoutSeconds))
                                                        ContinueMonitoring(timeout);
                                                        //VLOG(1) << "Monitoring connectivity.";
                                                                UpdateState(State::kMonitoring);
                                                                //Switching state from disabled to monitoring
                                                        //VLOG(2) << "Waiting for connection until: " << monitor_until_;
                                            (new Publisher(device_.get(),
                                                Update();
                                                        ExposeService();
                                                                //VLOG(2) << "DNS-SD update requested";
                                                                // VLOG(1) << "Updating service using DNS-SD, port: " << port
                                                                dns_sd_->PublishService(kPrivetServiceType, port, txt_record);
                                                                AvahiClient::PublishService
                                                                        //LOG(INFO) << "Publishing service";
                                                                        avahi_entry_group_update_service_txt_strlst

                                                privet_handler_.reset(new PrivetHandler(cloud_.get(), device_.get(),
                                                        cloud_->AddOnTraitsChangedCallback(base::Bind(
                                                              &PrivetHandler::OnTraitDefsChanged,
                                                              component_manager_->AddTraitDefChangedCallback(callback);
                                                              ComponentManagerImpl::AddTraitDefChangedCallback
                                                                        on_trait_changed_.push_back(callback);
                                                                                callback.Run();
                                                                                PrivetHandler::OnTraitDefsChanged


                                                        cloud_->AddOnStateChangedCallback(base::Bind(&PrivetHandler::OnStateChanged,
                                                        cloud_->AddOnComponentsChangeCallback(base::Bind(
                                                              &PrivetHandler::OnComponentTreeChanged,
                                                        AddHandler("/privet/info", &PrivetHandler::HandleInfo, AuthScope::kNone);
                                                        AddHandler("/privet/v3/pairing/start", &PrivetHandler::HandlePairingStart,
                                                for (const auto& path : privet_handler_->GetHttpPaths()) {
                                                        http_server->AddHttpRequestHandler(path, base::Bind(&Manager::PrivetRequestHandler,
                                                        handlers_[std::make_pair(path, httpd_.get())] = callback;
                                                                evhtp_set_cb(httpd_.get(), path.c_str(), &ProcessRequestCallback, this);

                                        http_server->AddHttpsRequestHandler(
                                                path, base::Bind(&Manager::PrivetRequestHandler,
                        AddSettingsChangedCallback(base::Bind(&DeviceManager::OnSettingsChanged,



        SampleHandler handler{daemon.GetTaskRunner()};
        handler.Register(daemon.GetDevice());
        daemon.Run();
                device_->Register(registration_data_, base::Bind(&OnRegisterDeviceDone, device_.get()))
                        device_info_->RegisterDevice(registration_data, callback);
                        DeviceRegistrationInfo::RegisterDevice
                                registration_data.oauth_url = GetDefaults().oauth_url;
                            registration_data.client_id = GetDefaults().client_id;
                            registration_data.client_secret = GetDefaults().client_secret;
                            registration_data.api_key = GetDefaults().api_key;
                                VLOG(1) << "RegisterDevice: "
                                  << "ticket_id: " << registration_data.ticket_id
                                  << ", oauth_url: " << registration_data.oauth_url
                                  << ", client_id: " << registration_data.client_id
                                  << ", client_secret: " << registration_data.client_secret
                                  << ", api_key: " << registration_data.api_key
                                  << ", service_url: " << registration_data.service_url
                                  << ", xmpp_endpoint: " << registration_data.xmpp_endpoint;
                            // RegisterDevice: ticket_id: 7b9689b0-65c2-b201-bb4b-29ed8d60eb59,
                            // oauth_url: https://accounts.google.com/o/oauth2/,
                            // client_id: 251090581729-ibu9pvq4f94rc8gkejtsrdd810p159qd.apps.googleusercontent.com,
                            // client_secret: g047ACP5rH0LkCf5345jSnZb,
                            // api_key: AIzaSyD5Ky09Wl9z9H01xd6vEixXNaaTNK_8YxM,
                            // service_url: https://www.googleapis.com/weave/v1/,
                            // xmpp_endpoint: talk.google.com:5223
                            RequestSender sender{HttpClient::Method::kPatch, url, http_client_};
                                sender.SetJsonData(req_json);
                                sender.Send(base::Bind(&DeviceRegistrationInfo::RegisterDeviceOnTicketSent,
                                        //VLOG(1) << "Sending request. id:" << debug_id
                                //<< " method:" << EnumToString(method_) << " url:" << url_;
                                        //VLOG(2) << "Request data: " << data_;
                                        transport_->SendRequest(method_, url_, GetFullHeaders(), data_,
                            base::Bind(on_done, debug_id, callback));
                                                CurlHttpClient::SendRequest
                                                        pending_tasks_.emplace_back(
                                                std::async(std::launch::async, SendRequestBlocking, method, url, headers,
                                                                SendRequestBlocking
                                                        CheckTasks();
                                                        //VLOG(4) << "CurlHttpClient::CheckTasks, size=" << pending_tasks_.size();

                task_runner_->Run();

DeviceRegistrationInfo::RegisterDevice
        DeviceRegistrationInfo::RegisterDeviceOnTicketSent
                RegisterDeviceOnTicketFinalized
                        RegisterDeviceOnAuthCodeSent

DeviceRegistrationInfo::RegisterDeviceOnAuthCodeSent
        change.set_robot_account(robot_account);
        change.set_refresh_token(refresh_token);
        StartNotificationChannel();
                //LOG(INFO) << "Starting notification channel";
                pull_channel_.reset(new PullChannel{pull_interval, task_runner_});
                        pull_channel_->Start(this);
                                delegate_ = delegate;
                                RePost();
                                        delegate_->OnCommandCreated(empty_dict, GetName());
                                        //DeviceRegistrationInfo::OnCommandCreated
                                        //VLOG(1) << "Command notification received: " << command;
                primary_notification_channel_.reset(
                new XmppChannel{GetSettings().robot_account, access_token_,
                        parser_ = XML_ParserCreate(nullptr);

                                XML_SetUserData(parser_, this);
                                XML_SetElementHandler(parser_, &XmppStreamParser::HandleElementStart,
                        &XmppStreamParser::HandleElementEnd);
                                XML_SetCharacterDataHandler(parser_, &XmppStreamParser::HandleCharData);
                                iq_stanza_handler_{new IqStanzaHandler{this, task_runner}}
                        CreateSslSocket();
                                //LOG(INFO) << "Starting XMPP connection to: " << xmpp_endpoint_;
                                //Starting XMPP connection to: talk.google.com:5223
                                network_->OpenSslSocket(host_port.first, port,
                          base::Bind(&XmppChannel::OnSslSocketReady,
                                EventNetworkImpl::OpenSslSocket(
                                        SSLStream::Connect(task_runner_, host, port, callback);
                        OnSslSocketReady
                                RestartXmppStream();
                                        SendMessage(BuildXmppStartStreamCommand());//....
                                                        ScheduleRegularPing();
                                                                SchedulePing(base::TimeDelta::FromSeconds(kRegularPingIntervalSeconds),
                                                                        //VLOG(1) << "Next XMPP ping in " << interval << " with timeout " << timeout;
                                                                        //Next XMPP ping in 60s with timeout 30s
                                                                        task_runner_->PostDelayedTask(FROM_HERE, base::Bind(&
                                                                        XmppChannel::PingServer,
                                                                                //VLOG(1) << "Sending XMPP ping";
                                                                                iq_stanza_handler_->SendRequestWithCustomTimeout(
                                                                                "get", jid_, account_, "<ping xmlns='urn:xmpp:ping'/>", timeout,
                                                                                base::Bind(&XmppChannel::OnPingResponse, task_ptr_factory_.GetWeakPtr(),
        primary_notification_channel_->Start(this)

        SendAuthInfo();
        ScheduleCloudConnection({});

SendMessage(BuildXmppStartStreamCommand());
        //  VLOG(2) << "Sending XMPP message: "
        // <stream:stream to='clouddevices.gserviceaccount.com' xmlns:stream='http://etherx.jabber.org/streams' xml:lang='*' version='1.0' xmlns='jabber:client'>
         stream_->Write(write_socket_data_.data(), write_socket_data_.size(),
                        base::Bind(&XmppChannel::OnMessageSent
                                OnMessageSent
                                 WaitForMessage();
                                        stream_->Read(read_socket_data_.data(), read_socket_data_.size(),
                                                base::Bind(&XmppChannel::OnMessageRead,
                                                OnMessageRead
                                                        //VLOG(2) << "Received XMPP packet: '" << msg << "'";
                                                        //Received XMPP packet: '<stream:stream from="clouddevices.gserviceaccount.com" id="6D74DC06FCA95808" version="1.0" xmlns:stream="http://etherx.jabber.org/streams" xmlns="jabber:client">'
                                                        stream_parser_.ParseData(msg);
                                                        XmppStreamParser::ParseData
                                                                XML_Parse(parser_, data.data(), data.size(), 0);
                                                                        XmppStreamParser::HandleElementStart
                                                                                XmppStreamParser::OnOpenElement
                                                                                //delegate_->OnStreamStart(node_name, std::move(attributes))
                                                                                        XmppChannel::OnStreamStart
                                                                                        //VLOG(2) << "XMPP stream start: " << node_name;
                                                                                        //XMPP stream start: stream:stream
                                                                                        node_stack_.emplace(new XmlNode{node_name, std::move(attributes)});
                                                        WaitForMessage();
                                                                //Received XMPP packet: '<stream:features><mechanisms xmlns="urn:ietf:params:xml:ns:xmpp-sasl"><mechanism>X-OAUTH2</mechanism><mechanism>X-GOOGLE-TOKEN</mechanism><mechanism>PLAIN</mechanism></mechanisms></stream:features>'
                                                                XmppStreamParser::HandleElementEnd
                                                                        XmppStreamParser::OnCloseElement
                                                                                //delegate_->OnStanza(std::move(node));
                                                                                XmppChannel::OnStanza
                                                                                        task_runner_->PostDelayedTask(
                                                                                base::Bind(&XmppChannel::HandleStanza,
                                                                                XmppChannel::HandleStanza
                                                                                        //VLOG(2) << "XMPP stanza received: " << stanza->ToString();
                                                                                        //XMPP stanza received: <stream:features><mechanisms xmlns="urn:ietf:params:xml:ns:xmpp-sasl"><mechanism>X-OAUTH2</mechanism><mechanism>X-GOOGLE-TOKEN</mechanism><mechanism>PLAIN</mechanism></mechanisms></stream:features>

XmppChannel::HandleStanza
        kConnected
        SendMessage(BuildXmppAuthenticateCommand(account_, access_token_));
        //Sending XMPP message: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='X-OAUTH2' auth:service='oauth2' auth:allow-non-google-login='true' auth:client-uses-full-bind-result='true' xmlns:auth='http://www.google.com/talk/protocol/auth'>ADBkMDdiNjcwZDNmMjhiN2EyNWU1ODViMjEwZjU5ZmZiQGNsb3VkZGV2aWNlcy5nc2VydmljZWFjY291bnQuY29tAHlhMjkuLnl3SU5YTXVzU2YxN2lWMl9zR0NjTTFZRVlDaUUtSEZzQXBmTnU0aVNORHBRaTRFdl9pU1dtQVpteEpES0ctOUJLQQ==</auth>
                BuildXmppAuthenticateCommand
                        Base64Encode
        //Received XMPP packet: '<success xmlns="urn:ietf:params:xml:ns:xmpp-sasl"/>'
        kAuthenticationStarted
        //XMPP stanza received: <success xmlns="urn:ietf:params:xml:ns:xmpp-sasl"/>
        RestartXmppStream();
                SendMessage(BuildXmppStartStreamCommand());
                        XmppChannel::OnStreamStart
                        //XMPP stream start: stream:stream

                        //Received XMPP packet: '<stream:features><bind xmlns="urn:ietf:params:xml:ns:xmpp-bind"/><session xmlns="urn:ietf:params:xml:ns:xmpp-session"/></stream:features>'
        kStreamRestartedPostAuthentication
                //XMPP stanza received: <stream:features><bind xmlns="urn:ietf:params:xml:ns:xmpp-bind"/><session xmlns="urn:ietf:params:xml:ns:xmpp-session"/></stream:features>
                stanza->FindFirstChild("bind", false
                IqStanzaHandler
                iq_stanza_handler_->SendRequest(
            "set", "", "", "<bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>",
            base::Bind(&XmppChannel::OnBindCompleted,
                       task_ptr_factory_.GetWeakPtr()),
            base::Bind(&XmppChannel::Restart, task_ptr_factory_.GetWeakPtr()));
                        BuildIqStanza(std::to_string(last_request_id_), type, to, from, body);
                        requests_.insert(std::make_pair(++last_request_id_, response_callback));
                        xmpp_channel_->SendMessage(message);
                        // Sending XMPP message: <iq id='1' type='set'><bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/></iq>
                        XmppChannel::OnBindCompleted,

        kBindSent
                iq_stanza_handler_->HandleIqStanza(std::move(stanza)
                        IqStanzaHandler::HandleIqStanza
                                requests_.find(id)
                                        XmppChannel::OnBindCompleted

XmppChannel::OnBindCompleted
        kSessionStarted
        iq_stanza_handler_->SendRequest(
      "set", "", "", "<session xmlns='urn:ietf:params:xml:ns:xmpp-session'/>",
      base::Bind(&XmppChannel::OnSessionEstablished,
      OnSessionEstablished
        kSubscribeStarted
        std::string body =
        "<subscribe xmlns='google:push'>"
        "<item channel='cloud_devices' from=''/></subscribe>";
        iq_stanza_handler_->SendRequest(
                "set", "", account_, body,
                base::Bind(&XmppChannel::OnSubscribed,
                        XmppChannel::OnSubscribed
                                kSubscribed
                                delegate_->OnConnected(GetName());
                                DeviceRegistrationInfo::OnConnected
                                        base::Bind(&DeviceRegistrationInfo::FetchAndPublishCommands,

                        DeviceRegistrationInfo::SendCloudRequest
                        DeviceRegistrationInfo::OnCloudRequestDone
DeviceRegistrationInfo::RefreshAccessToken

void DeviceRegistrationInfo::OnRefreshAccessTokenDone

//callback control flow
EventNetworkImpl::UpdateNetworkState()
        connectivity_probe_.reset(bufferevent_socket_new
        bufferevent_setcb(
                [](struct bufferevent* buf, short events, void* ctx) {
                        if (events & BEV_EVENT_CONNECTED) {
                        network->UpdateNetworkStateCallback(State::kOnline);

event_base_loop(g_event_base, EVLOOP_ONCE);
        EventNetworkImpl::UpdateNetworkStateCallback(
                Manager::OnConnectivityChanged() {
                        Manager::OnChanged() {
                                //VLOG(1) << "Manager::OnChanged";
                                publisher_->Update();
                                          ExposeService();
                                                //VLOG(2) << "DNS-SD update requested";
                                                //VLOG(1) << "Updating service using DNS-SD, port: " << port;
                                                dns_sd_->PublishService(kPrivetServiceType, port, txt_record);


                task_runner_->PostDelayedTask(
                        FROM_HERE, base::Bind(&EventNetworkImpl::UpdateNetworkState,

//dns sd
new weave::examples::HttpServerImpl{task_runner_.get()});
                                 SSL_library_init();
                                 httpd_.reset(evhtp_new(task_runner_->GetEventBase(), nullptr));
                                 evhtp_bind_socket(httpd_.get(), "0.0.0.0", GetHttpPort(), -1) //7780

StartPrivet();
        new privet::Manager{task_runner_}
        privet_->Start(network_
                for (const auto& path : privet_handler_->GetHttpPaths()) {
                        http_server->AddHttpRequestHandler(path, base::Bind(&Manager::PrivetRequestHandler,
                                handlers_[std::make_pair(path, httpd_.get())] = callback;
                                        evhtp_set_cb(httpd_.get(), path.c_str(), &ProcessRequestCallback, this);


ProcessRequestCallback
        static_cast<HttpServerImpl*>(arg)->ProcessRequest(req);
        HttpServerImpl::ProcessRequest
                new RequestImpl{EventPtr<evhtp_request_t>{req}}
                //it->second.Run(std::move(request));
                Manager::PrivetRequestHandler
                        request->GetData()
                        PrivetRequestHandlerWithData(request, content_type == http::kJson
                                value = base::JSONReader::Read(data)
                                value->GetAsDictionary(&dictionary);
                                PrivetHandler::HandleRequest(request->GetPath(), auth_header, dictionary,
                                base::Bind(&Manager::PrivetResponseHandler,)
                                //(this->*handler->second.handler)(*input, user_info, callback);
                                PrivetHandler::HandleInfo
                                        output.SetString(kInfoVersionKey, kInfoVersionValue);
                                                output.SetString(kInfoIdKey, cloud_->GetDeviceId());
                                                output.SetString(kNameKey, name);
                                                //callback.Run(http::kOk, output);
                                                Manager::PrivetResponseHandler
                                                        base::JSONWriter::WriteWithOptions(output, base::JSONWriter::OPTIONS_PRETTY_PRINT, &data);
                                                        //request->SendReply(status, data, http::kJson);
                                                                HttpServerImpl::SendReply
                                                                evhtp_send_reply_start(req_.get(), status_code);
                                                        evhtp_send_reply_body(req_.get(), buf.get());
                                                        evhtp_send_reply_end(req_.get());

raspberry pi:

make –j5 && make –j5 modules
CONCURRENCY_LEVEL=5 DEB_HOST_ARCH=armhf fakeroot make-kpkg --append-to-version raspberry --revision `date +%Y%m%d%H%M%S` --initrd kernel_image kernel_headers
sudo dpkg -i linux-header*.deb linux-image*.deb
sudo sh –c ‘echo “kernel=vmlinuz-3.18.11-rpi2-v7+” >> config.txt’
** mbed
iperf_run_client
        iperf_connect
                test->ctrl_sck = netdial(test->settings->domain, Ptcp, test->bind_address, 0, test->server_hostname, test->server_port);
                        s = socket(server_res->ai_family, proto, 0);
                        bind(s, (struct sockaddr *) local_res->ai_addr, local_res->ai_addrlen)
                        connect(s, (struct sockaddr *) server_res->ai_addr, server_res->ai_addrlen)
                Nwrite
                        r = write(fd, buf, nleft);
                FD_SET(test->ctrl_sck, &test->read_set);

udpecho_thread
        conn = netconn_new(NETCONN_UDP);
        netconn_bind(conn, NULL, 7);
        while (1)
    {
        err = netconn_recv(conn, &buf);
        netbuf_copy(buf, buffer, buf->p->tot_len)
        err = netconn_send(conn, buf);
        netbuf_delete(buf);
*** lwip
main
        app_low_level_init
        tcpip_init
        netif_add
        netif_set_default
        ping_init
                sys_thread_new("ping_thread", ping_thread, NULL, PING_STACKSIZE, PING_PRIORITY);
                OSA_Start();
                    vTaskStartScheduler();
                while(1){}

ping_thread
        netif_set_up(&fsl_netif0);
        lwip_socket(AF_INET, SOCK_RAW, IP_PROTO_ICMP)
        lwip_setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout))
        while (1)
    {
        ping_send(s, &ping_target)
                iecho = (struct icmp_echo_hdr *)mem_malloc((mem_size_t)ping_size);
                ping_prepare_echo(iecho, (u16_t)ping_size);
                lwip_sendto(s, iecho, ping_size, 0, (struct sockaddr*)&to, sizeof(to));
                        p = pbuf_alloc(PBUF_TRANSPORT, short_size, PBUF_RAM);
                        inet_addr_to_ipaddr_p(remote_addr, &to_in->sin_addr);
                        remote_port = ntohs(to_in->sin_port);
                        LOCK_TCPIP_CORE();
                        err = sock->conn->last_err = raw_sendto(sock->conn->pcb.raw, p, remote_addr);

                        UNLOCK_TCPIP_CORE();
                        pbuf_free(p);

        ping_recv(s);

define LWIP_DEBUG //


lwipv4_socket_recv
        recv_validate(socket, buf, len)
        recv_copy_free(socket, buf, len)

irqTCPRecv


tcp_pcb_purge
        //"tcp_pcb_purge\n"));
        //"tcp_pcb_purge: data left on ->unacked\n"
        tcp_segs_free(pcb->unacked);
                tcp_seg_free(seg);
                        pbuf_free(seg->p);
                        memp_free(MEMP_TCP_SEG, seg);



struct k64f_enetdata {
  struct netif *netif;  /**< Reference back to LWIP parent netif */
  volatile u32_t rx_free_descs; /**< Count of free RX descriptors */
  struct pbuf *rxb[ENET_RX_RING_LEN]; /**< RX pbuf pointer list, zero-copy mode */
  uint8_t *rx_desc_start_addr; /**< RX descriptor start address */
  uint8_t *tx_desc_start_addr; /**< TX descriptor start address */
  uint8_t tx_consume_index, tx_produce_index; /**< TX buffers ring */
  uint8_t rx_fill_index; /**< RX ring fill index */
  struct pbuf *txb[ENET_TX_RING_LEN]; /**< TX pbuf pointer list, zero-copy mode */
  void *txb_aligned[ENET_TX_RING_LEN]; /**< TX aligned buffers (if needed) */
};

EthernetInterface::init
        set_mac_address();//sal-iface-eth
                mbed_mac_address //mbed-hal-frdm-k64f
    init_netif(NULL, NULL, NULL);
        lwip_init();

            memset((void*) &netif, 0, sizeof(netif));
            netif_add(&netif, ipaddr, netmask, gw, NULL, eth_arch_enetif_init, ethernet_input);
                 netif->state = state;
                         netif->num = netifnum++;
                 netif->input = input; //ethernet_input
                 netif_set_addr(netif, ipaddr, netmask, gw);
                 //init(netif) //eth_arch_enetif_init
                        eth_arch_enetif_init
                                k64f_enetdata.netif = netif;
                                SysTick_Init();
                                netif->flags = NETIF_FLAG_BROADCAST
                                                                | NETIF_FLAG_ETHARP
                                                                | NETIF_FLAG_ETHERNET
                                                                | NETIF_FLAG_IGMP;
                                netif->state = &k64f_enetdata;
                                        err = low_level_init(netif);
                                                k64f_init_eth_hardware
                                                enetIfPtr->macCfgPtr = &g_enetMacCfg[BOARD_DEBUG_ENET_INSTANCE];
                                                        enetIfPtr->phyCfgPtr = &g_enetPhyCfg[
                                                enetIfPtr = (enet_dev_if_t *)&enetDevIf[BOARD_DEBUG_ENET_INSTANCE]
                                                enetIfPtr->macApiPtr = &g_enetMacApi;
                                                enetIfPtr->phyApiPtr = (void *)&g_enetPhyApi;
                                                k64f_rx_setup(netif, &rxbdCfg)
                                                        rxBdPtr = (uint8_t *)calloc(1, enet_hal_get_bd_size() * enetIfPtr->macCfgPtr->rxBdNumber + ENET_BD_ALIGNMENT);
                                                        k64f_rx_queue(netif, RX_PBUF_AUTO_INDEX);
                                                                pbuf_alloc(PBUF_RAW, enetIfPtr->macCfgPtr->rxBufferSize + RX_BUF_ALIGNMENT, PBUF_RAM);
                                                k64f_tx_setup(netif, &txbdCfg)
                                                enet_mac_init(enetIfPtr, &rxbdCfg, &txbdCfg)
                                                         enetIfHandle = enetIfPtr;
                                                phy_get_link_speed(enetIfPtr, &phy_speed);
                                                        phy_get_link_duplex(enetIfPtr, &phy_duplex);
                                                        BW_ENET_RCR_RMII_10T(enetIfPtr->deviceNumber, phy_speed == kEnetSpeed10M ? kEnetCfgSpeed10M : kEnetCfgSpeed100M);
                                                        BW_ENET_TCR_FDEN(enetIfPtr->deviceNumber, phy_duplex == kEnetFullDuplex ? kEnetCfgFullDuplex : kEnetCfgHalfDuplex);
                                netif->output = /*k64f_*/etharp_output;
                                        netif->linkoutput = k64f_low_level_output;
            netif_set_default(&netif);
                netif_default = netif;
            netif_set_link_callback  (&netif, netif_link_callback);
                netif->link_callback = link_callback;
                         // link_up = 1;
            netif_set_status_callback(&netif, netif_status_callback);
                netif->status_callback = status_callback;
                        //if_up = 1;
            allow_net_callbacks = 1;


lwip_init
        stats_init();
        mem_init();
        memp_init();
                #define LWIP_MEMPOOL(name,num,size,desc) u8_t memp_memory_ ## name ## _base \
                  [((num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size)))];
                #include "lwip/memp_std.h"

                /** This array holds the base of each memory pool. */
                static u8_t *const memp_bases[] = {
                #define LWIP_MEMPOOL(name,num,size,desc) memp_memory_ ## name ## _base,
                #include "lwip/memp_std.h"
                };
        pbuf_init();
        netif_init()
                netif_add(&loop_netif,
                netif_set_up(&loop_netif);
        //lwip_socket_init();
        //ip_init();
        //etharp_init();
        //raw_init();
        //udp_init();
        //tcp_init();
        //snmp_init();
        //autoip_init();
        igmp_init();
                IP4_ADDR(&allsystems, 224, 0, 0, 1);
                IP4_ADDR(&allrouters, 224, 0, 0, 2);
        dns_init();
                DNS_SERVER_ADDRESS(&dnsserver);
                dns_pcb = udp_new();
                        pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
                udp_bind(dns_pcb, IP_ADDR_ANY, 0);
                        //udp_bind(ipaddr = port = 0)
                        ip_addr_set(&pcb->local_ip, ipaddr);
                        pcb->local_port = port;
                        //udp_bind: bound to 0.0.0.0, port 49152
        udp_recv(dns_pcb, dns_recv, NULL);
                pcb->recv = recv;
                        pcb->recv_arg = recv_arg;
        dns_setserver(0, &dnsserver);
                dns_servers[numdns] = (*dnsserver);
        sys_timeouts_init();
                sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
                        timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
                        timeout->h = handler;
                        timeout->arg = arg;
                        timeout->time = msecs;
                        static struct sys_timeo *next_timeout;
                        for(t = next_timeout; t != NULL; t = t->next) {
                                timeout->next = t->next;
                        t->next = timeout;
                sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
                        etharp_tmr

                sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
                sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
                        dhcp_fine_tmr
                                if (netif->dhcp->request_timeout == 1)
                                        dhcp_timeout(netif);
                                                struct dhcp *dhcp = netif->dhcp;
                                                //dhcp_timeout()
                                                if (dhcp->state == DHCP_CHECKING)
                                                        //dhcp_timeout(): CHECKING, ARP request timed out
                                                        dhcp_bind(netif);
                                                                //dhcp_bind(netif=%p)
                                                                //dhcp_bind(): t1 renewal timer 345600 secs
                                                                dhcp->t1_timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
                                                                //dhcp_bind(): set request timeout 345600000 msecs
                                                                //dhcp_bind(): t2 rebind timer 604800 secs
                                                                dhcp->t2_timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
                                                                //dhcp_bind(): set request timeout 604800000 msecs
                                                                //dhcp_bind(): IP: 0x5204a8c0
                                                                netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
                                                                        //netif_set_ipaddr: netif address being changed
                                                                        //netif: IP address of interface en set to 192.168.4.82
                                                                //"dhcp_bind(): SN: 0x%08"X32_F"
                                                                netif_set_netmask(netif, &sn_mask);
                                                                        //netif: netmask of interface en set to 255.255.254.0
                                                                //dhcp_bind(): GW: 0x0104a8c0
                                                                netif_set_gw(netif, &gw_addr);
                                                                        //netif: GW address of interface en set to 192.168.4.1
                                                                netif_set_up(netif);
                                                                dhcp_set_state(dhcp, DHCP_BOUND);
                //sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);
                sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
                sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);

EthernetInterface::connect
        netif_set_up(struct netif *netif)
                etharp_gratuitous
                        etharp_request((netif), &(netif)->ip_addr)// dst is us, RFC3220
                                //etharp_request: sending ARP request.
                                etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                                        pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
                                        //"etharp_raw: sending raw ARP packet
                                        result = netif->linkoutput(netif, p);
                                        k64f_low_level_output
                                                k64f_tx_ready(netif)
                                                k64f_update_txbds(k64f_enet, idx, q->payload, q->len, 0);
                                                //k64f_low_level_output: pbuf packet(0x20003a28) sent, chain#=0, size = 44 (index=0)
                                                enet_hal_active_txbd(BOARD_DEBUG_ENET_INSTANCE_ADDR);
                                                         HW_ENET_TDAR_SET(instance, BM_ENET_TDAR_TDAR);
                                        pbuf_free(p);
                                        // ("pbuf_free: %p has ref %"U16_F", ending here


etharp_request((netif), &(netif)->ip_addr)// dst is us, RFC3220
        //etharp_request: sending ARP request.
        etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
                //"etharp_raw: sending raw ARP packet
                result = netif->linkoutput(netif, p);
                k64f_low_level_output
                        k64f_tx_ready(netif)
                        k64f_update_txbds(k64f_enet, idx, q->payload, q->len, 0);
                        //k64f_low_level_output: pbuf packet(0x20003a28) sent, chain#=0, size = 44 (index=0)
                        enet_hal_active_txbd(BOARD_DEBUG_ENET_INSTANCE_ADDR);
                                 HW_ENET_TDAR_SET(instance, BM_ENET_TDAR_TDAR);
                pbuf_free(p);
                // ("pbuf_free: %p has ref %"U16_F", ending here


enet_mac_tx_isr(void *enetIfPtr)
        enet_hal_clear_interrupt(((enet_dev_if_t *)enetIfPtr)->deviceNumber, kEnetTxFrameInterrupt);
        k64f_tx_reclaim(k64f_enet);
                pbuf_free(k64f_enet->txb[i]);
                //pbuf_free: deallocating


EthernetInterface::connect
        eth_arch_enable_interrupts
                enet_hal_config_interrupt(BOARD_DEBUG_ENET_INSTANCE_ADDR, (kEnetTxFrameInterrupt | kEnetRxFrameInterrupt), true);
                INT_SYS_EnableIRQ(enet_irq_ids[BOARD_DEBUG_ENET_INSTANCE][enetIntMap[kEnetRxfInt]]);
                INT_SYS_EnableIRQ(enet_irq_ids[BOARD_DEBUG_ENET_INSTANCE][enetIntMap[kEnetTxfInt]]);
         dhcp_start(&netif);
                //dhcp_start(netif=%p)
                if (dhcp == NULL) {
                        //"dhcp_start(): starting new DHCP client
                        dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
                        //dhcp_start(): allocated dhcp
                        dhcp->pcb = udp_new();
                        udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);//68
                        udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);//67
                                ip_addr_set(&pcb->remote_ip, ipaddr);
                                pcb->remote_port = port;
                                //udp_connect: connected to %"U16_F".%"U16_F"
                                pcb->next = udp_pcbs;
                                udp_pcbs = pcb;
                        udp_recv(dhcp->pcb, dhcp_recv, netif);
                                pcb->recv = recv;
                                pcb->recv_arg = recv_arg;
                        result = dhcp_discover(netif);

dhcp_discover(netif);
        //"dhcp_discover()\n")
        ip_addr_set_any(&dhcp->offered_ip_addr);
        dhcp_set_state(dhcp, DHCP_SELECTING);
        result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER)
        //"dhcp_discover: making request
        //"dhcp_discover: realloc()ing\n"
        udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
                udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
                        ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
                                ip_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
                                        netif->output(netif, p, dest);



ENET_Receive_IRQHandler  ; Ethernet MAC Receive Interrupt//startup_mk64f12.s
        enet_hal_get_interrupt_status(((enet_dev_if_t *)enetIfPtr)->deviceNumber
        enet_mac_rx_isr(enetIfHandle);
                struct k64f_enetdata *k64f_enet = &k64f_enetdata;
                enet_bd_struct_t * bdPtr = (enet_bd_struct_t*)k64f_enet->rx_desc_start_addr;
                enet_hal_clear_interrupt
                while ((bdPtr[idx].control & kEnetRxBdEmpty)
                        k64f_enetif_input(k64f_enet->netif, idx);
                                p = k64f_low_level_input(netif, idx);
                                        k64f_rx_queue(netif, idx)
                                                p = pbuf_alloc(PBUF_RAW, enetIfPtr->macCfgPtr->rxBufferSize + RX_BUF_ALIGNMENT, PBUF_RAM);
                                                k64f_rxqueue_pbuf(k64f_enet, p, idx);
                                                        enet_hal_init_rxbds(start + idx, (uint8_t*)p->payload, idx == ENET_RX_RING_LEN - 1);
                                                        enet_hal_active_rxbd(BOARD_DEBUG_ENET_INSTANCE_ADDR);
                                //netif->input(p, netif)
                                ethernet_input
                idx = (idx + 1) % ENET_RX_RING_LEN;

ethernet_input
        //ethernet_input: dest:%"X8_F"
        type = ethhdr->type;
        case PP_HTONS(ETHTYPE_ARP):
                etharp_arp_input (netif, (struct eth_addr*)(netif->hwaddr), p)
                        //update_arp_entry:
                        find_entry(ipaddr, flags);
                                for (i = 0; i < ARP_TABLE_SIZE; ++i) {
                                        //"find_entry: found empty entry
                                        //find_entry: no empty entry found and not allowed to recycle
                        update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
                           for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
                        //etharp_arp_input: incoming ARP reply
                        dhcp_arp_reply(netif, &sipaddr);
                        //"dhcp_arp_reply()\
        case PP_HTONS(ETHTYPE_IP):
                ip_input(p, netif);
                        iphdr_len = ntohs(IPH_LEN(iphdr));
                        pbuf_realloc(p, iphdr_len);
                        //"ip_input: iphdr->dest 0x%"X32_F" netif->ip_addr 0x%"X32_F
                        if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
                                //"ip_input: UDP packet to DHCP client port
                                if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
                                        //"ip_input: DHCP packet accepted
                        //ip_input: \n"
                        ip_debug_print(p);
                        //ip_input: p->len 328 p->tot_len 328
                        switch (IPH_PROTO(iphdr))
                                case IP_PROTO_UDP:
                                udp_input(p, inp);
                                case IP_PROTO_TCP:
                                tcp_input(p, inp);
                                case IP_PROTO_ICMP:
                                icmp_input(p, inp);
                                case IP_PROTO_IGMP:
                                igmp_input(p, inp, &current_iphdr_dest);

udp_input
        //("udp_input: calculating checksum
        mpcb->recv(mpcb->recv_arg, mpcb, q, ip_current_src_addr(), src);
        dhcp_recv
                //"dhcp_recv(pbuf = %p) from DHCP server
                //("searching DHCP_OPTION_MESSAGE_TYPE
                if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING))
                        //"DHCP_OFFER received in DHCP_SELECTING state
                        dhcp_handle_offer(netif);
                                //dhcp_handle_offer(netif
                                ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
                                //dhcp_handle_offer(): server 0x%08"
                                ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
                                //"dhcp_handle_offer(): offer for 0
                                dhcp_select(netif);
                                        dhcp_set_state(dhcp, DHCP_REQUESTING);
                                        result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
                                        dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
                                dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
                                        udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
                if (msg_type == DHCP_ACK)
                        //DHCP_ACK received
                        dhcp_handle_ack(netif);
                                dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
                                dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
                                dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
                                ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
                                ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
                                ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
                                ip4_addr_set_u32(&dns_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
                                dns_setserver(n, &dns_addr);
                        dhcp_check(netif);
                                //dhcp_check(netif=0x1fffaac0) en
                                dhcp_set_state(dhcp, DHCP_CHECKING);
                                etharp_query(netif, &dhcp->offered_ip_addr, NULL);
                                        //etharp_request: sending ARP request.
                                dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;

TCPStream(SOCKET_STACK_LWIP_IPV4) _stream;              /**< The TCP Socket */
        TCPAsynch::TCPAsynch(const socket_stack_t stack)
                Socket(stack)
                        Socket(const socket_stack_t stack);
                                CThunk(this)
                                        init(instance, NULL, NULL);
                                                m_thunk.context = (uint32_t)context;
                                m_thunk.instance = (uint32_t)instance;
                                m_thunk.callback = (uint32_t)&m_callback;
                                m_thunk.trampoline = (uint32_t)&trampoline;
                                _irq.callback(&Socket::_nvEventHandler);
                            _socket.handler = (socket_api_handler_t)_irq.entry();
                                return (((uint32_t)&m_thunk)|CTHUNK_ADDRESS);
                            _socket.impl = NULL;
                            _socket.stack = stack;
                            _socket.api = socket_get_api(stack);
                            //socket_api_ptrs[i]  lwipv4_socket_init() {
                        //	return socket_register_stack(&lwipv4_socket_api);
                _socket.family = SOCKET_STREAM;

_stream.open(SOCKET_AF_INET4);
        socket_error_t err = Socket::open(af, SOCKET_STREAM);
                _socket.api->create(&_socket, af, pf, (socket_api_handler_t)_irq.entry());
                lwipv4_socket_create
                        struct tcp_pcb *tcp = tcp_new();
                                return tcp_alloc(TCP_PRIO_NORMAL);
                                        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);

                        sock->impl = (void *)tcp;
                    sock->stack = SOCKET_STACK_LWIP_IPV4;
                    tcp_arg(tcp, (void*) sock);
                    tcp_err(tcp, tcp_error_handler);
                sock->family = pf;
                sock->handler = (void*)handler;//_nvEventHandler

_nvEventHandler
        minar::Scheduler::postCallback(_onError.bind(this, ev->i.e));
        minar::Scheduler::postCallback(_onReadable.bind(this));
        minar::Scheduler::postCallback(_onSent.bind(this, ev->i.t.sentbytes));
        minar::Scheduler::postCallback(_onDNS.bind(this, ev->i.d.addr, ev->i.d.domain));

Socket::resolve //fix ip
        _socket.api->resolve(&_socket, address);
        lwipv4_socket_resolve
                err_t err = dns_gethostbyname(address, &ia, dnscb, sock);
                        ipaddr = ipaddr_addr(hostname);
                        ip4_addr_set_u32(addr, ipaddr);
                        //dns_enqueue(hostname, found, callback_arg);
                dnscb(address, &ia, sock);
                        socket_api_handler_t handler = (socket_api_handler_t) sock->handler;
                        e.event = SOCKET_EVENT_DNS;
                        socket_addr_set_ipv4_addr(&e.i.d.addr, addr->addr);
                        //handler()
                        _nvEventHandler
                                minar::Scheduler::postCallback(_onDNS.bind(this, ev->i.d.addr, ev->i.d.domain));
                lwipv4_socket_error_remap(err);

 _stream.connect
        _socket.api->connect(&_socket, address.getAddr(), port);
        lwipv4_socket_connect
                tcp_connect((struct tcp_pcb *)sock->impl, (void*)socket_addr_get_ipv4_addrp(address), port, irqConnect);
                        pcb->remote_ip = *ipaddr;
                        pcb->remote_port = port;
                        pcb->local_port = tcp_new_port();
                        pcb->connected = connected;//irqConnect
                        tcp_enqueue_flags(pcb, TCP_SYN);
                                //tcp_enqueue_flags: queuelen:
                                pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)
                                seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)
                                //tcp_enqueue_flags: queueing
                                pcb->unsent = seg;
                                pcb->snd_queuelen += pbuf_clen(seg->p);
                                //tcp_enqueue_flags: 1 (after enqueued)
                        TCP_REG(&tcp_active_pcbs, pcb);
                        tcp_output(pcb);
                                //tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd
                                 tcp_output_segment(seg, pcb);
                                         seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
                                         seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
                                         //tcp_output_segment: %"U32_F":%"U32_F"\
                                         inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
                                         seg->tcphdr->chksum = FOLD_U32T(acc);
                                         //netif->output()
                                         ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
                                         IP_PROTO_TCP);
                                 pcb->unacked = seg;

ip_output
        netif = ip_route(dest)
        ip_output_if(p, src, dest, ttl, tos, proto, netif);
                ip_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
                pbuf_header(p, IP_HLEN)
                //pbuf_header: old 0x20003a4c new 0x20003a38
                IPH_TTL_SET(iphdr, ttl);
        IPH_PROTO_SET(iphdr, proto);
                iphdr = (struct ip_hdr *)p->payload
                ip_addr_copy(iphdr->src, *src);
                ip_addr_copy(dest_addr, iphdr->dest);
                ip_debug_print(struct pbuf *p)
/*
IP header:
+-------------------------------+
| 4 | 5 |  0x00
|        44     | (v, hl, tos, len)
+-------------------------------+
|        0
|000|       0   | (id, flags, offset)
+-------------------------------+
|  255
|    6  |    0x31d7     | (ttl, proto, chksum)
+-------------------------------
+
|  192  |  168  |    4  |   11  | (src)
+-------------------------------+
|  192
|  168  |    4  |  153  | (dest)
+-------------------------------+
*/

netif->output(netif, p, dest);
        etharp_output
                pbuf_header(q, sizeof(struct eth_hdr)
                etharp_query(netif, ipaddr, q);
                        find_entry(ipaddr, ETHARP_FLAG_TRY_HARD)
                                //find_entry: found empty entry 0
                                //find_entry: selecting empty entry 0
                        if (arp_table[i].state == ETHARP_STATE_EMPTY) {
                        arp_table[i].state = ETHARP_STATE_PENDING;
                        }
                        result = etharp_request(netif, ipaddr);
                        etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
                        //etharp_send_ip: sending packet %p
                        netif->linkoutput(netif, p)
                        k64f_low_level_output
                                k64f_tx_ready(netif)
                                k64f_update_txbds(k64f_enet, idx, q->payload, q->len, 0);
                                //k64f_low_level_output: pbuf packet(0x20003a28) sent, chain#=0, size = 44 (index=0)
                                enet_hal_active_txbd(BOARD_DEBUG_ENET_INSTANCE_ADDR);
                                         HW_ENET_TDAR_SET(instance, BM_ENET_TDAR_TDAR);
request_module
        call_usermodehelper
** linux
*** network
static struct inet_protosw inetsw_array[] =
{
        {
                .type =       SOCK_STREAM,
                .protocol =   IPPROTO_TCP,
                .prot =       &tcp_prot,
                .ops =        &inet_stream_ops,
                .no_check =   0,
                .flags =      INET_PROTOSW_PERMANENT |
                              INET_PROTOSW_ICSK,
        },
struct proto tcp_prot = {
        .name			= "TCP",
        .owner			= THIS_MODULE,
        .close			= tcp_close,
        .connect		= tcp_v4_connect,
        .disconnect		= tcp_disconnect,
        .accept			= inet_csk_accept,
        .ioctl			= tcp_ioctl,
        .init			= tcp_v4_init_sock,
        .destroy		= tcp_v4_destroy_sock,
        .shutdown		= tcp_shutdown,
        .setsockopt		= tcp_setsockopt,
        .getsockopt		= tcp_getsockopt,
        .recvmsg		= tcp_recvmsg,
        .sendmsg		= tcp_sendmsg,
        .sendpage		= tcp_sendpage,
        .backlog_rcv		= tcp_v4_do_rcv,
        .release_cb		= tcp_release_cb,
        .mtu_reduced		= tcp_v4_mtu_reduced,
        .hash			= inet_hash,
        .unhash			= inet_unhash,
        .get_port		= inet_csk_get_port,
        .enter_memory_pressure	= tcp_enter_memory_pressure,
        .sockets_allocated	= &tcp_sockets_allocated,
        .orphan_count		= &tcp_orphan_count,
        .memory_allocated	= &tcp_memory_allocated,
        .memory_pressure	= &tcp_memory_pressure,
        .sysctl_wmem		= sysctl_tcp_wmem,
        .sysctl_rmem		= sysctl_tcp_rmem,
        .max_header		= MAX_TCP_HEADER,
        .obj_size		= sizeof(struct tcp_sock),
        .slab_flags		= SLAB_DESTROY_BY_RCU,
        .twsk_prot		= &tcp_timewait_sock_ops,
        .rsk_prot		= &tcp_request_sock_ops,
        .h.hashinfo		= &tcp_hashinfo,
        .no_autobind		= true,
#ifdef CONFIG_COMPAT
        .compat_setsockopt	= compat_tcp_setsockopt,
        .compat_getsockopt	= compat_tcp_getsockopt,
#endif
#ifdef CONFIG_MEMCG_KMEM
        .init_cgroup		= tcp_init_cgroup,
        .destroy_cgroup		= tcp_destroy_cgroup,
        .proto_cgroup		= tcp_proto_cgroup,
#endif
};
const struct proto_ops inet_stream_ops = {
        .family            = PF_INET,
        .owner             = THIS_MODULE,
        .release           = inet_release,
        .bind              = inet_bind,
        .connect           = inet_stream_connect,
        .socketpair        = sock_no_socketpair,
        .accept            = inet_accept,
        .getname           = inet_getname,
        .poll              = tcp_poll,
        .ioctl             = inet_ioctl,
        .listen            = inet_listen,
        .shutdown          = inet_shutdown,
        .setsockopt        = sock_common_setsockopt,
        .getsockopt        = sock_common_getsockopt,
        .sendmsg           = inet_sendmsg,
        .recvmsg           = inet_recvmsg,
        .mmap              = sock_no_mmap,
        .sendpage          = inet_sendpage,
        .splice_read       = tcp_splice_read,
#ifdef CONFIG_COMPAT
        .compat_setsockopt = compat_sock_common_setsockopt,
        .compat_getsockopt = compat_sock_common_getsockopt,
        .compat_ioctl      = inet_compat_ioctl,
#endif
};

SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)
        sock_create
                __sock_create
                        sock = sock_alloc();
                        //pf->create(net, sock, protocol, kern);
                        inet_create
                                 sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot)
                                 //sk->sk_prot->init(sk);
                                        tcp_v4_init_sock
        sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));
                sock_alloc_file(sock, flags, NULL);
                        alloc_file(&path, FMODE_READ | FMODE_WRITE,
                                &socket_file_ops);
                fd_install(fd, newfile);

SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)
        //sock->ops->bind(sock,
        inet_bind
                inet->inet_rcv_saddr = inet->inet_saddr = addr->sin_addr.s_addr;
                inet_csk_get_port
                        head = &hashinfo->bhash[inet_bhashfn(net, rover,
                inet->inet_sport = htons(inet->inet_num);
                inet->inet_daddr = 0;
                inet->inet_dport = 0;

inet_listen
        inet_csk_listen_start(sk, backlog);
                inet_connection_sock *icsk = inet_csk(sk);
                reqsk_queue_alloc(&icsk->icsk_accept_queue, nr_table_entries);
                         nr_table_entries = min_t(u32, nr_table_entries, sysctl_max_syn_backlog);
                //sk->sk_prot->hash(sk);
                inet_hash
                        __inet_hash(sk);
                        ilb = &hashinfo->listening_hash[inet_sk_listen_hashfn(sk)];
                        __sk_nulls_add_node_rcu(sk, &ilb->head);

accept4
        sock = sockfd_lookup_light(fd, &err, &fput_needed);
        newsock = sock_alloc();
        newsock->type = sock->type;
        newsock->ops = sock->ops;
        newfile = sock_alloc_file(newsock, flags, sock->sk->sk_prot_creator->name);
        //sock->ops->accept(sock, newsock, sock->file->f_flags)
        inet_accept
                //sk2 = sk1->sk_prot->accept(sk1, flags, &err)
                inet_csk_accept
                        request_sock_queue *queue = &icsk->icsk_accept_queue;
                        req = reqsk_queue_remove(queue);
                        newsk = req->sk;
                        sk_acceptq_removed(sk);
                sock_graft(sk2, newsock);
                        sk_set_socket(sk, parent);
        newsock->ops->getname(newsock, (struct sockaddr *)&address,
        move_addr_to_user(&address,
        fd_install(newfd, newfile);

SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,
        sockfd_lookup_light(fd, &err, &fput_needed);
        err = move_addr_to_kernel(uservaddr, addrlen, &address);
        //sock->ops->connect(sock, (struct sockaddr *)&address, addrlen,
        inet_stream_connect
                err = __inet_stream_connect(sock, uaddr, addr_len, flags);
                        //err = sk->sk_prot->connect(sk, uaddr, addr_len);
                        tcp_v4_connect

inet_init(void)
        proto_register(&tcp_prot, 1);
        for (q = inetsw_array; q < &inetsw_array[INETSW_ARRAY_LEN]; ++q)
                inet_register_protosw(q);
        inet_add_protocol(&tcp_protocol, IPPROTO_TCP)
        arp_init();
        ip_init();
        tcp_v4_init();
        tcp_init();
        dev_add_pack(&ip_packet_type);
                ptype_head(pt)
                        if (pt->type == htons(ETH_P_ALL))
                                return &ptype_all;
                        else
                                return &ptype_base[ntohs(pt->type) & PTYPE_HASH_MASK];

DEFINE_PER_CPU_ALIGNED(struct softnet_data, softnet_data);
struct napi_struct {

net_dev_init
        for_each_possible_cpu(i) {
                struct softnet_data *sd = &per_cpu(softnet_data, i);
                skb_queue_head_init(&sd->input_pkt_queue);
                skb_queue_head_init(&sd->process_queue);
                sd->backlog.poll = process_backlog;
        open_softirq(NET_TX_SOFTIRQ, net_tx_action);
        open_softirq(NET_RX_SOFTIRQ, net_rx_action);

static struct sdio_drv_priv sdio_drvpriv = {
        .r871xs_drv.probe = rtw_drv_init,
rtw_drv_init
        rtw_sdio_if1_init
                rtw_set_hal_ops
                        rtl8723bs_set_hal_ops
                                rtl8723bs_init_recv_priv
rtl8723bs_recv_tasklet
        rtw_recv_entry
                recv_func
                        recv_func_prehandle
                                mp_recv_frame
                                        recv_indicatepkts_in_order
                                                rtw_recv_indicatepkt
                                                        rtw_os_recv_indicate_pkt
                                                                pkt->protocol = eth_type_trans(pkt, padapter->pnetdev);
                                                                        is_multicast_ether_addr(eth->h_dest)
                                                                        ether_addr_equal_64bits(eth->h_dest, dev->broadcast)
                                                                        skb->pkt_type =
                                                                        if (ntohs(eth->h_proto) >= ETH_P_802_3_MIN)
                                                                                return eth->h_proto;
                                                                rtw_netif_rx
                                                                        _rtw_netif_rx
                                                                                netif_rx

netif_rx
        netpoll_rx(skb)
        //trace_netif_rx(skb);
        enqueue_to_backlog(skb, get_cpu(), &qtail);
                __skb_queue_tail(&sd->input_pkt_queue, skb);
                ____napi_schedule(sd, &sd->backlog);
                        list_add_tail(&napi->poll_list, &sd->poll_list);
                        __raise_softirq_irqoff(NET_RX_SOFTIRQ);

net_rx_action
        while (!list_empty(&sd->poll_list)) {
                work = n->poll(n, weight);
                        process_backlog
                                while ((skb = __skb_dequeue(&sd->process_queue))) {
                                        __netif_receive_skb(skb);
                //trace_napi_poll(n);
                list_move_tail(&n->poll_list, &sd->poll_list);

__netif_receive_skb
        __netif_receive_skb_core(skb, false)
        //trace_netif_receive_skb(skb);
                skb->skb_iif = skb->dev->ifindex;
                deliver_skb(skb, pt_prev, orig_dev);
                        //pt_prev->func(skb, skb->dev, pt_prev, orig_dev);
                        ip_rcv

ip_rcv
        iph = ip_hdr(skb);
        ip_fast_csum((u8 *)iph, iph->ihl)
        len = ntohs(iph->tot_len);
        skb->transport_header = skb->network_header + iph->ihl*4;
        NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, NULL,
                       ip_rcv_finish)
                ip_route_input_noref(skb, iph->daddr, iph->saddr, iph->tos, skb->dev);
                        res = ip_route_input_slow(skb, daddr, saddr, tos, dev);
                                fib_lookup(net, &fl4, &res);
                                fib_validate_source(skb, saddr, daddr, tos,
                                rth->dst.input= ip_local_deliver;
                                skb_dst_set(skb, &rth->dst);
                                ip_rcv_options(skb)
                                dst_input(skb);
                                //skb_dst(skb)->input(skb)
                                        ip_local_deliver
                                                ip_is_fragment(ip_hdr(skb)
                                                        ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER)
                                                NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, skb, skb->dev, NULL,
                                         ip_local_deliver_finish
                                                __skb_pull(skb, skb_network_header_len(skb));
                                                protocol = ip_hdr(skb)->protocol
                                                ipprot = rcu_dereference(inet_protos[protocol]);
                                                //ret = ipprot->handler(skb);
                                                tcp_v4_rcv //tcp_protocol
tcp_v4_rcv
        th = tcp_hdr(skb);
        iph = ip_hdr(skb);
        TCP_SKB_CB(skb)->seq = ntohl(th->seq);
        TCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +
                                    skb->len - th->doff * 4);
        TCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);
        sk = __inet_lookup_skb(&tcp_hashinfo, skb, th->source, th->dest);
                __inet_lookup(dev_net(skb_dst(skb)->dev), hashinfo,
                        __inet_lookup_established(net, hashinfo,
                                hash = inet_ehashfn(net, daddr, hnum, saddr, sport);
                                INET_MATCH(sk, net, acookie,
                                INET_TW_MATCH(sk, net, acookie,
                        __inet_lookup_listener(net, hashinfo, saddr, sport,
                                struct inet_listen_hashbucket *ilb = &hashinfo->listening_hash[hash];
                        if (!tcp_prequeue(sk, skb))
                                        sysctl_tcp_low_latency || !tp->ucopy.task
                                        skb_dst_force(skb);
                                        __skb_queue_tail(&tp->ucopy.prequeue, skb);
                                        tp->ucopy.memory += skb->truesize;
                                ret = tcp_v4_do_rcv(sk, skb);
                                        if (sk->sk_state == TCP_ESTABLISHED) {
                                                tcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len)
                                        if (sk->sk_state == TCP_LISTEN) {// second ack
                                                tcp_v4_hnd_req(sk, skb);
                                                        request_sock *req = inet_csk_search_req(sk, &prev, th->source,
                                                       iph->saddr, iph->daddr);
                                                        tcp_check_req(sk, skb, req, prev, false);
                                                                //inet_csk(sk)->icsk_af_ops->syn_recv_sock(sk, skb, req, NULL);
                                                                        tcp_v4_syn_recv_sock
                                                                                newsk = tcp_create_openreq_child(sk, req, skb);
                                                                                inet_sk_rx_dst_set(newsk, skb);
                                                                                dst = inet_csk_route_child_sock(sk, newsk, req);
                                                                                __inet_inherit_port(sk, newsk)
                                                                                        tb = inet_csk(sk)->icsk_bind_hash;
                                                                                        port = inet_sk(child)->inet_num;
                                                                                        inet_bind_hash(child, tb, port);
                                                                                                sk_add_bind_node(sk, &tb->owners);
                                                                                __inet_hash_nolisten(newsk, NULL);
                                                                                        head = inet_ehash_bucket(hashinfo, sk->sk_hash);
                                                                                        __sk_nulls_add_node_rcu(sk, list);
                                                                inet_csk_reqsk_queue_unlink(sk, req, prev);
                                                                inet_csk_reqsk_queue_removed(sk, req);
                                                                inet_csk_reqsk_queue_add(sk, req, child);
                                                tcp_child_process(sk, nsk, skb)
                                                        tcp_rcv_state_process(child, skb, tcp_hdr(skb),
                                                                case TCP_SYN_RECV:
                                                                tcp_set_state(sk, TCP_ESTABLISHED);
                                                                tp->snd_una = TCP_SKB_CB(skb)->ack_seq;
                                                                tp->snd_wnd = ntohs(th->window)
                                                                tcp_init_wl(tp, TCP_SKB_CB(skb)->seq);
                                                        parent->sk_data_ready(parent, 0);

                                        tcp_rcv_state_process(sk, skb, tcp_hdr(skb), skb->len)
                                                if (th->syn) { //first syn
                                                        //icsk->icsk_af_ops->conn_request(sk, skb)
                                                        tcp_v4_conn_request
                                                                inet_csk_reqsk_queue_is_full
                                                                sk_acceptq_is_full
                                                                inet_reqsk_alloc(&tcp_request_sock_ops);
                                                                        request_sock *req = reqsk_alloc(ops);
                                                                tcp_parse_options(skb, &tmp_opt, 0, want_cookie ? NULL : &foc);
                                                                tcp_openreq_init(req, &tmp_opt, skb);
                                                                ireq = inet_rsk(req);
                                                                ireq->loc_addr = daddr;
                                                                ireq->rmt_addr = saddr;
                                                                isn = tcp_v4_init_sequence(skb);
                                                                __tcp_v4_send_check(skb_synack, ireq->loc_addr, ireq->rmt_addr);
                                                                skb_set_queue_mapping(skb_synack, skb_get_queue_mapping(skb));
                                                                err = ip_build_and_send_pkt(skb_synack, sk, ireq->loc_addr,
                                                                     ireq->rmt_addr, ireq->opt);
                                                                inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);

tcp_rcv_established
        tcp_checksum_complete_user(sk, skb))
        tcp_queue_rcv(sk, skb, tcp_header_len, &fragstolen);
                __skb_pull(skb, hdrlen);
                tcp_sk(sk)->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
                __skb_queue_tail(&sk->sk_receive_queue, skb);
                skb_set_owner_r(skb, sk);
        tcp_event_data_recv(sk, skb);
        tcp_ack(sk, skb, FLAG_DATA);
        tcp_data_snd_check(sk);
        if (!inet_csk_ack_scheduled(sk))
        __tcp_ack_snd_check(sk, 0);


SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,
        sock_recvmsg
                __sock_recvmsg
                        __sock_recvmsg_nosec(iocb, sock, msg, size, flags)
                                //sock->ops->recvmsg(iocb, sock, msg, size, flags);
                                tcp_recvmsg

tcp_recvmsg
        skb_queue_walk(&sk->sk_receive_queue, skb) {
                err = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, used);
                        //trace_skb_copy_datagram_iovec(skb, len);
                *seq += used;
                copied += used;
                len -= used;
                tcp_rcv_space_adjust(sk);
                tcp_cleanup_rbuf(sk, copied);
                if (copied >= target && !sk->sk_backlog.tail)
                        break;

ip_rcv
        ip_route_input_noref(skb, iph->daddr, iph->saddr, iph->tos, skb->dev);
                res = ip_route_input_slow(skb, daddr, saddr, tos, dev);
                        fib_lookup(net, &fl4, &res);
                        err = ip_mkroute_input(skb, &res, &fl4, in_dev, daddr, saddr, tos);
                                __mkroute_input(skb, res, in_dev, daddr, saddr, tos);
                                        out_dev = __in_dev_get_rcu(FIB_RES_DEV(*res));
                                        fib_validate_source(skb, saddr, daddr, tos, FIB_RES_OIF(*res),
                                        rt_dst_alloc(out_dev->dev,
                                        rth->dst.input = ip_forward;
                                        rth->dst.output = ip_output;
                                        skb_dst_set(skb, &rth->dst);
                                        ip_rcv_options(skb)
                                        dst_input(skb);
                                        //skb_dst(skb)->input(skb)
                                        ip_forward
                                                IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb)
                                                skb_forward_csum(skb);
                                                if (ip_hdr(skb)->ttl <= 1)
                                                xfrm4_route_forward(skb)//ipsec
                                                rt = skb_rtable(skb);
                                                opt->is_strictroute && rt->rt_uses_gateway
                                                ip_may_fragment(skb) && ip_exceeds_mtu(skb, dst_mtu(&rt->dst)
                                                skb_cow(skb, LL_RESERVED_SPACE(rt->dst.dev)+rt->dst.header_len)
                                                ip_decrease_ttl(iph);
                                                skb->priority = rt_tos2priority(iph->tos);
                                                NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, skb, skb->dev,
                                                               rt->dst.dev, ip_forward_finish);
                                                        dst_output(skb);
                                                                //skb_dst(skb)->output(skb)
                                                                ip_output

SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,
        sock = sockfd_lookup_light(fd, &err, &fput_needed);
        err = move_addr_to_kernel(addr, addr_len, &address);
        err = sock_sendmsg(sock, &msg, len);
                 __sock_sendmsg(&iocb, sock, msg, size);
                        __sock_sendmsg_nosec(iocb, sock, msg, size);
                                //sock->ops->sendmsg(iocb, sock, msg, size);
                                tcp_sendmsg

tcp_sendmsg
        timeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);
        sk_stream_alloc_skb(sk,
                alloc_skb_fclone(size + sk->sk_prot->max_header, gfp);
                        cache = (flags & SKB_ALLOC_FCLONE)
                        ? skbuff_fclone_cache : skbuff_head_cache;
                        skb = kmem_cache_alloc_node(cache, gfp_mask & ~__GFP_DMA, node);
                        size = SKB_DATA_ALIGN(size);
                        size += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
                        data = kmalloc_reserve(size, gfp_mask, node, &pfmemalloc);
                        shinfo = skb_shinfo(skb);
                                //skb->head + skb->end;
        skb_entail(sk, skb);
        __tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);
                tcp_write_xmit(sk, cur_mss, nonagle, 0,
                        while ((skb = tcp_send_head(sk))) {
                                tso_segs = tcp_init_tso_segs(sk, skb, mss_now);
                                cwnd_quota = tcp_cwnd_test(tp, skb);
                                tcp_snd_wnd_test(tp, skb, mss_now)
                                tcp_nagle_test(tp, skb, mss_now,
                                tcp_transmit_skb(sk, skb, 1, gfp)
                                //icsk->icsk_af_ops->queue_xmit(skb, &inet->cork.fl);
                                        ip_queue_xmit


ip_queue_xmit // struct inet_connection_sock_af_ops ipv4_specific = {
        inet_opt = rcu_dereference(inet->inet_opt);
        fl4 = &fl->u.ip4;
        rt = skb_rtable(skb);
        rt = (struct rtable *)__sk_dst_check(sk, 0);
        ip_route_output_ports(sock_net(sk), fl4, sk,
                flowi4_init_output(fl4, oif, sk ? sk->sk_mark : 0, tos,
                ip_route_output_flow(net, fl4, sk);
                        __ip_route_output_key(net, flp4);
                        xfrm_lookup(net, &rt->dst, flowi4_to_flowi(flp4),
        skb_dst_set_noref(skb, &rt->dst);
                __skb_dst_set_noref(skb, dst, false);
                        skb->_skb_refdst = (unsigned long)dst | SKB_DST_NOREF;
        skb_push(skb, sizeof(struct iphdr) + (inet_opt ? inet_opt->opt.optlen : 0));
        skb_reset_network_header(skb);
        iph = ip_hdr(skb);
        iph->ttl      = ip_select_ttl(inet, &rt->dst);
        iph->protocol = sk->sk_protocol;
        ip_copy_addrs(iph, fl4);
        ip_local_out(skb);
                __ip_lip_finish_output2ocal_out(skb);
                        ip_send_check
                                iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
                        dst_output
                                //skb_dst(skb)->output(skb);
                                ip_output

ip_output
        struct net_device *dev = skb_dst(skb)->dev;
        skb->dev = dev;
        skb->protocol = htons(ETH_P_IP);
        ip_finish_output
                if (skb->len > ip_skb_dst_mtu(skb) && !skb_is_gso(skb))
                        return ip_fragment(skb, ip_finish_output2);
                else
                        return ip_finish_output2(skb);
                                nexthop = (__force u32) rt_nexthop(rt, ip_hdr(skb)->daddr);
                                neigh = __ipv4_neigh_lookup_noref(dev, nexthop);
                                dst_neigh_output(dst, neigh, skb);
                                //n->output(n, skb);
                                        neigh_resolve_output//struct neigh_ops arp_hh_ops = {
                                                __skb_pull(skb, skb_network_offset(skb));
                                        seq = read_seqbegin(&neigh->ha_lock);
                                        err = dev_hard_header(skb, dev, ntohs(skb->protocol),
                                        dev_queue_xmit(skb);
                                                txq = netdev_pick_tx(dev, skb);
                                                q = rcu_dereference_bh(txq->qdisc);
                                                //trace_net_dev_queue(skb);
                                                __dev_xmit_skb(skb, q, dev, txq);
                                                        __qdisc_run(q)

rtw_drv_init
        rtw_sdio_if1_init
                rtw_wdev_alloc(padapter, dvobj_to_dev(dvobj));
                        wiphy = wiphy_new(&rtw_cfg80211_ops, sizeof(_adapter*));
                                cfg80211_rtw_change_iface	//rtw_cfg80211_ops
                                        netdev_open
                                                _netdev_open
                                                        rtw_netif_wake_queue
                                                                netif_tx_wake_all_queues
                rtw_init_netdev
                        pnetdev->features |= NETIF_F_IP_CSUM;
netif_tx_wake_all_queues
        netif_tx_wake_queue(txq);
                netif_tx_wake_queue(netdev_get_tx_queue(dev, 0));
                        __netif_schedule(dev_queue->qdisc);
                                *sd->output_queue_tailp = q;
                                sd->output_queue_tailp = &q->next_sched;
                                raise_softirq_irqoff(NET_TX_SOFTIRQ);

net_tx_action
        head = sd->output_queue;
        while (head) {
                qdisc_run(q);
                        __qdisc_run(q);
                                qdisc_restart(q)
                                        skb = dequeue_skb(q);
                                        dev = qdisc_dev(q);
                                        txq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));
                                        sch_direct_xmit(skb, q, dev, txq, root_lock);
                                                dev_hard_start_xmit(skb, dev, txq);
                                                        //ops->ndo_start_xmit(skb, dev);
                                                        rtw_cfg80211_monitor_if_xmit_entry
                                                dev_requeue_skb//o

cfg80211_rtw_add_virtual_intf //rtw_cfg80211_ops
        rtw_cfg80211_add_monitor_if
                mon_ndev->netdev_ops = &rtw_cfg80211_monitor_if_ops;

netif_start_queue
        netif_tx_start_queue(netdev_get_tx_queue(dev, 0))
                clear_bit(__QUEUE_STATE_DRV_XOFF, &dev_queue->state);
*** fuse
//android/system/core/sdcard/sdcard.c
fd = open("/dev/fuse", O_RDWR);
snprintf(opts, sizeof(opts),            "fd=%i,rootmode=40000,default_permissions,allow_other,user_id=%d,group_id=%d",
res = mount("/dev/fuse", dest_path, "fuse", MS_NOSUID | MS_NODEV, opts);
fuse_init(&fuse, fd, source_path, write_gid, derive, split_perms);
res = ignite_fuse(&fuse, num_threads);
        handlers = malloc(num_threads * sizeof(struct fuse_handler));
        pthread_create(&thread, NULL, start_handler, &handlers[i]);

start_handler
        handle_fuse_requests(handler);
                read(fuse->fd,
                handler->request_buffer, sizeof(handler->request_buffer));
                handle_fuse_request(fuse, handler, hdr, data, data_len);
                        case FUSE_OPEN: { /* open_in -> open_out */
                const struct fuse_open_in *req = data;
                return handle_open(fuse, handler, hdr, req);
                fuse_status(fuse, unique, res);
                         write(fuse->fd, &hdr, sizeof(hdr));
*** lguest
main //tools/lguest/lguest.c
        devices.descpage = get_pages(1);
        setup_block_file
                new_device("block", VIRTIO_ID_BLOCK);
                        dev->desc = new_dev_desc(type);
                add_virtqueue(dev, VIRTQUEUE_NUM, blk_request);
                        vq->config.num = num_descs;
                        vq->config.irq = devices.next_irq++;
                        vq->config.pfn = to_guest_phys(p) / getpagesize();
                set_config(dev, offsetof(struct virtio_blk_config, geometry), &conf);
        boot = from_guest_phys(0);
        tell_kernel(start);
                lguest_fd = open_or_die("/dev/lguest", O_RDWR);
                write(lguest_fd, args, sizeof(args)) < 0) //LHREQ_INITIALIZE
                        write //drivers/lguest/lguest_user.c
                                initialize(file, input);//drivers/lguest/lguest_user.c
                                        lg = kzalloc(sizeof(*lg), GFP_KERNEL);
                                        err = lg_cpu_start(&lg->cpus[0], 0, args[2]);
                                                cpu->regs_page = get_zeroed_page(GFP_KERNEL);
                                                cpu->regs = (void *)cpu->regs_page + PAGE_SIZE - sizeof(*cpu->regs);
                                                lguest_arch_setup_regs(cpu, start_ip);
                                                        regs->ds = regs->es = regs->ss = __KERNEL_DS|GUEST_PL;
                                                        regs->cs = __KERNEL_CS|GUEST_PL;
                                                        setup_guest_gdt(cpu);
                                                                cpu->arch.gdt[GDT_ENTRY_KERNEL_CS] = FULL_EXEC_SEGMENT;
                                                                cpu->arch.gdt[GDT_ENTRY_KERNEL_DS] = FULL_SEGMENT;
                                        err = init_guest_pagetable(lg);
                                                cpu->cpu_pgd = new_pgdir(cpu, 0, &allocated);
                                                        cpu->lg->pgdirs[next].gpgdir = gpgdir;
                                                        flush_user_mappings(cpu->lg, next);
                                                allocate_switcher_mapping
                                                        pte_t *pte = find_spte(cpu, switcher_addr
                                                        get_page(lg_switcher_pages[0]);
                                                        set_pte(pte, mk_pte(lg_switcher_pages[0], PAGE_KERNEL_RX));
        run_guest();
                for (;;) {
                pread(lguest_fd, &notify_addr,sizeof(notify_addr), cpu_id);
                        run_guest(cpu, (unsigned long __user *)user);
                                lguest_arch_run_guest(cpu);
                                        run_guest_once(cpu, lguest_pages(raw_smp_processor_id()));
                                                copy_in_guest_info(cpu, pages);
                                                        map_switcher_in_guest(cpu, pages);
                                                                pages->state.host_cr3 = __pa(current->mm->pgd);
                                                                map_switcher_in_guest(cpu, pages);
                                                                        set_pte(pte, mk_pte(regs_page, __pgprot(__PAGE_KERNEL & ~_PAGE_GLOBAL)));
                                                                        set_pte(pte, mk_pte(percpu_switcher_page,
                                                        copy_traps(cpu, pages->state.guest_idt, default_idt_entries);
                                                        copy_gdt(cpu, pages->state.guest_gdt);
                                                asm volatile("pushf; lcall *lguest_entry"
                                                         "0"(pages), "1"(__pa(cpu->lg->pgdirs[cpu->cpu_pgd].pgdir))
                                                        switch_to_guest //switch_32.S
                        //	lguest_arch_handle_trap(cpu);
                        //		case LGUEST_TRAP_ENTRY:
                        //		cpu->hcall = (struct hcall_args *)cpu->regs;
                handle_output(notify_addr);
                        update_device_status(i);
                                start_device(dev);
                                        create_thread(vq);
                                                vq->eventfd = eventfd(0, 0);
                                                write(lguest_fd, &args, sizeof(args)
                                                        attach_eventfd(lg, input);
                                                vq->thread = clone(do_thread, stack + 32768, CLONE_VM | SIGCHLD, vq);

do_thread // launcher device thread
        vq->service(vq);
        //blk_request
                head = wait_for_vq_desc(vq, iov, &out_num, &in_num);
                        trigger_irq(vq);
                                write(lguest_fd, buf, sizeof(buf)
                                        user_send_irq(cpu, input);
                                                set_interrupt(cpu, irq);
                                                        set_bit(irq, cpu->irqs_pending);
                                                        kick_process(cpu->tsk); //laucher tsk
                                                        //vring_interrupt

                        read(vq->eventfd, &event, sizeof(event)) != sizeof(event)
                lseek64(vblk->fd, off, SEEK_SET)
                readv(vblk->fd, iov + out_num, in_num);
                add_used(vq, head, wlen);
run_guest
        irq = interrupt_pending(cpu, &more);
        if (irq < LGUEST_IRQS)
        try_deliver_interrupt(cpu, irq, more);
                idt = &cpu->arch.idt[FIRST_EXTERNAL_VECTOR+irq];
                set_guest_interrupt(cpu, idt->a, idt->b, false);
                        push_guest_stack(cpu, &gstack, eflags);
                        push_guest_stack(cpu, &gstack, cpu->regs->cs);
                        push_guest_stack(cpu, &gstack, cpu->regs->eip);
                        cpu->regs->ss = ss;
                        cpu->regs->esp = virtstack + (gstack - origstack);
                        cpu->regs->cs = (__KERNEL_CS|GUEST_PL);
                        cpu->regs->eip = idt_address(lo, hi);
        /*	vring_interrupt
                        virtblk_done
                                virtqueue_get_buf(vblk->vq, &len)
                                virtblk_bio_done(vbr); */
init // drivers/lguest/core.c
        map_switcher
                lg_switcher_pages[i] = alloc_page(GFP_KERNEL|__GFP_ZERO);
                switcher_addr = FIXADDR_START - (TOTAL_SWITCHER_PAGES+1)*PAGE_SIZE;
                err = map_vm_area(switcher_vma, PAGE_KERNEL_EXEC, &pagep);
                memcpy(switcher_vma->addr, start_switcher_text, //switcher_32.S
        err = init_interrupts();
        err = lguest_device_init();
                misc_register(&lguest_dev);
        lguest_arch_host_init();
                default_idt_entries[i] += switcher_offset();
                store_idt(&state->host_idt_desc);
                setup_default_gdt_entries(state);
                /* Most IDT entries are the same for all Guests, too.*/
                setup_default_idt_entries(state, default_idt_entries);
                        default_idt_entry(&state->guest_idt[i], i, def[i], NULL);
                lguest_entry.offset = (long)switch_to_guest + switcher_offset();
                lguest_entry.segment = LGUEST_CS;
//guest os
lguest_entry //arch/x86/lguest/i386_head.S
        //jmp lguest_init+__PAGE_OFFSET
        lguest_init
                pv_cpu_ops.load_gdt = lguest_load_gdt;
                pv_cpu_ops.cpuid = lguest_cpuid;
                switch_to_new_gdt(0);
                i386_start_kernel();
                                start_kernel
                                        setup_arch
                                                paravirt_arch_setup_early();
                                                paravirt_patch_apply();


postcore_initcall(lguest_devices_init) //drivers/lguest/lguest_device.c
        lguest_root = root_device_register("lguest");
        lguest_devices = lguest_map(max_pfn<<PAGE_SHIFT, 1);
        scan_devices();
                add_lguest_device(d, i);
                        ldev->vdev.config = &lguest_config_ops;
                        register_virtio_device(&ldev->vdev) != 0)



init //drivers/block/virtio_blk.c
        virtblk_wq = alloc_workqueue("virtio-blk", 0, 0);
        major = register_blkdev(0, "virtblk");
        error = register_virtio_driver(&virtio_blk);

virtblk_probe
        vdev->priv = vblk = kmalloc(sizeof(*vblk) +
                                    sizeof(vblk->sg[0]) * sg_elems, GFP_KERNEL);
        err = init_vq(vblk);
                vblk->vq = virtio_find_single_vq(vblk->vdev, virtblk_done, "requests");
                        vdev->config->find_vqs(vdev, 1, &vq, callbacks, names);
                        //	.find_vqs = lg_find_vqs,
                                lg_find_vqs
                                        lg_find_vq(vdev, i, callbacks[i], names[i]);
                                                lvq->pages = lguest_map((unsigned long)lvq->config.pfn << PAGE_SHIFT,
                                                vq = vring_new_virtqueue(index, lvq->config.num, LGUEST_VRING_ALIGN, vdev,
                                                                         true, lvq->pages, lg_notify, callback, name);
                                                err = lguest_setup_irq(lvq->config.irq);
                                                err = request_irq(lvq->config.irq, vring_interrupt, IRQF_SHARED,
                                                                  dev_name(&vdev->dev), vq);
        vblk->disk = alloc_disk(1 << PART_BITS);
        q = vblk->disk->queue = blk_init_queue(virtblk_request, NULL);
        blk_queue_make_request(q, virtblk_make_request);
        add_disk(vblk->disk);

virtblk_make_request
        vbr = virtblk_alloc_req(vblk, GFP_NOIO);
        virtblk_bio_send_data(vbr);
                virtblk_add_req(vbr, have_data);
                         __virtblk_add_req(vblk->vq, vbr, vbr->sg,
                                                 have_data)) < 0)
                                virtqueue_add_sgs(vq, sgs, num_out, num_in, vbr, GFP_ATOMIC);
                                        virtqueue_add(_vq, sgs, sg_next_chained,
                             total_out, total_in, out_sgs, in_sgs, data, gfp);
                virtqueue_kick(vblk->vq);

virtblk_request
        blk_peek_request
        do_req(q, vblk, req)
                __virtblk_add_req(vblk->vq, vbr, vblk->sg, num) < 0)
        blk_start_request
        virtqueue_kick(vblk->vq);
                virtqueue_kick_prepare(vq)
                virtqueue_notify(vq);
                        vq->notify(_vq);
                        //lg_notify(struct virtqueue *vq)
                        hcall(LHCALL_NOTIFY, lvq->config.pfn << PAGE_SHIFT, 0, 0, 0);
                                asm volatile("int $" __stringify(LGUEST_TRAP_ENTRY)
                                deliver_to_host // switcher_32.S
                                //do_hypercalls(cpu);
                                        do_hcall(cpu, cpu->hcall);
                                                cpu->pending_notify = args->arg1;
                                                send_notify_to_eventfd(cpu)
                                                        rcu_dereference(cpu->lg->eventfds);
                                                        if (map->map[i].addr == cpu->pending_notify) {
                                                        eventfd_signal(map->map[i].event, 1);
                                                        //launcher do_thread



SYSCALL_DEFINE1(unlink, const char __user *, pathname)
        do_unlinkat(AT_FDCWD, pathname);
                name = user_path_parent(dfd, pathname, &nd, lookup_flags);
                dentry = lookup_hash(&nd);
                //security_path_unlink(&nd.path, dentry)
                error = vfs_unlink(nd.path.dentry->d_inode, dentry);
                        ext4_unlink
                                bh = ext4_find_entry(dir, &dentry->d_name, &de, NULL);
                                retval = ext4_delete_entry(handle, dir, de, bh);
                                ext4_orphan_add(handle, inode);

iput
        iput_final(inode);
                op->drop_inode(inode);
                        ext4_drop_inode
                                generic_drop_inode(inode);
        evict(inode);
                op->evict_inode(inode);
                        ext4_evict_inode
                                ext4_truncate(inode);
                                ext4_orphan_del(NULL, inode);

ext4_mount
        ext4_fill_super
                ext4_orphan_cleanup(sb, es);
                        while (es->s_last_orphan) {
                                inode = ext4_orphan_get(sb, le32_to_cpu(es->s_last_orphan));
                                ext4_truncate(inode);
                                iput(inode);  /* The delete magic happens here! */
*** devicemapper
//dmsetup
dev_create
        alloc_dev
                md->queue = blk_alloc_queue(GFP_KERNEL);
                dm_init_md_queue(md);
                        md->queue->queuedata = md;
                        md->queue->backing_dev_info.congested_fn = dm_any_congested;
                        md->queue->backing_dev_info.congested_data = md;
                        blk_queue_make_request(md->queue, dm_request);
                md->disk = alloc_disk(1);
                md->disk->major = _major;
                md->disk->first_minor = minor;
                md->disk->fops = &dm_blk_dops;
                md->disk->queue = md->queue;
                md->disk->private_data = md;
                sprintf(md->disk->disk_name, "dm-%d", minor);
                add_disk(md->disk);
        dm_hash_insert(param->name, *param->uuid ? param->uuid : NULL, md);
        __dev_status(md, param);

table_load
        md = find_device(param);
        dm_table_create(&t, get_mode(param), param->target_count, md)
                alloc_targets(t, num_targets))
        populate_table(t, param, param_size);
                dm_table_add_target(table, spec->target_type,
                                        (sector_t) spec->sector_start,
                                        (sector_t) spec->length,
                                        target_params);
                        dm_get_target_type(type)
                        tgt->type->ctr(tgt, argc, argv);
                        //.ctr = cache_ctr,
        dm_setup_md_queue(md);
                dm_init_request_based_queue(md)
                        blk_init_allocated_queue(md->queue, dm_request_fn, NULL);
                        md->queue = q;
                        dm_init_md_queue(md);
                        blk_queue_softirq_done(md->queue, dm_softirq_done);
                        blk_queue_prep_rq(md->queue, dm_prep_fn);
        __dev_status(md, param);

dm_request
        _dm_request(q, bio);
                __split_and_process_bio(md, bio);
                        ci.map = dm_get_live_table(md);
                        ci.md = md;
                        ci.io = alloc_io(md);
                        ci.io->bio = bio;
                        ci.io->md = md;
                        ci.sector = bio->bi_sector;
                        __split_and_process_non_flush(&ci);
                                dm_table_find_target(ci->map, ci->sector);
                                __clone_and_map_data_bio(ci, ti, ci->sector, bio->bi_max_vecs,
                                        tio = alloc_tio(ci, ti, nr_iovecs, target_bio_nr);
                                        clone_bio(tio, bio, sector, idx, bv_count, len);
                                        __map_bio(tio);
                                                clone->bi_end_io = clone_endio;
                                                //dm_endio_fn endio = tio->ti->type->end_io;
                                                        //cache_end_io
                                                ti->type->map(ti, clone);
                                                //cache_map
                                                generic_make_request(clone);

md_init
        register_blkdev(MD_MAJOR, "md"))
        register_blkdev(0, "mdp"))
        blk_register_region(MKDEV(MD_MAJOR, 0), 1UL<<MINORBITS, THIS_MODULE,
                            md_probe, NULL, NULL);
        blk_register_region(MKDEV(mdp_major, 0), 1UL<<MINORBITS, THIS_MODULE,
                            md_probe, NULL, NULL);
        md_geninit();

md_probe
        md_alloc
                blk_alloc_queue(GFP_KERNEL);
                blk_queue_make_request(mddev->queue, md_make_request);
                disk = alloc_disk(1 << shift);
                disk->fops = &md_fops;
                add_disk(disk);

md_ioctl
        set_array_info
                mddev->major_version = info->major_version;
                mddev->minor_version = info->minor_version;
                mddev->patch_version = info->patch_version;
                mddev->persistent = !info->not_persistent;

        add_new_disk
                rdev = md_import_device(dev, -1, 0);
                        alloc_disk_sb(rdev);
                        super_types[super_format].load_super(rdev, NULL, super_minor);

                rdev->raid_disk = info->raid_disk;
                rdev->sb_start = calc_dev_sboffset(rdev);
                rdev->sectors = rdev->sb_start;
                bind_rdev_to_array(rdev, mddev);

        do_md_run
                md_run
                        //mddev->pers->run(mddev)
                        raid0_run
                                blk_queue_max_write_same_sectors(mddev->queue, mddev->chunk_sectors);
                                create_strip_zones(mddev, &conf);
                                                conf->devlist = kzalloc(sizeof(struct md_rdev*)*
                                                                conf->nr_strip_zones*mddev->raid_disks,	GFP_KERNEL);
                                mddev->private = conf;
                                blk_queue_merge_bvec(mddev->queue, raid0_mergeable_bvec);
                bitmap_load


md_make_request
        //mddev->pers->make_request(mddev, bio);
        raid0_make_request
                zone = find_zone(mddev->private, &sector_offset);
                tmp_dev = map_sector(mddev, zone, bio->bi_sector, &sector_offset);
                bio->bi_bdev = tmp_dev->bdev;
                bio->bi_sector = sector_offset + zone->dev_start +	tmp_dev->data_offset;


raid0_init
        register_md_personality

*** crashkernel
setup_arch
        reserve_crashkernel
                parse_crashkernel(boot_command_line, total_mem,
                reserve_bootmem(crash_base, crash_size, BOOTMEM_EXCLUSIVE)
                crashk_res.start = crash_base;
                crashk_res.end = crash_base + crash_size - 1

parse_crashkernel
        __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,
                                        "crashkernel=", NULL);
crash_save_vmcoreinfo_init

vmcore_init
        proc_create("vmcore", S_IRUSR, NULL, &proc_vmcore_operations);

kexec -p <dump-capture-kernel-vmlinux-image> \
   --initrd=<initrd-for-dump-capture-kernel> --args-linux \
   --append="root=<root-dev> <arch-specific-options>"

kexec_load
        dest_image = &kexec_crash_image;
        result = kimage_crash_alloc(&image, entry,
                                                     nr_segments, segments);
                do_kimage_alloc(&image, entry, nr_segments, segments);
        kimage_alloc_crash_control_pages
        machine_kexec_prepare(image);
        kimage_load_segment(image, &image->segment[i]);
                kimage_load_crash_segment(image, segment);
                        copy_from_user(ptr, buf, uchunk);
panic
        crash_kexec  //Documentation/kdump
                crash_save_vmcoreinfo();
                machine_kexec(kexec_crash_image);

*** sound
snd_soc_init
        platform_driver_register(&soc_driver);
        /*static struct platform_driver soc_driver = {
                .driver		= {
                        .name		= "soc-audio",
                        .owner		= THIS_MODULE,
                        .pm		= &snd_soc_pm_ops,
                },
                .probe		= soc_probe,
                .remove		= soc_remove,
        };
        atm7059_link_init
                atm7059_link_snd_device = platform_device_alloc("soc-audio", -1);
                ret = platform_device_add(atm7059_link_snd_device); */
                soc_probe
                        snd_soc_register_card(card);
                                ret = snd_soc_instantiate_card(card);
                                        soc_bind_dai_link(card, i);
                                        snd_soc_init_codec_cache(codec, compress_type)
                                        snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1, card->owner, 0, &card->snd_card);
                                                snd_ctl_create(card);
                                                        snd_device_new(card, SNDRV_DEV_CONTROL, card, &ops);
                                                snd_info_card_create(card);
*** memory
paging_init
        early_alloc(PAGE_SIZE);
                early_alloc_aligned
                        memblock_alloc
        bootmem_init
                arm64_memory_present
                        memory_present
                                sparse_index_alloc
                                        alloc_bootmemmem_node(NODE_DATA(nid), array_size)
        sparse_init
                sparse_early_usemaps_alloc_node



early_init_dt_alloc_memory_arch
        memblock_alloc
        sparse_init
                alloc_bootmem
                        __alloc_memory_core_early
/*
 * vmalloc=size forces the vmalloc area to be exactly 'size'
 * bytes. This can be used to increase (or decrease) the vmalloc
 * area - the default is 240m.
 */
static int __init early_vmalloc(char *arg)
{
        unsigned long vmalloc_reserve = memparse(arg, NULL);

        if (vmalloc_reserve < SZ_16M) {
                vmalloc_reserve = SZ_16M;
                printk(KERN_WARNING
                        "vmalloc area too small, limiting to %luMB\n",
                        vmalloc_reserve >> 20);
        }

        if (vmalloc_reserve > VMALLOC_END - (PAGE_OFFSET + SZ_32M)) {
                vmalloc_reserve = VMALLOC_END - (PAGE_OFFSET + SZ_32M);
                printk(KERN_WARNING
                        "vmalloc area is too big, limiting to %luMB\n",
                        vmalloc_reserve >> 20);
        }

        vmalloc_min = (void *)(VMALLOC_END - vmalloc_reserve);
        return 0;
}
early_param("vmalloc", early_vmalloc);
*** loadbalance
load_balance(cpu, rq, sd, idle, &balance)
        find_busiest_group(&env, balance);
                update_sd_lb_stats(env, balance, &sds);
                        load_idx = get_sd_load_idx(env->sd, env->idle)
                                load_idx = sd->idle_idx
                        update_sg_lb_stats
                                load = target_load(i, load_idx)
                                        weighted_cpuload(cpu)
                                                cpu_rq(cpu)->load.weight
                                        max(rq->cpu_load[type-1], total);
                                sgs->group_load += load;
                                sgs->sum_nr_running += nr_running;
                                sgs->sum_weighted_load += weighted_cpuload(i);
                                update_group_power(env->sd, env->dst_cpu)
                                        update_cpu_power(sd, cpu);
                                                power *= arch_scale_freq_power(sd, cpu)
                                                         default_scale_freq_power(sd, cpu)
                                                                return SCHED_POWER_SCALE
                                                power *= scale_rt_power(cpu)
                                                        div_u64(available, total)
                                                cpu_rq(cpu)->cpu_power = power;
                                                sdg->sgp->power = power
                                sgs->avg_load = (sgs->group_load*SCHED_POWER_SCALE) / group->sgp->power;
                        sds->total_load += sgs.group_load;
                        sds->total_pwr += sg->sgp->power;
        update_h_load(env.src_cpu);
                walk_tg_tree(tg_load_down, tg_nop, (void *)cpu)
                        tg_load_down
                                load = tg->parent->cfs_rq[cpu]->h_load;
                                load *= tg->se[cpu]->load.weight;
                                load /= tg->parent->cfs_rq[cpu]->load.weight + 1;
        busiest = find_busiest_queue(&env, group);
        cur_ld_moved = move_tasks(&env)

loadavg_proc_show
*** scheduler
scheduler_tick
        trigger_load_balance
                run_rebalance_domains
                        rebalance_domains(this_cpu, idle);
                                load_balance(cpu, rq, sd, idle, &balance)


__schedule
        idle_balance
                load_balance(this_cpu, this_rq,sd, CPU_NEWLY_IDLE, &balance)


const struct sched_class fair_sched_class = {
        .next			= &idle_sched_class,
        .enqueue_task		= enqueue_task_fair,
        .dequeue_task		= dequeue_task_fair,
        .yield_task		= yield_task_fair,
        .yield_to_task		= yield_to_task_fair,

        .check_preempt_curr	= check_preempt_wakeup,

        .pick_next_task		= pick_next_task_fair,
        .put_prev_task		= put_prev_task_fair,

#ifdef CONFIG_SMP
        .select_task_rq		= select_task_rq_fair,
#ifdef CONFIG_FAIR_GROUP_SCHED
        .migrate_task_rq	= migrate_task_rq_fair,
#endif
        .rq_online		= rq_online_fair,
        .rq_offline		= rq_offline_fair,

        .task_waking		= task_waking_fair,
#endif

        .set_curr_task          = set_curr_task_fair,
        .task_tick		= task_tick_fair,
        .task_fork		= task_fork_fair,

        .prio_changed		= prio_changed_fair,
        .switched_from		= switched_from_fair,
        .switched_to		= switched_to_fair,

        .get_rr_interval	= get_rr_interval_fair,

#ifdef CONFIG_FAIR_GROUP_SCHED
        .task_move_group	= task_move_group_fair,
#endif
};


update_cfs_rq_blocked_load(cfs_rq, 1);
        u64 now = cfs_rq_clock_task(cfs_rq) >> 20;
        decays = now - cfs_rq->last_decay;
        atomic64_read(&cfs_rq->removed_load))	// removed_load from migrate task
                subtract_blocked_load_contrib(cfs_rq, removed_load);
                        cfs_rq->blocked_load_avg -= load_contrib
        cfs_rq->blocked_load_avg = decay_load(cfs_rq->blocked_load_avg,  decays);
        __update_cfs_rq_tg_load_contrib(cfs_rq, force_update);
                tg_contrib = cfs_rq->runnable_load_avg + cfs_rq->blocked_load_avg;
                tg_contrib -= cfs_rq->tg_load_contrib;
                atomic64_add(tg_contrib, &tg->load_avg);
                cfs_rq->tg_load_contrib += tg_contrib;

start_kernel
        cgroup_init
                struct cgroup_subsys *ss = subsys[i]
                        #define SUBSYS(_x) [_x ## _subsys_id] = &_x ## _subsys,
                        static struct cgroup_subsys *subsys[CGROUP_SUBSYS_COUNT] = {
                                #include <linux/cgroup_subsys.h>
                        };
                                #if IS_SUBSYS_ENABLED(CONFIG_CGROUP_SCHED)
                                        SUBSYS(cpu_cgroup)// cpu_cgroup_subsys
                                #endif
                cgroup_init_subsys(ss)
                        cgroup_init_cftsets(ss);
                        //css = ss->css_alloc(dummytop)
                        cpu_cgroup_css_alloc
                                sched_create_group(parent)
                                        alloc_fair_sched_group(tg, parent)
                        init_cgroup_css(css, ss, dummytop);

        cpuset_init
                register_filesystem(&cpuset_fs_type)

cgroup_tg

cpu_shares_write_u64
        sched_group_set_shares(cgroup_tg(cgrp), scale_load(shareval))
                for_each_sched_entity(se)
                        update_cfs_shares(group_cfs_rq(se));


update_cfs_shares
        tg = cfs_rq->tg;
        se = tg->se[cpu_of(rq_of(cfs_rq))];	// on this cpu

        if (likely(se->load.weight == tg->shares))

        shares = calc_cfs_shares(cfs_rq, tg);
                tg_weight = calc_tg_weight(tg, cfs_rq);
                        tg_weight = atomic64_read(&tg->load_avg);
                        tg_weight -= cfs_rq->tg_load_contrib;
                        tg_weight += cfs_rq->load.weight
                load = cfs_rq->load.weight;
                shares = (tg->shares * load);
                shares /= tg_weight;
        reweight_entity(cfs_rq_of(se), se, shares);
                account_entity_dequeue(cfs_rq, se);
                        update_load_sub(&cfs_rq->load, se->load.weight)
                                lw->weight -= dec;
                update_load_set(&se->load, weight);// se.load.weight = shares
                        lw->weight = w;
                account_entity_enqueue(cfs_rq, se);
                        update_load_add(&cfs_rq->load, se->load.weight)
                                lw->weight += inc;

update_entity_load_avg(se, 1);
        __update_entity_runnable_avg(now, &se->avg, se->on_rq, cfs_rq->curr == se, cpu)
                delta = now - sa->last_runnable_update
                delta >>= 10
                periods = delta / 1024
                sa->runnable_avg_sum = decay_load(sa->runnable_avg_sum, periods + 1);
                sa->runnable_avg_period = decay_load(sa->runnable_avg_period, periods + 1);
                sa->usage_avg_sum = decay_load(sa->usage_avg_sum, periods + 1);
                /* add the contribution from this period */
                /* Efficiently calculate \sum (1..n_period) 1024*y^i */
                runnable_contrib = __compute_runnable_contrib(periods);
                        contrib = decay_load(contrib, n);
                        return contrib + runnable_avg_yN_sum[n];
                // load_avg = u_0` + y*(u_0 + u_1*y + u_2*y^2 + ... )
                sa->runnable_avg_sum += delta;
                sa->runnable_avg_period += delta;
                return decayed;// 1ms
        if (!__update_entity_runnable_avg(now, &se->avg, se->on_rq,	cfs_rq->curr == se, cpu))
                return;

        contrib_delta = __update_entity_load_avg_contrib(se, &ratio_delta);
                if (entity_is_task(se)) {
                        __update_task_entity_contrib(se);
                                contrib = se->avg.runnable_avg_sum * scale_load_down(se->load.weight);
                                contrib /= (se->avg.runnable_avg_period + 1);
                                se->avg.load_avg_contrib = scale_load(contrib);
                                //trace_sched_task_load_contrib(task_of(se), se->avg.load_avg_contrib);
                                contrib = se->avg.runnable_avg_sum * scale_load_down(NICE_0_LOAD);
                                contrib /= (se->avg.runnable_avg_period + 1);
                                se->avg.load_avg_ratio = scale_load(contrib);
                                //trace_sched_task_runnable_ratio(task_of(se), se->avg.load_avg_ratio);
                } else {
                        __update_tg_runnable_avg(&se->avg, group_cfs_rq(se));
                                group_cfs_rq
                                        return grp->my_q; // task group
                                tg = cfs_rq->tg
                                atomic_add(contrib, &tg->runnable_avg);
                                cfs_rq->tg_runnable_contrib += contrib;
                        __update_group_entity_contrib(se);
                                contrib = cfs_rq->tg_load_contrib * tg->shares;
                                se->avg.load_avg_contrib = div64_u64(contrib, atomic64_read(&tg->load_avg) + 1);
                                runnable_avg = atomic_read(&tg->runnable_avg);
                                se->avg.load_avg_contrib *= runnable_avg;
                                se->avg.load_avg_contrib >>= NICE_0_SHIFT;
                return se->avg.load_avg_contrib - old_contrib;
        cfs_rq->runnable_load_avg += contrib_delta;
        rq_of(cfs_rq)->avg.load_avg_ratio += ratio_delta;

__schedule
        deactivate_task(rq, prev, DEQUEUE_SLEEP)
                dequeue_task(rq, p, flags);
                        update_rq_clock(rq);
                        sched_info_dequeued(p);
                        //p->sched_class->dequeue_task(rq, p, flags);
                        dequeue_task_fair

dequeue_task_fair
        cfs_rq = cfs_rq_of(se);
        for_each_sched_entity(se)
                dequeue_entity(cfs_rq, se, flags);
                        update_curr(cfs_rq);
                        dequeue_entity_load_avg(cfs_rq, se, flags & DEQUEUE_SLEEP);
                                update_entity_load_avg(se, 1);
                                /* we force update consideration on load-balancer moves */
                                update_cfs_rq_blocked_load(cfs_rq, !sleep);
                                cfs_rq->runnable_load_avg -= se->avg.load_avg_contrib;
                                rq_of(cfs_rq)->avg.load_avg_ratio -= se->avg.load_avg_ratio;
                                cfs_rq->blocked_load_avg += se->avg.load_avg_contrib;
                                se->avg.decay_count = atomic64_read(&cfs_rq->decay_counter);
                        update_stats_dequeue(cfs_rq, se);
                                if (se != cfs_rq->curr)
                                        update_stats_wait_end
                                        //trace_sched_stat_wait(task_of(se), rq_of(cfs_rq)->clock - se->statistics.wait_start);
                                        schedstat_set(se->statistics.wait_start, 0);
                        if (tsk->state & TASK_INTERRUPTIBLE)
                                se->statistics.sleep_start = rq_of(cfs_rq)->clock;
                        if (tsk->state & TASK_UNINTERRUPTIBLE)
                                se->statistics.block_start = rq_of(cfs_rq)->clock;
                        __dequeue_entity(cfs_rq, se);
                        se->on_rq = 0;
                        account_entity_dequeue(cfs_rq, se);
                                update_load_sub(&rq_of(cfs_rq)->load, se->load.weight);
                                cfs_rq->nr_running--;
                        return_cfs_rq_runtime(cfs_rq);
                                __return_cfs_rq_runtime(cfs_rq);
                        update_min_vruntime(cfs_rq);
                        update_cfs_shares(cfs_rq);
        for_each_sched_entity
                update_cfs_shares(cfs_rq);
                update_entity_load_avg(se, 1);
        dec_nr_running(rq);
        update_rq_runnable_avg(rq, 1);
        hrtick_update(rq)

pre_schedule_idle
        idle_exit_fair(rq);
                update_rq_runnable_avg(this_rq, 0);
        rq_last_tick_reset(rq);

enqueue_task_fair
        enqueue_entity(cfs_rq, se, flags)
                se->vruntime += cfs_rq->min_vruntime
                update_curr(cfs_rq)
                enqueue_entity_load_avg(cfs_rq, se, flags & ENQUEUE_WAKEUP);
                        if (wakeup) {
                                subtract_blocked_load_contrib(cfs_rq, se->avg.load_avg_contrib);
                                        cfs_rq->blocked_load_avg -= load_contrib;
                                update_entity_load_avg(se, 0);
                        cfs_rq->runnable_load_avg += se->avg.load_avg_contrib;
                        rq_of(cfs_rq)->avg.load_avg_ratio += se->avg.load_avg_ratio;
                account_entity_enqueue(cfs_rq, se);
                        update_load_add(&cfs_rq->load, se->load.weight)
                update_cfs_shares(cfs_rq);
                if (flags & ENQUEUE_WAKEUP) {
                        place_entity(cfs_rq, se, 0);
                        enqueue_sleeper(cfs_rq, se);//try to wakeup
                                delta = rq_of(cfs_rq)->clock - se->statistics.sleep_start
                                //trace_sched_stat_sleep(tsk, delta);
                                if (tsk) {
                                        if (tsk->in_iowait) {
                                                //trace_sched_stat_iowait(tsk, delta);
                                //trace_sched_stat_blocked(tsk, delta);
                update_stats_enqueue(cfs_rq, se);
                        if (se != cfs_rq->curr)
                                update_stats_wait_start(cfs_rq, se);
                                        schedstat_set(se->statistics.wait_start, rq_of(cfs_rq)->clock);
                check_spread(cfs_rq, se)
                __enqueue_entity(cfs_rq, se);// insert to rb tree
                se->on_rq = 1
        for_each_sched_entity
                update_cfs_shares(cfs_rq);
                update_entity_load_avg(se, 1);
        update_rq_runnable_avg(rq, rq->nr_running);
        inc_nr_running(rq);
        hrtick_update(rq)
                hrtick_start_fair(rq, curr)
                        sched_slice(cfs_rq, se)
                                 __sched_period(cfs_rq->nr_running + !se->on_rq)
                                        // p = (nr <= nl) ? l : l*nr/nl
                                slice = calc_delta_mine(slice, se->load.weight, load)
                                        //delta *= weight / lw
                                ran = se->sum_exec_runtime - se->prev_sum_exec_runtime
                                delta = slice - ran
                        hrtick_start(rq, delta);
                                hrtimer_set_expires(timer, time)
                                hrtimer_restart(timer)

try_to_wake_up_local // workqueue
wake_up_process
        try_to_wake_up(p, TASK_NORMAL, 0
                cpu = select_task_rq(p, SD_BALANCE_WAKE, wake_flags);
                        int cpu = p->sched_class->select_task_rq(p, sd_flags, wake_flags);
                        select_task_rq_fair
                                cpu = smp_processor_id()
                                prev_cpu = task_cpu(p)
                                new_cpu = select_idle_sibling(p, prev_cpu)
                set_task_cpu
                        //trace_sched_migrate_task(p, new_cpu);
                        //p->sched_class->migrate_task_rq(p, new_cpu);
                        migrate_task_rq_fair
                                update_cfs_rq_blocked_load(cfs_rq, 0);
                                se->avg.decay_count = -__synchronize_entity_decay(se);
                                atomic64_add(se->avg.load_avg_contrib, &cfs_rq->removed_load)
                                __set_task_cpu(p, new_cpu);
                                        set_task_rq(p, cpu);
                                                p->se.cfs_rq = tg->cfs_rq[cpu];
                                                p->se.parent = tg->se[cpu];
                ttwu_queue(p, cpu)
                        ttwu_do_activate(rq, p, 0);
                                ttwu_queue_remote(p, cpu); // we can use scheduler IPI
                                ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING)
                                        activate_task(rq, p, en_flags);
                                                enqueue_task(rq, p, flags);
                                                        //p->sched_class->enqueue_task(rq, p, flags)
                                                        enqueue_task_fair
                                        p->on_rq = 1;
                                ttwu_do_wakeup
                                        check_preempt_curr(rq, p, wake_flags);
                                                //rq->curr->sched_class->check_preempt_curr(rq, p, flags)
                                                check_preempt_wakeup
                                        //trace_sched_wakeup(p, true);
                                        if (rq->idle_stamp) {
                                                u64 delta = rq->clock - rq->idle_stamp;
                                                u64 max = 2*sysctl_sched_migration_cost;
                                                if (delta > max)
                                                        rq->avg_idle = max;
                                                else
                                                        update_avg(&rq->avg_idle, delta);
update_curr(cfs_rq);
        delta_exec = (unsigned long)(now - curr->exec_start）
        __update_curr(cfs_rq, curr, delta_exec);
                curr->sum_exec_runtime += delta_exec
                schedstat_add(cfs_rq, exec_clock, delta_exec)
                delta_exec_weighted = calc_delta_fair(delta_exec, curr)
                        calc_delta_mine(delta, NICE_0_LOAD, &se->load)
                                delta *= weight / lw
                curr->vruntime += delta_exec_weighted;
                update_min_vruntime(cfs_rq)
                        vruntime = cfs_rq->curr->vruntime
                        se = rb_entry(cfs_rq->rb_leftmost
                        vruntime = min_vruntime(vruntime, se->vruntime)
                        cfs_rq->min_vruntime = max_vruntime(cfs_rq->min_vruntime, vruntime)
        curr->exec_start = now;
        //trace_sched_stat_runtime
        cpuacct_charge(curtask, delta_exec)//cgroup 统计
                ca = task_ca(tsk)
                cpuusage = per_cpu_ptr(ca->cpuusage, cpu);
                *cpuusage += cputime
        account_group_exec_runtime(curtask, delta_exec)
                cputimer = &tsk->signal->cputimer
                cputimer->cputime.sum_exec_runtime += ns
        account_cfs_rq_runtime(cfs_rq, delta_exec)
                __account_cfs_rq_runtime(cfs_rq, delta_exec)
                        cfs_rq->runtime_remaining -= delta_exec
                        expire_cfs_rq_runtime(cfs_rq)
                                rq->clock - cfs_rq->runtime_expires
task_fork_fair
        update_rq_clock(rq);
                rq->clock += delta;
                update_rq_clock_task(rq, delta)
                        rq->clock_task += delta
        update_curr(cfs_rq);
        se->vruntime = curr->vruntime;
        place_entity(cfs_rq, se, 1);
                vruntime = cfs_rq->min_vruntime
                vruntime += sched_vslice(cfs_rq, se);
                se->vruntime = max_vruntime(se->vruntime, vruntime)
        se->vruntime -= cfs_rq->min_vruntime;// normized to relative vtime

do_fork
        copy_process
                sched_fork(p);
                        __sched_fork(p);
                        p->sched_class = &fair_sched_class
                        p->sched_class->task_fork(p)
                        task_fork_fair
                set_load_weight(p);
                        load->weight = scale_load(prio_to_weight[prio]);
                        load->inv_weight = prio_to_wmult[prio];
        //trace_sched_process_fork
        wake_up_new_task
                rq = __task_rq_lock(p);
                activate_task(rq, p, 0);
                        enqueue_task
                                update_rq_clock(rq);
                                        sched_clock_cpu
                                                sched_clock
                                                        //sched_clock_func
                                                        sched_clock_32
                                                                //read_sched_clock
                                                                owl_read_sched_clock
                                                                        act_readl(T0_VAL)
                                        update_rq_clock_task(rq, delta)
                                                rq->clock_task += delta
                                sched_info_queued(p);
                                        t->sched_info.last_queued = task_rq(t)->clock
                                //p->sched_class->enqueue_task(rq, p, flags)
                                enqueue_task_fair
                p->on_rq = 1;
                trace_sched_wakeup_new(p, true);
                check_preempt_curr(rq, p, WF_FORK)
                        //rq->curr->sched_class->check_preempt_curr(rq, p, flags)

__schedule();//idle case
        pre_schedule(rq, prev);
                //prev->sched_class->pre_schedule(rq, prev);
                pre_schedule_idle
                        idle_exit_fair(rq);
                                update_rq_runnable_avg(this_rq, 0);
                        rq_last_tick_reset(rq);
        next = pick_next_task(rq);
                // class->pick_next_task(rq)
                pick_next_task_fair
                        pick_next_entity(cfs_rq);
                                se = __pick_first_entity(cfs_rq)

                        set_next_entity(cfs_rq, se)
                                update_stats_wait_end(cfs_rq, se);
                                        if (entity_is_task(se)) {
                                                //trace_sched_stat_wait(task_of(se), rq_of(cfs_rq)->clock - se->statistics.wait_start);
                                cfs_rq->curr = se
        context_switch(rq, prev, next); /* unlocks the rq */
                prepare_task_switch(rq, prev, next);
                        //trace_sched_switch(prev, next);
schedule
        sched_submit_work(tsk);
                 blk_schedule_flush_plug
        __schedule();
                hrtick_clear(rq)
                deactivate_task(rq, prev, DEQUEUE_SLEEP);
                        dequeue_task(rq, p, flags);
                                update_rq_clock(rq);
                                //p->sched_class->dequeue_task(rq, p, flags);
                                dequeue_task_fair
                pre_schedule(rq, prev);
                        //prev->sched_class->pre_schedule(rq, prev);
                put_prev_task(rq, prev);
                        //prev->sched_class->put_prev_task(rq, prev);
                        put_prev_task_fair
                                put_prev_entity
                                        update_stats_wait_start(cfs_rq, prev);
                                                schedstat_set(se->statistics.wait_start, rq_of(cfs_rq)->clock);
                                        __enqueue_entity(cfs_rq, prev);
                                        update_entity_load_avg(prev, 1);
                                        cfs_rq->curr = NULL;
                next = pick_next_task(rq);
                        // class->pick_next_task(rq)
                        pick_next_task_fair
                                pick_next_entity(cfs_rq);
                                        se = __pick_first_entity(cfs_rq)
                                        wakeup_preempt_entity(cfs_rq->last, left)
                                                wakeup_gran(curr, se)
                                                        sysctl_sched_wakeup_granularity;
                                                        calc_delta_fair(gran, se)
                                        clear_buddies
                                set_next_entity(cfs_rq, se)
                                        update_stats_wait_end(cfs_rq, se);
                                                if (entity_is_task(se)) {
                                                        //trace_sched_stat_wait(task_of(se), rq_of(cfs_rq)->clock - se->statistics.wait_start);
                                        __dequeue_entity(cfs_rq, se);//rbtree remove
                                        update_entity_load_avg(se, 1);
                                        update_stats_curr_start(cfs_rq, se);
                                                se->exec_start = rq_of(cfs_rq)->clock_task;
                                        cfs_rq->curr = se
                                        se->prev_sum_exec_runtime = se->sum_exec_runtime;
                                hrtick_start_fair(rq, p)
                        pick_next_task_idle
                context_switch(rq, prev, next); /* unlocks the rq */
                        prepare_task_switch(rq, prev, next);
                                //trace_sched_switch(prev, next);
                                sched_info_switch(prev, next);
                                        sched_info_depart(prev);
                                        sched_info_arrive(next);
                        arch_start_context_switch
                        switch_mm
                        context_tracking_task_switch
                        switch_to
                        finish_task_switch
                post_schedule(rq);
                        //rq->curr->sched_class->post_schedule(rq)
wake_up_process
        try_to_wake_up(p, TASK_NORMAL, 0)

task_tick_fair
        entity_tick(cfs_rq, se, queued);
                update_curr(cfs_rq);
                update_entity_load_avg(curr, 1);
                update_cfs_rq_blocked_load(cfs_rq, 1);
                update_cfs_shares(cfs_rq);
                resched_task(rq_of(cfs_rq)->curr)
                check_preempt_tick(cfs_rq, curr)
                        ideal_runtime = sched_slice(cfs_rq, curr);
                        delta_exec = curr->sum_exec_runtime - curr->prev_sum_exec_runtime;
                        if (delta > ideal_runtime)
                                resched_task(rq_of(cfs_rq)->curr);
        update_rq_runnable_avg(rq, 1);
                __update_entity_runnable_avg(rq->clock_task, &rq->avg, runnable,
                                     runnable, cpu);
                __update_tg_runnable_avg(&rq->avg, &rq->cfs);
                //trace_sched_rq_runnable_ratio(cpu_of(rq), rq->avg.load_avg_ratio);
                //trace_sched_rq_runnable_load(cpu_of(rq), rq->cfs.runnable_load_avg);
                //trace_sched_rq_nr_running(cpu_of(rq), rq->nr_running, rq->nr_iowait.counter);
hrtick
        update_rq_clock(rq);
        //rq->curr->sched_class->task_tick(rq, rq->curr, 1);
        task_tick_fair

wake_up_process //wakeup on local cpu
try_to_wake_up(p, TASK_NORMAL, 0
        cpu = select_task_rq(p, SD_BALANCE_WAKE, wake_flags);
                int cpu = p->sched_class->select_task_rq(p, sd_flags, wake_flags);
                select_task_rq_fair
                        cpu = smp_processor_id()
                        prev_cpu = task_cpu(p)
                        new_cpu = select_idle_sibling(p, prev_cpu)
        ttwu_queue(p, cpu)
                ttwu_do_activate(rq, p, 0);
                        ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING)
                                activate_task(rq, p, en_flags);
                                        enqueue_task(rq, p, flags);
                                                enqueue_task_fair
                                                        enqueue_entity(cfs_rq, se, flags)
                                                                se->vruntime += cfs_rq->min_vruntime
        1							update_curr(cfs_rq)   // 1
                                                                enqueue_entity_load_avg(cfs_rq, se, flags & ENQUEUE_WAKEUP);
                                                                if (wakeup) {
                                                                        subtract_blocked_load_contrib(cfs_rq, se->avg.load_avg_contrib);
                                                                                cfs_rq->blocked_load_avg -= load_contrib;
        2 3								update_entity_load_avg(se, 0);// 2 3
                                                                if (flags & ENQUEUE_WAKEUP) {
                                                                        place_entity(cfs_rq, se, 0);
                                                                        enqueue_sleeper(cfs_rq, se);//try to wakeup
        4									delta = rq_of(cfs_rq)->clock - se->statistics.sleep_start
                                                                                //trace_sched_stat_sleep(tsk, delta);  //4
                                                        update_rq_runnable_avg(rq, rq->nr_running);
                                                                __update_entity_runnable_avg(rq->clock_task, &rq->avg, runnable, runnable, cpu);
                                                                __update_tg_runnable_avg(&rq->avg, &rq->cfs);
        5							//trace_sched_rq_runnable_ratio(cpu_of(rq), rq->avg.load_avg_ratio);
        6							//trace_sched_rq_runnable_load(cpu_of(rq), rq->cfs.runnable_load_avg);
        7							//trace_sched_rq_nr_running
                                ttwu_do_wakeup
                                        check_preempt_curr(rq, p, wake_flags);
        8				//trace_sched_wakeup(p, true);

 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052720: sched_stat_runtime: comm=Chrome_ChildIOT pid=5402 runtime=210750 [ns] vruntime=7375806629872 [ns]\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052730: sched_task_load_contrib: comm=Chrome_IOThread pid=5362 load_contrib=1689\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052732: sched_task_runnable_ratio: comm=Chrome_IOThread pid=5362 ratio=442\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052736: sched_stat_sleep: comm=Chrome_IOThread pid=5362 delay=438250 [ns]\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052740: sched_rq_runnable_ratio: cpu=3 ratio=623\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052742: sched_rq_runnable_load: cpu=3 load=2380\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052744: sched_rq_nr_running: cpu=3 nr_running=1 nr_iowait=0\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052750: sched_wakeup: comm=Chrome_IOThread pid=5362 prio=114 success=1 target_cpu=003\n\

 schedule  //task sleep
        sched_submit_work(tsk);
                 blk_schedule_flush_plug
        __schedule();
                hrtick_clear(rq)
                deactivate_task(rq, prev, DEQUEUE_SLEEP);
                        dequeue_task(rq, p, flags);
                                update_rq_clock(rq);
                                //p->sched_class->dequeue_task(rq, p, flags);
                                dequeue_task_fair
                                        cfs_rq = cfs_rq_of(se);
                                        for_each_sched_entity(se)
                                                dequeue_entity(cfs_rq, se, flags);
        1						update_curr(cfs_rq);
                                        dec_nr_running(rq);
        2 3 4			update_rq_runnable_avg(rq, 1);
                next = pick_next_task(rq);
                        pick_next_task_fair
                                set_next_entity(cfs_rq, se)
                                        update_stats_wait_end(cfs_rq, se);
                                                if (entity_is_task(se)) {
        5						//trace_sched_stat_wait
                context_switch(rq, prev, next); /* unlocks the rq */
                        prepare_task_switch(rq, prev, next);
        6			//trace_sched_switch(prev, next);
 Chrome_ChildIOT-5402  ( 5331) [003] d..3 120167.052807: sched_stat_runtime: comm=Chrome_ChildIOT pid=5402 runtime=89750 [ns] vruntime=7375806653401 [ns]\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..3 120167.052816: sched_rq_runnable_ratio: cpu=3 ratio=442\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..3 120167.052818: sched_rq_runnable_load: cpu=3 load=1689\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..3 120167.052819: sched_rq_nr_running: cpu=3 nr_running=1 nr_iowait=0\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..3 120167.052823: sched_stat_wait: comm=Chrome_IOThread pid=5362 delay=89750 [ns]\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..3 120167.052828: sched_switch: prev_comm=Chrome_ChildIOT prev_pid=5402 prev_prio=114 prev_state=S ==> next_comm=Chrome_IOThread next_pid=5362 next_prio=114\n\


wake_up_process
        try_to_wake_up(p, TASK_NORMAL, 0
                cpu = select_task_rq(p, SD_BALANCE_WAKE, wake_flags);
                set_task_cpu
1			//trace_sched_migrate_task(p, new_cpu);
                ttwu_queue(p, cpu)
                        ttwu_do_activate(rq, p, 0);
                                ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING)
                                        activate_task(rq, p, en_flags);
                                                enqueue_task(rq, p, flags);
                                                        enqueue_task_fair
                                                                enqueue_entity(cfs_rq, se, flags)
                                                                        se->vruntime += cfs_rq->min_vruntime
                                                                        update_curr(cfs_rq)
                                                                        enqueue_entity_load_avg(cfs_rq, se, flags & ENQUEUE_WAKEUP);
                                                                        if (wakeup) {
                                                                                subtract_blocked_load_contrib(cfs_rq, se->avg.load_avg_contrib);
                                                                                        cfs_rq->blocked_load_avg -= load_contrib;
                                                                                update_entity_load_avg(se, 0);
                                                                        if (flags & ENQUEUE_WAKEUP) {
                                                                                place_entity(cfs_rq, se, 0);
                                                                                enqueue_sleeper(cfs_rq, se);//try to wakeup
                                                                                        delta = rq_of(cfs_rq)->clock - se->statistics.sleep_start
2											//trace_sched_stat_sleep(tsk, delta);  //4
                                                                update_rq_runnable_avg(rq, rq->nr_running);
                                                                        __update_entity_runnable_avg(rq->clock_task, &rq->avg, runnable,
                                                                                             runnable, cpu);
                                                                        __update_tg_runnable_avg(&rq->avg, &rq->cfs);
3									//trace_sched_rq_runnable_ratio(cpu_of(rq), rq->avg.load_avg_ratio);
4									//trace_sched_rq_runnable_load(cpu_of(rq), rq->cfs.runnable_load_avg);
5									//trace_sched_rq_nr_running
                                        ttwu_do_wakeup
                                                check_preempt_curr(rq, p, wake_flags);
6						//trace_sched_wakeup(p, true);

 Chrome_IOThread-5362  ( 5062) [003] d..4 120167.053800: sched_migrate_task: comm=Chrome_ChildIOT pid=5402 prio=114 orig_cpu=3 dest_cpu=2\n\
 Chrome_IOThread-5362  ( 5062) [003] d..5 120167.053822: sched_stat_sleep: comm=Chrome_ChildIOT pid=5402 delay=1010500 [ns]\n\
 Chrome_IOThread-5362  ( 5062) [003] d..5 120167.053830: sched_rq_runnable_ratio: cpu=2 ratio=181\n\
 Chrome_IOThread-5362  ( 5062) [003] d..5 120167.053831: sched_rq_runnable_load: cpu=2 load=691\n\
 Chrome_IOThread-5362  ( 5062) [003] d..5 120167.053834: sched_rq_nr_running: cpu=2 nr_running=0 nr_iowait=0\n\
 Chrome_IOThread-5362  ( 5062) [003] d..5 120167.053846: sched_wakeup: comm=Chrome_ChildIOT pid=5402 prio=114 success=1 target_cpu=002\n\

cpu_idle_loop
        schedule_preempt_disabled();
                schedule();
                        __schedule();//idle case
                                pre_schedule(rq, prev);
                                        //prev->sched_class->pre_schedule(rq, prev);
                                        pre_schedule_idle
                                                idle_exit_fair(rq);
1 2 3						update_rq_runnable_avg(this_rq, 0);
                                                rq_last_tick_reset(rq);
                                next = pick_next_task(rq);
                                        // class->pick_next_task(rq)
                                        pick_next_task_fair
                                                pick_next_entity(cfs_rq);
                                                        se = __pick_first_entity(cfs_rq)
                                                set_next_entity(cfs_rq, se)
                                                        update_stats_wait_end(cfs_rq, se);
                                                                if (entity_is_task(se)) {
4									//trace_sched_stat_wait(task_of(se), rq_of(cfs_rq)->clock - se->statistics.wait_start);
                                                        cfs_rq->curr = se
                                context_switch(rq, prev, next); /* unlocks the rq */
                                        prepare_task_switch(rq, prev, next);
5						//trace_sched_switch(prev, next);

          <idle>-0     (-----) [002] dN.3 120167.053865: sched_rq_runnable_ratio: cpu=2 ratio=181\n\
          <idle>-0     (-----) [002] dN.3 120167.053870: sched_rq_runnable_load: cpu=2 load=691\n\
          <idle>-0     (-----) [002] dN.3 120167.053871: sched_rq_nr_running: cpu=2 nr_running=1 nr_iowait=0\n\
          <idle>-0     (-----) [002] dN.3 120167.053876: sched_stat_wait: comm=Chrome_ChildIOT pid=5402 delay=0 [ns]\n\
          <idle>-0     (-----) [002] d..3 120167.053882: sched_switch: prev_comm=swapper/2 prev_pid=0 prev_prio=120 prev_state=R ==> next_comm=Chrome_ChildIOT next_pid=5402 next_prio=114\n\



sched_init
        init_sched_domains(cpu_active_mask);
        init_rq_hrtick
                hrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
                        __hrtimer_init(timer, clock_id, mode);
                rq->hrtick_timer.function = hrtick;
                init_idle(current, smp_processor_id());
                        rq->curr = rq->idle = idle;
                        idle->sched_class = &idle_sched_class;

=> update_process_times

 => tick_sched_timer

 => __run_hrtimer

 => hrtimer_interrupt

 => twd_handler

 => handle_percpu_devid_irq

 => generic_handle_irq

 => handle_IRQ

 => gic_handle_irq

 => __irq_svc

 => _raw_spin_unlock_irq

 => finish_task_switch

 => __schedule

 => schedule_preempt_disabled

 => cpu_startup_entry

 => start_kernel
*** timer
update_process_times(user_mode(get_irq_regs()));
        run_local_timers
                hrtimer_run_queues();
                        timerqueue_getnext
                        cpu_base = &__get_cpu_var(hrtimer_bases)
                        __run_hrtimer(timer, &base->softirq_time)
                raise_softirq(TIMER_SOFTIRQ);
                        run_timer_softirq
                                hrtimer_run_pending();
                                        tick_check_oneshot_change
                                        hrtimer_switch_to_hres()
                                                tick_nohz_switch_to_nohz();
                                                        tick_switch_to_oneshot(tick_nohz_handler)
                                __run_timers(base)
                                        call_timer_fn(timer, fn, data);
        rcu_check_callbacks
        scheduler_tick
                sched_clock_tick
                update_rq_clock
                update_cpu_load_active
                        __update_cpu_load(this_rq, this_rq->load.weight, 1);
                                this_rq->cpu_load[0] = this_load;
                                this_rq->cpu_load[i] = (old_load * (scale - 1) + new_load) >> i
                                sched_avg_update(this_rq)
                                        rq->rt_avg /= 2
                        calc_load_account_active(this_rq)
                //curr->sched_class->task_tick(rq, curr, 0);
                task_tick_fair
                trigger_load_balance

hrtimer_switch_to_hres
        tick_init_highres
                tick_switch_to_oneshot(hrtimer_interrupt)
                                //hrtimer_interrupt
                                __run_hrtimer(timer, &basenow);
                                tick_program_event(expires_next, 1);
                        td = &__get_cpu_var(tick_cpu_device)
                        dev->event_handler = handler;
                        clockevents_set_mode(dev, CLOCK_EVT_MODE_ONESHOT);
                        tick_broadcast_switch_to_oneshot();
        tick_setup_sched_timer();
                ts = &__get_cpu_var(tick_cpu_sched);
                hrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
                ts->sched_timer.function = tick_sched_timer;// only forward timer no reprogram tick device
                        tick_sched_do_timer(now);
                                tick_do_update_jiffies64(now);
                        tick_sched_handle(ts, regs);
                                update_process_times(user_mode(regs));
                                touch_softlockup_watchdog();
                        hrtimer_forward(timer, now, tick_period); //
tick_handle_periodic
        tick_periodic(cpu);
                do_timer(1);
                        jiffies_64 += ticks;
                        update_wall_time();
                                //clock->read(clock)
                                owl_read_timer
                                        act_readl(T0_VAL)
                                timekeeping_adjust(tk, offset)
                        calc_global_load(ticks);
/*  Once every LOAD_FREQ:
 *
 *   nr_active = 0;
 *   for_each_possible_cpu(cpu)
 *      nr_active += cpu_of(cpu)->nr_running + cpu_of(cpu)->nr_uninterruptible;
 *
 *   avenrun[n] = avenrun[0] * exp_n + nr_active * (1 - exp_n) */
                update_process_times(user_mode(get_irq_regs()));
        ktime_add(dev->next_event, tick_period);
        clockevents_program_event(dev, next, false)


CLOCKSOURCE_OF_DECLARE(arm_twd_a9, "arm,cortex-a9-twd-timer", twd_local_timer_of_register);
twd_local_timer_of_register

time_init
        //machine_desc->init_time()
        owl_timer_init
                owl_gp_timer_init
                        setup_sched_clock(owl_read_sched_clock, 32, rate);
                        clocksource_register_hz(&owl_clksrc, rate);
                                sched_clock_timer.data = msecs_to_jiffies(w - (w / 10));
                                update_sched_clock();
                        setup_irq(OWL_IRQ_TIMER1, &owl_timer_irq);
                        owl_clkevt.cpumask = cpumask_of(0);
                        clockevents_config_and_register(&owl_clkevt, rate,0xf, 0xffffffff);
                                clockevents_register_device
                                        tick_check_new_device
                                                td = &per_cpu(tick_cpu_device, cpu);
                                                tick_setup_device(td, newdev, cpu, cpumask_of(cpu))
                                                        td->evtdev = newdev
                                                        tick_setup_periodic(newdev, 0)
                                                                tick_set_periodic_handler(dev, broadcast)
                                                                        dev->event_handler = tick_handle_periodic
                                                                clockevents_set_mode(dev, CLOCK_EVT_MODE_ONESHOT);
                                                                        clockevents_program_event
                                                                                //dev->set_next_event((unsigned long) clc, dev);
                                                                                owl_clkevt_next
                owl_twd_init
                        twd_local_timer_register(&twd_local_timer)
                                twd_base = ioremap(tlt->res[0].start, resource_size(&tlt->res[0]));
                                twd_local_timer_common_register(NULL);
                                        request_percpu_irq(twd_ppi, twd_handler, "twd", twd_evt);
                                        local_timer_register(&twd_lt_ops);
                                                //struct local_timer_ops *lt_ops = twd_lt_ops ;
                                                //static struct local_timer_ops twd_lt_ops __cpuinitdata = {
                                                //	.setup	= twd_timer_setup,
                                                        twd_timer_setup
                                                                clk->name = "local_timer";
                                                                clk->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |
                                                                                CLOCK_EVT_FEAT_C3STOP;
                                                                clk->rating = 350;
                                                                clk->set_mode = twd_set_mode;
                                                                clk->set_next_event = twd_set_next_event;
                                                                clk->irq = twd_ppi;
                                                                this_cpu_clk = __this_cpu_ptr(twd_evt);
                                                                *this_cpu_clk = clk;
                                                                clockevents_config_and_register(clk, twd_timer_rate,
                                                                                                0xf, 0xffffffff);
                                                                enable_percpu_irq(clk->irq, 0);
                                        twd_get_clock(np);
                                                of_clk_get(np, 0);
                                                clk_get_sys("smp_twd", NULL);
                                                clk_prepare_enable(twd_clk);

        sched_clock_postinit
                sched_clock_poll(sched_clock_timer.data);//
                        mod_timer(&sched_clock_timer, round_jiffies(jiffies + wrap_ticks));
                        update_sched_clock();
start_kernel
        init_timers();
                open_softirq(TIMER_SOFTIRQ, run_timer_softirq)
                        run_timer_softirq
                                hrtimer_run_pending
        hrtimers_init();
                open_softirq(HRTIMER_SOFTIRQ, run_hrtimer_softirq);
        time_init();
        rest_init
                init_idle_bootup_task(current);
                cpu_startup_entry(CPUHP_ONLINE);
                        cpu_idle_loop();
}
*** cpu hotplug
cpu_down
        _cpu_down
                __cpu_notify(CPU_DOWN_PREPARE | mod, hcpu, -1, &nr_calls)
                __stop_machine
                __cpu_die
                        platform_cpu_kill(cpu)
                                //smp_ops.cpu_kill
                                owl_cpu_kill
                cpu_notify_nofail(CPU_DEAD | mod, hcpu)

scheduler_ipi
        tick_nohz_full_check();
                tick_nohz_full_cpu(smp_processor_id())
                tick_nohz_restart_sched_tick(ts, ktime_get());
                        tick_nohz_restart(ts, now);
        sched_ttwu_pending();
                ttwu_do_activate(rq, p, 0);

cpu_idle_loop
        tick_nohz_idle_enter();
                ts = &__get_cpu_var(tick_cpu_sched);
                ts->inidle = 1;
                __tick_nohz_idle_enter(ts);
                        tick_nohz_start_idle(cpu, ts)
                                ts->idle_entrytime = now;
                                ts->idle_active = 1;
                                sched_clock_idle_sleep_event();
                        can_stop_idle_tick(cpu, ts)
                        expires = tick_nohz_stop_sched_tick(ts, now, cpu);
                                rcu_needs_cpu
                                get_next_timer_interrupt
                                nohz_balance_enter_idle(cpu);
                                        set_bit(NOHZ_TICK_STOPPED, nohz_flags(cpu));
                                calc_load_enter_idle();
                                        calc_load_fold_active(this_rq);
                                ts->last_tick = hrtimer_get_expires(&ts->sched_timer);
                                ts->tick_stopped = 1;
                                raise_softirq_irqoff(TIMER_SOFTIRQ);
                                //trace_tick_stop(1, " ");
        if (cpu_is_offline(smp_processor_id()))
                arch_cpu_idle_dead();
                        cpu_die
                                //smp_ops.cpu_die(cpu)
                                owl_cpu_die
                                        platform_do_lowpower
                                                cpu_enter_lowpower
                                                        scu_power_mode(scu_base, 0x3);//WFI
        arch_cpu_idle_enter();
                ledtrig_cpu(CPU_LED_IDLE_START);
        arch_cpu_idle();
                if (cpuidle_idle_call())
                        default_idle();
                                if (arm_pm_idle)
                                        arm_pm_idle();
                                else
                                        cpu_do_idle();
                                                //__glue(CPU_NAME,_do_idle) //name##fn
                                                cpu_v7_do_idle //arch/arm/mm/proc-v7.S
        arch_cpu_idle_exit();
        tick_nohz_idle_exit();
        schedule_preempt_disabled();
                schedule();

hotplug_timer
        cpu_down
        cpu_up

owl_pm_hotplug_init
        INIT_DELAYED_WORK(&hotplug_work, hotplug_timer);
        INIT_DELAYED_WORK(&(freq_trans_works.work), adjust_hot_plug_with_freq);
        INIT_DELAYED_WORK(&detecting_freq_work, set_cpu_frequence);

secondary_start_kernel
        //smp_ops.smp_secondary_init(cpu);
        owl_secondary_init
                gic_secondary_init(NULL, CPU_STARTING, (void*)0)
        notify_cpu_starting(cpu)
        cpu_startup_entry
                cpu_idle_loop();

start_kernel
        setup_arch
                smp_init_cpus()
                        //smp_ops.smp_init_cpus()
                        owl_smp_init_cpus
        rest_init
                kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);
                        kernel_init_freeable
                                smp_prepare_cpus(setup_max_cpus)
                                        percpu_timer_setup();
                                                struct clock_event_device *evt = &per_cpu(percpu_clockevent, cpu);
                                                //lt_ops->setup(evt)
                                                twd_timer_setup
                                                        clk->name = "local_timer";
                                                        clk->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |
                                                                        CLOCK_EVT_FEAT_C3STOP;
                                                        clk->rating = 350;
                                                        clk->set_mode = twd_set_mode;
                                                        clk->set_next_event = twd_set_next_event;
                                                        clk->irq = twd_ppi;
                                                        this_cpu_clk = __this_cpu_ptr(twd_evt);
                                                        *this_cpu_clk = clk;
                                                        clockevents_config_and_register(clk, twd_timer_rate,
                                                                                        0xf, 0xffffffff);
                                                        enable_percpu_irq(clk->irq, 0);

                                        //smp_ops.smp_prepare_cpus(max_cpus)
                                        owl_smp_prepare_cpus
                                smp_init
                                        idle_threads_init
                                                idle_init
                                                        fork_idle
                                                                copy_process
                                                                init_idle_pids(task->pids);
                                                                init_idle(task, cpu);
                                                                        idle->sched_class = &idle_sched_class;
                                        cpu_up(cpu);//
                                                _cpu_up
                                                        cpu_hotplug_begin
                                                        __cpu_notify(CPU_UP_PREPARE | mod, hcpu, -1, &nr_calls);
                                                        __cpu_up(cpu, idle);
                                                                idle = idle_thread_get(cpu);
                                                                        per_cpu(idle_threads, cpu)
                                                                boot_secondary(cpu, idle)
                                                                        //smp_ops.smp_boot_secondary(cpu, idle)
                                                                        owl_boot_secondary
                                                                                wakeup_secondary
                                                                                        owl_powergate_power_on
                                                                                        act_writel(virt_to_phys(owl_secondary_startup)
                                                                                                secondary_startup//HEAD.S
                                                                                                        secondary_start_kernel
                                                        cpu_notify(CPU_ONLINE | mod, hcpu)
                                                        cpu_hotplug_done()
                                        smp_cpus_done//bogomips

static struct smp_operations owl_smp_ops =
{
#ifdef CONFIG_SMP
    .smp_init_cpus = owl_smp_init_cpus,
    .smp_prepare_cpus = owl_smp_prepare_cpus,
    .smp_secondary_init = owl_secondary_init,
    .smp_boot_secondary = owl_boot_secondary,
#ifdef CONFIG_HOTPLUG_CPU
        .cpu_kill = owl_cpu_kill,
        .cpu_die = owl_cpu_die,
        .cpu_disable = owl_cpu_disable,
#endif
#endif
};

owl_smp_init
        smp_set_ops(&owl_smp_ops);
*** irq
static struct irq_chip gic_chip = {
        .name			= "GIC",
        .irq_mask		= gic_mask_irq,
        .irq_unmask		= gic_unmask_irq,
        .irq_eoi		= gic_eoi_irq,
        .irq_set_type		= gic_set_type,
        .irq_retrigger		= gic_retrigger,
#ifdef CONFIG_SMP
        .irq_set_affinity	= gic_set_affinity,
#endif
        .irq_set_wake		= gic_set_wake,
};

const struct irq_domain_ops gic_irq_domain_ops = {
        .map = gic_irq_domain_map,
        .xlate = gic_irq_domain_xlate,
};

request_irq
        request_threaded_irq
                irq_to_desc
                __setup_irq(irq, desc, action)

owl_init_irq
        gic_init
                gic_init_bases
                        irq_alloc_descs
                        irq_domain_add_legacy //gic_irq_domain_ops
                                irq_domain_alloc
                                //ops->map(domain, irq, hwirq)
                                gic_irq_domain_map
                                        irq_set_chip_and_handler(irq, &gic_chip,handle_percpu_devid_irq);
                                irq_domain_add
                         set_smp_cross_call(gic_raise_softirq);
*** pinctrl
p = pinctrl_get(dev);
                create_pinctrl
                        pinctrl_dt_to_map
                                kasprintf(GFP_KERNEL, "pinctrl-%d", state)
                                of_find_property
                                dt_to_map_one_config(p, statename, np_config)
                                        pctldev = get_pinctrl_dev_from_of_node(np_pctldev)
                                        ops = pctldev->desc->pctlops
                                        ops->dt_node_to_map(pctldev, np_config, &map, &num_maps)
                                        //owl_pinctrl_dt_node_to_map
                                        dt_remember_or_free_map(p, statename, pctldev, map, num_maps)
                                                pinctrl_register_map(map, num_maps, false, true)
                                                        pinmux_validate_map(&maps[i], i)
                                                        list_add_tail(&maps_node->node, &pinctrl_maps)
s = pinctrl_lookup_state(p, "8bit");
ret = pinctrl_select_state(p, s);
static struct pinctrl_ops owl_pctlops_ops = {
        .get_groups_count = owl_pctlops_get_groups_count,
        .get_group_name = owl_pctlops_get_group_name,
        .get_group_pins = owl_pctlops_get_group_pins,
        .pin_dbg_show = owl_pctlops_pin_dbg_show,
        .dt_node_to_map = owl_pinctrl_dt_node_to_map,
        .dt_free_map = owl_pinctrl_dt_free_map,

};


static struct pinmux_ops owl_pmxops_ops = {
        .get_functions_count = owl_pmxops_get_funcs_count,
        .get_function_name = owl_pmxops_get_func_name,
        .get_function_groups = owl_pmxops_get_groups,
        .enable = owl_pmxops_enable,
        .disable = owl_pmxops_disable,
        .request = owl_pmxops_request,
        .gpio_request_enable = owl_pmxops_gpio_request_enable,
        .gpio_disable_free = owl_pmxops_gpio_disable_free,

};

static struct pinctrl_desc owl_pinctrl_desc = {
        .name = NULL,
        .pins = NULL,
        .npins = 0,
        .pctlops = &owl_pctlops_ops,
        .pmxops = &owl_pmxops_ops,
        .confops = &owl_confops_ops,
        .owner = THIS_MODULE,
};

owl_pinctrl_common_probe
        pinctrl_register(&owl_pinctrl_desc, &pdev->dev, apctl)

cpu0_set_target
        cpufreq_frequency_table_target
        opp_find_freq_ceil
        opp_get_voltage
        cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE)
        clk_set_rate
        regulator_set_voltage_tol
        cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE)

static struct cpufreq_driver cpu0_cpufreq_driver = {
        .flags = CPUFREQ_STICKY,
        .verify = cpu0_verify_speed,
        .target = cpu0_set_target,
        .get = cpu0_get_speed,
        .init = cpu0_cpufreq_init,
        .exit = cpu0_cpufreq_exit,
        .name = "generic_cpu0",
        .attr = cpu0_cpufreq_attr,
};
*** cpufreq
late_initcall(cpu0_cpufreq_driver_init);
        owl_cpu0_cpufreq_driver_init
                get_cpu_device(0)
                owl_cpu0_clk_init
                devm_regulator_get
                init_cpu0_opp_info
                find_cpu0_opp_info_max_min_freq
                CF0AOT_all //opp_add
                cpufreq_register_driver
cpufreq_interactive_speedchange_task
        __cpufreq_driver_target
                cpufreq_driver->target(policy, target_freq, relation)

cpufreq_interactive_timer
        update_load(data);
        choose_freq(pcpu, loadadjfreq);
                cpufreq_frequency_table_target
        cpufreq_frequency_table_target(pcpu->policy, pcpu->freq_table,new_freq, CPUFREQ_RELATION_L,&index)
        wake_up_process(speedchange_task)

cpufreq_governor_interactive
        CPUFREQ_GOV_POLICY_INIT:
        policy->governor_data = tunables
        CPUFREQ_GOV_START:
        freq_table = cpufreq_frequency_get_table(policy->cpu)
        cpufreq_interactive_timer_start
                add_timer_on(&pcpu->cpu_timer, cpu)
                //pcpu->cpu_timer.function = cpufreq_interactive_timer;
                cpufreq_interactive_timer
struct cpufreq_governor cpufreq_gov_interactive = {
        .name = "interactive",
        .governor = cpufreq_governor_interactive,
        .max_transition_latency = 10000000,
        .owner = THIS_MODULE,
};
cpufreq_add_dev
        cpufreq_add_dev_interface(cpu, policy, dev)
                __cpufreq_set_policy(policy, &new_policy)
                        __cpufreq_governor(data, CPUFREQ_GOV_POLICY_INIT))
                                //policy->governor->governor(policy, event)
                                cpufreq_governor_interactive
                        __cpufreq_governor(data, CPUFREQ_GOV_START)

static struct subsys_interface cpufreq_interface = {
        .name		= "cpufreq",
        .subsys		= &cpu_subsys,
        .add_dev	= cpufreq_add_dev,
        .remove_dev	= cpufreq_remove_dev,
};

cpufreq_register_driver
        subsys_interface_register(&cpufreq_interface)

of_find_compatible_node

/*
cpu0_cpufreq_probe
        of_init_opp_table
                of_find_property(dev->of_node, "operating-points", NULL)
                opp_add(dev, freq, volt)
        opp_init_cpufreq_table
                find_device_opp
                freq_table[i].frequency = opp->rate / 1000
        cpufreq_register_driver
*/
*** regulator
regulator_get
        _regulator_get
                regulator_dev_lookup
                        of_get_regulator
                        list_for_each_entry(r, &regulator_list, list)
                                if (r->dev.parent && node == r->dev.of_node)
                create_regulator
                        regulator->rdev = rdev;
                        list_add(&regulator->list, &rdev->consumer_list);
regulator_enable
        _regulator_enable
                _regulator_do_enable
                        _regulator_get_enable_time(rdev)
                        trace_regulator_enable(rdev_get_name(rdev));
                        rdev->desc->ops->enable(rdev)
devm_regulator_get
        devres_alloc
                alloc_dr
__device_release_driver
        devres_release_all
                release_nodes
                        dr->node.release(dev, dr->data);
*** zram
shrink_page_list
        add_to_swap
                entry = get_swap_page();
                         swp_entry(type, offset);
        add_to_swap_cache(page, entry,
                __add_to_swap_cache
                        swap_address_space(entry); //&swapper_spaces[swp_type(entry)
        pageout
                // mapping->a_ops->writepage
                swap_writepage // swap_aops
                        try_to_free_swap
                                delete_from_swap_cache(page);
                        frontswap_store
                        __swap_writepage(page, wbc, end_swap_bio_write)//else
                                page_swap_info(page)
                                get_swap_bio(GFP_NOIO, page, end_write_func);
                                submit_bio(rw, bio);
handle_pte_fault
        do_swap_page
                lookup_swap_cache
                        swapin_readahead
                                read_swap_cache_async
                                        swap_readpage
                                                get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);
                                                submit_bio(READ, bio);
                swap_free
                        swap_entry_free(p, entry, 1);
                                //disk->fops->swap_slot_free_notify
                                zram_slot_free_notify	//zram_devops
__remove_mapping
        swapcache_free
                swap_entry_free

(zram_slot_free_notify+0x1c/0x40) from [<c010f0d0>] (swap_entry_free+0x12c/0x168)
(swap_entry_free+0x12c/0x168) from [<c010f2c8>] (swap_free+0x20/0x2c)
(swap_free+0x20/0x2c) from [<c010006c>] (handle_pte_fault+0x3e0/0x85c)
(handle_pte_fault+0x3e0/0x85c) from [<c01005bc>] (handle_mm_fault+0xd4/0x11c)
(handle_mm_fault+0xd4/0x11c) from [<c001b118>] (do_page_fault+0x250/0x3a4)
(do_page_fault+0x250/0x3a4) from [<c00084d4>] (do_DataAbort+0x38/0x98)
(do_DataAbort+0x38/0x98) from [<c000f074>] (__dabt_usr+0x34/0x40)

SYSCALL_DEFINE2(swapon
        alloc_swap_info
                swap_info_struct p = swap_info[type]
        p->swap_file = file_open_name(name,
        claim_swapfile(p, inode);
                p->bdev = bdgrab(I_BDEV(inode))
                blkdev_open //bdev->bd_inode->i_mapping
                set_blocksize(p->bdev, PAGE_SIZE);
        read_mapping_page(mapping, 0, swap_file);
        setup_swap_map_and_extents
        enable_swap_info
                frontswap_init
                        __frontswap_init(type, map)
                                frontswap_ops->init(type); //zcache_frontswap_ops
                                        zcache_frontswap_init
                _enable_swap_info(p, prio, swap_map);


zram_init
        register_blkdev(0, "zram");
                 create_device(&zram_devices[dev_id], dev_id);
                        blk_queue_make_request(zram->queue, zram_make_request);
                        zram->disk->fops = &zram_devops;
zram_make_request
        __zram_make_request(zram, bio, bio_data_dir(bio));
                zram_bvec_rw(zram, &bv, index+1, 0, bio, rw) < 0)
                                zram_bvec_write
                                        zs_malloc(meta->mem_pool, clen);
                        bio_endio(bio, 0);
zcache_init
        zcache_frontswap_register_ops
                frontswap_register_ops(&zcache_frontswap_ops);

warn_slowpath_common+0x4c/0x68) from [<c00309f8>] (warn_slowpath_null+0x1c/0x24)
warn_slowpath_null+0x1c/0x24) from [<c02783c8>] (fuse_lookup+0x120/0x130)
fuse_lookup+0x120/0x130) from [<c0124bf0>] (lookup_real+0x20/0x50)
lookup_real+0x20/0x50) from [<c01254e8>] (__lookup_hash+0x34/0x44)
__lookup_hash+0x34/0x44) from [<c0125530>] (lookup_slow+0x38/0x9c)
lookup_slow+0x38/0x9c) from [<c01275b4>] (path_lookupat+0x22c/0x7c8)
path_lookupat+0x22c/0x7c8) from [<c0127b70>] (filename_lookup+0x20/0xbc)
filename_lookup+0x20/0xbc) from [<c0129f6c>] (user_path_at_empty+0x50/0x7c)
user_path_at_empty+0x50/0x7c) from [<c0129fac>] (user_path_at+0x14/0x1c)
user_path_at+0x14/0x1c) from [<c01205f8>] (vfs_fstatat+0x4c/0x90)
vfs_fstatat+0x4c/0x90) from [<c01208fc>] (SyS_fstatat64+0x14/0x30)
SyS_fstatat64+0x14/0x30) from [<c000f0c0>] (ret_fast_syscall+0x0/0x30)

[ 8495.987327] [<c0015ea0>] (unwind_backtrace+0x0/0x134) from [<c00132d8>] (show_stack+0x10/0x14)
[ 8495.996053] [<c00132d8>] (show_stack+0x10/0x14) from [<c072a80c>] (dump_header.isra.12+0x74/0x1a0)
[ 8496.005108] [<c072a80c>] (dump_header.isra.12+0x74/0x1a0) from [<c00d84fc>] (oom_kill_process+0x268/0x3b8)
[ 8496.014817] [<c00d84fc>] (oom_kill_process+0x268/0x3b8) from [<c00d8ac0>] (out_of_memory+0x2ac/0x2dc)
[ 8496.024075] [<c00d8ac0>] (out_of_memory+0x2ac/0x2dc) from [<c00dd2f0>] (__alloc_pages_nodemask+0x84c/0x8f4)
[ 8496.033843] [<c00dd2f0>] (__alloc_pages_nodemask+0x84c/0x8f4) from [<c00d74d0>] (filemap_fault+0x1cc/0x44c)
[ 8496.043600] [<c00d74d0>] (filemap_fault+0x1cc/0x44c) from [<c00f60f0>] (__do_fault+0x6c/0x4d8)
[ 8496.052243] [<c00f60f0>] (__do_fault+0x6c/0x4d8) from [<c00f9480>] (handle_pte_fault+0x70/0x898)
[ 8496.061045] [<c00f9480>] (handle_pte_fault+0x70/0x898) from [<c00f9d7c>] (handle_mm_fault+0xd4/0x11c)
[ 8496.070404] [<c00f9d7c>] (handle_mm_fault+0xd4/0x11c) from [<c001b29c>] (do_page_fault+0x250/0x3a4)
[ 8496.079739] [<c001b29c>] (do_page_fault+0x250/0x3a4) from [<c0008568>] (do_PrefetchAbort+0x34/0x98)
[ 8496.088816] [<c0008568>] (do_PrefetchAbort+0x34/0x98) from [<c000f294>] (ret_from_exception+0x0/0x10)
*** memleak
kmalloc
        kmalloc_index
        __kmalloc
                __do_kmalloc
                        kmalloc_slab
                        slab_alloc
                                __do_cache_alloc
                                        kmemleak_alloc_recursive
                                                kmemleak_alloc
                                                        create_object

                                        kmemcheck_slab_alloc
                        //trace_kmalloc


kmemleak_scan_thread
        kmemleak_scan
                scan_block

proc_stat_init
        proc_create("stat", 0, NULL, &proc_stat_operations);
        stat_open
                single_open(file, show_stat, NULL)
                        show_stat
                                get_iowait_time
                                        get_cpu_iowait_time_us


setup_vmstat
        proc_create("buddyinfo", S_IRUGO, NULL, &fragmentation_file_operations);
        proc_create("pagetypeinfo", S_IRUGO, NULL, &pagetypeinfo_file_ops);
        proc_create("vmstat", S_IRUGO, NULL, &proc_vmstat_file_operations);
        proc_create("zoneinfo", S_IRUGO, NULL, &proc_zoneinfo_file_operations);
vmstat_op
*** ion
liger_reserve
        asoc_pdev_ion_data.heaps[0].base = asoc_ion0_start;
        asoc_pdev_ion_data.heaps[0].size = asoc_ion0_size;
        asoc_pdev_ion_data.heaps[1].base = asoc_ion1_start;
        asoc_pdev_ion_data.heaps[1].size = asoc_ion1_size;
struct dma_map_ops arm_dma_ops = {
        .alloc			= arm_dma_alloc,
        .free			= arm_dma_free,
        .mmap			= arm_dma_mmap,
        .get_sgtable		= arm_dma_get_sgtable,
        .map_page		= arm_dma_map_page,
        .unmap_page		= arm_dma_unmap_page,
        .map_sg			= arm_dma_map_sg,
        .unmap_sg		= arm_dma_unmap_sg,
        .sync_single_for_cpu	= arm_dma_sync_single_for_cpu,
        .sync_single_for_device	= arm_dma_sync_single_for_device,
        .sync_sg_for_cpu	= arm_dma_sync_sg_for_cpu,
        .sync_sg_for_device	= arm_dma_sync_sg_for_device,
        .set_dma_mask		= arm_dma_set_mask,
};
static struct ion_heap_ops ion_cma_ops = {
        .allocate = ion_cma_allocate,
        .free = ion_cma_free,
        .map_dma = ion_cma_heap_map_dma,
        .unmap_dma = ion_cma_heap_unmap_dma,
        .phys = ion_cma_phys,
        .map_user = ion_cma_mmap,
        .map_kernel = ion_cma_map_kernel,
        .unmap_kernel = ion_cma_unmap_kernel,
};

ion_ioctl
        ion_alloc
                ion_buffer_create
                        ion_cma_allocate //heap->ops->allocate
                                dma_alloc_coherent
                        buffer->sg_table = table;
                        buffer->pages[k++] = page++;
                        ion_buffer_add
                ion_handle_create
                ion_handle_add

static struct dma_buf_ops dma_buf_ops = {
        .map_dma_buf = ion_map_dma_buf,
        .unmap_dma_buf = ion_unmap_dma_buf,
        .mmap = ion_mmap,
        .release = ion_dma_buf_release,
        .begin_cpu_access = ion_dma_buf_begin_cpu_access,
        .end_cpu_access = ion_dma_buf_end_cpu_access,
        .kmap_atomic = ion_dma_buf_kmap,
        .kunmap_atomic = ion_dma_buf_kunmap,
        .kmap = ion_dma_buf_kmap,
        .kunmap = ion_dma_buf_kunmap,
};

ion_ioctl
        ion_share_dma_buf_fd//ION_IOC_SHARE
                ion_share_dma_buf
                        ion_buffer_get
                        dma_buf_export(buffer, &dma_buf_ops, buffer->size, O_RDWR)
                                dma_buf_export_named
                                        anon_inode_getfile("dmabuf", &dma_buf_fops, dmabuf, flags)
                                                path.dentry = d_alloc_pseudo(anon_inode_mnt->mnt_sb, &this)//anon_inode_mnt = kern_mount(&anon_inode_fs_type);
                                                alloc_file(&path, OPEN_FMODE(flags), dma_buf_fops);
                                                //.mmap		= dma_buf_mmap_internal,
                                        dmabuf->file = file;
                dma_buf_fd
                        get_unused_fd_flags(flags);
                        fd_install(fd, dmabuf->file);

ion_ioctl
        ion_import_dma_buf//ION_IOC_IMPORT
                dmabuf = dma_buf_get(fd)
                        file->private_data
                buffer = dmabuf->priv;
                handle = ion_handle_create(client, buffer);
                ion_handle_add(client, handle);

dma_buf_mmap_internal //dma_buf_fops
        ion_mmap//dmabuf->ops->mmap   dma_buf_ops
                ion_cma_mmap // buffer->heap->ops->map_user ion_cma_ops
                        dma_mmap_coherent
                                dma_mmap_attrs
                                        arm_dma_mmap //arm_dma_ops
                                                vma->vm_page_prot = __get_dma_pgprot(attrs, vma->vm_page_prot)
                                                remap_pfn_range
asoc_ion_driver
        asoc_ion_probe
                ion_device_create(asoc_ion_ioctl);
                        idev->dev.fops = &ion_fops;
                        misc_register
                        idev->custom_ioctl = asoc_ion_ioctl;
                ion_heap_create
                        ion_carveout_heap_create
                                ion_pages_sync_for_device
                                        dma_sync_sg_for_device //arm_dma_ops
                                                arm_dma_sync_sg_for_device
                                                        arm_dma_sync_single_for_device
                                gen_pool_create
                                        pool->algo = gen_pool_first_fit;
                                gen_pool_add(carveout_heap->pool, carveout_heap->base, heap_data->size,
                                carveout_heap->heap.ops = &carveout_heap_ops;
                                        //ion_carveout_heap_allocate
                                                //ion_carveout_allocate
                                                        //gen_pool_alloc
                                                                //gen_pool_first_fit
                                carveout_heap->pool = gen_pool_create(12, -1);
                        ion_system_contig_heap_create
                        ion_system_heap_create
                        ion_cma_heap_create
                                cma_heap->heap.ops = &ion_cma_ops;
                                        //ion_cma_allocate
                                                //dma_alloc_coherent
                ion_device_add_heap
                        plist_add(&heap->node, &dev->heaps);

dma_alloc_noncoherent
dma_alloc_coherent
        dma_alloc_attrs
                arm_dma_alloc
                        __dma_alloc
                                __alloc_from_contiguous
                                        dma_alloc_from_contiguous
                                                alloc_contig_range(pfn, pfn + count, MIGRATE_CMA);
                                                        start_isolate_page_range
                                                                set_migratetype_isolate
                                                                        set_pageblock_migratetype(page, MIGRATE_ISOLATE);
                                                                        nr_pages = move_freepages_block(zone, page, MIGRATE_ISOLATE);
                                                                        __mod_zone_freepage_state(zone, -nr_pages, migratetype);
                                                        __alloc_contig_migrate_range
                                                                isolate_migratepages_range
                                                                        __isolate_lru_page
                                                                        del_page_from_lru_list(page, lruvec, page_lru(page));
                                                                        list_add(&page->lru, migratelist);
                                                                        //trace_mm_compaction_isolate_migratepages
                                                                reclaim_clean_pages_from_list
                                                                        shrink_page_list(&clean_pages,
                                                                migrate_pages(&cc->migratepages, alloc_migrate_target,0, MIGRATE_SYNC, MR_CMA);
                                                                        unmap_and_move(get_new_page, private,page, pass > 2, mode);
                                                                                alloc_migrate_target
                                                                                __unmap_and_move
                                                                        //trace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);
                                __dma_clear_buffer
                                __dma_remap(page, size, prot);
                                        apply_to_page_range(&init_mm, start, size, __dma_update_fpte, &prot);
                                page_address(page);


dma_contiguous_set_global_reserve_size

core_initcall(cma_init_reserved_areas);
cma_init_reserved_areas
        cma_create_area
                cma->base_pfn = base_pfn;
                cma->count = count;
                cma->bitmap = kzalloc(bitmap_size, GFP_KERNEL);
                cma_activate_area
                        init_cma_reserved_pageblock
                                __ClearPageReserved(p);
                                set_page_refcounted(page);
                                set_pageblock_migratetype(page, MIGRATE_CMA);
                                __free_pages(page, pageblock_order);
        dev_set_cma_area
                dma_contiguous_default_area = cma;
/*
  static int __init foo_set_up_cma_areas(void)
    {
        struct cma *cma;

        cma = dev_get_cma_area(device1);
        dev_set_cma_area(device2, cma);
        return 0;
    }
    postcore_initcall(foo_set_up_cma_areas);
*/

start_kernel
        setup_arch
                arm_memblock_init
                        dma_contiguous_reserve //CONFIG_CMA_SIZE_MBYTES
                                dma_declare_contiguous
                                        __memblock_alloc_base
                                                memblock_reserve




__page_set_anon_rmap
        page->mapping = (struct address_space *) anon_vma;
        page->index = linear_page_index(vma, address);



sys_remap_file_pages // VM_NONLINEAR
        find_vma
        vma->vm_flags |= VM_NONLINEAR;
        vma_interval_tree_remove(vma, &mapping->i_mmap);
        vma_nonlinear_insert(vma, &mapping->i_mmap_nonlinear);
        mmu_notifier_invalidate_range_start(mm, start, start + size);
        err = vma->vm_ops->remap_pages(vma, start, size, pgoff);
        mmu_notifier_invalidate_range_end(mm, start, start + size);
*** alloc_pages
buffered_rmqueue
        list = &pcp->lists[migratetype]; // order == 0
        page = list_entry(list->prev, struct page, lru);
        __rmqueue
                __rmqueue_smallest
                        &area->free_list[migratetype]
                        rmv_page_order
                                __ClearPageBuddy
                                set_page_private(page, 0);
                        expand
                                set_page_order
                                        set_page_private(page, order);
                                        __SetPageBuddy(page);
                __rmqueue_fallback
                        migratetype = fallbacks[start_migratetype][i]
                        move_freepages_block
                        set_pageblock_migratetype
                        expand
                migratetype = MIGRATE_RESERVE;
                        goto retry_reserve;
                        //trace_mm_page_alloc_extfrag
        //trace_mm_page_alloc_zone_locked
        prep_new_page
                check_new_page
                set_page_private(page, 0);
                set_page_refcounted(page);

alloc_pages
        __alloc_pages_nodemask
                gfp_zone
                allocflags_to_migratetype
                first_zones_zonelist
                alloc_flags |= ALLOC_CMA;
                get_page_from_freelist
                        zone_watermark_ok
                                __zone_watermark_ok// min_free_order_shift
                                buffered_rmqueue
                                        //trace_mm_page_alloc_zone_locked
                __alloc_pages_slowpath
                        wake_all_kswapd
                                wakeup_kswapd
                                        //trace_mm_vmscan_wakeup_kswapd
                        gfp_to_alloc_flags
                        get_page_from_freelist //~ALLOC_NO_WATERMARKS last chance
                        __alloc_pages_high_priority
                                get_page_from_freelist //ALLOC_NO_WATERMARKS
                                wait_iff_congested //__GFP_NOFAIL
                                //trace_writeback_wait_iff_congested
                        __alloc_pages_direct_compact
                        __alloc_pages_direct_reclaim
                                get_page_from_freelist
                                drain_all_pages
                                        drain_local_pages
                        __alloc_pages_may_oom
                                get_page_from_freelist //ALLOC_WMARK_HIGH|ALLOC_CPUSET
                                        out_of_memory(zonelist, gfp_mask, order, nodemask, false);

                        if (should_alloc_retry(gfp_mask, order, did_some_progress,pages_reclaimed)) {
                                        wait_iff_congested(preferred_zone, BLK_RW_ASYNC, HZ/50);
                                        //trace_writeback_wait_iff_congested
                                        goto rebalance;
                //trace_mm_page_alloc(page, order, gfp_mask, migratetype);
*** meminit
free_area_init_nodes
        find_zone_movable_pfns_for_nodes
                find_usable_zone_for_movable
                        movable_zone = zone_index;
                zone_movable_pfn[nid] = end_pfn;
        free_area_init_node

init_per_zone_wmark_min // module_init(init_per_zone_wmark_min)
        setup_per_zone_wmarks
                __setup_per_zone_wmarks
                        setup_zone_migrate_reserve
                                set_pageblock_migratetype(page,	MIGRATE_RESERVE);
                                move_freepages_block(zone, page,MIGRATE_RESERVE);

min_free_kbytes_sysctl_handler
        setup_per_zone_wmarks

free_area_init_core
        zone->present_pages = realsize;
        zone_pcp_init
                zone->pageset = &boot_pageset;
        lruvec_init(&zone->lruvec);
        set_pageblock_order();
        setup_usemap(pgdat, zone, zone_start_pfn, size);
                usemap_size
                zone->pageblock_flags = alloc_bootmem_node_nopanic
        init_currently_empty_zone(zone, zone_start_pfn,size, MEMMAP_EARLY);
                zone_wait_table_init
                zone->zone_start_pfn = zone_start_pfn
                zone_init_free_lists
                        zone->free_area[order].nr_free = 0;
        memmap_init
                memmap_init_zone // all page reserved & MIGRATE_MOVABLE
                        SetPageReserved(page);
                        set_pageblock_migratetype(page, MIGRATE_MOVABLE); //

start_kernel
        setup_arch
                setup_machine_fdt
                        for_each_machine_desc
                        of_scan_flat_dt(early_init_dt_scan_memory, NULL);
                                early_init_dt_add_memory_arch
                                        arm_add_memory
                arm_memblock_init(&meminfo, mdesc);
                        memblock_add(mi->bank[i].start, mi->bank[i].size);
                                memblock_add_region(&memblock.memory, base, size, MAX_NUMNODES);
                        memblock_reserve(__pa(_stext), _end - _stext);
                        arm_mm_memblock_reserve();
                        arm_dt_memblock_reserve();	//4M
                        if (mdesc->reserve)
                                mdesc->reserve();
                sanity_check_meminfo
                        high_memory = __va(arm_lowmem_limit - 1) + 1;
                paging_init
                        early_alloc
                                memblock_alloc
                        prepare_page_table
                        map_lowmem
                                for_each_memblock(memory, reg)
                                        create_mapping
                                                alloc_init_pud(pgd, addr, next, phys, type, force_pages);
                        dma_contiguous_remap
                        devicemaps_init
                        bootmem_init
                                find_limits
                                arm_bootmem_init
                                        bitmap = memblock_alloc_base
                                                memblock_reserve
                                        init_bootmem_node
                                                init_bootmem_core
                                                        bdata->node_bootmem_map = phys_to_virt(PFN_PHYS(mapstart));//bitmap
                                                        memset(bdata->node_bootmem_map, 0xff, mapsize);
                                        free_bootmem
                                                mark_bootmem
                                                        mark_bootmem_node
                                                                __free
                                                                        test_and_clear_bit(idx, bdata->node_bootmem_map)
                                        reserve_bootmem
                                arm_bootmem_free
                                        zone_size[0] = max_low - min;
                                        free_area_init_node
                                                alloc_node_mem_map(pgdat);
                                                        pgdat->node_mem_map = map + (pgdat->node_start_pfn - start);
                                                free_area_init_core
                unflatten_device_tree();
                arm_dt_init_cpu_maps();

        setup_per_cpu_areas

        build_all_zonelists
                __build_all_zonelists
                        build_zonelists(pgdat);
                                build_zonelists_node
                                        zoneref_set_zone
                                                zoneref->zone_idx = zone_idx(zone);
                        build_zonelist_cache(pgdat);
                        for_each_possible_cpu(cpu) {
                                setup_pageset(&per_cpu(boot_pageset, cpu), 0);

        mm_init
                page_cgroup_init_flatmem();
                mem_init();
                        free_all_bootmem();
                                free_all_bootmem_core
                                        reset_node_lowmem_managed_pages(pgdat)
                                                //z->managed_pages = 0;
                                        __free_pages_bootmem
                                                page_zone(page)->managed_pages += 1 << order;
                                                __ClearPageReserved(p);
                                                __free_pages
                                                        free_hot_cold_page
                kmem_cache_init();
                percpu_init_late();
                pgtable_cache_init();
                vmalloc_init();

        setup_per_cpu_pageset
                setup_zone_pageset
                        setup_pageset(pcp, zone_batchsize(zone));

        rest_init
                kernel_init
                        free_initmem
                                poison_init_mem
                                free_initmem_default
                                        __free_page
                                                __free_pages_ok(page, order);
                                                        set_freepage_migratetype(page, migratetype);
                                                        free_one_page(page_zone(page), page, order, migratetype);
                                                                __free_one_page
                                                                        __mod_zone_freepage_state
                                                                                __mod_zone_page_state(zone, NR_FREE_PAGES,
                                                                                __mod_zone_page_state(zone, NR_FREE_CMA_PAGES
                                                                        list_add(&page->lru, &zone->free_area[order].free_list[migratetype]);

                        do_basic_setup();
                                cpuset_init_smp();
                                usermodehelper_init();
                                shmem_init();
                                driver_init();
                                init_irq_proc();
                                do_ctors();
                                usermodehelper_enable();
                                do_initcalls();
                                        do_initcall_level(level);
                                /*
                                        static char *initcall_level_names[] __initdata = {
                                                        "early",
                                                        "core",
                                                        "postcore",
                                                        "arch",
                                                        "subsys",
                                                        "fs",
                                                        "device",
                                                        "late",
                                                };
                                */
                                random_int_secret_init();
*** shrink
mpage_da_submit_io
        pagevec_release
                __pagevec_release
                        lru_add_drain
                        release_pages

lru_add_drain
        lru_add_drain_cpu
                pagevec_lru_move_fn(pvec, lru_deactivate_fn, NULL);
                        lru_deactivate_fn
                                ClearPageActive
                                ClearPageReferenced
                        release_pages
                                __ClearPageLRU
                                put_page_testzero
                                del_page_from_lru_list
                                list_add(&page->lru, &pages_to_free)
                                free_hot_cold_page_list
                                        //trace_mm_page_free_batched
                                        free_hot_cold_page

free_hot_cold_page
        free_pages_prepare
                //trace_mm_page_free
        get_pageblock_migratetype(page);
        list_add_tail(&page->lru, &pcp->lists[migratetype]);
        if (pcp->count >= pcp->high) {
                free_pcppages_bulk(zone, pcp->batch, pcp);
                        __free_one_page //buddy system
                        //trace_mm_page_pcpu_drain(page, 0, mt);
end_page_writeback
        TestClearPageReclaim
                rotate_reclaimable_page
                        pvec = &__get_cpu_var(lru_rotate_pvecs);
                        pagevec_add(pvec, page)

page_referenced
mark_page_accessed

alloc_pages_vma
        __alloc_pages_nodemask
                __alloc_pages_slowpath
                        __alloc_pages_direct_reclaim
                                __perform_reclaim
                                        try_to_free_pages


filemap_fault //ext4_file_vm_ops = {
        do_sync_mmap_readahead(vma, ra, file, offset);
                ra_submit(ra, mapping, file);
                        __do_page_cache_readahead
                                page_cache_alloc_readahead(mapping);
                                        __page_cache_alloc
                                                alloc_pages
                                read_pages(mapping, filp, &page_pool, ret);
                                        mapping->a_ops->readpages(filp, mapping, pages, nr_pages);
                                                ext4_readpages //ext4_da_aops
                                                        mpage_readpages(mapping, pages, nr_pages, ext4_get_block);
                                                                add_to_page_cache_lru
                                                                //trace_mm_filemap_add_to_page_cache(page);
                                                                mpage_bio_submit(READ, bio);
                                                                        bio->bi_end_io = mpage_end_io;
                                                                        submit_bio(rw, bio);
        page_cache_read
                add_to_page_cache_lru
                        add_to_page_cache
                                add_to_page_cache_locked
                                        //trace_mm_filemap_add_to_page_cache
                mapping->a_ops->readpage(file, page); //ext4_da_aops
                        ext4_readpage
                                //trace_ext4_readpage
                                mpage_readpage
                                        do_mpage_readpage
                                        mpage_bio_submit(READ, bio);
                                                submit_bio(rw, bio);


do_page_fault
        __do_page_fault
                handle_mm_fault
                        //count_vm_event(PGFAULT);
                        handle_pte_fault
                                do_linear_fault
                                        __do_fault
                                                alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);
                                                        __alloc_pages_nodemask
                                                        //count_vm_event(PGMAJFAULT);
                                                ret = vma->vm_ops->fault(vma, &vmf);
                                                        filemap_fault //ext4_file_vm_ops

                                                        //count_vm_event(PGMAJFAULT);
                                do_anonymous_page
                                        alloc_zeroed_user_highpage_movable(vma, address);
                                                __alloc_zeroed_user_highpage(__GFP_MOVABLE, vma, vaddr);
                                                        alloc_page_vma(GFP_HIGHUSER | movableflags,	vma, vaddr);
                                                                __alloc_pages_nodemask
                                                                        //trace_mm_page_alloc(page, order, gfp_mask, migratetype);
                                do_nonlinear_fault
                                do_swap_page
                                        //count_vm_event(PGMAJFAULT);

pageout

do_wp_page
        page_add_new_anon_rmap
                __page_set_anon_rmap
                        page->mapping = (struct address_space *) anon_vma;
                        page->index = linear_page_index(vma, address);

page_check_references
        page_referenced
                page_rmapping
                page_referenced_ksm
                page_referenced_anon
                        page_lock_anon_vma_read
                        vma_address
                        page_referenced_one
        pin	page_referenced_file
        TestClearPageReferenced

free_hot_cold_page
        get_pageblock_migratetype
                get_pageblock_flags_group
                        zone->pageblock_flags;
        set_freepage_migratetype
                page->index = migratetype;
                if (cold)
                        list_add_tail(&page->lru, &pcp->lists[migratetype]);
                else
                        list_add(&page->lru, &pcp->lists[migratetype]);
                if (pcp->count >= pcp->high) {
                        free_pcppages_bulk(zone, pcp->batch, pcp);
                                mt = get_freepage_migratetype(page);
                                __free_one_page(page, zone, 0, mt);
                                        list_add(&page->lru, &zone->free_area[order].free_list[migratetype]);
                                //trace_mm_page_pcpu_drain(page, 0, mt);
                        pcp->count -= pcp->batch;
                }


shrink_inactive_list(nr_to_scan, lruvec, sc, lru)
        while (unlikely(too_many_isolated(zone, file, sc))) {
                        congestion_wait(BLK_RW_ASYNC, HZ/10);
                                //trace_writeback_congestion_wait
        lru_add_drain
        nr_taken = isolate_lru_pages(nr_to_scan, lruvec, &page_list, &nr_scanned, sc, isolate_mode, lru);
                __isolate_lru_page
                        get_page_unless_zero
                        ClearPageLRU(page);
                //trace_mm_vmscan_lru_isolate(sc->order, nr_to_scan, scan,nr_taken, mode, is_file_lru(lru));
        shrink_page_list(&page_list, zone, sc, TTU_UNMAP, &nr_dirty, &nr_writeback, false);
                SetPageReclaim //o PageWriteback
                wait_on_page_writeback

                page_check_references
                        page_referenced
                                TestClearPageReferenced
                                SetPageReferenced//o referenced_ptes

                try_to_unmap //page_mapped

                SetPageReclaim//PageDirty
                pageout(page, mapping, sc)
                        is_page_cache_freeable
                        clear_page_dirty_for_io
                        SetPageReclaim
                        mapping->a_ops->writepage(page, &wbc); //ext4_da_aops
                                ext4_writepage
                                        //trace_ext4_writepage(page);
                        //trace_mm_vmscan_writepage(page, trace_reclaim_flags(page));
                __remove_mapping(mapping, page)
                        __delete_from_page_cache
                                //trace_mm_filemap_delete_from_page_cache
                __clear_page_locked
                list_add(&page->lru, &free_pages);
                free_hot_cold_page_list(&free_pages, 1);
                        //trace_mm_page_free_batched
                        free_hot_cold_page
                wait_iff_congested
                        //trace_writeback_wait_iff_congested
        //trace_mm_vmscan_lru_shrink_inactive

shrink_lruvec
        get_scan_count
                size = get_lru_size(lruvec, lru);
                scan = size >> sc->priority; // nr_inactive_file
        nr_reclaimed += shrink_list(lru, nr_to_scan,lruvec, sc)
                shrink_active_list
                shrink_inactive_list(nr_to_scan, lruvec, sc, lru)
        throttle_vm_writeout(sc->gfp_mask);
                global_dirty_limits
                        //trace_global_dirty_state(background, dirty);
                if (global_page_state(NR_WRITEBACK) <= dirty_thresh)
                break;
                congestion_wait(BLK_RW_ASYNC, HZ/10);
                        //trace_writeback_congestion_wait


alloc_pages
        __alloc_pages_nodemask
                get_page_from_freelist
                        zone_watermark_ok
                                __zone_watermark_ok// min_free_order_shift
                __alloc_pages_slowpath
                        wake_all_kswapd
                                wakeup_kswapd
                                        //trace_mm_vmscan_wakeup_kswapd

try_to_free_pages
        //trace_mm_vmscan_direct_reclaim_begin
        do_try_to_free_pages
                shrink_zones
                        shrink_zone
                wait_iff_congested
                        //trace_writeback_wait_iff_congested
        //trace_mm_vmscan_direct_reclaim_end


kswapd
        kswapd_try_to_sleep
                prepare_kswapd_sleep
                        pgdat_balanced
                                zone_balanced
                                        zone_watermark_ok_safe
                                                __zone_watermark_ok
                //trace_mm_vmscan_kswapd_sleep
        //trace_mm_vmscan_kswapd_wake
        balance_pgdat(pg_data_t * pgdat, int order, int * classzone_idx)
                age_active_anon(zone, &sc);
                zone_balanced(zone, order, 0, 0)
                        zone_watermark_ok_safe(zone, order, high_wmark_pages(zone) + 0
                                zone_page_state_snapshot
                                __zone_watermark_ok
                lru_pages += zone_reclaimable_pages(zone);
                        zone_page_state(zone, NR_ACTIVE_FILE) + zone_page_state(zone, NR_INACTIVE_FILE);
                nr_soft_reclaimed = mem_cgroup_soft_limit_reclaim
                balance_gap = min(low_wmark_pages(zone),zone->managed_pages /KSWAPD_ZONE_BALANCE_GAP_RATIO
                zone_balanced(zone, testorder,balance_gap, end_zone)
                        zone_watermark_ok_safe(zone, order, high_wmark_pages(zone) + balance_gap,
                shrink_zone(zone, &sc);
                        mem_cgroup_zone_lruvec
                        shrink_lruvec
                nr_slab = shrink_slab(&shrink, sc.nr_scanned, lru_pages);
                        //trace_mm_shrink_slab_start
                        do_shrinker_shrink
                                sc->nr_to_scan = nr_to_scan;
                                return (*shrinker->shrink)(shrinker, sc);
                                        lowmem_shrink
                        //trace_mm_shrink_slab_end
                pgdat_balanced(pgdat, order, *classzone_idx)
                        zone_balanced(zone, order, 0, i)
                } while (--sc.priority >= 0);
*** dts
setup_arch
        setup_machine_fdt
                for_each_machine_desc
                of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
                of_scan_flat_dt(early_init_dt_scan_memory, NULL);
                early_init_dt_add_memory_arch
        unflatten_device_tree
        mdesc->init_early()
        arm_dt_init_cpu_maps

IRQCHIP_DECLARE(cortex_a9_gic, "arm,cortex-a9-gic", gic_of_init);
init_IRQ
        irqchip_init
                of_irq_init(__irqchip_begin)
                        gic_of_init
                                of_iomap
                                of_property_read_u32

customize_machine
        of_platform_populate
                of_platform_bus_create

customize_machine
        .init_machine	= tegra_dt_init,
                of_platform_populate
*** pinctrl
devm_pinctrl_get_select

devm_pinctrl_get
        pinctrl_get
                create_pinctrl
pinctrl_lookup_state
pinctrl_select_state

pinctrl_register_mappings

pinctrl_register
        pinctrl_register_pins

of_gpiochip_add_pin_range
        gpiochip_add_pin_range
                pinctrl_find_and_add_gpio_range
                        pinctrl_add_gpio_range

pinctrl_gpio_range
pinctrl_add_gpio_range
pin_config_set


filemap_fdatawait_range(struct address_space * mapping, loff_t start_byte, loff_t end_byte)(struct address_space * mapping, loff_t start_byte, loff_t end_byte)

ext4_da_write_begin
writeback_dirty_page
generic_write_end
__ext4_journal_get_write_access

journal_start
journal_stop


ext2_super_block
EXT2_VALID_FS

ext2_get_block
ext2_get_blocks
*** blk cgroup
CONFIG_BLK_DEV_INTEGRITY
#define BLK_MAX_REQUEST_COUNT 16//4

CONFIG_BLK_CGROUP=y
CONFIG_DEBUG_BLK_CGROUP=y
CONFIG_CFQ_GROUP_IOSCHED=y
CONFIG_BLK_DEV_THROTTLING=y
CONFIG_BLK_DEV_IO_TRACE=y

CONFIG_PM_RUNTIME
CONFIG_BLK_CGROUP
CONFIG_CFQ_GROUP_IOSCHED
CONFIG_BLK_DEV_THROTTLING
CONFIG_BLK_DEV_IO_TRACE

cfq_group_served
        cfq_log_cfqq(cfqq->cfqd, cfqq,"sl_used=%u disp=%u charge=%u iops=%u sect=%lu",
cfq_set_prio_slice
        cfq_log_cfqq(cfqd, cfqq, "set_slice=%lu", cfqq->slice_end - jiffies);
cfq_add_cfqq_rr
        cfq_log_cfqq(cfqd, cfqq, "add_to_rr");
cfq_del_cfqq_rr
        cfq_log_cfqq(cfqd, cfqq, "del_from_rr");
cfq_activate_request
        cfq_log_cfqq(cfqd, RQ_CFQQ(rq), "activate rq, drv=%d",
                                                cfqd->rq_in_driver);
cfq_deactivate_request
        cfq_log_cfqq(cfqd, RQ_CFQQ(rq), "deactivate rq, drv=%d",
                                                cfqd->rq_in_driver);
__cfq_set_active_queue
        cfq_log_cfqq(cfqd, cfqq, "set_active wl_class:%d wl_type:%d",
                                cfqd->serving_wl_class, cfqd->serving_wl_type);
__cfq_slice_expired
        cfq_log_cfqq(cfqd, cfqq, "slice expired t=%d", timed_out);
        cfq_log_cfqq(cfqd, cfqq, "resid=%ld", cfqq->slice_resid);
cfq_should_idle
        cfq_log_cfqq(cfqd, cfqq, "Not idling. st->count:%d", st->count);
cfq_arm_slice_timer
        cfq_log_cfqq(cfqd, cfqq, "Not idling. think_time:%lu",
                             cic->ttime.ttime_mean);
        cfq_log_cfqq(cfqd, cfqq, "arm_idle: %lu group_idle: %d", sl,
                        group_idle ? 1 : 0);
cfq_dispatch_insert
        cfq_log_cfqq(cfqd, cfqq, "dispatch_insert");
cfq_check_fifo
        cfq_log_cfqq(cfqq->cfqd, cfqq, "fifo=%p", rq);
cfq_dispatch_requests
        cfq_log_cfqq(cfqd, cfqq, "dispatched a request");
cfq_put_queue
        cfq_log_cfqq(cfqd, cfqq, "put_queue");
check_blkcg_changed
        cfq_log_cfqq(cfqd, sync_cfqq, "changed cgroup");
cfq_find_alloc_queue
        cfq_log_cfqq(cfqd, cfqq, "alloced");
cfq_update_idle_window
        cfq_log_cfqq(cfqd, cfqq, "idle=%d", enable_idle);
cfq_preempt_queue
        cfq_log_cfqq(cfqd, cfqq, "preempt");
cfq_insert_request
        cfq_log_cfqq(cfqd, cfqq, "insert_request");
cfq_completed_request
        cfq_log_cfqq(cfqd, cfqq, "complete rqnoidle %d",
                     !!(rq->cmd_flags & REQ_NOIDLE));
cfq_completed_request
        cfq_log_cfqq(cfqd, cfqq, "complete rqnoidle %d",
                     !!(rq->cmd_flags & REQ_NOIDLE));
        cfq_log_cfqq(cfqd, cfqq, "will busy wait");
cfq_merge_cfqqs
        cfq_log_cfqq(cfqd, cfqq, "merging with queue %p", cfqq->new_cfqq);
cfq_set_request
        cfq_log_cfqq(cfqd, cfqq, "breaking apart cfqq");
choose_wl_class_and_type
        cfq_log(cfqd, "workload slice:%d", slice);

blk_register_tracepoints
        register_trace_block_getrq(blk_add_trace_getrq, NULL);

static struct tracer blk_tracer __read_mostly = {
        .name		= "blk",
        .init		= blk_tracer_init,
        .reset		= blk_tracer_reset,
        .start		= blk_tracer_start,
        .stop		= blk_tracer_stop,
        .print_header	= blk_tracer_print_header,
        .print_line	= blk_tracer_print_line,
        .flags		= &blk_tracer_flags,
        .set_flag	= blk_tracer_set_flag,
};
blk_tracer_print_line
        print_one_line
                blk_log_action

cfq_log_cfqq
        blk_add_trace_msg
                __trace_note_message
                        trace_note

} what2act[] = {
        [__BLK_TA_QUEUE]	= {{  "Q", "queue" },      blk_log_generic },
        [__BLK_TA_BACKMERGE]	= {{  "M", "backmerge" },  blk_log_generic },
        [__BLK_TA_FRONTMERGE]	= {{  "F", "frontmerge" }, blk_log_generic },
        [__BLK_TA_GETRQ]	= {{  "G", "getrq" },      blk_log_generic },
        [__BLK_TA_SLEEPRQ]	= {{  "S", "sleeprq" },    blk_log_generic },
        [__BLK_TA_REQUEUE]	= {{  "R", "requeue" },    blk_log_with_error },
        [__BLK_TA_ISSUE]	= {{  "D", "issue" },      blk_log_generic },
        [__BLK_TA_COMPLETE]	= {{  "C", "complete" },   blk_log_with_error },
        [__BLK_TA_PLUG]		= {{  "P", "plug" },       blk_log_plug },
        [__BLK_TA_UNPLUG_IO]	= {{  "U", "unplug_io" },  blk_log_unplug },
        [__BLK_TA_UNPLUG_TIMER]	= {{ "UT", "unplug_timer" }, blk_log_unplug },
        [__BLK_TA_INSERT]	= {{  "I", "insert" },     blk_log_generic },
        [__BLK_TA_SPLIT]	= {{  "X", "split" },      blk_log_split },
        [__BLK_TA_BOUNCE]	= {{  "B", "bounce" },     blk_log_generic },
        [__BLK_TA_REMAP]	= {{  "A", "remap" },      blk_log_remap },
};

struct cfq_group {
        /* must be the first member */
        struct blkg_policy_data pd;  // embed in cfg_group
        //blkcg_gq  ref  blkg_policy_data
        //blkcg_gq  link  request_queue and blkcg
struct blkcg {
        struct cgroup_subsys_state	css;// kernel cgroup

struct bio {

#ifdef CONFIG_BLK_CGROUP
        struct io_context	*bi_ioc; // ionice
        struct cgroup_subsys_state *bi_css //cgroup

struct cfq_io_cq {
        struct io_cq		icq;		/* must be the first member */
        struct cfq_queue	*cfqq[2];
struct io_cq {
        struct request_queue	*q;
        struct io_context	*ioc;
struct request {
        union {
                struct {
                        struct io_cq		*icq;
                        void			*priv[2];
                } elv;

struct throtl_data
{
        /* service tree for active throtl groups */
        struct throtl_rb_root tg_service_tree;
        /* Total Number of queued bios on READ and WRITE lists */
        unsigned int nr_queued[2];

struct throtl_grp {
        /* must be the first member */
        struct blkg_policy_data pd;
        /* active throtl group service_tree member */
        struct rb_node rb_node;

generic_make_request_checks
        blk_throtl_bio
                throtl_lookup_tg
                        blkg_lookup
                        blkg_to_tg
                throtl_lookup_create_tg
                tg_may_dispatch
                throtl_add_bio_tg
                        throtl_enqueue_tg
                                __throtl_enqueue_tg
                                        tg_service_tree_add
                throtl_schedule_next_dispatch
                        throtl_schedule_delayed_work //blk_throtl_work

blk_throtl_work
        throtl_dispatch
                throtl_select_dispatch
                        blk_start_plug
                                generic_make_request
                        blk_finish_plug
*** blk cfq
get_resultsquest
        __get_request
                //trace_block_getrq
                        blk_add_trace_getrq
                                __blk_add_trace

get_request
        blk_get_rl
                bio_blkcg
                        task_blkcg(current);
                                 container_of(task_subsys_state(tsk, blkio_subsys_id),
                                        task_subsys_state_check
                blkg_lookup_create
                        __blkg_lookup
                        blkcg_parent
                                 //blkcg->css.cgroup->parent;
                        blkg_create
                                blkg_alloc // create blkcg_gq
                                // pd_init_fn
                                cfq_pd_init // create cfq_group
                //return &blkg->rl;
        __get_request
                queue_congestion_on_threshold// q->nr_congestion_on = q->nr_requests - (q->nr_requests / 8) + 1;
                blk_rl_full                              // nr_requests =128 , then  q->nr_congestion_on=113
                ioc_set_batching
                blk_set_rl_full
                blk_rq_should_init_elevator
                ioc_lookup_icq//
                mempool_alloc
                blk_rq_init
                blk_rq_set_rl
                        ioc_create_icq//o
                                kmem_cache_alloc_node(et->icq_cache
                                radix_tree_insert(&ioc->icq_tree
                                //et->ops.elevator_init_icq_fn
                                cfq_init_icq
                                        //cic->ttime.last_end_request = jiffies;
                //rq->elv.icq = icq;
                elv_set_request
                        //e->type->ops.elevator_set_req_fn
                        cfq_set_request
                                check_ioprio_changed
                                        //cfq_mark_cfqq_prio_changed
                                check_blkcg_changed
                                cic_to_cfqq(cic, is_sync);
                                        return cic->cfqq[is_sync]; // sync �� async�ǲ�ͬ����
                                cfq_get_queue//o
                                        cfq_async_queue_prio//async
                                                return &cfqd->async_cfqq[0][ioprio]; //IOPRIO_CLASS_RT
                                                return &cfqd->async_cfqq[1][ioprio]; //IOPRIO_CLASS_BE
                                                return &cfqd->async_idle_cfqq; //IOPRIO_CLASS_IDLE
                                        cfq_find_alloc_queue // syncÿ�����һ�����У� cgroup����async
                                                bio_blkcg
                                                cfq_lookup_create_cfqg
                                                kmem_cache_alloc_node(cfq_pool,
                                                cfq_init_cfqq(cfqd, cfqq, current->pid, is_sync);
                                                cfq_init_prio_data(cfqq, cic);
                                                cfq_link_cfqq_cfqg(cfqq, cfqg);
                                                //cfq_log_cfqq(cfqd, cfqq, "alloced");
                                cic_set_cfqq//o
                                rq->elv.priv[0] = cfqq;
                                rq->elv.priv[1] = cfqq->cfqg;
                //trace_block_getrq(q, bio, rw_flags & 1);
        prepare_to_wait_exclusive
        //trace_block_sleeprq
        io_schedule
        ioc_set_batching


//q->elevator->type->ops.elevator_add_req_fn(q, rq);
cfq_insert_request

add_acct_request
        drive_stat_acct//account
                part_round_stats
                part_inc_in_flight
        __elv_add_request
                //trace_block_rq_insert
                elv_rqhash_add //ELEVATOR_INSERT_SORT
                //q->elevator->type->ops.elevator_add_req_fn(q, rq);
                cfq_insert_request
                        cfq_init_prio_data
                        rq_set_fifo_time
                        cfq_log_cfqq
                        list_add_tail(&rq->queuelist
                        cfq_add_rq_rb(rq);
                                elv_rb_add(&cfqq->sort_list, rq);
                                cfq_add_cfqq_rr
                                        cfq_resort_rr_list
                                                cfq_service_tree_add // add cfg_queue to cfg_group 's service tree
                                                    //rb_key = cfq_slice_offset(cfqd, cfqq) + jiffies
                                                    //higer prio cfqueue get small rb_key in cfq_group's service tree
                                                        //&cfqg->service_trees[class][type]; st_for(cfqq->cfqg, cfqq_class(cfqq), cfqq_type(cfqq));
                                                        cfqq->service_tree = st;
                                                        cfq_group_notify_queue_add
                                                                //st = &cfqd->grp_service_tree
                                                                cfq_group_service_tree_add // add cfg_group to cfgd's grp_service_tree
                                                                        cfq_update_group_weight(cfqg);
                                                                        __cfq_group_service_tree_add
                                                                                cfqg_key //cfqg->vdisktime - st->min_vdisktime;
                                                                        //vfr = vfr * pos->leaf_weight / pos->children_weight;
                                                cfq_prio_tree_add  // add cfg_queue to cfgd 's prio tree
                                                        //cfqq->p_root = &cfqd->prio_trees[cfqq->org_ioprio];
                                cfq_choose_req // choose the request that is closest to the head right now
                                cfq_prio_tree_add //o  cfqq->p_root = &cfqd->prio_trees[cfqq->org_ioprio];
                        cfqg_stats_update_io_add(RQ_CFQG(rq), cfqd->serving_group,
                                                 rq->cmd_flags);
                        cfq_rq_enqueued(cfqd, cfqq, rq);
                                        cfq_update_io_thinktime(cfqd, cfqq, cic);
                                        cfq_update_io_seektime(cfqd, cfqq, rq);
                                        cfq_update_idle_window(cfqd, cfqq, cic);
                                                // cfqd->cfq_slice_idle ==0  then cfq_cfqq_idle_window =0
                                        cfq_should_preempt
                                                cfq_preempt_queue

// ioc_batching  when request_list is congested, and bio had io_context ,
// then can use batching to get more  q->nr_batching  request

cfq_slice_expired
        __cfq_slice_expired
                cfq_group_served
                        // vdisktime determine cgroup position in grp_service_tree
                        vfr = cfqg->vfraction;
                        cfq_group_service_tree_del(st, cfqg);
                        cfqg->vdisktime += cfqg_scale_charge(charge, vfr);
                        cfq_group_service_tree_add(st, cfqg);
                cfq_resort_rr_list


    __rq_for_each_bio(
bio_for_each_segment
blk_queue_bio(struct request_queue * q, struct bio * bio)

blk_peek_request
        __elv_next_request
                q->prep_rq_fn//null
                //q->elevator->type->ops.elevator_dispatch_fn ��������û��reqʱ
                cfq_dispatch_requests
                        cfq_select_queue
                                cfq_close_cooperator
                                        cfqq_close
                                                root = &cfqd->prio_trees[cur_cfqq->org_ioprio];
                                                __cfqq = cfq_prio_tree_lookup(cfqd, root, sector, &parent, NULL);
                                cfq_slice_expired
                                        __cfq_slice_expired

                                cfq_choose_cfqg
                                        cfq_get_next_cfqg(cfqd);
                                                cfq_rb_first_group(cfqd->grp_service_tree)
                                        choose_wl_class_and_type
                                        //cfq_log(cfqd, "workload slice:%d", slice);
                                                cfq_choose_wl_type
                                                cfq_group_slice //cfqd->cfq_target_latency * cfqg->vfraction >> CFQ_SERVICE_SHIFT;
                                                                //async workload slice is scaled down according to the sync/async slice ratio.
                                cfq_set_active_queue
                                        __cfq_set_active_queue //cfq_mark_cfqq_slice_new(cfqq);
                                        //cfq_log_cfqq(cfqd, cfqq, "set_active wl_class:%d wl_type:%d",

                        cfq_dispatch_request
                                cfq_dispatch_insert
                                        cfq_find_next_rq
                                                cfq_choose_req
                                        cfq_remove_request
                                        elv_dispatch_sort
                                                //list_add(&rq->queuelist, entry);
                        cfq_slice_expired //expire an async queue immediately if it has used up its slice. idle queue always expire after 1 dispatch round.
                                __cfq_slice_expired

cfq_schedule_dispatch

__blk_end_request

blk_finish_request
        blk_delete_timer
        blk_account_io_done
        __blk_put_request
                elv_completed_request
                        //e->type->ops.elevator_completed_req_fn
                        cfq_completed_request
                                cfqg_stats_update_completion
                                RQ_CIC(rq)->ttime.last_end_request = now;
                                cfq_set_prio_slice //cfq_cfqq_slice_new
                                        //cfq_log_cfqq(cfqd, cfqq, "set_slice=%lu", cfqq->slice_end - jiffies);
                                        cfq_scaled_cfqq_slice // when low_latency ==0, slice determined by prio
                                                cfq_prio_to_slice
                                                cfq_group_slice //cfqd->cfq_target_latency * cfqg->vfraction >> CFQ_SERVICE_SHIFT
                                                //slice = max(slice * group_slice / expect_latency,  low_slice);
                                        cfqq->slice_start = jiffies;
                                        cfqq->slice_end = jiffies + slice;
                                        cfqq->allocated_slice = slice;
                                cfq_should_wait_busy //extend_sl = cfqd->cfq_group_idle;
                                cfq_arm_slice_timer //	cfq_idle_slice_timer
                                        cfq_idle_slice_timer
                                                cfq_slice_expired //cfq_slice_used
                                                        __cfq_slice_expired
                                cfq_schedule_dispatch
                blk_rq_rl
                blk_free_request(rl, req);
                freed_request(rl, flags);
                blk_put_rl(rl);
*** blk cgroup
cfq_blkcg_files
        cfq_set_weight
                __cfq_set_weight
                        //blkcg->cfq_weight

cgroup_subsys

struct cgroup_subsys blkio_subsys = {
        .name = "blkio",
        .css_alloc = blkcg_css_alloc,
        .css_offline = blkcg_css_offline,
        .css_free = blkcg_css_free,
        .can_attach = blkcg_can_attach,
        .subsys_id = blkio_subsys_id,
        .base_cftypes = blkcg_files,
        .module = THIS_MODULE,

        /*
         * blkio subsystem is utterly broken in terms of hierarchy support.
         * It treats all cgroups equally regardless of where they're
         * located in the hierarchy - all cgroups are treated as if they're
         * right below the root.  Fix it and remove the following.
         */
        .broken_hierarchy = true,
};

struct blkcg blkcg_root = { .cfq_weight = 2 * CFQ_WEIGHT_DEFAULT,
                            .cfq_leaf_weight = 2 * CFQ_WEIGHT_DEFAULT, };


static struct blkcg_policy blkcg_policy_throtl = {
        .pd_size		= sizeof(struct throtl_grp),
        .cftypes		= throtl_files,

        .pd_init_fn		= throtl_pd_init,
        .pd_exit_fn		= throtl_pd_exit,
        .pd_reset_stats_fn	= throtl_pd_reset_stats,
};
static struct blkcg_policy blkcg_policy_cfq = {
        .pd_size		= sizeof(struct cfq_group),
        .cftypes		= cfq_blkcg_files,

        .pd_init_fn		= cfq_pd_init,
        .pd_offline_fn		= cfq_pd_offline,
        .pd_reset_stats_fn	= cfq_pd_reset_stats,
};


cfq_init
        cfq_slice_idle
        blkcg_policy_register // blkcg_policy_cfq
                cgroup_add_cftypes
        elv_register

elevator_init
        //.elevator_init_fn =		cfq_init_queue,
        cfq_init_queue
                //	cfqd->grp_service_tree = CFQ_RB_ROOT;
                blkcg_activate_policy //blkcg_policy_cfq
                        blkg_alloc
                        blk_queue_bypass_start
                        blkg_create
                        // pd_init_fn
                        cfq_pd_init
                //cfqd->root_group = blkg_to_cfqg(q->root_blkg);




blk_alloc_queue_node
        blkcg_init_queue
                blk_throtl_init
                        blkcg_activate_policy // blkcg_policy_throtl  blk_throtl_work

set_task_ioprio

cfq_io_context

/* max queue in one round of service */
static const int cfq_quantum = 8;
static const int cfq_fifo_expire[2] = { HZ / 4, HZ / 8 };
/* maximum backwards seek, in KiB */
static const int cfq_back_max = 16 * 1024;
/* penalty of a backwards seek */
static const int cfq_back_penalty = 2;
static const int cfq_slice_sync = HZ / 10;
static int cfq_slice_async = HZ / 25;
static const int cfq_slice_async_rq = 2;
static int cfq_slice_idle = HZ / 125;
static int cfq_group_idle = HZ / 125;
static const int cfq_target_latency = HZ * 3/10; /* 300 ms */
static const int cfq_hist_divisor = 4;


blk_queue_init_tags
blk_queue_start_tag
blk_queue_end_tag

blk_init_queue

touch_buffer //trace_block_touch_buffer
mark_buffer_dirty //trace_block_dirty_buffer

blk_account_io_merge //attempt_merge
drive_stat_acct //add_acct_request bio_attempt_back_merge blk_queue_bio
blk_account_io_done //blk_finish_request




blk_queue_make_request
        //q->nr_batching = BLK_BATCH_REQ;
blk_rq_map_sg

elv_merge(struct request_queue * q, struct request * * req, struct bio * bio)

elv_add_request
        blk_do_rq

CONFIG_BLK_DEV_IO_TRACE
*** submit_bio
blk_flush_plug_list //
        queue_unplugged
                __blk_run_queue
                 //cfqd->unplug_work, cfq_kick_queue);
                        cfq_kick_queue
                                __blk_run_queue
                                //q->request_fn
                                        DDL_DiskRequestArrivedCB

submit_bio
        generic_make_request
                generic_make_request_checks
                        blk_partition_remap
                                //trace_block_bio_remap
                        blk_throtl_bio

                //trace_block_bio_queue
                //q->make_request_fn
                blk_queue_bio
                        attempt_plug_merge
                                bio_attempt_back_merge
                                        ll_back_merge_fn
                                                queue_max_sectors
                                                ll_new_hw_segment
                                        //trace_block_bio_backmerge
                                bio_attempt_front_merge
                                        ll_front_merge_fn
                                        //trace_block_bio_frontmerge(q, bio)

                        elv_merge // �ж�merge���ͣ� �Լ��ҵ���Ӧ��req
                                blk_try_merge // q->last_merge
                                elv_rqhash_find
                                elv_rq_merge_ok
                                        elv_iosched_allow_merge
                                                //e->type->ops.elevator_allow_merge_fn
                                                cfq_allow_merge
                                //e->type->ops.elevator_merge_fn
                                cfq_merge
                        bio_attempt_back_merge  // ��bio���뵽req�У��ϲ����ȼ�IOPRIO_CLASS_BE
                        elv_bio_merged
                                //e->type->ops.elevator_bio_merged_fn(
                                cfq_bio_merged
                        attempt_back_merge
                                elv_latter_request
                                        // e->type->ops.elevator_latter_req_fn
                                        elv_rb_latter_request
                                attempt_merge
                                        ll_merge_requests_fn
                                        blk_account_io_merge //account
                                        elv_merge_requests
                                                //e->type->ops.elevator_merge_req_fn(q, rq, next);
                                                cfq_merged_requests
                                        __blk_put_request
                                                elv_completed_request
                                                        //e->type->ops.elevator_completed_req_fn
                                                        cfq_completed_request
                        elv_merged_request// ǰ��ʧ�ܺ�
                                //e->type->ops.elevator_merged_fn
                                cfq_merged_request
                        get_request(q, rw_flags, bio, GFP_NOIO)
                        init_request_from_bio
                        list_add_tail(&req->queuelist, &plug->list);//��ǰ��plug
                        //trace_block_plug(q);
                        add_acct_request // ��ǰû��plugʱ
                                drive_stat_acct//account
                                        part_round_stats
                                        part_inc_in_flight
                                __elv_add_request
                                        //trace_block_rq_insert
                                        elv_rqhash_add //ELEVATOR_INSERT_SORT
                                        //q->elevator->type->ops.elevator_add_req_fn(q, rq);
                                        cfq_insert_request
                        __blk_run_queue

blk_peek_request
        __elv_next_request
                q->prep_rq_fn//null
                //q->elevator->type->ops.elevator_dispatch_fn ��������û��reqʱ
                cfq_dispatch_requests
        elv_activate_rq
                 //CONFIG_CFQ_GROUP_IOSCHED
                        cfq_activate_request//CONFIG_BLK_DEV_THROTTLING
                                cfq_log_cfqq //CONFIG_BLK_DEV_IO_TRACE ��Ҫ��blk tracer


=> ftrace_ops_no_ops\n\
 => ftrace_graph_call\n\
 => filemap_write_and_wait_range\n\
 => ext4_sync_file\n\
 => generic_write_sync\n\
 => generic_file_aio_write\n\
 => ext4_file_write\n\
 => do_sync_write\n\
 => vfs_write\n\
 => SyS_write\n\
 => ret_fast_syscall\n\
 => elv_rqhash_find\n\
 => elv_merge\n\
 => blk_queue_bio\n\
 => generic_make_request\n\
 => submit_bio\n\
 => ext4_io_submit\n\
 => mpage_da_submit_io\n\  //ext4_bio_write_page io_submit_add_bh   io_submit_init
                                                        //ext4_end_io_work   ext4_end_bio
 => mpage_da_map_and_submit\n\
 => ext4_da_writepages\n\  //tag_pages_for_writeback blk_start_plug
 => do_writepages\n\
 => __filemap_fdatawrite_range\n\
 => filemap_write_and_wait_range\n\
 => ext4_sync_file\n\
 => vfs_fsync\n\
 => do_fsync\n\

bio_endio(struct bio * bio, int error)
        ext4_end_bio(struct bio * bio, int error)
                ext4_free_io_end
                        put_io_page
                                end_page_writeback
                                        test_clear_page_writeback
                                        wake_up_page(page, PG_writeback);
                                put_page
LDL_ThreadLoop
LDL_DeviceRequestInsertPage
        LDL_ThreadInsertOneRequest
                wake_up(&LDL_ThreadPool.thread[unitNo].go);
*** VFS
__mark_inode_dirty
        bdi_wakeup_thread_delayed //5S
                bdi_forker_thread
                        wb_do_writeback
                                bdi_writeback_thread

wb_update_bandwidth
        __bdi_update_bandwidth
                bdi_update_dirty_ratelimit
                        //trace_bdi_dirty_ratelimit


bdi_start_background_writeback
        //trace_writeback_wake_background
        bdi_wakeup_flusher

default_bdi_init
        alloc_workqueue("writeback"
        bdi_init
                bdi_wb_init
                        INIT_DELAYED_WORK(&wb->dwork, bdi_writeback_workfn);
        bdi_register
                device_create_vargs

__blk_run_queue\n\
 => queue_unplugged\n\
 => blk_flush_plug_list\n\
 => blk_queue_bio\n\
 => generic_make_request\n\
 => submit_bio\n\
 => ext4_io_submit\n\
 => ext4_bio_write_page\n\
 => mpage_da_submit_io\n\
 => mpage_da_map_and_submit\n\
 => write_cache_pages_da\n\
 => ext4_da_writepages\n\
 => do_writepages\n\
 => __writeback_single_inode\n\
 => writeback_sb_inodes\n\
 => __writeback_inodes_wb\n\
 => wb_writeback\n\
 => wb_do_writeback\n\
 => bdi_writeback_workfn\n\
 => process_one_work\n\
 => worker_thread\n\
 => kthread\n\
ext4_da_writepages  //trace_ext4_da_writepages
        tag_pages_for_writeback //PAGECACHE_TAG_TOWRITE
        blk_start_plug
        ext4_da_writepages_trans_blocks
        ext4_journal_start
        write_cache_pages_da //trace_ext4_da_write_pages
                pagevec_lookup_tag
                lock_page
                mpage_da_map_and_submit
                        ext4_journal_current_handle
                        ext4_map_blocks
                                ext4_es_lookup_extent
                                //trace_ext4_es_lookup_extent_enter(inode, lblk);
                                //trace_ext4_es_lookup_extent_exit(inode, es, found);
                                ext4_ext_map_blocks(handle, inode, map, flags & EXT4_GET_BLOCKS_KEEP_SIZE);
                                ext4_mark_inode_dirty
                                        //trace_ext4_mark_inode_dirty(inode, _RET_IP_);
                        mpage_da_submit_io
                                pagevec_lookup
                                clear_page_dirty_for_io
                                ext4_bio_write_page
                                        set_page_writeback
                                        io_submit_add_bh
                                                io_submit_init
                                                        bio_get_nr_vecs
                                                                queue_max_segments
                                                        ext4_init_io_end //ext4_end_io_work
                                                //bio->bi_private = io->io_end = io_end;
                                                //bio->bi_end_io = ext4_end_bio;
                                                bio_add_page
                                                        __bio_add_page
                                                //ext4_io_submit
                                        unlock_page
                                ext4_io_submit
                                        submit_bio
        ext4_journal_stop
        blk_finish_plug

bdi_writeback_workfn //
        wb_do_writeback //trace_writeback_pages_written
                get_next_work_item
                //trace_writeback_exec
                wb_writeback
                        list_empty(&wb->bdi->work_list)
                        over_bground_thresh
                                global_dirty_limits //trace_global_dirty_state
                        //trace_writeback_start(wb->bdi, work);
                        __writeback_inodes_wb//trace_writeback_written
                                writeback_sb_inodes
                                        writeback_chunk_size  //MIN_WRITEBACK_PAGES ����4M ���ٶȵ�һ��
                                        inode->i_state |= I_SYNC;
                                        writeback_single_inode
                                                __writeback_single_inode
                                                //trace_writeback_single_inode_start
                                                do_writepages
                                                        ext4_da_writepages
                                                filemap_fdatawait //wbc->sync_mode == WB_SYNC_ALL
                                                mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)
                                                inode->i_state &= ~I_DIRTY_PAGES;/* Clear I_DIRTY_PAGES if we've written out all dirty pages */
                                                //trace_writeback_single_inode
                                                inode_sync_complete
                                        requeue_inode
                                        inode_sync_complete
                                        time_is_before_jiffies // ����100ms�˳�
                        //trace_writeback_written
                        wb_update_bandwidth
                                __bdi_update_bandwidth
                                        bdi_update_write_bandwidth
                        inode_wait_for_writeback //trace_writeback_wait
                complete
                wb_check_old_data_flush
                wb_check_background_flush
        //trace_writeback_pages_written
        mod_delayed_work
        bdi_wakeup_thread_delayed


ext4_file_write
        generic_file_aio_write
                __generic_file_aio_write
                        generic_file_buffered_write
                                generic_perform_write
                                        ext4_write_begin
                                        iov_iter_copy_from_user_atomic//memcpy
                                        balance_dirty_pages_ratelimited
                                        ext4_write_end

mark_buffer_dirty
        __set_page_dirty_buffers
                __set_page_dirty_nobuffers
                        account_page_dirtied
                        __inc_zone_page_state(page, NR_FILE_DIRTY);
                        __inc_zone_page_state(page, NR_DIRTIED);
                        __inc_bdi_stat(mapping->backing_dev_info, BDI_RECLAIMABLE);
                        __inc_bdi_stat(mapping->backing_dev_info, BDI_DIRTIED);
                        current->nr_dirtied++;
                        this_cpu_inc(bdp_ratelimits);

end_page_writeback
        TestClearPageReclaim
                rotate_reclaimable_page
                        pvec = &__get_cpu_var(lru_rotate_pvecs);
                        pagevec_add(pvec, page)
        test_clear_page_writeback
                __bdi_writeout_inc
                        __inc_bdi_stat(bdi, BDI_WRITTEN);
                        __fprop_inc_percpu_max(&writeout_completions, &bdi->completions,
                               bdi->max_prop_frac);


global_dirty_state: dirty=24396 writeback=10230 unstable=0 bg_thresh=3917 thresh=31343 limit=35562 dirtied=106877 written=72240\n\
bdi_dirty_ratelimit: bdi 93:32: write_bw=12848 awrite_bw=18572 dirty_rate=10512 dirty_ratelimit=39616 task_ratelimit=9160 balanced_dirty_ratelimit=16176\n\

trace_printk("%s--%d nr_reclaimable %d nr_dirty %d ",__FILE__, __LINE__, nr_reclaimable,nr_dirty);
balance_dirty_pages_ratelimited
        ratelimit = current->nr_dirtied_pause;
        if (bdi->dirty_exceeded)
                ratelimit = min(ratelimit, 32 >> (PAGE_SHIFT - 10));
        p =  &__get_cpu_var(bdp_ratelimits); // account_page_dirtied ��ext4_write_begin��ʱ�����
        // bdp_ratelimits OR nr_dirtied > nr_dirtied_pause then
        balance_dirty_pages
                nr_dirty = nr_reclaimable + global_page_state(NR_WRITEBACK);
                global_dirty_limits(&background_thresh, &dirty_thresh);
                freerun = dirty_freerun_ceiling//(dirty_thresh + background_thresh) / 2;
                current->nr_dirtied_pause = dirty_poll_interval(nr_dirty, dirty_thresh);
                //nr_dirtied_pause =  (ilog2(dirty_thresh - nr_dirty)
                bdi_start_background_writeback
                bdi_thresh = bdi_dirty_limit(bdi, dirty_thresh);
                //bounded by the bdi->min_ratio and/or bdi->max_ratio parameters,
                // default max=100 min=0, if only one bdi, bdi_thresh will equal dirty_thresh
                bdi_dirty = bdi_stat(bdi, BDI_RECLAIMABLE)+bdi_stat(bdi, BDI_WRITEBACK);
                dirty_exceeded = (bdi_dirty > bdi_thresh) && (nr_dirty > dirty_thresh);
                        bdi->dirty_exceeded = 1;
                bdi_update_bandwidth(bdi, dirty_thresh, background_thresh,nr_dirty, bdi_thresh, bdi_dirty,start_time);
                        if (time_is_after_eq_jiffies(bdi->bw_time_stamp + BANDWIDTH_INTERVAL)
                        // wb_update_bandwidth in flusher thread will update write_banwidth, but did not update dirty_rate
                        //wb_writeback
                        //	wb_update_bandwidth
                        //__		bdi_update_bandwidth
                        //				bdi_update_write_bandwidth
                        __bdi_update_bandwidth
                                global_update_bandwidth
                                bdi_update_dirty_ratelimit
                                        dirty_rate = (dirtied - bdi->dirtied_stamp) * HZ / elapsed;
                                        // (now dirtied pages - last snapshot)  / now - last snapshot
                                        bdi_position_ratio
                                        if (unlikely(balanced_dirty_ratelimit > write_bw))
                                                balanced_dirty_ratelimit = write_bw;
                                        bdi->dirty_ratelimit = balanced_dirty_ratelimit;
                                        //step = 0;
                                        //if (dirty < setpoint) {
                                        //	x = min(bdi->balanced_dirty_ratelimit,
                                        //               min(balanced_dirty_ratelimit, task_ratelimit));
                                        //	if (dirty_ratelimit < x)
                                        //		step = x - dirty_ratelimit;
                                        //}  �˴�����bug�� ��ʱdirty_ratelimit ���� x ʱ��stepһֱΪ0�� ����
                                        // dirty_ratelimit һֱ���ڶ��г�ʼ���ĳ�ʼֵ100M

                                        //trace_bdi_dirty_ratelimit
                                bdi_update_write_bandwidth
                max_pause = bdi_max_pause(bdi, bdi_dirty);
                min_pause = bdi_min_pause(bdi, max_pause,
                period = HZ * pages_dirtied / task_ratelimit;
                pause = period;
                //trace_balance_dirty_pages
                trace_balance_dirty_pages(bdi,
                __set_current_state(TASK_KILLABLE);
                io_schedule_timeout(pause);

generic_writepages
        write_cache_pages
                //trace_wbc_writepage


ext4_write_begin
        //trace_ext4_write_begin
        ext4_writepage_trans_blocks
        grab_cache_page_write_begin
                find_lock_page
                        find_get_page
                                radix_tree_lookup_slot
                        lock_page
                __page_cache_alloc//o
                add_to_page_cache_lru//o
                        add_to_page_cache
                                __set_page_locked
                                add_to_page_cache_locked
                        lru_cache_add_file
                wait_for_stable_page//
                        bdi_cap_stable_pages_required
                        wait_on_page_writeback
        unlock_page
        ext4_journal_start
        lock_page
        wait_on_page_writeback
        __block_write_begin(page, pos, len, ext4_get_block);
                ext4_get_block
                        _ext4_get_block
                                ext4_map_blocks
                                        ext4_ext_map_blocks


ext4_write_end
        //trace_ext4_write_end
        generic_write_end


ext4_ext_map_blocks(handle, inode, map, flags & EXT4_GET_BLOCKS_KEEP_SIZE);
        //trace_ext4_ext_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);
        //trace_ext4_ext_show_extent(inode, ee_block, ee_start, ee_len);
        ext4_mb_new_blocks(handle, &ar, &err);
                //trace_ext4_request_blocks(ar);
                ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);
                        ext4_journal_get_write_access
                ext4_mb_release_context(ac);
                        //trace_ext4_mballoc_prealloc(ac);
                //trace_ext4_allocate_blocks(ar, (unsigned long long)block);
        get_reserved_cluster_alloc(inode,map->m_lblk, allocated);
                //trace_ext4_get_reserved_cluster_alloc(inode, lblk_start, num_blks);
        ext4_da_update_reserve_space(inode,	reserved_clusters, 0);
                //trace_ext4_da_update_reserve_space(inode, used, quota_claim);
                dquot_claim_block
                        mark_inode_dirty_sync
                                __mark_inode_dirty
        //trace_ext4_ext_map_blocks_exit(inode, map, err ? err : allocated);
        ext4_es_insert_extent
                //trace_ext4_es_insert_extent(inode, &newes);
        ext4_ext_show_leaf

ext4_writepage
ext4_da_write_begin
        //trace_ext4_da_write_begin
        grab_cache_page_write_begin
        unlock_page
        handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, 1);
        lock_page
        wait_on_page_writeback
         __block_write_begin(page, pos, len, ext4_da_get_block_prep)
                ext4_da_get_block_prep
                        ext4_da_map_blocks
                                ext4_es_lookup_extent
                                //trace_ext4_es_lookup_extent_enter(inode, lblk);
                                //trace_ext4_es_lookup_extent_exit(inode, es, found);
                                ext4_ext_map_blocks
ext4_da_write_end
        //trace_ext4_da_write_end
        generic_write_end
                block_write_end
                        __block_commit_write
                                mark_buffer_dirty
                                //trace_block_dirty_buffer(bh);
                                        __set_page_dirty
                                                account_page_dirtied
                                                //trace_writeback_dirty_page(page, mapping);
                if (i_size_changed)
                        mark_inode_dirty(inode);
                                __mark_inode_dirty
                                        //trace_writeback_dirty_inode_start
                                        ext4_dirty_inode
                                                ext4_journal_start
                                                ext4_mark_inode_dirty
                                                        ext4_reserve_inode_write
                                                                ext4_get_inode_loc
                                                                        submit_bh(READ | REQ_META | REQ_PRIO, bh);
                                                                        wait_on_buffer(bh);
                                                                ext4_journal_get_write_access
                                                        ext4_mark_iloc_dirty
                                                                __ext4_get_inode_loc
                                                //trace_ext4_mark_inode_dirty
                                                ext4_journal_stop
                                                        jbd2_journal_stop
                                                        //trace_jbd2_handle_stats
                                        //trace_writeback_dirty_inode
*** jbd2
do_sync_write
        ext4_file_write
                generic_file_aio_write
                        __generic_file_aio_write
                                generic_file_buffered_write
                                        generic_perform_write
                                                ext4_da_write_begin
                                                iov_iter_copy_from_user_atomic
                                                        __copy_from_user_inatomic
                                                ext4_da_write_end
                                                cond_resched
                                                balance_dirty_pages_ratelimited
                                                        __bdi_update_bandwidth
                generic_write_sync
                        vfs_fsync_range
                                ext4_sync_file

ext4_sync_file
        filemap_write_and_wait_range
                __filemap_fdatawrite_range
                        do_writepages
                                        ext4_da_writepages  //trace_ext4_da_writepages
                filemap_fdatawait_range
                        pagevec_lookup_tag//PAGECACHE_TAG_WRITEBACK
                        wait_on_page_writeback
        jbd2_complete_transaction
                jbd2_log_wait_commit
                        wait_event(journal->j_wait_done_commit,
        blkdev_issue_flush


jbd2_get_transaction
jbd2_journal_flush


ext4_journal_start
        __ext4_journal_start
                __ext4_journal_start_sb
                //trace_ext4_journal_start
                        jbd2__journal_start
                        //trace_jbd2_handle_start
                                new_handle
                                current->journal_info = handle;
                                start_this_handle
                                        if (transaction->t_state == T_LOCKED) {
                                                prepare_to_wait(&journal->j_wait_transaction_locked,&wait, TASK_UNINTERRUPTIBLE);
                                        atomic_inc(&transaction->t_updates);
ext4_journal_stop
        __ext4_journal_stop
                jbd2_journal_stop
                //trace_jbd2_handle_stats

                        if (handle->h_sync ||
                                jbd2_log_start_commit(journal, transaction->t_tid);
                        wake_up(&journal->j_wait_updates

                        if (wait_for_commit)
                                err = jbd2_log_wait_commit(journal, tid);

ext4_bread
        ext4_getblk
                ext4_map_blocks
                bh = sb_getblk(inode->i_sb, map.m_pblk);
                ext4_handle_dirty_metadata
        ll_rw_block
        wait_on_buffer

ext4_handle_dirty_dirent_node
ext4_group_add_blocks
ext4_free_blocks
ext4_mb_mark_diskspace_used
ext4_delete_entry
ext4_init_new_dir
        ext4_handle_dirty_metadata

ext4_handle_dirty_metadata
        __ext4_handle_dirty_metadata
                jbd2_journal_dirty_metadata
                        __jbd2_journal_file_buffer
                                list = &transaction->t_buffers;

ext4_journal_get_write_access
        __ext4_journal_get_write_access
                jbd2_journal_get_write_access
                        jbd2_journal_add_journal_head
                        do_get_write_access
                                if (jh->b_jlist == BJ_Shadow) {
                                                trace_printk("on shadow: sleep \n");
                                __jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);
                                        list = &transaction->t_reserved_list;
                                jbd2_journal_cancel_revoke(handle, jh);
                        jbd2_journal_put_journal_head

ext4_da_writepages
jbd2_complete_transaction
        jbd2_log_start_commit
                __jbd2_log_start_commit
                        journal->j_commit_request = target;
                        wake_up(&journal->j_wait_commit);
        jbd2_log_wait_commit
                wait_event(journal->j_wait_done_commit,!tid_gt(tid, journal->j_commit_sequence));

kjournald2
        jbd2_journal_commit_transaction
                //trace_jbd_start_commit(journal, commit_transaction);
                //trace_jbd_commit_locking(journal, commit_transaction);
                prepare_to_wait(&journal->j_wait_updates
                __jbd2_journal_clean_checkpoint_list(journal);
                jbd2_clear_buffer_revoked_flags(journal);
                jbd2_journal_switch_revoke_table(journal);
                //trace_jbd2_commit_flushing
                journal_submit_data_buffers
                        list_for_each_entry(jinode, &commit_transaction->t_inode_list,
                        //trace_jbd2_submit_inode_data(jinode->i_vfs_inode);
                        journal_submit_inode_data_buffers
                                generic_writepages
                                        ret = write_cache_pages(mapping, wbc, __writepage, mapping);
                jbd2_journal_write_revoke_records
                //trace_jbd2_commit_logging
                jbd2_journal_get_descriptor_buffer
                        jbd2_journal_next_log_block
                                jbd2_journal_bmap
                        __getblk
                        jbd2_journal_add_journal_head
                jbd2_journal_next_log_block
                jbd2_journal_write_metadata_buffer
                        jbd2_alloc
                                __get_free_pages
                        memcpy(tmp, mapped_data + new_offset, jh2bh(jh_in)->b_size);
                        __jbd2_journal_file_buffer(jh_in, transaction, BJ_Shadow);
                        jbd2_journal_file_buffer(new_jh, transaction, BJ_IO);
                write_tag_block
                bh->b_end_io = journal_end_buffer_io_sync;
                                submit_bh(WRITE_SYNC, bh);

                journal_finish_inode_data_buffers

                journal_submit_commit_record
                        if (journal->j_flags & JBD2_BARRIER &&
                            !JBD2_HAS_INCOMPAT_FEATURE(journal,
                                                       JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT))
                                ret = submit_bh(WRITE_SYNC | WRITE_FLUSH_FUA, bh);
                        else
                                ret = submit_bh(WRITE_SYNC, bh);

                wait_on_buffer
                clear_buffer_jwrite(bh);
                jbd2_journal_unfile_buffer(journal, jh);
                        __jbd2_journal_unfile_buffer
                                __jbd2_journal_temp_unlink_buffer
                                        mark_buffer_dirty
                //trace_jbd2_run_stats(journal->j_fs_dev->bd_dev,  commit_transaction->t_tid, &stats.run);
                journal->j_commit_callback(journal, commit_transaction);
                //trace_jbd2_end_commit(journal, commit_transaction);
                __jbd2_journal_drop_transaction
                jbd2_journal_free_transaction
                wake_up(&journal->j_wait_done_commit);


end_buffer_async_write
        end_page_writeback
                test_clear_page_writeback
                        TestClearPageWriteback
                        __dec_bdi_stat(bdi, BDI_WRITEBACK)
                        __bdi_writeout_inc(bdi);
                        dec_zone_page_state(page, NR_WRITEBACK);
                        inc_zone_page_state(page, NR_WRITTEN);
                wake_up_page(page, PG_writeback);
*** blk
blk_init_queue
        blk_init_queue_node
                blk_alloc_queue_node
                        bdi_init
                                bdi_wb_init
                        blk_throtl_init
                        setup_timer(&q->timeout, blk_rq_timed_out_timer, (unsigned long) q)
                        kobject_init(&q->kobj, &blk_queue_ktype);
                blk_init_allocated_queue
                        blk_queue_make_request(q, blk_queue_bio);
                        elevator_init
                                elevator_init_queue
                                        cfq_init_queue nand_elv_init_queue//eq->type->ops.elevator_init_fn


add_disk
        bdi_register_dev
                bdi_register
                        device_create_vargs
        blk_register_queue
                elv_register_queue
                        __elv_register_queue

blk_peek_request
        __elv_next_request

" /sys/kernel/debug/tracing/events/block/block_rq_issue/enable"
" /sys/kernel/debug/tracing/events/block/block_rq_complete/enable"
*** ext4
const struct file_operations ext4_file_operations = {
        .llseek		= ext4_llseek,
        .read		= do_sync_read,
        .write		= do_sync_write,
        .aio_read	= generic_file_aio_read,
        .aio_write	= ext4_file_write,
        .unlocked_ioctl = ext4_ioctl,
#ifdef CONFIG_COMPAT
        .compat_ioctl	= ext4_compat_ioctl,
#endif
        .mmap		= ext4_file_mmap,
        .open		= ext4_file_open,
        .release	= ext4_release_file,
        .fsync		= ext4_sync_file,
        .splice_read	= generic_file_splice_read,
        .splice_write	= generic_file_splice_write,
        .fallocate	= ext4_fallocate,
};

schedule
        sched_submit_work
                blk_schedule_flush_plug
                        blk_flush_plug_list
                                __elv_add_request  //trace_block_rq_insert
                                        elv_drain_elevator  //.elevator_dispatch_fn =
                                                nand_elv_dispatch_requests,
                                                        deadline_dispatch_requests
                                                        cfq_dispatch_requests
                                                                cfq_dispatch_request
                                                                        cfq_dispatch_insert
                                        __blk_run_queue
                                queue_unplugged  //trace_block_unplug
                                        blk_run_queue_async
                                                queue_delayed_work //kblockd
                                                        blk_delay_work
                                                                __blk_run_queue
                                                                        //q->request_fn
                                                                        DDL_DiskRequestArrivedCB

do_sync_write
        ext4_file_write
                generic_file_aio_write
                        blk_start_plug
                        __generic_file_aio_write
                                generic_file_buffered_write
                        blk_finish_plug


madvise
        madvise_vma
                madvise_willneed
                        force_page_cache_readahead
                                __do_page_cache_readahead
                                        page_cache_alloc_readahead
                                        read_pages
                                                blk_start_plug
                                                        blkdev_readpage//a_ops->readpages



do_sync_read
        generic_file_aio_read //>f_op->aio_rea
                do_generic_file_read
                        page_cache_alloc_cold
                        add_to_page_cache_lru
                                add_to_page_cache
                                        __set_page_locked
                                        add_to_page_cache_locked
                                                //trace_mm_filemap_add_to_page_cache(page);
                        blkdev_readpage//a_ops->readpage
                                block_read_full_page
                                        create_empty_buffers
                                                alloc_page_buffers
                                                        attach_page_buffers
                                                        set_bh_page
                                        blkdev_get_block//get_block
                                                set_buffer_mapped
                                        lock_buffer
                                        mark_buffer_async_read //bh->b_end_io = end_buffer_async_read;
                                        submit_bh //bio->bi_end_io = end_bio_bh_io_sync;
                                                submit_bio
                                                        generic_make_request
                                                                //q->make_request_fn(
                                                                        blk_queue_bio
                        lock_page_killable
                                __lock_page_killable   //PG_locked  end_buffer_async_read
                                        __wait_on_bit_lock  //  wait loop  TASK_KILLABLE
                                                sleep_on_page_killable
                                                        sleep_on_page
                                                                io_schedule
                                                                        atomic_inc(&rq->nr_iowait);//����iowait
                                                                        blk_flush_plug
                                                                                schedule
                        unlock_page
                        page_cache_release
                                put_page
                        file_read_actor
                                __copy_to_user
        wait_on_retry_sync_kiocb  // while loop
                schedule


blk_peek_request
        __elv_next_request
                q->prep_rq_fn//null
                //q->elevator->type->ops.elevator_dispatch_fn ��������û��reqʱ
                cfq_dispatch_requests
        elv_activate_rq
                 //CONFIG_CFQ_GROUP_IOSCHED
                        cfq_activate_request//CONFIG_BLK_DEV_THROTTLING
                                cfq_log_cfqq //CONFIG_BLK_DEV_IO_TRACE ��Ҫ��blk tracer

_dealDiskRequest  // device driver ==> user
        __blk_end_request
                __blk_end_bidi_request
                        blk_update_bidi_request
                                blk_update_request
                                        req_bio_endio
                                                bio_endio
                                                        end_bio_bh_io_sync //bio->bi_end_io
                                                                end_buffer_async_read
                                                                        set_buffer_uptodate
                                                                        SetPageUptodate
                                                                        unlock_page //PG_locked
                                                                                clear_bit_unlock(PG_locked
                                                                                wake_up_page
                blk_finish_request
                        blk_delete_timer
                        blk_account_io_done
                        req->end_io(req, error); //flush_end_io
                        __blk_put_request
                                elv_completed_request
                                        //e->type->ops.elevator_completed_req_fn
                                        cfq_completed_request
                                                cfqg_stats_update_completion
                                                RQ_CIC(rq)->ttime.last_end_request = now;
                                blk_rq_rl
                                blk_free_request(rl, req);
                                freed_request(rl, flags);
                                blk_put_rl(rl);

flush_end_io
        elv_completed_request
        blk_flush_complete_seq
                __blk_end_request_all(rq, error);

__elv_add_request
        blk_insert_flush
        rq->end_io = flush_data_end_io;
        blk_flush_complete_seq

flush_data_end_io
        blk_flush_complete_seq(rq, REQ_FSEQ_DATA, error)

blk_flush_complete_seq
        blk_kick_flush
                //q->flush_rq.end_io = flush_end_io;

trace_ext4_sync_file_enter
ext4_sync_file
        filemap_write_and_wait_range
                __filemap_fdatawrite_range
                        do_writepages
                                ext4_da_writepages
                                        blk_finish_plug
                                                blk_flush_plug_list
                                                        __elv_add_request
                                                                nand_elv_add_request
                                                                        __blk_run_queue
                                                queue_unplugged
                                                        __blk_run_queue

static const struct address_space_operations def_blk_aops = {
        .readpage	= blkdev_readpage,
        .writepage	= blkdev_writepage,
        .write_begin	= blkdev_write_begin,
        .write_end	= blkdev_write_end,
        .writepages	= generic_writepages,
        .releasepage	= blkdev_releasepage,
        .direct_IO	= blkdev_direct_IO,
};


ext4_bread
        ll_rw_block
                block_read_full_page
                        submit_bh
                                submit_bio
                                        generic_make_request
                                                //q->make_request_fn(
                                                        blk_queue_bio


_DiskPartitionCreate
 queue = blk_init_queue(DDL_DiskRequestArrivedCB
         blk_init_queue_node
                 blk_init_allocated_queue
                        blk_queue_make_request
                                // q->make_request_fn = blk_queue_bio

 nand_elv_init
        iosched_nand_elv
*** panic
panic(param...)
__die
        unwind_backtrace
                dump_backtrace_entry   // (%pS)
                                printk
                                        vsnprintf
                                                pointer
                                                        symbol_string
                                                                kallsyms_lookup


kmsg_dump_register(struct kmsg_dumper * dumper)(struct kmsg_dumper * dumper)
*** ftrace
tracing_sched_register
        register_trace_sched_wakeup
                probe_sched_wakeup
                        ftrace_trace_userstack //entry->tgid = current->tgid;

tracing_mark_write
        trace_buffer_lock_reserve  //ftrace.h Ҳ�����event = trace_current_buffer_lock_reserve
                tracing_generic_entry_update  /*        entry->preempt_count		= pc & 0xff;
                                                                                        entry->pid			= (tsk) ? tsk->pid : 0;
                                                                                        entry->padding			= 0;
                                                                                        entry->flags = */
        ring_buffer_unlock_commit
                rb_commit
                        rb_update_write_stamp


trace_create_file("trace_options", 0644, d_tracer,
                        NULL, &tracing_iter_fops);
                        tracing_trace_options_write
                                        set_tracer_flags



trace_create_file("trace_pipe", 0444, d_cpu,
                        (void *) cpu, &tracing_pipe_fops);
                tracing_open
                        __tracing_open
                                seq_open(file, &tracer_seq_ops);//s_show
s_show
        print_trace_line
                print_trace_fmt
                        trace_print_context     //TRACE_ITER_CONTEXT_INFO
                                trace_find_cmdline   //
                                trace_print_lat_fmt //TRACE_ITER_IRQ_INFO
                        ftrace_find_event
                                event->funcs->trace
                                        ftrace_raw_output_##call

event_trace_init
        __trace_add_event_call
                ftrace_event_reg
                        trace_event_raw_init
                                register_ftrace_event //event->type = trace_search_list
                                        ftrace_event_reg
                                                tracepoint_probe_register


tracer_init_debugfs
ftrace_init
ftrace_module_notify
ftrace_global_list_func

ftrace_graph_caller
ftrace_dyn_arch_init
ftrace_caller
ftrace_make_call

// trace.c
tracer_init_debugfs //fs_initcall(tracer_init_debugfs);
        trace_create_file("current_tracer", 0644, d_tracer,
                                &global_trace, &set_tracer_fops);
        init_tracer_debugfs
                tracing_init_debugfs_percpu
                        tracing_dentry_percpu
                                debugfs_create_dir("per_cpu", d_tracer);
                        trace_create_cpu_file("trace", 0644, d_cpu,
                                tr, cpu, &tracing_fops);

tracing_set_trace_write
        tracing_set_tracer
                tracer_init
                        t->init
                        //trace_irqsoff.c
                        irqsoff_tracer_init
                                start_irqsoff_tracer
                                        register_ftrace_function //irqsoff_tracer_call
                                                ftrace_startup
                                                        ftrace_run_update_code // ftrace_trace_function = ftrace_ops_list_func
                                        register_ftrace_graph // irqsoff_graph_return irqsoff_graph_entry

trace_hardirqs_off
trace_create_file("tracing_enabled", 0644, d_tracer,
                        &global_trace, &tracing_ctrl_fops);
tracing_ctrl_write
        current_trace->start
                        //trace_irqsoff.c
                        irqsoff_tracer_start
http://lwn.net/Articles/379903/
register_ftrace_event

ftrace_event_id_fops
ftrace_enable_fops
ftrace_event_filter_fops
ftrace_event_format_fops

trace_module_nb

blk_register_queue
        blk_trace_init_sysfs
                sysfs_create_group(&dev->kobj, &blk_trace_attr_group);
                        //sysfs_blk_trace_attr_show
                        //sysfs_blk_trace_attr_store
//blktrace.c
sysfs_blk_trace_attr_store
        blk_trace_setup_queue
                blk_register_tracepoints //blk_add_trace_rq_insert

//elavtor.c
trace_block_rq_insert
        blk_add_trace_rq_insert
                __blk_add_trace
                        trace_buffer_unlock_commit
//samples/tracepoint

//trace_irqsoff.c
init_irqsoff_tracer
irqsoff_tracer

*** console
Kernel
printk
       vprintk
              local_irq_save
              console_unlock
                     call_console_drivers
                            _call_console_drivers
                                   __call_console_drivers
con->write // asoc_console_write
    con->write
platform_driver_probe
       asoc_serial_probe
              uart_add_one_port
                     uart_configure_port
                            register_console // asoc_console

android �е�klogd
��android
          init
              klog_init
                  android/system/core/libcutils/klog.c

mknod(name, S_IFCHR | 0600, (1 << 8) | 11) ʹ/dev/__kmsg__
        kernel/drivers/char/mem.c
       [11] = { "kmsg", 0, &kmsg_fops, NULL },
����klog_write�����յ���kmsg_fops��kmsg_writev ��д��printk���ڲ�buffer�С�

Logcat�еĴ�ӡ�᲻���ӡ��printkʹ�õ�buffer�����Ǵ�ӡ����drivers/staging/android/logger.c���ж���ļ���buffer�С�

Sh��ʹ�õĴ�ӡ������� (/dev/console)
service_start
       open_console (/dev/console)
service console /system/bin/sh
    class core
    console
disabled

/dev/console
console_fops->open
tty_open
       tty_lookup_driver
              console_device
                     c->device
                            uart_console_device
                                   p->tty_driver
        tty->ops->open(tty, filp)
                     uart_open
                            uart_startup
                                   uart_port_startup
                                          uport->ops->startup // asoc_uart_pops
                                                 asoc_startup
p->tty_driver//arch/arm/mach_leopard/asoc_serial.c
asoc_serial_init
uart_register_driver
       tty_register_driver


shell
console_fops->write
redirected_tty_write
    tty_write
        do_tty_write
            ld->ops->write  //  tty_ldisc_N_TTY
            n_tty_write
                tty->ops->write // uart_ops
                uart_write
                    uart_start
                        spin_lock_irqsave(&port->lock, flags);
                        __uart_start(tty);
                            port->ops->start_tx // asoc_uart_pops
                            asoc_start_tx
                            spin_unlock_irqrestore(&port->lock, flags);`
* 标案
** AP
*** Linux 发行版
**** debian
s900 96boards
http://builds.96boards.org/snapshots/bubblegum/linaro/debian/latest/
https://github.com/ofree/ramdisk
https://github.com/ofree/linux/tree/bubblegum96-3.10
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F36FEB@srv-mail-02.actions.com.cn][这张图是linux的架构图吗？]]
*** S700
**** 快速倒车
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B05144FF2@srv-mail-02.actions.com.cn][快速倒车移植文档]]
**** 第二阶段规格
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEB3F5@srv-mail-02.actions.com.cn][答复: AD700A第二阶段规格讨论]]
**** 方糖规格
***** TODO [[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061654AE@srv-mail-02.actions.com.cn][转发: 答复: CubieBoard7-S700 第二阶段协作开发]]
**** ubuntu 环境
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10353C339@srv-mail-02.actions.com.cn][GS700E 的ubuntu xml]]
**** UI性能
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04FA97DD@srv-mail-02.actions.com.cn][发送电子邮件: GS700D_UI_性能评估数据.xls, GS700D_UI_性能评估报告.doc]]
**** 视频
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0503D16D@srv-mail-02.actions.com.cn][答复: H.264性能数据]]
*** 支持工作
**** 7059 以太网台湾支持
[[mu4e:msgid:45C9CD6E9A1F8E40A999E51EF137BF15324A1B@srv-mail-02.actions.com.cn][RE: 答复: About ATM7059 /S500 RTL8201 相關眼圖測試_初版]]
**** 3605
mediaWin alsa 支持， 编译环境， tinyalsa支持
**** s900 项目申报
**** twd屏问题
**** 泽迪V700 双屏
**** 泽迪V700 usb支持nanoc的陀螺仪
**** S700 revovery老化
硬件修改了， 没有通知软件
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A9008C@srv-mail-02.actions.com.cn][答复: 答复: S700 recovery老化卡死在Android动画问题]]
**** s700 绿屏
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103465020@srv-mail-02.actions.com.cn][答复: 答复: S700 多任务操作下小机出现绿屏]]
**** TODO S700 usb otg
**** 领芯EDP屏支持
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB8B5@srv-mail-02.actions.com.cn][答复: 领芯S900工控板子的eDP屏的调试]]
**** 900c youtube 问题
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8FE69@srv-mail-02.actions.com.cn][【v700】【YouTube】v700 nibiru海外版固件使用YouTube tv版播放搜索视频报错]]r
**** ksd 性能相关问题调试
+ sdio wifi死机， 主要是sdio的max block大小原因
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103464E9E@srv-mail-02.actions.com.cn][答复: KSD死机打印]]
**** 7059 mipi屏幕调试
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103464ED5@srv-mail-02.actions.com.cn][答复: 7059C 7寸MIPI调试资料]]
**** 文晟
[[mu4e:msgid:0E3AB831E505F842818BA4F9798C30A4016F11D3@srv-mail-02.actions.com.cn][答复: 【S500】文晟 USB通信20170425]]
**** 火百灵
提供sdk给对方
tinyalsa 提供
alsa lib调试
**** TODO  v700 泽迪分体机hdmi输出
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8FCE9@srv-mail-02.actions.com.cn][V700泽迪分体机hdmi输出竖屏信号问题]]
**** 文晟
ov5460 camera倒立
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F37DC2@srv-mail-02.actions.com.cn][答复: 文晟7059 ov5640 camera拍照后照片放到PC上倒立180°]]
**** 乐百灵
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB7DC@srv-mail-02.actions.com.cn][RE: 深圳广佳乐新智能的ATS3605的远场语音识别的方案]]
4.14号拜访乐白灵的出差记录，请各位知悉。

乐百灵

l 给我们演示了双MIC的样机效果（宣传指标：远场5m，唤醒率94%，识别率90%），
唤醒不了的情况还是比较多发生（给我们的解释是里面的测试固件，其实我们手
上的echo dot也一样）。

l 乐百灵的这款双MIC采用的方式直接CX20921贴主板上，没有用模块。AEC没有
使用ADC，直接使用的是AP出来的I2S的输出连接到CX20921上，CX20921负责下采
样。同时这个方案是有音效的，音效是外挂IC，也就是说当前的AEC是从音效处
理之前采集的。他给我们的说法是这样做多对性能有影响的，只是当时为了省
ADC才这样做了。

l 乐百灵采用的是云之声的语音识别算法，云之声将云识别算法和CX20921打包
方式给乐白灵。

l 唤醒词部分是他们自己的算法，他们可以更换唤醒词。咨询唤醒词的运算量，
他说的他们自己的很小。他对CX20921的冷唤醒词识别不是很看好。

l 他也提到了Airpaly和DLNA的需求是WIFI音箱的must需求。

l 语音识别库：老朱看来认为故事机和WIFI音箱是两个不同的产品，对算法要求
不同，他给我们的解释是故事机针对小孩，WIFI音箱针对大人，大人小孩的声音
识别训练模型是有差异的（待确认），我们3503故事机和WIFI音箱公用语音识别
的方式关注一下这个。

l 乐白灵的模具因为语音识别做过多次调整，最后选择将MIC的腔体放在上偏后
面，同时模具设计上对震动音箱等都有充分考虑。他的说法是这部分对算法效果
影响非常大。

l 他们手上有语音识别且蓝牙和WIFI切换的模具，是一款公模。比较切合我们
ATS3503的WIFI音箱的方案需求。

l 初步沟通准备从他们家购买单MIC和双MIC的模具作为我们标案开发使用。
**** 地平线
***** 内存泄露问题
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C2DF@srv-mail-02.actions.com.cn][答复: hobocCAPI精简版]]
**** 瑞泰
***** 瑞泰cvbs in
***** 卡量产
***** TODO U盘升级
***** TODO 双系统倒车
***** 蓝牙slave
***** sofia资料
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A246B5@srv-mail-02.actions.com.cn][答复: 瑞泰项目未来几个需要做的事情]]
**** wilinko debian
客户自己使用我们的sdk， 自己编译了新的initrd， 新的debian jessie可以完整跑起来。
**** 凯硕达
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F37853@srv-mail-02.actions.com.cn][答复: 【7059】铠硕达200WmipiCamera调试]]
**** S900 双屏支持
***** TODO 文档
**** S900 HDMI IN
***** TODO 文档
**** AD700A标案
**** TODO S700 QC 廖田养
**** s700 以太网支持  李钊军
**** S700 蓝牙支持slave模式  李钊军
**** TODO  S700 蓝牙支持pcm
**** ubuntu支持旋转（竖屏） 刘世军
**** tv in支持  黄海宇  瑞泰
**** ubuntu linux 支持 S700 廖田养
**** 3605 linux 环境 廖田养
**** 900c 电池 FCC未更新
**** TODO 点创车机老化 camera问题
*** 客户需求
**** 视美泰
***** 性能要求
+ 循环视频播放相同或者不同格式视频时间需大于240小时。不卡顿，不退出，不暂停。
+ USB或者CSI等摄像头须预览或者录像时间大于240小时。不卡顿，不退出，不暂停。
+ WIFI，以太网，3G能连接上网时间大于240小时。
+ 音视频需要支持多种视频格式和高清视频，长时间播放无黑屏和死机现象。
+ 支持双屏同/异显示（LVDS显示界面，HDMI显示视频），播放高清视频无抖动，卡顿现象。
+ USB,IIC触摸屏流畅，不断点，不卡顿。
+ 强行掉电开机后必须保证能工作的有（测试次数大于4000次）：
+ 前置USB摄像头能正常使用；
+ 后置USB摄像头能正常使用；
+ SD卡分区可读写
+ U盘分区可读写
+ WIFI自动连接，获取IP，上网；或者能与手机直连
+ ETH 自动连接，获取IP，上网
+ 3G自动连接，获取IP，上网
+ BT自动连接
+ 能进入android桌面，并不能恢复出厂设置。
+ USB触摸屏能正常使用
+ WIFI，以太网ETH，3G数据通信保证不丢包，吞吐量足够大。（ping 192.xxx.xxx.xxx -n 102400 -l 10240）
+ 多个视频同时播放高清视频的解码能力，性能，音视频同步。
***** 软件系统要求
+ 软件固件同时支持1G,2G DDR的容量,无需更换固件.
+ 开机时间5秒内需显示Logo，20S内进入Android桌面。任何原因关机须显示框等正常关机，时间在5秒内完全断电关机。HDMI与LVDS须同时显示,相差不得大于3S.
+ 全志三个阶段Logo需要支持不同分辨率，不同屏幕旋转状态正常显示。支持更换Logo方案。
+ 恢复出厂设置或者update升级,需要HDMI,LVDS都可以显示UI,不得黑屏.
+ 支持截屏。需要支持0,90,180,270旋转屏后的截屏保存。
+ 屏幕旋转模式须支持0,90,180,270旋转，包括3个阶段的logo显示,界面UI，视频等等都需要旋转。
+ 屏幕状态栏隐藏设置，同时支持手势方式显示或者隐藏状态栏。（如华为手机荣耀6）
+ 声音输出通道设置，可以设置自动检测和Codec，HDMI强制输出等不同通道输出。
+ 2G，3G，4G模块需要兼容性支持。支持模拟语音与数据通信。当无3G等模块插入时，须模拟3G模块，包括手机信息等，如IMEI号码等等信息供应用使用。支持3G通话，如手机操作。
+ 循环播放视频时，视频切换时黑屏时间少于1S。
+ USB外设支持：
  3G dongle，
  USB读卡器，
  USB触摸屏，
  USB摄像头：支持录像，录音。支持QQ视频通话问题。
+ 串口外设支持（包括USB转TTL，PL2303，FT2303等）
  POS打印机，
  读卡器等外设。
+ 默认支持GooglePlay等APK。
+ 摄像头APK进入前，需要支持手动选择使用前置和后置摄像头。
+ 设置APK关于设备项目中，须加入我们特定信息：如DDR，EMMC大小，MCU版本号等等。
+ 须支持遥控盒子功能和鼠标模式。IR至少需支持Setting里面设置，Launch，浏览器和输入法正常应用。
+ 支持升级方式：USB升级，TF 升级卡升级，TF update.zip升级。其中TF update.zip升级能做到插入TF卡后,无需操作就直接升级了.
+ 支持恢复出厂方式：（无论是HDMI，LVDS，VGA输出， 恢复出厂设置需要统一通知用户，包括正在进行，成功，失败信息。）
+ 支持标准视美泰API方式。包括APK看门狗，视美泰板卡识别。
+ 支持定时开关机，加密系统。
+ 支持多家广告机发布系统：如实验室，星际，南翼和视展等等。
+ 静默安装APK。
+ 开关机指示灯定义与实现：
+ 网络优先级设置：ETH>WIFI>3G。可在设置进行选择。
+ HDMI，VGA，LVDS显示下，支持调节显示亮度，对比度和饱和度等显示设置。
+ 串口，IIC，扩展IO口，须提供接口以便支持应用层APP调用。串口支持485协议。
+ 需要支持单/双路,6/8位RGB_LVDS输出。支持双路8位 1080P，Freq=168MHz输出。
+ 支持双屏同/异显。（至少LVDS显示界面，HDMI显示视频,图片）。
+ 单WIFI 8188ETV和WIFI+BT 8723BU 模块，支持双频WIFI2.4+5G，软件能自动识别。
+ 支持TF卡/U盘进行参数配置，其中包括
  + 屏参设置
  + 屏幕旋转模式
  + 屏幕状态栏默认隐藏配置
  + 声音大小，喇叭，耳机，3G
  + 声音输出通道默认配置
  + USB HID的VID，PID设置
  + USB触摸屏原点位置
  + IIC电容屏配置，IC芯片，地址，大小分辨率，原点位置（为了兼容多家IIC触摸不造成软件分支）
  + WIFI AP默认名称和密码配置
  + 遥控器机器码厂家配置
  + 3G模块名称配置。（为了兼容多家3G模块不造成软件分支）
  + 是否支持3G模块选择。（为了支持多串口，兼容USB转TTL，PL2303，FT2303等）
  + 调试背光频率，相位和默认背光强度。
+ 一键恢复出厂设置。
+ 支持TF卡/U盘OTA完整固件升级。
+ Bootlogo 支持动态更改，支持旋转0 90 180 270度。
+ USB摄像头支持500W。
  + 支持假待机，关闭LVDS，eDP，HDMI，VGA等显示，声音，只是系统在后台运行。
** 3503
*** amr 16K编码
**** 20170703 地平线
如微信沟通，关于AMR 16KHz 编码的问题，需要炬芯的同事帮忙尽快更新一下～从我们专业的角度看，16KHz是主流的方式，且与8KHz比较有诸多优点～
以下为我们总结的点供参考：推荐采用amr-wb 16Khz的理由:
+  在语音识别领域，目前主流都是采用16KHz， 16bit的语音数据进行语音识别， 8KHz, 16bit目前主要是应用在电信客服等少数领域，后续也有逐步被16KHz替换掉的趋势；AR/VR会采用32KHz采样；
+ 相比于8KHz采样， 16KHz的语音包含更多语音信息， 在MOS指标上也要有明显提升；
+ 在噪声鲁邦性上16KHz采样语音要明显优于8KHz， 很多生活场景、玩具电机噪声都分布在2KHz一下，相比于16KHz采样语音，8KHz语音更容易受到干扰；针对远场语音识别， DOA，BF等算法采用 16KHz采样的语音都要由于8KHz采样语音；
+ 16KHz在语音识别的情况下，可以提取更多频带信息，在目前深度学习的框架下，相比于8KHz语音模型可以更好的建模语音特征；
+ 语音本身传输带宽比较小，调整为16KHz采样后，带宽增加也不多，但是可以明显提升语音识别性能。
**** 各种格式对比
| speex | 最佳的语音识别算法                                       |
| msbc  | 特征提取，msbc是不可逆的，不能还原声音，做大数据分析困难 |
| amr   | 肯定不适合做语音识别，流量和网络存储开销大               |
*** 蓝牙地址
**** TODO [[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906260C5B@srv-mail-02.actions.com.cn][ZS350A SN和蓝牙mac地址在产线上该如何烧写]]
*** WIFI 兼容性
*** zephyr中文文档
http://www.96boards.net/forum.php?mod=viewthread&tid=38
http://iot-fans.xyz/zephyr/doc/v1.6.0/index.html
*** 发布文档
**** TODO 入门指南
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F1035B6F53@srv-mail-02.actions.com.cn][答复: ZS350A 发布文档准备]]
**** 数据烧写工具
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B05144321@srv-mail-02.actions.com.cn][数据烧写工具使用指南]]
**** 用户手册
[[mu4e:msgid:1215223C59CBD54AA38F93133AF342D503DF5D17@srv-mail-02.actions.com.cn][答复: ZS350A 发布文档准备]]
**** wifi测试手册
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749063298C9@srv-mail-02.actions.com.cn][答复: ZS350A 发布文档准备]]
*** TODO 需改进
AirKiss协议实现不标准， 增加了basee64编码
json实现不标准，修改了基本语义
解码库里有很多重复代码
在parser和解码库中存在重复功能。 对代码量有影响。
*** 蓝牙空间
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D5D7A@srv-mail-02.actions.com.cn][zs350a增加蓝牙功能后memory资源占用]]
*** 功耗数据
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D58DB@srv-mail-02.actions.com.cn][答复: 【测试结果确认】ZS350A_ATS3503_XLT_JQRHB功耗&续航指标测试]]
*** mqtt粘包问题
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103465985@srv-mail-02.actions.com.cn][答复: 关于mqtt粘包的修改]]
*** 不烧写序列号
[[mu4e:msgid:0E3AB831E505F842818BA4F9798C30A4016F2641@srv-mail-02.actions.com.cn][转发:  关于如何避免烧写设备序列号]]
*** 网络性能设计
**** [[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F7490626097F@srv-mail-02.actions.com.cn][答复: 关于网络卡顿的设计和优化]]
+ 边下边播
  在有卡存在的情况下, 会在播放的时候， 同时下载到卡上， 网络性能和写卡的性能大于播放器消耗码流的速度的时候， 可以有效的避免播放卡顿
+ 网络缓冲区的零拷贝
 从网络驱动开始， wifi驱动 + 网络协议栈 + 网络流buffer + 播放器码流buffer 都使用同一个buffer，都使用同一个网络buffer， 最大限度的使用内存
+ TCP 重传支持
  在zephyr中没有重传的支持， 增加了重传机制， 在丢包情况下
+ TCP 窗口优化
  结合内存情况设置合理的TCP的滑动窗口， 在各个场景，较好的平衡性能，缓冲以及满足重传时间间隔要求
+ tcp的ACK包，以及mqtt 心跳包使用保留的小buffer
  避免网络数据包被接受的音乐数据长时间占住后， 不能及时回复响应
  同时也可以节省更多的大的网络buffer给音乐数据
*** wifi性能分析

[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D4E7F@srv-mail-02.actions.com.cn][在线播放网络影响分析]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906329AB3@srv-mail-02.actions.com.cn][答复: ZS350A 发布文档准备]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F7490632988A@srv-mail-02.actions.com.cn][ZS350A在线播放高码率卡顿情况分析]]
cache miss
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906329B13@srv-mail-02.actions.com.cn][答复: spi 2x mode]]
1、环境：EVB_004板子，code在spi nor；

Tcp rx：500kbps（包长590），1Mbps（包长1514）统计tcp data数据

测试环境：spi_1x,spi_2x, spi_4x, spi clock 48MHz，代码在spi nor中，
(spi_2x, spi_4x屏蔽房环境, spi_1x之前办公区测试)；

spi_xxspi clocktcp iperf rx   cache miss   一次miss spi cs
               (Kbps)         （次/秒）    时间
api_1x48MHz    500            70000        12us
spi_2x48MHz    800            120000       6.3us
Spi4x 48MHz    1200           200000       3.3us


**** 在线播放卡顿分类：
+ ap与机子之间wifi传输存在丢包，导致wifi包重传,甚至导致tcp层重传，重传导致300~700ms之间没数据传输；卡顿情况编号：1,9,10,13;
这种情况，向南方硅谷了解，跟干扰，天线好坏有关；
+ 网络传输延迟，即发出了ack，服务器收到ack后发出数据包，到收到数据包的时间长达200~700ms不等，而传输快的情况，从发出ack到收到数据包，20ms就可以了；卡顿情况编号：4,6,7,11,12,13；
+ 网络丢包，即数据包在服务器到ap之间传输就丢了，导致后面数据包重传，抓到的一个重传后收到已是1.3秒之后；卡顿情况编号12；
+ 连续多次卡顿，主要是这段时间内网络传输延迟引起；卡顿情况编号：13；
+ 部分空中包抓不到，从抓包前后编号及时间间隔，算出这段时间传输的数据速率低于音乐播放码率，引起卡顿；卡顿情况编号：2,3,5,8;
+ 对于单独一、两次网络延迟的情况，理论上加大tcp window，让跟多的数据包在服务器与机子之间传输，可以一定程度减小收到包的时延。对于一段时间内多次传输时延，还没想到规避办法；
   对于网络丢包，除了缓存足够数据等到重传包的到来，暂时没有其它办法规避；

向南方硅谷了解的wifi相关情况：
+ Wifi传输使用退避算法，会一直等待空气空闲，复杂环境下，会一直等待，等待时间不确定，可能会很长；
+ Wifi多次重传，有时连续重传多次间隔都很小，有时重传间隔会大，看到一个第3次重传已经是400多ms之后，重传是由于发出数据包没收到ack，只要回ack，另一端收到的概率很大，主要是收不到发出的数据，跟干扰，天线好坏有关，这个现象只能说是和干扰，硬件RF性能相关，因为回ack都是硬件做的；
+ Ap发送一个数据包，多次重传后都收不到ack，就会丢掉这个包，传输下一个包，retry次数ap各不同，这个没有spec规定，测试同一个ap，都抓到两次不同的重传情况，一次在10ms秒就重传了6次，一次在400ms内才重传了3次；
播放音乐码率：128kbps，不卡顿需要的收包频率约100ms收到一个数据包
*** 二维码
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D4E25@srv-mail-02.actions.com.cn][发送电子邮件: ACTS3503011_27.jpg]]
二维码烧写指令：storyapp set_sn ACTS3503011_27
二维码烧写指令：storyapp set_sn ACTS3503026_38
清除ap 信息的指令：storyapp clear_ap_info
清除音量设置指令：storyapp set_config AUDIOUT_VOLUME
关闭半小时自动关机指令：storyapp set_config AUTO_POWERDOWN false
*** 项目计划
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74905FFA9E6@srv-mail-02.actions.com.cn][发送电子邮件: ZS350A项目计划.pdf]]
*** 开发
**** jtag调试
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10336CE0E@srv-mail-02.actions.com.cn][答复: 会议记录:US282F SDK培训(一)]]
*** hardware
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74905FFA154@srv-mail-02.actions.com.cn][GPIO配置]]
*** 规格
**** 规格简介
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74905FF9A31@srv-mail-02.actions.com.cn][ZS350A方案规格简介]]
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F155DAE9@srv-mail-02.actions.com.cn][Fwd: 发送电子邮件: ZS350A_SPEC V1.0.xlsx]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74905FF9BFF@srv-mail-02.actions.com.cn][答复: GL5118Plus对CPU速度和RAM增加的需求讨论]]

*** 3503语音接口定义
+ 语音识别接口支持 POST 方式
+ 需要支持片段语音识别的模式，整段语音可以分成多个片段上传进行识别
+ 原始语音的录音格式目前只支持  8k/16k 采样率 16bit 位深的单声道语音
+ 压缩格式支持：pcm（不压缩）、wav、opus、speex、amr
+ 系统支持语言种类：中文（zh）
**** 语音上传模式

语音数据直接放在 HTTP-BODY 中，控制参数以及相关统计信息通过 REST 参数传递，REST参数说明：
| 字段名  | 数据类型 | 可需 | 描述                                                        |   |   |
| cuid    | string   | 必填 | 用户 ID，推荐使用设备mac 地址/手机IMEI 等设备唯一性参数     |   |   |
| token   | string   | 必填 | 开发者身份验证密钥                                          |   |   |
| lan     | string   | 选填 | 语种选择，中文=zh，不区分大小写，默认中文 |   |   |
| offset  | int      | 必填 | 语音片段在本次识别中的偏移                                  |   |   |
| is_last | boolean  | 必填 | 当前语音片段是否是最后一段                                  |   |   |


语音数据的采样率和压缩格式在 HTTP-HEADER 里的 content-type 表明，例：

Content-Type:audio/amr;rate=8000
Content-length 请填写语音片段长度。

**** 下行接口定义

返回的结果，采用 JSON 格式封装，如果识别成功，识别结果放在 JSON的“result”字段中，统一采用 utf-8 方式编码。

| 字段名  | 数据类型 | 可需 | 描述                   |
| err_no  | int      | 必填 | 错误码                 |
| err_msg | string   | 必填 | 必填错误码描述         |
| result  | string   | 必填 | 识别结果               |
| url     | string   | 必填 | 百科问答的结果音频文件 |

string 类型utf-8 编码

**** 错误码解释
| 错误码 | 含义               |
|   3300 | 输入参数不正确     |
|   3301 | 识别错误           |
|   3302 | 验证失败           |
|   3303 | 语音服务器后端问题 |

*** roobo
     请使用这个账号。注意：这个是测试环境的账号，接的URL地址为ros.roobo.net。切记
     agentId： U4NTc4YTQ2MjhlYz
     token：89330257fc00279373b7c1e979aa8d0e7636

**** testcode

***** asr
(setf drakma:*header-stream* *standard-output*)
     (let ((stream (drakma:http-request "http://ros.roobo.net/voice/v1/asr"
                                       :method :post
                                       :close nil
                                       :want-stream t
                                       :content #p "/Users/zhangdongfeng/Desktop/2017/3503/baidu/Baidu_Voice_RestApi_SampleCode/sample/test.pcm"
                                       :content-type "audio/pcm;bit=16;rate=8000"
                                       :content-length 52512
                                       :parameters
                                       '(("agentId" . "U4NTc4YTQ2MjhlYz")
                                         ("lang" . "cmn-CHN")
                                         ("sessionId" . "serial987654321")
                                         ("token" .
                                          "89330257fc00279373b7c1e979aa8d0e7636")))))
      (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
      (yason:parse stream :object-as :plist))

(let ((stream (drakma:http-request "http://ros.roobo.net/voice/v1/asr"
                                       :method :post
                                       :close nil
                                       :want-stream t
                                       :content #p "/Users/zhangdongfeng/Desktop/2017/3503/roobo/RECORD.AMR"
                                       :content-type "audio/amr;rate=8000"
                                       :content-length 15174
                                       :parameters
                                       '(("agentId" . "U4NTc4YTQ2MjhlYz")
                                         ("lang" . "cmn-CHN")
                                         ("sessionId" . "serial987654321")
                                         ("token" .
                                          "89330257fc00279373b7c1e979aa8d0e7636")))))
      (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
      (yason:parse stream :object-as :plist))
***** tts
(let ((stream (drakma:http-request "http://ros.roobo.net/voice/v1/tts"
                                       :method :post
                                       :close nil
                                       :want-stream t
                                       :content "今天天气怎么样"
                                       :content-type "audio/pcm;bit=16;rate=8000"
                                       :content-length (trivial-utf-8:UTF-8-BYTE-LENGTH "今天天气怎么样")
                                       :external-format-out :utf-8
                                       :parameters
                                       '(("agentId" . "U4NTc4YTQ2MjhlYz")
                                         ("lang" . "cmn-CHN")
                                         ("sessionId" . "serial987654321")
                                         ("token" .
                                          "89330257fc00279373b7c1e979aa8d0e7636")))))
      (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
      (yason:parse stream :object-as :plist))

***** query
(let ((stream (drakma:http-request "http://ros.roobo.net/voice/v1/query"
                                       :method :post
                                       :close nil
                                       :want-stream t
                                       :content #p "/Users/zhangdongfeng/Desktop/2017/3503/roobo/RECORD.AMR"
                                       :content-type "audio/amr;rate=8000"
                                       :content-length 15174
                                       :parameters
                                       '(("agentId" . "U4NTc4YTQ2MjhlYz")
                                         ("lang" . "cmn-CHN")
                                         ("sessionId" . "serial987654321")
                                         ("token" .
                                          "89330257fc00279373b7c1e979aa8d0e7636")))))
      (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
      (yason:parse stream :object-as :plist))

 ip.addr == 60.205.122.156
*** mqtt
**** mqtt_api.h
#ifndef __HEADER_H__
#define __HEADER_H__
/*loop_mode_t - player mode
 *  REPEAT_ONE: repeat one
 *  REPEAT_ALL: repeat all
 * This enum is used in send_loop_mode as a argument
 */
typedef enum {
        REPEAT_ONE,
        REPEAT_ALL
}loop_mode_t;

/*play_status_t - player status
 *  PLAY: playing status
 *  PAUSE: pause status
 * This enum is used in send_play_status as a argument
 */
typedef enum {
        PLAY,
        PAUSE
}play_status_t;


/*music_track_info_t - the struct describes a track(music or story) for normal play or download
 *  @track_id: track id of the music or story
 *  @play_url: url of the music or story
 *  @download_url: download url of the music or story
 * This struct describes a music or story to play or download
 */
typedef struct{
        int track_id;
        char *play_url;
        char *download_url;
}music_track_info_t;

/*demand_music_info_t - the struct describes a track(music or story) on demand
 *  @voice_url: url of the notify voice
 *  @url: url of the music or story
 *  @track_id: track id of the music or story
 * This struct describes a music or story on demand
 */
typedef struct {
        char *voice_url;
        char *url;
        int track_id;
}demand_music_info_t;

/**track_list_t - list of tracks
 *  @name: list name
 *  @id: list id
 *  @size: list size
 *  @trackIDs: track id array in this list
 * This struct describes a track list. It is used for play list operations.
 */
typedef struct {
        char *name;
        int id;
        int size;
        int *trackIDs;
}track_list_t;

/**command_type_t - received server message , command type
 * This enum describes simple command types.
 */
typedef enum {
        Play,
        Pause,
        Resume,
        Next,
        Prev,
        SetVolume,
        GetVolume,
        SetLoopMode,
        GetLoopMode,
        GetCurrentTrack,
        GetSysInfo,
        SetPowerOff,
        GetPlayStatus,
        GetOnlineStatus,
        SetPlayTrackListId,
        GetPlayTrackListId,
        GetTracksById,
        GetPlayProgress
}command_type_t;

/**Sys_info_t - sys info
 * This struct describes system information.
 */
typedef struct SysInfo {
        char ssid[64];
        char fw_version[64];
        bool is_charging;
        int battery_vol;
        int storage_total;
        int storage_free;
}Sys_info_t;


/**play_list_arg_t - argument for SetPlayTrackListId command
 * @ids: id array
 * @size: id array size
 * This struct describes list ids to set.
 * SetPlayTrackListId can set one or more lists at one time
 */
typedef struct {
        int *ids;
        int size;
}play_list_arg_t;

/**play_list_arg_t - argument for Play command
 * @list_id: list id
 * @track_id£º track id
 * @play_url: play url
 * @download_url£º download url
 *
 */
typedef struct {
        int list_id;
        int track_id;
        char *play_url;
        char *download_url;
}play_track_arg_t;

/**fw_info_t - firmware information
 * @version: firmware version
 * @url£º firmware download url
 * This struct is used to transform fw information
 */
typedef struct {
        char *version;
        char *url;
}fw_info_t;

/**track_type_t - track type
 * MUSIC_TYPE: music or story normal type
 * DEMAND_TYPE£º on demand type
 * VOICE_TYPE: voice type
 * This enum is used in send_current_track as an argument
 */
typedef enum {
        MUSIC_TYPE,
        DEMAND_TYPE,
        VOICE_TYPE
}track_type_t;

/**download_state_t - download state
 * DOWNLOAD_STATE_SUCCESS:
 * DOWNLOAD_STATE_ERROR:
 * DOWNLOAD_STATE_FULL:
 * This enum is used in send_download_state as an argument
 */
typedef enum {
        DOWNLOAD_STATE_SUCCESS,
        DOWNLOAD_STATE_ERROR,
        DOWNLOAD_STATE_FULL
}download_state_t;

/**************************APIs***************************************/
/*DOC:
 * 1. send_xxx APIs are realised in the lib,
 *    the upper app can use them directly.
 * 2. on_receive_xxx APIs are callback functions used in the lib,
 *    the upper app must realised them all.
 * 3. some simple commands are parsed in on_receive_command, the other commands are
 *    parsed to different on_receive_xxx callbacks.
 */



/*on_receive_command - SET²Ù×÷----¸ù¾Ý²»Í¬µÄÉèÖÃÃüÁî£¬´«Èë»Øµ÷µÄarg²ÎÊýÒ²ÊÇ²»Í¬µÄ

 *Play:               ´«Èë²ÎÊýÎªplay_track_arg_tÀàÐÍµÄÖ¸Õë£¬ÆäÖÐ´æ´¢ÐèÒª²¥·ÅµÄtrackÐÅÏ¢¡£
 *Pause/Resume/Next/Prev£º´«Èë²ÎÊýÎªNULL£¬½øÐÐÏàÓ¦µÄ²Ù×÷¡£
 *SetVolume£º         ´«Èë²ÎÊýÎªintÐÍÖ¸Õëint *vol£¬¼´ÎªÐèÒªÉèÖÃµÄvolume¡£
 *SetLoopMode£º       ´«Èë²ÎÊýÎªintÐÍÖ¸Õë£¬×ª»¯Îªloop_mode_tÀàÐÍ½øÐÐ´¦Àí¡£
 *SetPowerOff£º       ´«Èë²ÎÊýÎªNULL£¬½øÐÐ¹Ø»ú²Ù×÷¡£
 *SetPlayTrackListId: ´«Èë²ÎÊýÎªstruct play_list_arg_tÀàÐÍ£¬ÉèÖÃÐ¡»ú¶ËÒª²¥·ÅµÄÁÐ±íids¡£
*/

/*on_receive_command - GET²Ù×÷----´«Èë²ÎÊý¶¼ÎªNULL, ÐèÒªµ÷ÓÃ¶ÔÓ¦µÄsendÃüÁî·¢ËÍÏàÓ¦µÄ×´Ì¬¸ø·þÎñÆ÷

 *GetVolume:	»ñÈ¡ÒôÁ¿£¬°Ñµ±Ç°ÒôÁ¿Í¨¹ýsend_volume½Ó¿Ú·¢³öÈ¥¡£
 *GetLoopMode£º	»ñÈ¡²¥·ÅÄ£Ê½£¬°Ñµ±Ç°modeÍ¨¹ýsend_loop_mode·¢³ö¡£
 *GetCurrentTrack:»ñÈ¡µ±Ç°²¥·ÅµÄtrackÐÅÏ¢£¬ÐèÒªÔÚ»Øµ÷ÖÐµ÷ÓÃsend_current_music·¢ËÍ³öÈ¥¡£
 *GetSysInfo£º	»ñÈ¡µ½Ð¡»úÐÅÏ¢ºóÍ¨¹ýsend_sys_info·¢³öÀ´¡£
 *GetPlayStatus: »ñÈ¡²¥·Å×´Ì¬£¬Í¨¹ýsend_play_statusÀ´·¢ËÍ¡£
 *GetOnlineStatus£º»ñÈ¡Ð¡»úÊÇ·ñÔÚÏß£¬ÊÕµ½Õâ¸öÃüÁîÖ»ÐèÒªsend_online_status¼´¿É¡£
 *GetPlayTrackListId£º»ñÈ¡Ð¡»ú¶ËÒª²¥·ÅµÄÁÐ±íids,µ÷ÓÃsend_play_list_id·¢ËÍ³öÈ¥¡£
 */
void on_receive_command(command_type_t cmd, void *arg);

/* on_receive_emoji - Ð¡»ú½ÓÊÕµ½ÁË±íÇéÏûÏ¢¡£
 * on_receive_text_message - Ð¡»ú½ÓÊÕµ½ÁËÎÄ×ÖÏûÏ¢¡£
 * on_receive_voice_message - Ð¡»ú½ÓÊÕµ½ÁËÁôÑÔÏûÏ¢¡£
 * on_receive_image_message - Ð¡»ú½ÓÊÕµ½ÁËÍ¼Æ¬ÏûÏ¢¡£
 * on_receive_video_message - Ð¡»ú½ÓÊÕµ½ÁËÊÓÆµÏûÏ¢¡£
 * on_receive_demand_music - Ð¡»ú½ÓÊÕµ½ÁËµã²¥ÏûÏ¢¡£
 * send_message_download_success - Í¨Öª·þÎñÆ÷ÏûÏ¢×ÊÔ´ÒÑ¾­ÏÂÔØ
 */
void on_receive_emoji(char *url);
void on_receive_text_message(char *text, char *nickname, char *avatar, int64_t timestamp);
void on_receive_voice_message(char *url, char *nickname, char *avatar, int64_t timestamp);
void on_receive_image_message(char *url, char *nickname, char *avatar, int64_t timestamp);
void on_receive_video_message(char *url, char *nickname, char *avatar, int64_t timestamp);
void on_receive_demand_music(demand_music_info_t *musicInfo);
void on_receive_demand_music_online(demand_music_info_t *musicInfo);
void send_message_download_success(char *resUrl);

/*get_track_info_by_id - Ð¡»ú·¢ËÍÏûÏ¢µ½·þÎñÆ÷ÒÔ»ñÈ¡¸úidÏà¹ØµÄtrack info
 *get_track_info_array_by_id - Óëget_track_info_by_idÀàËÆ£¬Ò»´Î»ñÈ¡¶à¸öµÄ½Ó¿Ú
 *on_receive_track_info - Ð¡»ú½ÓÊÕµ½ÁË·þÎñÆ÷·µ»ØµÄtrack infoÏûÏ¢
 *on_receive_track_info_array - Óëon_receive_track_infoÀàËÆ£¬Ò»´Î½ÓÊÕ¶à¸öµÄ½Ó¿Ú
 *
 */
void get_track_info_by_id(int track_id);
void get_track_info_array_by_id(int *ids, int size);
void on_receive_track_info(music_track_info_t *info);
void on_receive_track_info_array(music_track_info_t *info, int size);



/* username: ÓÃÓÚMQTT·þÎñÆ÷Á¬½ÓÐí¿ÉÑéÖ¤£¬·ÇÑéÖ¤·½Ê½Á¬½ÓÖ±½ÓÌîNULL
 * password£ºÓÃÓÚMQTT·þÎñÆ÷Á¬½ÓÐí¿ÉÑéÖ¤£¬·ÇÑéÖ¤·½Ê½Á¬½ÓÖ±½ÓÌîNULL
 * ×¢Òâ£ºÊÇ·ñ´«ÈëusernameºÍpasswordÐè¸ù¾ÝMQTT·þÎñÆ÷ÅäÖÃÀ´¾ö¶¨¡£
 */
void client_lib_open(char *srv_addr, char *id, char *username, char *password);
void client_lib_close(void);
void on_server_connect(void);
void on_server_disconnect(void);


void send_online_status(void);


void send_current_track(int list_id, int track_id, track_type_t type);


void send_demand_music_broadcast(int track_id);


void send_download_success(int track_id, char *url);
void send_download_error(int track_id, char *url);
void send_download_full(int track_id, char *url);

void send_download_state(download_state_t type, int *ids, int size);

/*Ð¡»úÆäËûÏà¹Ø×´Ì¬´ð¸´*/
void send_volume(int vol);
void send_loop_mode(loop_mode_t mode);
void send_play_status(play_status_t status);
void send_play_progress(int time);
void send_sys_info(Sys_info_t *info);

/*Ð¡»ú»ñÈ¡listµÄ²Ù×÷*/
void get_list_by_id(int list_id);
void on_receive_list(track_list_t *list);

/*Ô¤ÖÃlist²Ù×÷*/
void send_predefine_list(track_list_t *list);
void on_receive_predefine_list_id(char *name, int list_id);
void send_preset_list(track_list_t *list);

/*Í¬²½list²Ù×÷*/
void send_sync_list_request(void);
void on_receive_update_list_id(int *listIDs, int size);
void on_receive_add_list_id(int listID, char *name);
void on_receive_deleted_list_id(int *listIDs, int size);

/*·¢ËÍ²¥·ÅÁÐ±í,Ð¡»ú½ÓÊÕµ½GetPlayTrackListIdÃüÁîºóµÄ´ð¸´*/
void send_play_list_id(int *listIDs, int size);
void send_voice_media_id(char *media_id);

/*´ÓlistÀïÅúÁ¿Ìí¼Ó£¬É¾³ýtrackÎÄ¼þ*/
void on_delete_track_by_id(int list_id, int *trackIDs, int size);
void on_add_track_by_id(int list_id, int *trackIDs, int size);

/*OTA ²Ù×÷*/
void on_receive_upgrade_firmware(fw_info_t *fw);
void send_upgrade_start(void);
void send_upgrade_stop(void);

void send_change_listid(int listid);
void send_wifi_success(void);

/***********************customer extension APIs*****************************/

/**
 *DOC:
 *	the customer-extending message should be follow these rules below:
 *	1.it must be a JSON string
 *	2.it should include the key-value: {"cmd" : "customer", ...}
 */

/*send_customer_message - send customer-extending message
 *@data: message data point
 *@length: message data length
 */
void send_customer_message(char *data, int length);

/*on_receive_customer_message - when the lib received a customer-extending message,
 *				this callback will be called
 *@data: message data point
 *@length: message data length
 */
void on_receive_customer_message(char *data, int length);

void get_track_info_for_collector(int trackid);
void on_receive_track_info_for_collector(int sourceId, int duration, int customerId);

void send_test_result(char *result);
void on_receive_test_mode(char *url);

void on_receive_get_initial_track_list(int tracklistId);
void on_receive_play_tracks(int *trackIds,int size);

/* »ØÓ¦·þÎñÆ÷¶ËgetTracksÃüÁî£¬·µ»Ø¹ÊÊÂ»úÁÐ±íÄÚÈÝ */
void send_tracks_list_content(int trackListId, int *trackIds, int size);

#endif //__HEADER_H__

**** 自己搭建服务器格式
注：以下json格式为伪格式，字段和字符型的值的引号都忽略了

1.订阅topic希望加上应用名
例如：小机端订阅 storybox/mac地址/server 和 storybox/mac地址/server/page
服务端订阅 storybox/+/client 和 storybox/+/server/page

2.远程设置
1）音量调节
发起方：页面
接收方：小机
格式：{ cmd:setVolume, value:50}

2）远程关机
发起方：页面
接收方：小机
格式：{ cmd:setPoweroff}

3)主动询问音量
发起方：页面
接收方：小机
格式：{ cmd:getVolume}

4)小机音量，这里2种情况：主动询问后的回答及小机音量变化
发起方：小机
接收方：页面
格式：{volume:50}
{"volume":38}

3.故事机信息显示
1）主动询问故事机信息
发起方：页面
接收方：小机
格式：{ cmd:getBoxInfo}

2)故事机信息
发起方：小机
接收方：页面
格式：{boxInfo:{net:xxx,cardAvailable:xxx,cardTotal:xxx, electricity:xxx,firmwareVersion:xxx}}
{"boxInfo":{"net":"ess","cardAvailable":208,"cardTotal":300, "electricity":80,"firmwareVersion":"34343434"}}

4.设备的上下线管理
1)设备上线，设备上线及
发起方：小机
接收方：服务器和页面
格式：{onlineStatus:on}
{"onlineStatus":"on"}


2)设备下线
发起方：小机
接收方：服务器和页面
格式：{onlineStatus:off}
{"onlineStatus":"off"}

3)设备掉线
发起方：小机
接收方：服务器和页面
格式：{onlineStatus:abnormal}
{"onlineStatus":"abnormal"}

4）主动询问设备是否在线
发起方：页面
接收方：小机
格式：{ cmd:getOnlineStatus}
小机答复: {"onlineStatus":"online"}


8.上线时列表及信息同步
1)设备主动询问需要同步的列表
发起方：小机
接收方：服务器
格式：    {"cmd":"getUpdateListId"}
服务器回复：{ cmd:setUpdateListId,trackListIds:[1,2,3,4]}
和 SetPlayTrackListId



在新增一个列表时 {cmd:addList,trackListId:xxx,name:xxx}
移除一个列表 {cmd:delList,trackListId:xxx}

2)
发起方：小机
接收方：服务器
格式：{ cmd:getList,trackListId:xxx}  {"cmd":"getList","trackListId":1}
服务器回复：{cmd:setList, trackListId:xxx,name:xxx,trackIds:[1,2,3]}



3)设备在线时编辑列表后服务器发送
发起方：服务器
接收方：小机
格式：{cmd:listAddTrack, trackListId:xxx,trackIds:[1,2,3]}
{cmd:listRemoveTrack,trackListId:xxx,trackIds:[1,2,3]}


11.文件下载功能
1)文件下载成功后
发起方：小机
接收方：服务器/页面
格式：{downloadStatus:xxx,trackId:1, url:xxxx}  xxx为success,error,full
{"downloadStatus":"success","trackId":203, "url":"xxxx"}

2)批量文件下载成功后
发起方：小机
接收方：服务器/页面
格式：{downloadStatus:xxx,trackIds:[1,2,3]}  xxx为success,error,full
{"downloadStatus":"success","trackIds":[1,2,3]}

12.正在播放状态显示& 遥控公仔功能
1)页面主动向小机请求获取当前歌曲
发起方：页面
接收方：小机
格式：{cmd:getTrack} 获取当前播放歌曲，或者点播歌曲。


2)页面主动向小机请求获取当前播放状态
发起方：页面
接收方：小机
格式：{cmd:getPlayStatus} playing pause

3)小机播放状态改变
发起方：小机
接收方：页面
格式：{playStatus:xxx}  xxx为playing,pause
{"playStatus":"playing"}

4)小机播放歌曲的改变，这里也是页面主动向小机请求获取当前歌曲的答复
发起方：小机
接收方：页面
格式：返回{trackListId:5,trackId:1,type:0} type=0普通列表播放 1点播 2留言
type=1和2时，trackListId保持原值返回

当播放列表改变时,消息: {"changedTrackListId":3}


5)发起方：页面
接收方：小机
格式：
下一首 {cmd:forward}
上一首 {cmd:backward}
暂停 {cmd:pause}
继续播放 {cmd:resume}

6）播放列表设置
发起方：页面
接收方：小机
格式：{cmd:setPlayTrackLists,trackListIds:[3,4,5]}


小机从服务端拿track的信息
{ cmd:getTrackInfo， trackId:xxx}   id为trackid

{"cmd":"getTrackInfo","trackId":7161457}
服务端回复
{cmd:trackInfo,id:xxx,title:xxx,url:xxx,downloadUrl:xxx}

批量询问track信息
{"cmd":"getTrackInfoArray","trackIds":[3,4,5]}
答复
{cmd:trackInfoArray,data:[ {id:xxx,title:xxx,url:xxx,downloadUrl:xxx}]}

小机从服务端拿回传需要的信息
{ cmd:getTrackInfoForCollector， trackId:xxx}   id为trackid
服务端回复
{cmd:trackInfoForCollector,sourceId:xxx,duration:100,customerId:0,appKey:xxx,appSecret:xxx}  sourceId为厂商的资源id


7)页面主动询问播放列表
发起方：页面
接收方：小机
格式：{cmd:getPlayTrackListId}
答复：{playTrackListIds:[3,4,5]}
{"playTrackListIds":[25,26]}


8)播放歌
发起方：页面
接收方：小机
格式：{cmd:playTrack,trackListId:5,trackId:1,url:xxx,downloadUrl:xxx}


9)播放网络上的歌曲
发起方：页面
接收方：小机
格式：{cmd:playTracks,trackIds:[1,2,3]}


14. 留言功能
发起方：服务器
接收方：小机
格式：{cmd:playVoice,url:xxx}

发起方：小机
接收方：服务端
格式：{voiceMediaId:xxx}
{"voiceMediaId":"z7xJObuOFDNZT4HKHAlOMK8KafN32MPFgaBoHQJkONPXR4_AYXNx7OFRwjJTxmhi"}

15.点播
发起方：服务器
接收方：小机
格式：{cmd:demandMusic,voiceUrl:xxx,trackId:5,url:xxx}

开始播放点播
发起方：小机
接收方：服务器
格式：{cmd:startDemandMusic,trackId:5}

在线点播
发起方：服务器
接收方：小机
格式：{cmd:demandMusicOnline,trackId:5,url:xxx}



18.预置功能开发
1）初始化列表
发起方：小机
接收方：服务器
格式：{cmd:initTrackList,trackListId:0,name:xxx,trackIds:[1,2,3]}

{"cmd":"initTrackList","trackListId":0,"name":"国学","trackIds":[1,2,3,4,5]}

2)初始化结果
发起方：服务器
接收方：小机
格式：{cmd: initret,trackListId: 32,name:国学}


3)询问小机初始列表内容
发起方：页面
接收方：小机
格式：{"cmd":"getInitialTrackList","trackListId":32}

4)小机答复初始列表内容
发起方：小机
接收方：服务器
格式：{"cmd":"initialTrackList","trackListId":32,"trackIds":[1,2,3,4,5]}



19.设置播放模式
发起方：页面
接收方：小机
{ cmd:setMode, value:xxx}   xxx为 repeat one，repeat all

主动询问播放模式
发起方：页面
接收方：小机
格式：{ cmd:getMode}

播放模式变化，这里也包括主动询问后的答复
发起方：小机
接收方：页面
格式：{ mode:xxx}

播放表情
{cmd:playVoiceEmoji,voiceUrl:xxx}



OTA升级
{cmd:"upgrade","versionName":"xx","firmwareUrl":"xxx"}


开始升级
发起方：小机
接收方：服务器和页面
格式：{onlineStatus:off-for-upgrade}      （废弃{cmd:"startUpgrade"} ）


5)升级失败后重新上线
发起方：小机
接收方：服务器和页面
格式：{onlineStatus:on-upgrade-failed}    （废弃{upgradeResult:success} success/failed）

网络配置成功后的消息
{"configWifi":"success"}

让设备进入测试模式
{"cmd":"startTestMode","url":"xxx"}

设备测试完回传测试报告
{"cmd":"quitTestMode","content":"xxx"}


页面询问故事机列表内容
{"cmd":"getTracks","trackListId":x} x是大于0的整数（代表普通列表）和-1（代表在线列表）
故事机返回内容
{"cmd":"trackListContent","trackListId":x,"trackIds":[1,2,3]}

**** doc
http://blog.csdn.net/jiesa/article/details/50635222
MQTT Version 3.1.1
http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html
MQTT driver for cl-async
https://github.com/ivan4th/cl-mqtt
cl-async - Asynchronous operations for Common Lisp
http://quickdocs.org/cl-async/
(load "/Users/zhangdongfeng/quicklisp/dists/quicklisp/software/slime-v2.18/contrib/swank-listener-hooks.lisp")
Welcome to the libuv API documentation¶
http://docs.libuv.org/en/v1.x/


https://github.com/eclipse/mosquitto

https://mosquitto.org/download/

transfer-encoding:chunked的含义
http://blog.csdn.net/whatday/article/details/7571451

**** testcode
    (load "/Users/zhangdongfeng/quicklisp/dists/quicklisp/software/slime-v2.18/contrib/swank-listener-hooks.lisp")
    (ql:quickload 'cl-async-repl)
    (as-repl:start-async-repl)


brew services start mosquitto


(defun test-it (host port)
           (bb:alet ((conn (mqtt:connect
                            host
                            :port port
                            :on-message #'(lambda (message)
                                            (format t "~%RECEIVED: ~s~%"
                                                    (babel:octets-to-string
                                                     (mqtt:mqtt-message-payload message)
                                                     :encoding :utf-8))))))
             (bb:walk
               (mqtt:subscribe conn "/a/#")
               (mqtt:subscribe conn "/b/#")
               (mqtt:publish conn "/a/b" "whatever1")
               (mqtt:unsubscribe conn "/a/#")
               (mqtt:publish conn "/a/b" "whatever2")
               (mqtt:publish conn "/b/c" "foobar")
               (as:with-delay (1)
                 (mqtt:disconnect conn))))
           (values))



(test-it "120.76.40.40" 1883 "WWW18_46")
http://we.qq.com/d/
AQCb4nXBUj4HcGMN9ChjHlDCmgaPMjjXDgmNJbz6
WWW18_46

storybox/WWW18_46/server/#
storybox/WWW18_46/client

*** 在线播放音乐性能
在线播放音乐测试数据
1、	测试条件
Nbuf及tcp配置：
CONFIG_NET_NBUF_RX_COUNT=18	/* 接收头buf个数 */
CONFIG_NET_NBUF_TX_COUNT=8		/* 发送头buf个数 */
CONFIG_NET_NBUF_DATA_COUNT=18	/* 数据buf个数 */
每一个发送的数据需要一个RX buf和一个 DATA buf；
每个接收的数据包需要一个TX buf和一个DATA buf；
Tcp包长配置，MSS:1460，一个tcp包最大的负载数据长度。
Tcp windown: 1024*3（尝试过加大windown到1024*6，抗网络抖动效果与1024*3没差异）

测试网络：
采用公网接口使用android机子搭建http服务器：112.91.148.197，测试320kbs、192kbps码率

直接播放微信点播的音乐：测试32kbps码率，
http://fdfs.xmcdn.com/group15/M00/10/D7/wKgDZVVmyd2Qz25sAAQlePPVts4468.mp3

2、	在线播放音乐流畅条件
音乐码率（kbps）	每秒需要数据量（Kbyte）	每秒需要tcp包数（个）	每包平均间隔（ms）
32	4	2.8	357
192	24	16.8	59.5
320	40	28	35.7

3、	各种码率的分析
32kbps音乐：
没出现声音卡顿情况，即使使用平板连接相同ap，下载文件（下载速率到400Kbyte/s）
接收分配data buf有5%需要等待，回应ack分配data buf有50%需要等待，多数情况下data buf剩余0~2个，播放时看到最多剩余6个，收到很多非tcp的数据包，recv很多，ack回应很好，表示不是http获取的数据，出现tcp丢包情况也没导致声音卡顿。由于有很多非tcp的数据包，统计的接收包间隔参考性不大。

192kbps音乐：
在没有干扰情况下能流畅播放，制造干扰（平板连接相同ap下载文件，平板连接相同信道的其它ap下载文件，pc通过网线连接相同ap下载文件）会导致声音卡顿。流畅播放时，data buf剩余多为0个，接收、回应ack分配data buf约80%需要等待，等待从50~100ms不等，接收包间隔多数位于50~60ms，当出现多次间隔超100ms，很快就会产生声音卡顿。

320kbsp音乐：
在没有干扰情况下能流畅播放，制造干扰（平板连接相同ap下载文件，平板连接相同信道的其它ap下载文件，pc通过网线连接相同ap下载文件）会导致声音卡顿。流畅播放时，data buf剩余多为0个，接收、回应ack分配data buf约70%需要等待，等待时间多为20~50ms，接收包间隔多数位于20~50ms。

在播放高码率音乐时，在网络流畅情况下，data buf都被音频数据占住，导致网络收发数据需要等待data buf，只要网络流畅，数据包在时间上均匀到达，播放能流程。一旦出现网络延时，丢包，数据包不能及时到达，就会出现声音卡顿。

*** WIFI问题
+ airkiss配对时，获取到需要配对的ap及密码后，自动配对过程中出现找不到ap；
+ 连接上ap使用的时候，有时出现自动断开ap的连接；
+ wifi抢占信道资源的使用，资源有限，没能缓存较多数据，当wifi所在信道较多人使用时，wifi接收数据包产生延时，导致在线播放音乐卡顿，最好能增强wifi抢占信道资源的能力；
*** code
 void dump_mem(const void *buf, int size)
{
    int i;
    for (i = 0; i < size; i++ ) {
        printk("%02x ",*((unsigned char *)buf + i));
        if (i % 16 == 15) {
            printk("\n");
        }
    }

    printk("\n");
}
** 5116
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F3707F@srv-mail-02.actions.com.cn][US282F SDK培训(一)]]

** 3703
*** spec
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749063298B7@srv-mail-02.actions.com.cn][LS370A spec]]
请查收附件最新量产版本以及视频通话P2P开发文档。
[[mu4e:msgid:c29199ddc1534f1aaff425c78118a2ef@hobot.cc][答复: LS370A IOS支持集成准备]]
*** TODO [[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F7490625FE93@srv-mail-02.actions.com.cn][请帮忙统一开通下访问权限]]
*** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C3A6@srv-mail-02.actions.com.cn][发送电子邮件: LS370A_meminfo分析.xls]]
[[mu4e:msgid:27615070.3131.1495501734427.JavaMail.fwint2@srd-fw-share009][会议记录:关于工业级产品专项的信息进展沟通和讨论]]
*** nor 空间
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C3DF@srv-mail-02.actions.com.cn][答复: LS370A_统计nand存储空间分配]]

*** 发布tag
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906260D55@srv-mail-02.actions.com.cn][转发: LS370A集成完毕通知（TAG_LS370A_3400_170527）]]

*** 5118 plus 需求
** 5118+
定位：低端数码管蓝牙音箱市场
基本需求：GL5118+数码管+RTC+红外
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74905FF9BFF@srv-mail-02.actions.com.cn][答复: GL5118Plus对CPU速度和RAM增加的需求讨论]]
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0514425A@srv-mail-02.actions.com.cn][答复: GL5118B/GL5116C支持规格]]
*** romcode
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906260921@srv-mail-02.actions.com.cn][关于5118 的内存空间！]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906260B6A@srv-mail-02.actions.com.cn][答复: GL5118B 蓝牙固化代码调整相关讨论]]

** 5601
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F7490632A697@srv-mail-02.actions.com.cn][答复: 关于GL5601A版上增加cache机制的评估]]
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0514442A@srv-mail-02.actions.com.cn][移动端BLE APP需求讨论]]
*** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B051441D6@srv-mail-02.actions.com.cn][Nordic-Thingy-52 开发套件]]
*** 语音遥控器
[[mu4e:msgid:1B6B99321A9A92489ABE223C54DA0BAE2CCCC248@MAIL-AP.ampak.com.tw][RE: 答复: <矩芯/意天> 提供语音遥控器头端补丁]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749062606C0@srv-mail-02.actions.com.cn][cordio_ble4.2_传输性能]]
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B051441E1@srv-mail-02.actions.com.cn][Realtek8762的蓝牙遥控器头端的补丁]]
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0514433D@srv-mail-02.actions.com.cn][转发: 关于RFSEN的双向音频遥控器资料]]
*** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B051441D6@srv-mail-02.actions.com.cn][Nordic-Thingy-52 开发套件]]
*** cmsis dap
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D527B@srv-mail-02.actions.com.cn][答复: 5601_DAPLink（cmsis-dap）]]
l 支持CMSIS-DAP debug protocol：
Keil MDK/IAR Workbench/pyOCD都已经支持CMSIS-DAP，可以通过daplink进行
debug（单步、断点等）和load（hex文件烧写）。
l USB Disk drag and drop programming：
插上后Pc上弹出一个udisk。将bin/hex文件拖到udisk后自动完成烧写。
*暂时只支持16KB eeprom。
l USB Serial Port：
插上后Pc上会增加一个串口设备。
*串口打印数据较多时，会有数据丢失。
后续规划evb板可以集成这款daplink。
*** arm
**** UPF
ARM答复是我们如果做了比较大的代码修改，参加是有意义的

For our partners that are licensing our technology, they will already gain the benefits, since we attend them and put the fixes in our code.
Only if Actions is making heavy changes to our code, the it would make sense for them to attend.
What would be more valuable for them is to purchase 3rd party compliance testers. For RF there is R+S and Anritsu. For Link Layer, Ellisys.




Hi 深遠,
If you need more information on Bluetooth World/UPF, please feel free to let us know.

@ Bluetooth World Asia , please see :
https://www.bluetooth.com/news-events/events/2017/bluetooth-asia-2017

@ Bluetooth World, please see:
https://bluetoothworldevent.com/

@UPF, Please see our feedback as following:
UPF events are testing events to catch interoperability issues. We also find them to be good opportunities to network and to collaborate about the effects of new specification changes.
For our partners that are licensing our technology, they will already gain the benefits, since we attend them and put the fixes in our code.
Only if Actions is making heavy changes to our code, the it would make sense for them to attend.

*** 策略
发件人: 陶永耀
发送时间: 2017年3月6日 16:55
收件人: 黄少彬; 张天益; Connie Meng; 张东风; 魏华铭
抄送: 杨哲军; 阳昕; 易宏伟; 龚建; Chris Chang; 桂阳
主题: 答复: 关于智能珠宝-低功耗的传输

按我的理解先回答一下。
Pm和业务同样会遭遇类似的疑问，多给点理由，会是好事。^_^

1、	如果只是作为数据传输，需要的系统功耗并不大，因此RAM上动态功耗是会比Eflash小，但是不见得整体功耗优势会很大。只有对于有算法带宽需求的应用，功耗优势才会被放大。
Yytao：这个要看具体场景。确实要看有多少是在程序运行的，算系统功耗的占空比。

2、	对于beacon类应用，通常CPU此时是休眠的，beacon定期发送的数据（ADV）通常有BLE内部实现，无需叫醒主控。也就是说此时系统的功耗可能可以忽略。
Yytao：这个也要算下beacon代码运行的占空比。特别是定制需求的的beacon，还有带mesh的beacon。至少sram架构不会高于eflash，只是看有多明显的价值。

3、	个人的疑问，如果beacon用于替代说明书之类的东西，为何不采用二维码之类更简单且更低成本的做法？
Yytao：这个暂时只有二维码“更不易损坏”一条价值，ble比二维码的距离远的好处，暂时还突出不出来。^_^。这是广告推送的一种用法。


总之，ble这颗的需求排序：低功耗，大容量，低成本。
这三句话都是有条件来说的，推广的时候可以针对场景来强调：
在低成本对手中（一般也是nor结构），我们是低功耗的（功耗优化设计的单模的RF，和以sram运行程序的mem架构）。
在低功耗对手中，我们是大容量的（一般是128kbyte，我们是512kbyte），而且是低成本的（是nordic51822价格的80%）。
还有个重要前提，开发难度和nordic差异不大，工具链，量产流程都一样，不信就试试看！^_^
服务就更不用说，比nordic好，更超过dialog和ti。

*** info
发件人: 陶永耀
发送时间: 2017年3月6日 14:23
收件人: 张天益; Connie Meng; 张东风; 魏华铭
抄送: 杨哲军; 阳昕; 易宏伟; 龚建; 黄少彬; Chris Chang; 桂阳
主题: 关于智能珠宝-低功耗的传输


http://www.eet-china.com/news/article/201702280853?utm_source=EETC%20Article%20Alert&utm_medium=Email&utm_campaign=2017-03-01
巴菲特高调进入智能珠宝市场，可穿戴行业要变天？
•	2017年2月28日
智能珠宝，可能是穿戴式的一个重要分支。
从现在看最大量的51比52更有价值。
受益最大的应该是dialog和nordic的51822，Ti2541（但主要被51822打击）

关键是低功耗，mem的大小还不是最关键。
传统产品的，智能化升级是关键。有和没有的差别带来的天量。包括低功耗数传。
而功能多和少的差别，对量的影响次之，而且功耗会更大。

比如现在的心率，吃功耗和处理能力。主要还是运动人群用，使用受限。而且不准，量的增加不会多过低功耗的ble穿戴式设备。
至少我这么看。

所以我感觉发挥ble的本身的价值，低功耗的无线传输。会是一个主要的方向。再加上加密，数据安全（aes可被调用）。比如纽扣电池的蓝牙锁。
会比提升运算能力更有爆发力。

我打个比方，如果能在，16kbyte能解决的问题。一次把nor的程序load到程序中，基本数传的profile被rom化了。
可以做到比eflash运行程序更低的功耗。比eflash base的noric的51822更低。Wafer的制造成本也比eflash低了30%。
扩展性上，比dialog的14580的otp更有扩展性。

而且beacon的价值也是要沿着低功耗的传输来做。
比如之前google的提到的，不带说明的药盒，做成耗材，将成为天量。

看后续ble的产品是否可以沿这个方向做一些宣传和技术突破，看看价值。
这里需要更多的技术数据的支撑。

以上推测，来自两点基本前提（或假设）：
1，在sram运行程序，比eflash运行可大幅降低。比如30%。
2，不含eflash的制程比不带elfash制程可大幅便宜。比如30%
而且系统功耗占较大，常驻运行空间需求较低的场景。

至于如何找到功耗更低，容量小的低价norflash可以通过合作来达成，比如一年100M的单可以考虑定制flash容量和规格。
当然前提也是要有这样一类大的市场出现。可以用5601的市场推广来摸索一下这种可能性。
参考

*** 开发方式

**** spinor
rodata问题
+ rodata不能放在nor上， 而只能放在ram中， 放在ram中，
+ switch case， 以及literal pool, short string等也会需要访问data的page miss问题

搜了一下，keil编译器提供下面这个编译选项可以去除代码段中的数据
--execute_only

这个等效于加上了下面这几个编译选项
--no_integer_literal_pools.
--no_float_literal_pools.
--no_string_literal_pools.
--no_branch_tables.

相对于EFLASH方案， spi nor使用page miss的方式，在调试方式上有两点不同，
*bluetooh



+ 如果设置的断电刚好是nor上代码，设置的断点会停两次， 第一次停在E800，第二次才是正确的指令
+ 在单步调试nor上的代码的时候， 在debug窗口看到的都是e800 单步后，才会变成正确的指令
**** 使用感受
我就说一下我的这个想法吧：
1、从开发环境的使用角度来讲，使用的是keil集成开发环境，编译、下载都还挺方便的，和TI的IAR开发环境没啥差别。

2、调试手段可以用标准的Jlink，并且还可以通过打印调试，debug起来很容易。
从上面的感觉这比我以前用的泰凌微TLSR8266，要更好一些。

从ble的软件结构来看，这种事件驱动的前后台系统，和我以前用过的Ti的也差不多，这应该不是难点。

我们当前从eeprom或者flash中读取代码到ram中运行，但是这一点当前项目封装的还比较好，从应用层几乎看不到与从flash中直接运行的区别。

是否需要开发者过多的关心sct文件，也就是内存的分布问题，这一点我还不是太清楚。最好不要开发者过多的关心sct文件，否者就会增加开发的门槛。

另外，对硬件的操作我们应该提供尽量多的、完善的代码，这一点我们目前的sdk上有，不知道做的是不是灵活、完善。

目前就这些看法哈。
发件人: 魏华铭
发送时间: 2017年3月27日 16:25
收件人: 吴升
抄送: 张东风; 杨哲军; 陈元捷; 刘世军
主题: GL5601-SDK-使用感受
重要性: 高

Hi吴升：

         上周末学习使用GL5601-SDK感觉如何？

开发方式和你之前用过的TI有哪些区别？使用上是否有不方便的地方？学习难度是否合理？请帮忙列举出来。

谢谢！
* doc`
** WIFI
https://en.wikipedia.org/wiki/Wi-Fi
https://en.wikipedia.org/wiki/IEEE_802.11
** commn lisp
*** slime
https://www.common-lisp.net/project/slime/doc/html/index.html#SEC_Contents
*** perl正则表达式
**** 正则表达式中的常用模式
/pattern/  结果
. 匹配除换行符以外的所有字符
x? 匹配 0 次或一次 x 字符串
x* 匹配 0 次或多次 x 字符串，但匹配可能的最少次数
x+ 匹配 1 次或多次 x 字符串，但匹配可能的最少次数
.* 匹配 0 次或一次的任何字符
.+ 匹配 1 次或多次的任何字符
{m} 匹配刚好是 m 个 的指定字符串
{m,n} 匹配在 m个 以上 n个 以下 的指定字符串
{m,} 匹配 m个 以上 的指定字符串
[] 匹配符合 [] 内的字符
[^] 匹配不符合 [] 内的字符
[0-9] 匹配所有数字字符
[a-z] 匹配所有小写字母字符
[^0-9] 匹配所有非数字字符
[^a-z] 匹配所有非小写字母字符
^ 匹配字符开头的字符
$ 匹配字符结尾的字符
\d 匹配一个数字的字符，和 [0-9] 语法一样
\d+ 匹配多个数字字符串，和 [0-9]+ 语法一样
\D 非数字，其他同 \d
\D+ 非数字，其他同 \d+
\w 英文字母或数字的字符串，和 [a-zA-Z0-9] 语法一样
\w+ 和 [a-zA-Z0-9]+ 语法一样
\W 非英文字母或数字的字符串，和 [^a-zA-Z0-9] 语法一样
\W+ 和 [^a-zA-Z0-9]+ 语法一样
\s 空格，和 [\n\t\r\f] 语法一样
\s+ 和 [\n\t\r\f]+ 一样
\S 非空格，和 [^\n\t\r\f] 语法一样
\S+ 和 [^\n\t\r\f]+ 语法一样
\b 匹配以英文字母,数字为边界的字符串
\B 匹配不以英文字母,数值为边界的字符串
a|b|c 匹配符合a字符 或是b字符 或是c字符 的字符串
abc 匹配含有 abc 的字符串

(pattern) () 这个符号会记住所找寻到的字符串，是一个很实用的语法。第一个 () 内所找到的字符串变成 $1 这个变量或是 \1 变量，第二个 () 内所找到的字符串变成 $2 这个变量或是 \2 变量，以此类推下去。
/pattern/i i 这个参数表示忽略英文大小写，也就是在匹配字符串的时候，不考虑英文的大小写问题。

\ 如果要在 pattern 模式中找寻一个特殊字符，如 "*"，则要在这个字符前加上 \ 符号，这样才会让特殊字符失效
**** 范例 说明
/perl/ 找到含有 perl 的字符串
/^perl/ 找到开头是 perl 的字符串
/perl$/ 找到结尾是 perl 的字符串
/c|g|i/ 找到含有 c 或 g 或 i 的字符串
/cg{2,4}i/ 找到 c 后面跟着 2个到 4个 g ，再跟着 i 的字符串
/cg{2,}i/ 找到 c 后面跟着 2个以上 g ，再跟着 i 的字符串
/cg{2}i/ 找到 c 后面跟着 2个 g，再跟着 i 的字符串
/cg*i/ 找到 c 后面跟着 0个或多个 g ，再跟着 i 的字符串，如同/cg{0,1}i/
/cg+i/ 找到 c 后面跟着一个以上 g，再跟着 i 的字符串，如同/cg{1,}i/
/cg?i/ 找到 c 后面跟着 0个或是 1个 g ，再跟着 i 的字符串，如同/cg{0,1}i/
/c.i/ 找到 c 后面跟着一个任意字符，再跟着 i 的字符串
/c..i/ 找到 c 后面跟着二个任意字符，再跟着 i 的字符串
/[cgi]/ 找到符合有这三个字符任意一个的字符串
/[^cgi]/ 找到没有这三个字符中任意一个的字符串
/\d/ 找寻符合数字的字符，可以使用/\d+/来表示一个或是多个数字组成的字符串
/\D/ 找寻符合不是数字的字符，可以使用/\D+/来表示一个或是更多个非数字组成的字符串
/\*/ 找寻符合 * 这个字符，因为 * 在常规表达式中有它的特殊意思，所以要在这个特殊符号前加上 \ 符号，这样才会让这个特殊字符失效
/abc/i 找寻符合 abc 的字符串而且不考虑这些字符串的大小写

*** quicklisp
***** yason
(defvar *json-string* "[{\"foo\":1,\"bar\":[7,8,9]},2,3,4,[5,6,7],true,null]")
(let* ((result (yason:parse *json-string*)))
  (print result)
  (alexandria:hash-table-plist (first result)))

(yason:encode
 (list (alexandria:plist-hash-table
        '("foo" 1 "bar" (7 8 9))
        :test #'equal)
       2 3 4
       '(5 6 7)
       t nil)
 *standard-output*)

(yason:with-output (*standard-output*)
  (yason:with-object ()
    (yason:encode-object-element "hello" "hu hu")
    (yason:with-object-element ("harr")
      (yason:with-array ()
        (dotimes (i 3)
          (yason:encode-array-element i))))))
(yason:with-output (*standard-output*)
  (yason:with-array ()
    (dotimes (i 3)
      (yason:encode-array-element i))))

(yason:encode
 (alexandria:plist-hash-table
  '("format"  "pcm" "rate" "8000" "channel" "1"
    "cuid" "serial987654321"
    "speech" "len")
  :test #'equal)
 *standard-output*)
***** cl-async
  http://orthecreedence.github.io/cl-async/documentation
  (load "/Users/zhangdongfeng/quicklisp/dists/quicklisp/software/slime-v2.18/contrib/swank-listener-hooks.lisp")
  (as:start-event-loop
          (lambda ()
            (format t "Exiting event loop.~%")))
(as:start-event-loop
          (lambda ()
            (as:delay
             (lambda ()
               (format t "Timer fired. Exiting.~%"))
             :time 3)))

(defun my-echo-server ()
  (format t "Starting server.~%")
  (as:tcp-server nil 9003  ; nil is "0.0.0.0"
                 (lambda (socket data)
                   ;; echo the data back into the socket
                   (as:write-socket-data socket data))
                 (lambda (err) (format t "listener event: ~a~%" err)))
  ;; catch sigint
  (as:signal-handler 2 (lambda (sig)
                         (declare (ignore sig))
                         (as:exit-event-loop))))

(as:start-event-loop #'my-echo-server)

(ql:quickload :cl-async)

(defun do-lookups ()
  (dolist (lookup `(("google.com")
                    ("musio.com" . ,as:+af-inet+)
                    ("www.google.com" . ,as:+af-inet6+)))
    (let ((host (car lookup))
          (family (if (cdr lookup) (cdr lookup) as:+af-unspec+)))
      (as:dns-lookup host
                     (lambda (addr fam)
                       (declare (ignore fam))
                       (format t "~a resolved to ~s (~s)~%" host addr family))
                     :event-cb (lambda (ev)
                                 (format t "ev: ~a(~a): ~a~%" host family ev))
                     :family family))))

(as:start-event-loop #'do-lookups)



(defun get-http-response (host &optional (port 80))
  (as:tcp-connect host port
    (lambda (sock data)
      (unless (as:socket-closed-p sock)
        (as:close-socket sock))
      (format t "~a" (babel:octets-to-string data)))
    (lambda (ev)
      (format t "ev: ~a~%" ev))
    :data (format nil "GET / HTTP/1.1~c~cHost: ~a~c~c~c~c"
                  #\return #\newline
                  host
                  #\return #\newline
                  #\return #\newline)
    :read-timeout 5))

(as:start-event-loop (lambda () (get-http-response "www.baidu.com")))
***** sb-textinfo

http://nikodemus.github.io/sb-texinfo/
https://github.com/sionescu/texinfo-docstrings

(sb-texinfo:generate-includes #p "/Users/zhangdongfeng/quicklisp/dists/quicklisp/software/babel-20150608-git/doc/include/" (list :babel :babel-streams :babel-tests))
***** roswell
https://github.com/roswell/roswell\

https://github.com/roswell/roswell/wiki/0.-FAQ


ros install elf
~/.roswell/local-projects
ln -s ~/quicklisp/local-projects/ ~/.roswell/local-projects


ros init
ros init test

#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#

(defun fact (n)
  (if (zerop n)
      1
      (* n (fact (1- n)))))

(defun main (n &rest argv)
  (declare (ignore argv))
  (format t "~&Factorial ~D = ~D~%" n (fact (parse-integer n))))

./test.ros 3
ros build test.ros
***** cl-project
(cl-project:make-project #p"~/.roswell/local-projects/cl-demo/"
                                  :depends-on '(:clack :cl-annot))
https://github.com/fukamachi/cl-project
http://labs.ariel-networks.com/cl-style-guide.html

***** flexi-streams

https://github.com/edicl

 unicode, utf-8, codepage的含义 以及 相互关系
http://blog.csdn.net/normallife/article/details/8548306

http://weitz.de/flexi-streams/

utf8汉字编码16进制对照
http://blog.chinaunix.net/uid-25544300-id-3281847.html

(defun bar (pathspec)
        "With a flexi stream."
        (with-open-file (out pathspec
                             :direction :output
                             :if-exists :supersede
                             :element-type 'octet
                                        ;:external-format '(:latin-1 :eol-style :lf)
                             )
          (setq out (make-flexi-stream out :external-format :utf-8))
          (write-line "ÄÖÜ1" out)
          (setf (flexi-stream-external-format out) '(:latin-1 :eol-style :lf))
          (write-line "ÄÖÜ2" out)
          (write-byte #xeb out)
          (write-byte #xa3 out)
          (write-byte #xa4 out)
          (write-byte #xa5 out)
                                        ;          (write-sequence #(#xa3 #xa4 #xa5) out)
          (setf (flexi-stream-external-format out) :ucs-2be)
          (write-line "ÄÖÜ3" out)))

(defun baz (pathspec)
        (let (result)
          (with-open-file (in pathspec :element-type 'octet)
            (setq in (make-flexi-stream in :external-format :utf-8))
            (push (read-line in) result)
            (push (read-byte in) result)
            (setf (flexi-stream-external-format in) '(:latin-1 :eol-style :lf))
            (push (read-line in) result)
            (setf (flexi-stream-external-format in) :greek)
            (push (read-char in) result)
            (setf (flexi-stream-external-format in) :latin0)
            (let ((string (make-string 3 :element-type 'character)))
              (read-sequence string in)
              (push string result))
            (let ((octets (make-array 2 :element-type 'octet)))
              (read-sequence octets in)
              (push octets result))
            (setf (flexi-stream-external-format in) :ucs-2be)
            (push (read-line in) result))
          (nreverse result)))

***** CFFI
https://common-lisp.net/project/cffi/manual/html_node/
 (defpackage :cffi-user
    (:use :common-lisp :cffi))
  (in-package :cffi-user)
  (define-foreign-library libcurl
    (:darwin (:or "libcurl.3.dylib" "libcurl.dylib"))
    (:unix (:or "libcurl.so.3" "libcurl.so"))
    (t (:default "libcurl")))
  (use-foreign-library libcurl)

  (defctype curl-code :int)
  ;;; Initialize libcurl with FLAGS.
  (defcfun "curl_global_init" curl-code
    (flags :long))
(curl-global-init 0)
(defcfun "curl_easy_init" :pointer)

  (defcfun "curl_easy_cleanup" :void
    (easy-handle :pointer))
(defparameter *easy-handle* (curl-easy-init))

(defmacro define-curl-options (name type-offsets &rest enum-args)
    (flet ((enumerated-value (type offset)
             (+ (getf type-offsets type) offset)))
      `(progn
         (defcenum ,name
           ,@(loop for (name type number) in enum-args
                collect (list name (enumerated-value type number))))
         ',name)))                ;for REPL users' sanity

  (define-curl-options curl-option
      (long 0 objectpoint 10000 functionpoint 20000 off-t 30000)
    (:noprogress long 43)
    (:nosignal long 99)
    (:errorbuffer objectpoint 10)
    (:url objectpoint 2))

(foreign-funcall "curl_easy_setopt"
               :pointer *easy-handle*
               curl-option :nosignal :long 1 curl-code)

 (defctype easy-handle :pointer)

 (defmacro curl-easy-setopt (easy-handle enumerated-name
                              value-type new-value)
    `(foreign-funcall "curl_easy_setopt" easy-handle ,easy-handle
                      curl-option ,enumerated-name
                      ,value-type ,new-value curl-code))
** share lib 空间优化
https://stackoverflow.com/questions/31354641/c-reduce-library-size-by-excluding-unnecessary-functions-programmatically
https://stackoverflow.com/questions/8021470/how-to-optimize-size-of-shared-library

*** elf
https://docs.oracle.com/cd/E19683-01/817-3677/6mj8mbtc9/index.html#chapter6-73709

** LInux网站
*** mail list
搜素patch 得到日期
http://www.gossamer-threads.com/lists/linux/kernel/
通过日期+1查找archiver
https://lkml.org/
http://vger.kernel.org/lkml/
*** linux actions upstreaming
https://git.kernel.org/pub/scm/linux/kernel/git/afaerber/linux-actions.git/log/?h=v4.13/arm
*** other
https://git.kernel.org/cgit/
http://kernelnewbies.org/
http://www.tux.org/lkml/
http://lwn.net/
http://linux-mm.org/
http://stackoverflow.com
http://askubuntu.com/
http://gmane.org  邮件列表
http://en.wikipedia.org/wiki/Unix_philosophy
http://blog.csdn.net/21cnbao?viewmode=contents
http://lxr.free-electrons.com/
http://www.linuxfromscratch.org
https://0xax.gitbooks.io/linux-insides/content/Concepts/per-cpu.html
linux inside book
https://www.gitbook.com/book/0xax/linux-insides
http://advdbg.org
** LInux distribution
*** general
https://en.wikipedia.org/wiki/Linux_distribution
https://en.wikipedia.org/wiki/DistroWatch
https://en.wikipedia.org/wiki/Comparison_of_Linux_distributions
**** C standard library
https://en.wikipedia.org/wiki/C_standard_library
C date and time functions
https://en.wikipedia.org/wiki/C_date_and_time_functions
https://en.wikipedia.org/wiki/UClibc
https://git.uclibc.org/uClibc/
http://www.kumouse.com/?p=1051
***** Comparison of C/POSIX standard library implementations for Linux
http://www.etalabs.net/compare_libcs.html
***** android
https://en.wikipedia.org/wiki/Hybris_(software)


**** Lightweight Linux distribution
https://en.wikipedia.org/wiki/Lightweight_Linux_distribution
***** Tiny Core Linux
https://en.wikipedia.org/wiki/Tiny_Core_Linux
http://tinycorelinux.net
"Tiny Core" (16 MB) is the recommended option for new users who have a wired network connection. It includes the base Core system and a dynamic FLTK/FLWM graphical user interface.[4]

"Core" (11 MB) (also known as "Micro Core Linux") is a smaller variant of Tiny Core without a graphical desktop, though additional extensions can be added to create a system with a graphical desktop environment.[4]

"dCore" (12 MB) is a core made from Debian or Ubuntu compatible files that uses import and the SCE package format,[5] a self-contained package format for the Tiny Core distribution since 5.x series.

"CorePure64" is a notable port of "Core" to the x86_64 architecture.

"Core Plus" (106 MB) is "an installation image and not the distribution".[4] It is composed of Tiny Core with additional functionality, most notably wireless support and non-US keyboard support.[4]

"piCore" is the Raspberry Pi port of "Core."
****** FLTK
https://en.wikipedia.org/wiki/FLTK
The Fast Light Toolkit (FLTK, pronounced fulltick)[3] is a cross-platform widget (graphical control element) library for graphical user interfaces (GUIs), developed by Bill Spitzak and others. Made to accommodate 3D graphics programming, it has an interface to OpenGL, but it is also suitable for general GUI programming.
****** FLWM
The Fast Light Window Manager is a stacking window manager written in C++ and available for redistribution under the terms of the GNU General Public Licence. FLWM is the default window manager for Tiny Core Linux.

**** Linux on embedded systems
***** Buildroot
https://en.wikipedia.org/wiki/Buildroot
***** Yocto Project
https://en.wikipedia.org/wiki/Yocto_Project
The Yocto Project is a Linux Foundation workgroup whose goal is to produce tools and processes that will enable the creation of Linux distributions for embedded software that are independent of the underlying architecture of the embedded software itself.

The project offers different sized targets from "tiny" to fully featured images which are configurable and customisable by the end user. The project encourages interaction with upstream projects and has contributed heavily to OpenEmbedded-Core and BitBake as well as to numerous upstream projects, including the Linux kernel.[citation needed] The resulting images are typically useful in systems where embedded Linux would be used, these being single-use focused systems or systems without the usual screens/input devices associated with desktop Linux systems.

As well as building Linux systems, there is also an ability to generate a toolchain for cross compilation and a software development kit (SDK) tailored to their own distribution, also referred to as the Application Developer Toolkit (ADT). The project tries to be software and vendor agnostic. Thus, for example, it is possible to select which package manager format to use (deb, rpm, or ipk).
***** Deciding between Buildroot & Yocto
https://lwn.net/Articles/682540/
Buildroot, he said, focuses on simplicity. The core Buildroot tool is kept as small and as simple as possible, which makes it easy to use and understand. All special cases are handled in extensions, and Buildroot re-uses existing tools like kconfig wherever possible. Thus, he said, learning Buildroot means learning tools that are applicable in other scenarios.

Belloni continued, Yocto tries to be versatile and support a wide range of embedded systems. It does that by defining builds in recipes, which specify what software to build and how to build it, and by supporting layers, which are recipe collections written and maintained by the development community. Layers allow the community to support new boards or architectures, define new application stacks, or support entirely new use cases. By relying on cleanly defined layers, the default system image defined can remain small.

First, Buildroot currently supports a smaller set of available packages—a little over 1800. The list includes all of the core options one would expect, from graphics layers to application toolkits to multimedia frameworks and programming languages. But it is a curated list of packages and, notably, it does not include any development tools (e.g., compilers and linkers) to run on the target system. Buildroot targets are meant to be the end product, not the development system. Yocto, however, does provide target toolchains—and much more. About 8400 packages are available in total, including some of questionable value for current systems, like Qt 3. But there are packages for more programming languages, including some like Go and Rust that are not available for Buildroot, and there are layers available for many containerization and virtualization frameworks (use cases that are outside of Buildroot's scope).

Dependency handling differs as well. Buildroot again takes a minimalist approach: whenever a new package is added, it is built with as many features disabled as possible. That allows the creation of small footprints: the minimal image is just 2MB. But Buildroot does include a number of automatic dependencies, Petazzoni said. For instance, adding OpenSSL to the configuration will automatically add SSL support for other packages that include an SSL option. In Yocto, package configuration is done at the distribution layer: enabling SSL support enables it for every package by default, although it can still be disabled for individual packages (or enabled for individual packages, if it is set to be off by default). These dependencies can be overridden at the machine-configuration level, but that is considered bad practice.

***** OpenEmbedded
https://en.wikipedia.org/wiki/OpenEmbedded
OpenEmbedded is a software framework used for creating Linux distributions aimed for, but not restricted to, embedded devices. The build system is based on BitBake recipes,[2] which behave like Gentoo Linux ebuilds.

Recipes in the old OpenEmbedded-Classic were all found in one place. In the new OpenEmbedded-Core, the structure has changed into meta layers[3][4] to make adding custom recipes easier.
**** Linux From Scratch
https://en.wikipedia.org/wiki/Linux_From_Scratch
List of Linux distributions
https://en.wikipedia.org/wiki/List_of_Linux_distributions
Filesystem Hierarchy Standard
https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard
https://en.wikipedia.org/wiki/Linux_Standard_Base
***** Embedded Linux Wiki
http://elinux.org/Main_Page
***** OpenRC
https://en.wikipedia.org/wiki/OpenRC
https://en.wikipedia.org/wiki/Linux_for_mobile_devices

**** GUI
***** X Window System
https://en.wikipedia.org/wiki/X_Window_System

The X Window System (X11, or shortened to simply X) is a windowing system for bitmap displays, common on UNIX-like computer operating systems.

X provides the basic framework for a GUI environment: drawing and moving windows on the display device and interacting with a mouse and keyboard. X does not mandate the user interface – this is handled by individual programs. As such, the visual styling of X-based environments varies greatly; different programs may present radically different interfaces.
****** Software architecture
X uses a client–server model: an X server communicates with various client programs. The server accepts requests for graphical output (windows) and sends back user input (from keyboard, mouse, or touchscreen). The server may function as:
+ an application displaying to a window of another display system
+ a system program controlling the video output of a PC
+ a dedicated piece of hardware
This client–server terminology – the user's terminal being the server and the applications being the clients – often confuses new X users, because the terms appear reversed. But X takes the perspective of the application, rather than that of the end-user: X provides display and I/O services to applications, so it is a server; applications use these services, thus they are clients.

The communication protocol between server and client operates network-transparently: the client and server may run on the same machine or on different ones, possibly with different architectures and operating systems. A client and server can even communicate securely over the Internet by tunneling the connection over an encrypted network session.

To use an X client application on a remote machine, the user may do the following:

+ on the local machine, open a terminal window
+ use ssh with the X forwarding argument to connect to the remote machine
+ request local display/input service (e.g., export DISPLAY=[user's machine]:0 if not using SSH with X forwarding enabled)
The remote X client application will then make a connection to the user's local X server, providing display and input to the user.

****** X Window System core protocol
https://en.wikipedia.org/wiki/X_Window_System_core_protocol
******* Overview[edit]
Communication between server and clients is done by exchanging packets over a channel. The connection is established by the client (how the client is started is not specified in the protocol). The client also sends the first packet, containing the byte order to be used and information about the version of the protocol and the kind of authentication the client expects the server to use. The server answers by sending back a packet stating the acceptance or refusal of the connection, or with a request for a further authentication. If the connection is accepted, the acceptance packet contains data for the client to use in the subsequent interaction with the server.

After connection is established, four types of packets are exchanged between client and server over the channel:

+ Request: The client requests information from the server or requests it to perform an action.
+ Reply: The server responds to a request. Not all requests generate replies.
+ Event: The server informs the client of an event, such as keyboard or mouse input, a window being moved, resized or exposed, etc.
+ Error: The server sends an error packet if a request is invalid. Since requests are queued, error packets generated by a request may not be sent immediately.
Request and reply packets have varying length, while event and error packets have a fixed length of 32 bytes.

Request packets are numbered sequentially by the server as soon as it receives them: the first request from a client is numbered 1, the second 2, etc. The least significant 16 bits of the sequential number of a request is included in the reply and error packets generated by the request, if any. They are also included in event packets to indicate the sequential number of the request that the server is currently processing or has just finished processing.
******** xlib
https://en.wikipedia.org/wiki/Xlib

****** Competitors
Android which runs on the Linux kernel, uses its own system for drawing the user interface known as SurfaceFlinger. 3D rendering is handled by EGL.

Wayland is being developed by several X.Org developers as a prospective replacement for X. It works directly with the GPU hardware, via DRI. Wayland can run an X.org server as a client, which can be rootless.[13] A proprietary port of the Wayland backend to the Raspberry Pi was completed in 2013.[14] The project reached version 1.0 in 2012. Like Android, Wayland is EGL-based.

Mir is a project from Canonical Ltd. with goals similar to Wayland.[15] Mir is intended to work with mobile devices using ARM chipsets (a stated goal is compatibility with Android device-drivers) as well as x86 desktops. Like Android, Mir/UnityNext are EGL-based. Backwards compatibility with X client-applications is accomplished via Xmir.

Other alternatives attempt to avoid the overhead of X by working directly with the hardware; such projects include DirectFB.[16] (The Direct Rendering Infrastructure (DRI), which aims to provide a reliable kernel-level interface to the framebuffer, might[citation needed] make these efforts redundant.)

***** Window manager
https://en.wikipedia.org/wiki/Window_manager
When a window manager is running, some kinds of interaction between the X server and its clients are redirected through the window manager. In particular, whenever an attempt to show a new window is made, this request is redirected to the window manager, which decides the initial position of the window. Additionally, most modern window managers are reparenting, which usually leads to a banner being placed at the top of the window and a decorative frame being drawn around the window. These two elements are controlled by the window manager rather than the program. Therefore, when the user clicks or drags these elements, it is the window manager that takes the appropriate actions (such as moving or resizing the window).
****** Comparison of X window managers
https://en.wikipedia.org/wiki/Comparison_of_X_window_managers
****** Compositing window manager
https://en.wikipedia.org/wiki/Compositing_window_manager
A compositing window manager, or compositor, is a window manager that provides applications with an off-screen buffer for each window. The window manager composites the window buffers into an image representing the screen and writes the result into the display memory.[1][2]
Compositing window managers may perform additional processing on buffered windows, applying 2D and 3D animated effects such as blending, fading, scaling, rotation, duplication, bending and contortion, shuffling, blurring, redirecting applications, and translating windows into one of a number of displays and virtual desktops. Computer graphics technology allows for visual effects to be rendered in real time such as drop shadows, live previews, and complex animation.[3][4] Since the screen is double buffered, it does not flicker during updates

******* AIGLX
Accelerated Indirect GLX ("AIGLX") is an open source project founded by Red Hat and the Fedora community, led by Kristian Høgsberg,[1] to allow accelerated indirect GLX rendering capabilities to the X.Org Server and DRI drivers. This allows remote X clients to get fully hardware accelerated rendering over the GLX protocol; coincidentally, this development was required for OpenGL compositing window managers to function with hardware acceleration.

******* GLX
GLX (initialism for "OpenGL Extension to the X Window System") is an extension to the X Window System core protocol providing an interface between OpenGL and the X Window System as well as extensions to OpenGL itself. It enables programs wishing to use OpenGL to do so within a window provided by the X Window System. GLX distinguishes two "states": indirect state and direct state.

******** GLX consists of three parts:

An API that provides OpenGL functions to an X Window System application.
An extension of the X protocol, which allows the client (the OpenGL application) to send 3D rendering commands to the X server (the software responsible for the display). The client and server software may run on different computers.
An extension of the X server that receives the rendering commands from the client and passes them on to the installed OpenGL library
If client and server are running on the same computer and an accelerated 3D graphics card using a suitable driver is available, the former two components can be bypassed by DRI. In this case, the client application is then allowed to directly access the video hardware through several API layers.

******* Hardware overlay
https://en.wikipedia.org/wiki/Hardware_overlay
******* Chroma key
https://en.wikipedia.org/wiki/Chroma_key

****** Stacking window manager
A stacking window manager (also called floating window manager) is a window manager that draws all windows in a specific order, allowing them to overlap, using a technique called painter's algorithm. All window managers that allow the overlapping of windows but are not compositing window managers are considered stacking window managers, although it is possible that not all use exactly the same methods. Other window managers that are not considered stacking window managers are those that do not allow the overlapping of windows, which are called tiling window managers.[1]

Stacking window managers allow windows to overlap by drawing them one at a time. Stacking, or repainting (in reference to painter's algorithm) refers to the rendering of each window as an image, painted directly over the desktop, and over any other windows that might already have been drawn, effectively erasing the areas that are covered. The process usually starts with the desktop, and proceeds by drawing each window and any child windows from back to front, until finally the foreground window is drawn.[2]
The order in which windows are to be stacked is called their z-order.

***** Display server
https://en.wikipedia.org/wiki/Display_server
A display server or window server is a program whose primary task is to coordinate the input and output of its clients to and from the rest of the operating system, the hardware, and each other. The display server communicates with its clients over the display server protocol, a communications protocol, which can be network-transparent or simply network-capable.
****** List of display servers
https://en.wikipedia.org/wiki/List_of_display_servers

****** X11
One example of a display server is the X.Org Server, which runs on top of the kernel (usually a Unix-based kernel, such as Linux or BSD). It receives data from evdev and passes it to one of its clients. The display server also receives data from its clients; it processes the data, it does the compositing and passes the data to one of three kernel components – DRM, gem or KMS driver. The component writes the data into the framebuffer and content of the framebuffer is transmitted to the connected screen and displayed. X relies on GLX.

One of the implementations of display server concept is X Window System, in particular its actually used version – X.Org Server and Xlib and XCB client libraries. The X.Org Server is a display server, but in its current implementation it relies on a second program, the compositing window manager, to do the compositing. Examples are Mutter or KWin.

******* X display manager (program type)
https://en.wikipedia.org/wiki/X_display_manager_(program_type)
In the X Window System, an X display manager is a graphical login manager which starts a session on an X server from the same or another computer.

A login screen shown by the KDM display manager.
A display manager presents the user with a login screen. A session starts when a user successfully enters a valid combination of username and password.

******** Local and remote display management[edit]
A display manager can run on the same computer where the user sits—starting one or more X servers, displaying the login screen at the beginning and (optionally) every time the user logs out—or on a remote one, working according to the XDMCP protocol.

In the X Window System, the X server runs on the computer in front of the user. The X server may connect to a display manager running on another computer, starting a session which may comprise a variety of programs running on that other computer.

The XDMCP protocol mandates that the X server starts autonomously and connects to the display manager. In the X Window System paradigm, the server runs on the computer providing the display and input devices. A server can connect, using the XDMCP protocol, to a display manager running on another computer, requesting it to start the session. In this case, the X server acts as a graphical telnet client while the display manager acts like a telnet server: users start programs from the computer running the display manager, while their input and output take place on the computer where the server (and the user) sits.
***** X.Org Server
https://en.wikipedia.org/wiki/X.Org_Server
X.Org Server is the free and open source implementation of the display server for the X Window System stewarded by the X.Org Foundation.

Implementations of the client side of the protocol are available e.g. in the form of Xlib and XCB.
****** Device Independent X (DIX)[edit]
The Device Independent X (DIX) is the part of the X.Org Server that interacts with clients and implements software rendering. Basically everything in the server except for the hw/ directory. The main loop and the event delivery are part of the DIX.[6]
An X server has a tremendous amount of functionality that must be implemented to support the X core protocol. This includes code tables, glyph rasterization and caching, XLFDs, and the entire core rendering API that draws stippled lines, polygons, wide arcs and many more state-of-the-1980s style graphics primitives.
****** Device Dependent X (DDX)[edit]
The Device Dependent X (DDX) is the part of the x-server that interacts with the hardware. In the X.Org Server source code, each directory under "hw" corresponds to one DDX. Hardware comprises graphics cards as well as mouse and keyboards. Each driver is hardware specific and implemented as a separate loadable module.
******* 2D graphics driver
For historical reasons the X.Org Server still contains graphics device drivers supporting some form of 2D rendering acceleration. In ancient times, the mode-setting was done by some x-server graphics device drivers specific to some video controller/graphics card. To this mode-setting functionality, additional support for 2D acceleration was added when such became available with various GPUs. The mode-setting functionality was moved into the DRM and is being exposed through an DRM mode-setting interface, the new approach being called "kernel mode-setting" (KMS). But the 2D rendering acceleration remained.

****** Wayland
Display servers that implement the Wayland display server protocol, are called Wayland compositors. Like any display server, a Wayland compositor is responsible for handling input and output for its clients and – in contrast to X11 – additionally for the compositing. Examples are Weston, Mutter, KWin or Enlightenment.

Wayland compositors communicate with Wayland clients over the Wayland display server protocol. This protocol defines that clients can directly write data into the framebuffer using the EGL rendering API. The display server still gets to decide which window is on top and thus visible to the user and also still is responsible for passing data regarding to input devices from evdev to its clients.

******* Wayland (display server protocol)
https://en.wikipedia.org/wiki/Wayland_(display_server_protocol)
https://wayland.freedesktop.org
Wayland is a computer protocol that specifies the communication between a display server (called a Wayland compositor[clarification needed]) and its clients, as well as a reference implementation of the protocol in the C programming language.[7]

Wayland is developed by a group of volunteers initially led by Kristian Høgsberg as a free and open community-driven project with the aim of replacing the X Window System with a modern, simpler windowing system in Linux and other Unix-like operating systems.[7] The project's source code is published under the terms of the MIT License, a permissive free software licence.[8][4]
******** Mutter (software)
https://en.wikipedia.org/wiki/Mutter_(software)
Mutter is a window manager initially designed and implemented for the X Window System, and recently has evolved to be a Wayland compositor. It became the default window manager in GNOME 3, replacing Metacity[5] which used GTK+ for rendering. Mutter uses a graphics library called Clutter giving it OpenGL capability. The name is a portmanteau of Metacity and Clutter.

******** KWin
https://en.wikipedia.org/wiki/KWin
KWin is a window manager for the X Window System and is currently in the process of becoming a Wayland compositor.[3] It is released as part of KDE Plasma 5 for which it is the default window manager. KWin can also be used on its own or with other desktop environments.

******** Enlightenment (software)
https://en.wikipedia.org/wiki/Enlightenment_(software)

******** Mesa (computer graphics)
Mesa is an open-source implementation of the OpenGL, Vulkan and other specifications. Its most important user surfacing parts are the two graphics drivers mostly developed and funded by Intel and AMD, which are using those implementations. The smaller GeForce graphics driver Nouveau in contrast is mostly a community effort. Mesa implements a cross-language, cross-platform (mostly on BSD and Linux distributions), vendor-neutral standard API for interfacing with diverse vendor-specific graphics hardware drivers.

****** Mir
The Mir display server comes with its own Mir display server protocol different from the protocols X11 or Wayland. Mir will additionally support the X11 and maybe the Wayland protocol. It was developed by Canonical and was intended to be the display server of choice for Ubuntu.
******* Mir (software)
https://en.wikipedia.org/wiki/Mir_(software)
Mir is a computer display server for the Linux operating system that is under development by Canonical Ltd. It was planned to replace the currently used X Window System for Ubuntu.
****** SurfaceFlinger
For Android (another Linux kernel-based operating system primarily for mobile devices) Google developed a display server called SurfaceFlinger:[2]

Everything in Android is rendered to a "surface"; "surfaces" are produced by applications and placed into a queue that is managed by SurfaceFlinger.[3][4]
****** DirectFB
https://en.wikipedia.org/wiki/DirectFB
http://www.directfb.org

DirectFB (Direct Frame Buffer) is a software library with a small memory footprint that provides graphics acceleration, input device handling and abstraction layer, and integrated windowing system with support for translucent windows and multiple display layers on top of the Linux framebuffer without requiring any kernel modifications.[2] DirectFB is free and open-source software subject to the terms of the GNU Lesser General Public License (LGPL).

DirectFB can host XDirectFB, a rootless X server implementation that uses DirectFB windows for X11 top-level windows. XDirectFB is an interface that mimics the X11 interface through the DirectFB API to simplify running applications written for X11 on DirectFB.[4]
DirectFBGL is an OpenGL extension for DirectFB/XDirectFB that uses Direct Rendering Infrastructure (DRI) in the Mesa 3D library to support OpenGL hardware acceleration.

******* Linux framebuffer
https://en.wikipedia.org/wiki/Linux_framebuffer
The Linux framebuffer (fbdev) is a graphic hardware-independent abstraction layer to show graphics on a computer monitor, typically on the console.[1] The word framebuffer means a part of video memory containing a current video frame, and the Linux framebuffer means “access method to the framebuffer under the Linux kernel”, without relying on system-specific libraries such as SVGALib or another user space software.
******** There are three applications of the Linux framebuffer.
+ An implementation of text Linux console that doesn't use hardware text mode (useful when that mode is unavailable, or to overcome its restrictions on glyph size, number of code points etc.). One popular aspect of this is the ability to have console show the Tux logo at boot up.
+ A possible graphic output method for a display server, independent of video adapter hardware and its drivers.
+ Graphic programs avoiding the heavy overhead of the X Window System.

Examples of the third application include Linux programs such as MPlayer, links2, Netsurf, fbida,[2] and fim [3] and libraries such as GGI, SDL, GTK+, and Qt, which can all use the framebuffer directly. This use case is particularly popular in embedded systems.

The now defunct DirectFB is another project aimed at providing a framework for hardware acceleration of the Linux framebuffer.
There was also a windowing system called FramebufferUI (fbui) implemented in kernel-space that provided a basic 2D windowing experience with very little memory use.[4]

***** Direct Rendering Manager
https://en.wikipedia.org/wiki/Direct_Rendering_Manager
In computing, the Direct Rendering Manager (DRM), a subsystem of the Linux kernel, interfaces with the GPUs of modern video cards. DRM exposes an API that user-space programs can use to send commands and data to the GPU, and to perform operations such as configuring the mode setting of the display. DRM was first developed as the kernel space component of the X Server's Direct Rendering Infrastructure,[1] but since then it has been used by other graphic stack alternatives such as Wayland.
User-space programs can use the DRM API to command the GPU to do hardware-accelerated 3D rendering and video decoding as well as GPGPU computing.
****** Direct Rendering Infrastructure (DRI)
https://en.wikipedia.org/wiki/Direct_Rendering_Infrastructure
The Direct Rendering Infrastructure (DRI) is a framework for allowing direct access to graphics hardware under the X Window System in a safe, efficient way.[6] The main use of DRI is to provide hardware acceleration for the Mesa implementation of OpenGL. DRI has also been adapted to provide OpenGL acceleration on a framebuffer console without a display server running

DRI implementation is scattered through the X Server and its associated client libraries, Mesa 3D and the Direct Rendering Manager kernel subsystem.[6] All of its source code is free software.
******* Overview
X clients should have direct access to graphics hardware rather than relying on a third party process to do so, saving all the IPC overload. This approach is called "direct rendering" as opposed to the "indirect rendering" provided by the classical X architecture. The Direct Rendering Infrastructure was initially developed to allow any X client to perform 3D rendering using this "direct rendering" approach
It should be noted that nothing prevents DRI from being used to implement accelerated 2D direct rendering within an X client.[3] Simply no one has had the need to do so because the 2D indirect rendering performance was good enough.

****** DMA Buffer Sharing and PRIME
The DMA Buffer Sharing API (often abbreviated as DMA-BUF) is a Linux kernel internal API designed to provide a generic mechanism to share DMA buffers across multiple devices, possibly managed by different types of device drivers.[25][26] For example, a Video4Linux device and a graphics adapter device could share buffers through DMA-BUF to achieve zero-copy of the data of a video stream produced by the first and consumed by the latter. Any Linux device driver can implement this API as exporter, as user (consumer) or both.
****** Hardware overlay
https://en.wikipedia.org/wiki/Hardware_overlay
****** Chroma key
https://en.wikipedia.org/wiki/Chroma_key
****** X video extension
https://en.wikipedia.org/wiki/X_video_extension
The video controller has to provide the required functions.
The device driver software for the video controller and the X display server program have to implement the XVideo interface.
The video playback software has to make use of this interface.
Most modern video controllers provide the functions required for XVideo; this feature is known as hardware scaling and YUV acceleration or sometimes as 2D hardware acceleration.

Video playback programs that run under the X Window system, such as MPlayer, MythTV or xine, typically have an option to enable XVideo output. It is very advisable to switch on this option if the system GPU video-hardware and device drivers supports XVideo and more modern rendering systems such as OpenGL and VDPAU are unavailable – the speedup is very noticeable even on a fast CPU.
****** Multiple buffering
https://en.wikipedia.org/wiki/Multiple_buffering#Page_flipping
****** Swap Chain
https://en.wikipedia.org/wiki/Swap_Chain
In computer graphics, a swap chain is a series of virtual framebuffers utilized by the graphics card and graphics API for frame rate stabilization and several other functions. The swap chain usually exists in graphics memory, but it can exist in system memory as well. The non-utilization of a swap chain may result in stuttering rendering, but its existence and utilization are required by many graphics APIs. A swap chain with two buffers is a double buffer.

In every swap chain there are at least two buffers. The first framebuffer, the screenbuffer, is the buffer that is rendered to the output of the video card. The remaining buffers are known as backbuffers. Each time a new frame is displayed, the first backbuffer in the swap chain takes the place of the screenbuffer, this is called presentation or swapping. A variety of other actions may be taken on the previous screenbuffer and other backbuffers (if they exist). The screenbuffer may be simply overwritten or returned to the back of the swap chain for further processing. The action taken is decided by the client application and is API dependent.

***** Free and open-source graphics device driver
https://en.wikipedia.org/wiki/Free_and_open-source_graphics_device_driver
The free and open-source drivers are primarily developed on Linux and for Linux. They have been under constant development by the Linux kernel developers, by 3rd party programming enthusiasts and also by employees of companies such as e.g.AMD. Each driver is composed out of five parts:

+ Linux kernel component DRM
+ Linux kernel component KMS driver: basically the device driver for the display controller
+ user-space component libDRM: a wrapper library for the system calls of the DRM, should only be used by Mesa 3D
+ user-space component in Mesa 3D: this component is highly hardware specific, is being executed on the CPU and does the translation of e.g. OpenGL commands into machine code for the GPU;
because of the split nature of the device driver, marshalling is possible;
Mesa 3D is the only available free and open-source implementation of OpenGL, OpenGL ES, OpenVG, GLX, EGL and OpenCL
as of July 2014 most of these components are written conforming to the Gallium3D-specifications;
there is a fully functional State Tracker for Direct3D version 9 written in C and an un-maintained one for Direct3D versions 10 and 11 written in C++.[19]
+ Device Dependent X (DDX), an additional special and distinct 2D graphics device driver extra for X.Org Server (Which is going to be replaced by Glamor)

****** ARM[edit]
See also: Mali
ARM Holdings is a fabless semiconductor company which licenses SIP cores. They are known for the licensing the ARM instruction set and CPUs based upon it but they also develop and license the Mali series of GPUs. On January 21, 2012, Phoronix reported that Luc Verhaegen was driving a reverse-engineering attempt aimed at the ARM Holdings Mali series of GPUs, specifically the Mali-200 and Mali-400 versions. The reverse-engineering project, called lima, was presented at FOSDEM, February 4, 2012.[34][35] On February 2, 2013, Verhaegen demonstrated Quake III Arena in timedemo mode, running on top of the Lima driver.[36]

ARM has shown no intention of providing support for their graphics acceleration hardware licensed under some free and open-source license. But in December 2015 and April 2016 ARM employees did send patches for the Linux kernel to support at least their display controller SIP blocks "ARM HDLCD display controller" and Mali DP500, DP550 and DP650.[37][38]

****** Imagination Technologies[edit]
See also: PowerVR
Imagination Technologies is a fabless semiconductor company that develops and licenses semiconductor intellectual property cores, among which are the PowerVR GPUs. Intel has manufactured a number of PowerVR based GPUs. PowerVR GPUs are widely used in mobile SoCs. Imagination Technologies does not provide a FOSS driver or any public documentation for the PowerVR. Due to its wide use in embedded devices, the Free Software Foundation has put reverse-engineering of the PowerVR driver on a high-priority project list.[39]

PowerVR reverse engineering project
**** RPM Package Manager
https://en.wikipedia.org/wiki/RPM_Package_Manager
**** Software repository
https://en.wikipedia.org/wiki/Software_repository
| Language     | Process                   | Repository               | How to install         | platform  | Autochecks |
| C++          |                           | Boost                    |                        |           |            |
| Haskell      | (CABAL)                   | Hackage                  | [1]                    |           |            |
| Java         |                           | Maven                    | [2]                    |           |            |
| Julia        |                           | [3]                      |                        |           |            |
| Common Lisp  |                           | Quicklisp                | [4]                    |           |            |
| .NET         | NuGet                     | NuGet                    | [5]                    |           |            |
| Node.js      |                           | NPM                      | [6]                    |           |            |
| Perl         |                           | CPAN                     | PPM[7]                 |           |            |
| PHP          | PEAR                      | PECL                     |                        |           |            |
| Python       | Setuptools                | PyPI                     | pip, EasyInstall, PyPM |           |            |
| R            | R CMD check process[2][3] | CRAN                     | install.packages       | R-Forge   |            |
| Bioconductor | BiocLite.R                |                          |                        |           |            |
| Ruby         | RubyGems                  | Ruby Application Archive |                        | RubyForge |            |
| TeX, LaTeX   |                           | CTAN                     |                        |           |            |
https://en.wikipedia.org/wiki/Boost_(C%2B%2B_libraries)
https://en.wikipedia.org/wiki/Apache_Maven
**** COCOMO
https://en.wikipedia.org/wiki/COCOMO
*** Debian
https://en.wikipedia.org/wiki/Debian#Embedded_systems
Debian has access to online repositories that contain over 50,000 software packages[8] making it the largest software compilation.[9] Debian officially contains only free software, but non-free software can be downloaded from the Debian repositories and installed.[10] Debian includes popular free programs such as LibreOffice,[11] Firefox web browser, Evolution mail, K3b disc burner, VLC media player, GIMP image editor, and Evince document viewer.[10] Debian is a popular choice for web servers

**** Package management[edit]
Package management operations can be performed with different tools available on Debian, from the lowest level command dpkg to graphical front-ends like Synaptic. The recommended standard for administering packages on a Debian system is the apt toolset.[96]

dpkg provides the low-level infrastructure for package management.[97] The dpkg database contains the list of installed software on the current system. The dpkg command tool does not know about repositories. The command can work with local .deb package files, and information from the dpkg database.[98]

**** APT tools[edit]

Using Aptitude to view Debian package details

Package installed with Aptitude
An Advanced Packaging Tool (APT) tool allows administering an installed Debian system to retrieve and resolve package dependencies from repositories. APT tools share dependency information and cached packages.[96]

+ Aptitude is a command line tool that also offers a text-based user interface. The program comes with enhancements such as better search on package metadata.[96]
+ apt-get and apt-cache are command tools of the standard apt package. apt-get installs and removes packages, and apt-cache is used for searching packages and displaying package information.[96]

**** dpkg
To install a .deb package:
dpkg -i filename.deb
where filename.deb is the name of the Debian package (such as pkgname_0.00-1_amd64.deb).

The list of installed packages can be obtained with:
dpkg -l [optional pattern]
To remove an installed package:

dpkg -r packagename

**** Advanced Packaging Tool

***** apt-get[edit]
apt-get is the command line package management tool supplied with the Debian package apt. APT searches its cached list of packages and lists the dependencies that must be installed or updated.

Triggers are the treatment of deferred actions.

APT retrieves, configures and installs the dependencies automatically.

Update, upgrade and dist-upgrade[edit]

****** Other commands used in apt-get:

+ update is used to resynchronize the package index files from their sources. The lists of available packages are fetched from the location(s) specified in /etc/apt/sources.list. For example, when using a Debian archive, this command retrieves and scans the Packages.gz files, so that information about new and updated packages is available.
+ upgrade is used to install the newest versions of all packages currently installed on the system from the sources enumerated in /etc/apt/sources.list. Packages currently installed with new versions available are retrieved and upgraded; under no circumstances are currently installed packages removed, or packages not already installed retrieved and installed. New versions of currently installed packages that cannot be upgraded without changing the install status of another package will be left at their current version.
+ dist-upgrade, in addition to performing the function of upgrade, also intelligently handles changing dependencies with new versions of packages; apt-get has a "smart" conflict resolution system, and it will attempt to upgrade the most important packages at the expense of less important ones if necessary. The /etc/apt/sources.list file contains a list of locations from which to retrieve desired package files.[12] aptitude has a smarter dist-upgrade feature called full-upgrade.[13]

***** apt-file[edit]
apt-file is a command to find which package includes a specific file, or to list all files included in a package. It is packaged separately from the main APT utilities.

Example to find a package:
$ apt-file update         # Fetch the files installed by the packages in local cache
$ apt-file find vmlinuz   # Find all packages providing a filename vmlinuz

** openWRT
https://en.wikipedia.org/wiki/OpenWrt
OpenWrt is an open source project for embedded operating system based on Linux, primarily used on embedded devices to route network traffic. The main components are Linux, util-linux, uClibc or musl,[5] and BusyBox. All components have been optimized for size, to be small enough for fitting into the limited storage and memory available in home routers.

OpenWrt is configured using a command-line interface (ash shell), or a web interface (LuCI). There are about 3500 optional software packages available for installation via the opkg package management system.
*** PulseAudio
https://en.wikipedia.org/wiki/PulseAudio
https://en.wikipedia.org/wiki/Comparison_of_free_software_for_audio
*** MPD
https://en.wikipedia.org/wiki/Music_Player_Daemon
*** opkg
https://en.wikipedia.org/wiki/Opkg
opkg (Open PacKaGe management) is a lightweight package management system based upon ipkg. It is written in C and resembles APT/dpkg in operation. It is intended for use on embedded GNU/Linux devices and is used in this capacity in the OpenEmbedded and OpenWrt projects.[2]

Opkg was originally forked from ipkg by the Openmoko project.[3] More recently, development of opkg has moved from its old Google Code repository to Yocto Project where it is actively maintained again.

openwrt框架分析
http://blog.csdn.net/kingvenll/article/details/27545221
openwrt: Makefile 框架分析
http://blog.csdn.net/flexman09/article/details/51849707

*** openWRT 发布包
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C3DA@srv-mail-02.actions.com.cn][转发: LS3605 OPENWRT]]
** libusb
*** libusb
    * libusb的官方网站：
      * http://libusb.
    * 代码：
      * https://github.com/libusb/libusb
    * 示例代码：
      * https://github.com/libusb/libusb/tree/master/examples
    * 一些文章
      * Android 用 libusb 操作 USB 设备，无须 root
      * http://blog.csdn.net/hubbybob1/article/details/52101356
      * (转载)libusb开发者指南
      * http://www.cnblogs.com/ele-eye/p/3261970.html
*** gaget cofigFS
  * 源码：
    * https://github.com/libusbg/libusbg
  * 文章：
    * Linux usb gadget configfs用法
    * http://blog.csdn.net/zoosenpin/article/details/38224149
    * How to enable Android ConfigFS gadgets
    * http://blog.csdn.net/ztguang/article/details/53106556
** RTOS
http://electronics360.globalspec.com/article/6887/the-rtos-in-2016
*** Internet of things
https://en.wikipedia.org/wiki/Internet_of_things
*** Comparison of real-time operating systems
https://en.wikipedia.org/wiki/Comparison_of_real-time_operating_systems
**** Contiki
https://en.wikipedia.org/wiki/Contiki
Contiki is designed to run on types of hardware devices that are severely constrained in memory, power, processing power, and communication bandwidth. A typical Contiki system has memory on the order of kilobytes, a power budget on the order of milliwatts, processing speed measured in megahertz, and communication bandwidth on the order of hundreds of kilobits/second. Such systems include many types of embedded systems, and old 8-bit computers.
**** RIOT (operating system)
RIOT is a small operating system for networked, memory-constrained systems with a focus on low-power wireless Internet of Things (IoT) devices. It is open-source software, released under the GNU Lesser General Public License (LGPL). Due to this unclonable license and its large independent community RIOT is often referred to as the Linux of the Internet of Things.
**** Zephyr (operating system)
https://en.wikipedia.org/wiki/Zephyr_(operating_system)
The Zephyr kernel is small and designed for use on resource-constrained systems: from simple embedded environmental sensors and light emitting diode (LED) wearables to sophisticated smart watches and IoT wireless gateways.

The kernel offers several features that distinguish it from other small OSes:
+ Single address-space
+ Highly configurable
+ Resources defined at compile-time
+ Minimal error checking
+ Development services
** scheme

https://github.com/cisco/chezscheme

** email
How to get email from exchange server without Outlook
http://blog.binchen.org/posts/how-to-get-email-from-exchange-server-without-outlook.html
http://davmail.sourceforge.net
http://growl.info

Emacs for Email
http://henry-y.github.io/emacs-for-email.html
http://blog.csdn.net/csfreebird/article/details/41408205
http://www.linuxidc.com/Linux/2014-11/109749.htm
Emacs as email client with offlineimap and mu4e on OS X
https://medium.com/@kirang89/emacs-as-email-client-with-offlineimap-and-mu4e-on-os-x-3ba55adc78b6
https://coldnew.github.io/blog/2016/01-02_mu4e/
http://www.djcbsoftware.nl/code/mu/mu4e/General.html
Does mu4e support searching for CJK (Chinese-Japanese-Korean) characters? Yes, if you have Xapian 1.2.8 or newer, and set the environment variable XAPIAN_CJK_NGRAM to non-empty before indexing, both when using mu from the command-line and from mu4e.
https://xapian.org
http://blog.csdn.net/visualcatsharp/article/details/4176083
https://emacs-china.org/t/imap-idle-mu4e/498
mu 解决中文搜索的问题，需要使用xapian的rsto的分支版本， cjk_words分支， 重新build， 以及重新build mu软件才可以。 参加xapian的pull request 180
https://github.com/rsto/xapian
http://blog.chedushi.com/archives/8498
export PKG_CONFIG_PATH=/usr/local/Cellar/icu4c/58.2/lib/pkgconfig/
export ICU_LIBS=/usr/local/Cellar/icu4c/58.2/lib
export ICU_INCLUDES=/usr/local/Cellar/icu4c/58.2/include
./configure
https://www.postgresql.org/message-id/071e7c00-beba-480d-fa62-0fbcf3fa7360@2ndquadrant.com
http://userguide.icu-project.org/howtouseicu


https://github.com/djcb/mu
https://www.emacswiki.org/emacs/mu4e
http://www.djcbsoftware.nl/code/mu/mu4e/index.htmln
machine localhost  login zhangdf password javateam1#  port 1025

Ten email commandments
http://timharford.com/2013/09/3180/
http://pragmaticemacs.com/emacs/master-your-inbox-with-mu4e-and-org-mode/
http://matt.hackinghistory.ca/2016/11/18/sending-html-mail-with-mu4e/
http://kitchingroup.cheme.cmu.edu/blog/2016/10/29/Sending-html-emails-from-org-mode-with-org-mime/
http://kitchingroup.cheme.cmu.edu/blog/category/orgmode/

http://orgmode.org/worg/org-contrib/org-mime.html
** Emacs编辑器——王垠
*** regexp
http://ergoemacs.org/emacs/emacs_regex.html
*** intro
  http://blog.csdn.net/superwen_go/article/details/8235185
  有哪些是必备的emacs扩展？
  https://www.zhihu.com/question/21943533
  Programming in Emacs+Sematic
  http://docs.huihoo.com/homepage/shredderyin/wiki/ProgrammingTricks.html
  Sams Teach Yourself Emacs in 24 Hours
  http://docs.huihoo.com/homepage/shredderyin/emacs24/index.htm
  我的Emacs折腾经验谈(一) 一些给新人的建议 –
  http://www.tuicool.com/articles/rIBBJn
  Emacs: How to Install Packages Using ELPA, MELPA
  http://ergoemacs.org/emacs/emacs_package_system.html
  Quickly finding project files using Emacs EDE
  http://stackoverflow.com/questions/23950534/quickly-finding-project-files-using-emacs-ede
  The function to show current file's full path in mini buffer
  http://stackoverflow.com/questions/3669511/the-function-to-show-current-files-full-path-in-mini-buffer
  Imenu显示符号列表
  http://www.gnu.org/software/emacs/manual/html_node/emacs/Imenu.html
  InteractivelyDoThings
  http://stackoverflow.com/questions/7394289/how-can-i-more-easily-switch-between-buffers-in-emacs
  https://www.emacswiki.org/emacs/InteractivelyDoThings
  Searching for marked (selected) text in Emacs
  http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html#SEC_Contents
  Emacs dired 模式
  http://blog.csdn.net/cxmanzhao/article/details/5685016
  emacs 快捷键（包括C／C++模式）
  http://www.cnblogs.com/xinxianshi/archive/2011/07/20/2157264.html

  CUA的矩形块操作很给力啊
http://www.cnblogs.com/bamanzi/archive/2011/02/28/emacs-cua-rectangle-cool.html
*** Emacs 24.4 Released, How to Install it in Ubuntu 14.04
  http://ubuntuhandbook.org/index.php/2014/10/emacs-24-4-released-install-in-ubuntu-14-04/
  https://www.emacswiki.org/emacs/SiteMap
  Emacs Starter Kit
  http://eschulte.github.io/emacs-starter-kit/
http://book.emacs-china.org
*** emacs + cscope 的使用
  http://blog.chinaunix.net/uid-20788636-id-1841254.html
  在Emacs下用C/C++编程
  http://blog.chinaunix.net/uid-9478057-id-2002272.html
  http://www.caole.net/diary/emacs_write_cpp.html
  使用gtags、etags、cscope、grep浏览源代码
  http://blog.csdn.net/wuyao721/article/details/3059242
  Cscope在emacs中的配置与使用
  http://www.cnblogs.com/jtf-china/articles/2077922.html
  一年成为Emacs高手(像神一样使用编辑器)
  http://blog.csdn.net/redguardtoo/article/details/7222501/
  https://www.emacswiki.org
  https://github.com/purcell/emacs.d
  https://www.emacswiki.org/emacs/EmacsWiki
  暴增 Emacs 生产力的十大最佳插件
  http://www.linuxidc.com/Linux/2016-01/127456.htm
  A Package in a league of its own: Helm
  http://tuhdo.github.io/helm-intro.html
  https://www.emacswiki.org/emacs/FindFileInProject
  rst mode in emacs on osx - cannot create pdf
  http://stackoverflow.com/questions/12602490/rst-mode-in-emacs-on-osx-cannot-create-pdf
  https://www.gnu.org/gnu/rms-lisp.html
  http://mirror.hust.edu.cn/gnu/
  https://en.wikipedia.org/wiki/Emacs_Lisp
*** init.el
  git clone https://github.com/purcell/emacs.d.git ~/.emacs.d
  (require 'ido)
  (ido-mode t)
  (setq auto-save-default nil)
  (require 'xcscope)
  (add-hook 'c-mode-common-hook 'cscope-minor-mode)
**** mu4e
(require 'mu4e)
(setq mu4e-maildir "~/mail")
(setq mu4e-drafts-folder "/Drafts")
(setq mu4e-sent-folder   "/Sent")
(setq mu4e-sent-messages-behavior 'delete)
(setq mu4e-get-mail-command "offlineimap")

;; shortcuts
(setq mu4e-maildir-shortcuts
      '( ("/INBOX"               . ?i)
         ("/Sentl"   . ?s)))

;; something about ourselves
(setq
 user-mail-address "zhangdf@actions-semi.com"
 user-full-name  "张东风"
 mu4e-compose-signature
 (concat
  "Regards,\n"
  "dongfeng\n"))

;; show images
(setq mu4e-show-images t)

;; use imagemagick, if available
(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))

;; convert html emails properly
;; Possible options:
;;   - html2text -utf8 -width 72
;;   - textutil -stdin -format html -convert txt -stdout
;;   - html2markdown | grep -v '&nbsp_place_holder;' (Requires html2text pypi)
;;   - w3m -dump -cols 80 -T text/html
;;   - view in browser (provided below)
(setq mu4e-html2text-command "textutil -stdin -format html -convert txt -stdout")

;; spell check
(add-hook 'mu4e-compose-mode-hook
          (defun my-do-compose-stuff ()
            "My settings for message composition."
            (set-fill-column 72)
            (flyspell-mode)))

;; add option to view html message in a browser
;; `aV` in view to activate
(add-to-list 'mu4e-view-actions
             '("ViewInBrowser" . mu4e-action-view-in-browser) t)

;; fetch mail every 10 mins
(setq mu4e-update-interval 600)

(require 'smtpmail)

;; alternatively, for emacs-24 you can use:
(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-stream-type 'plain
      smtpmail-default-smtp-server "localhost"
      smtpmail-smtp-server "localhost"
      smtpmail-smtp-service 1025)
(setq mu4e-sent-messages-behavior 'delete)
*** magit
  https://github.com/magit/magit/blob/master/Documentation/magit.texi
  http://blog.csdn.net/amuseme_lu/article/details/6931908
  http://www.emacswiki.org/emacs/Magit
  https://magit.vc/manual/magit/Getting-started.html
** cscope
   find frameworks/ packages/ bionic/ dalvik/ bootable/ libcore/ -name '*.c' -print -o -name '*.h' -print -o -name '*.cpp' -print -o -name '*.java' -print > cscope.files
   cscope –b –q -k
   find frameworks/ packages/ bionic/ dalvik/ bootable/ libcore/ -name '*.c' -print -o -name '*.h' -print -o -name '*.cpp' -print -o -name '*.java' –print | xargs etags -a
** old-doc
*** Linux
**** 常用linux网站：
https://git.kernel.org/cgit/
http://kernelnewbies.org/
http://www.tux.org/lkml/
http://lwn.net/
http://linux-mm.org/
http://stackoverflow.com
http://askubuntu.com/
http://gmane.org  邮件列表

http://en.wikipedia.org/wiki/Unix_philosophy

http://blog.csdn.net/21cnbao?viewmode=contents

http://lxr.free-electrons.com/
http://www.linuxfromscratch.org
https://0xax.gitbooks.io/linux-insides/content/Concepts/per-cpu.html

linux inside book
https://www.gitbook.com/book/0xax/linux-insides
http://advdbg.org
搜素patch 得到日期
http://www.gossamer-threads.com/lists/linux/kernel/
通过日期+1查找archiver
https://lkml.org/

http://bamboopuppy.com/android-cpu-frequency-using-interactive-governor/

https://developers.google.com/weave/

https://github.com/mbedmicro/mbed.git
https://github.com/mbedmicro/mbed
https://developer.mbed.org
https://www.mbed.com/zh-cn/
https://github.com/mbedmicro/mbed
使用 GIT 获得Linux Kernel的代码并查看，追踪历史记录
http://opensourceforu.efytimes.com/2011/05/linux-kernel-development-using-git/
**** Linux下如何配置VNC？
FD2R4-DHD5B-GP53H-32CL8-5EXZA
http://jingyan.baidu.com/article/6c67b1d6f003ca2787bb1ed6.html
**** Linux IPv6 HOWTO (en)
http://tldp.org/HOWTO/html_single/Linux+IPv6-HOWTO/

http://www.ibiblio.org/pub/Linux/docs/HOWTO/translations/zh/

超级详细Tcpdump 的用法
http://www.cnblogs.com/maifengqiang/p/3863168.html
Oracle Internet of Things Cloud Service
http://docs.oracle.com/cloud/latest/iot/index.html
http://docs.oracle.com/cd/E19253-01/819-7058/index.html

802.11
https://en.wikipedia.org/wiki/IEEE_802.11
**** LINUX 系统管理
http://www.cyberciti.biz

linux下syslog使用说明
http://blog.chinaunix.net/uid-25120309-id-3359929.html

Ubuntu(Debian)的aptitude与apt-get的区别和联系
http://www.cnblogs.com/yuxc/archive/2012/08/02/2620003.html
**** FUSE源码剖析
http://tech.uc.cn/?p=1597
**** Linux SCSI 子系统剖析
http://www.ibm.com/developerworks/cn/linux/l-scsi-subsystem/

关于linux SCSI 子系统
http://blog.chinaunix.net/uid-24218466-id-1746721.html
**** Lguest 之 guest篇
http://blog.chinaunix.net/uid-20704646-id-95907.html
Connecting Linux to hypervisors
http://blog.chinaunix.net/uid-28393380-id-3499070.html
lguest 三步曲之三 （源码分析）
http://blog.csdn.net/ustc_dylan/article/details/5043043
到底该不该选择LXC（Linux Container）技术？
http://blog.csdn.net/blade2001/article/details/41728565
虚拟机比较TechComparison
http://virt.kernelnewbies.org/TechComparison?cm_mc_uid=74305266494614353758483&cm_mc_sid_50200000=1447126276

KVM for ARM
http://www.docin.com/p-139299578.html

十辨十析之辨二--read()/write()/pread()/pwrite()等等
http://blog.chinaunix.net/uid-14336734-id-3154682.html
业界观察-Linux内核有待提高的七个领域
http://wenku.baidu.com/link?url=vp1_1-L4zqI2yQgvczzzWDhnNXpmqeOTgiuWmdQQntjYfFBYsN1usOknZdXzc5mGab5ayNWp3HzrVH_2lxXqL7L7jvOiBgKjmuOmsGEKP17
brillo
http://googledevelopers.blogspot.hk/2015/10/building-brillo-iant-devices-with-weave_27.html
https://developers.google.com/weave/
https://developers.google.com/brillo/
**** kvm qemu内幕介绍
http://blog.csdn.net/wj_j2ee/article/details/7978259
Virtio：针对 Linux 的 I/O 虚拟化框架（ibm）
http://www.cnblogs.com/chinacloud/archive/2010/08/10/1796824.html
ftp://ftp.os3.nl/people/nsijm/INR/Week%201/papers/32_virtio_Russel.pdf
http://www.ibm.com/developerworks/cn/linux/l-virtio/
虚拟 Linux
http://www.ibm.com/developerworks/cn/linux/l-linuxvirt/
剖析 Linux hypervisor
https://www.ibm.com/developerworks/cn/linux/l-hypervisor/index.html
探索 Linux 内核虚拟机
http://www.ibm.com/developerworks/cn/linux/l-linux-kvm/
内核虚拟化KVM/QEMU——Guest OS, Qemu, KVM工作流程
http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=29056899&id=4342136
http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=29056899&id=4342084
http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=29056899&id=4342100
KVM基本原理及架构五-IO虚拟化
http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=29056899&id=4395255
qemu i/o虚拟化-- virtio-blk设备
http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=29056899&id=4390276
virtio驱动如何同设备交互
http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=29056899&id=4390321
http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=29056899&id=4390325
KVM虚拟化原理与实践（连载）
http://smilejay.com/kvm_theory_practice/
(KVM连载)5.1.1 Virtio概述和基本原理（KVM半虚拟化驱动）
http://smilejay.com/2012/11/virtio-overview/
QEMU-KVM的初始化与客户系统的执行
http://blog.csdn.net/lux_veritas/article/details/9383643
KVM虚拟化技术：实战与原理解析（Intel虚拟化技术部门资深虚拟化技术专家和KVM研究者撰写，深入剖析KVM虚拟机的核心技术和原理）
http://product.dangdang.com/23341742.html#review_point
KVM虚拟化原理与实践（连载）
http://smilejay.com/kvm_theory_practice/
KVM的内存合并技术KSM--Kernel Samepage Merging
http://blog.chinaunix.net/uid-20794164-id-3601786.html
PXN防护技术的研究与绕过
http://blog.csdn.net/hu3167343/article/details/47394707
**** CFS调度器
http://wenku.baidu.com/link?url=WhsY1uKSVDWRZ0z3q8YQtFUt2qip_TUXTLvsdNM0MRkEoFAz-f9OfBwMSBkPilMyhA7teJzjjxtmvzNfIwSKKQ8mtOZoNqIBx3jiouwLzGC
利用dm-crypt内核模块对磁盘数据加密的尝试
http://blog.chinaunix.net/uid-23769728-id-3083389.html
自动精简配置(Thin Provisioning)
http://wenku.baidu.com/link?url=o6xRhVOqd2yJbyX-FKPZJ9zDbwTvzJw0mqmd-feCRoUqtOICzoRLOCaKr5O5COWrloSiGXLny_PJJP4hmrUcmlRlSRcafGokkR5klqQabqi
linux内核中的device mapper详解
http://blog.sina.com.cn/s/blog_6f5549150102v8rh.html
Device Mapper 代码分析
http://www.educity.cn/linux/1581785.html
cpu 负载平衡 之 计算运行队列和cpu的load
http://blog.csdn.net/ustc_dylan/article/details/4139110

W^X
https://en.wikipedia.org/wiki/W^X
深入探索 Kdump，第 1 部分：带你走进 Kdump 的世界
http://www.ibm.com/developerworks/cn/linux/l-cn-kdump1/
http://www.ibm.com/developerworks/cn/linux/l-cn-kdump2/
https://www.ibm.com/developerworks/cn/linux/l-cn-kdump4/

Linux apanic mechanism and difference from newer ram_console/persistent_ram mechanism
http://stackoverflow.com/questions/18118807/linux-apanic-mechanism-and-difference-from-newer-ram-console-persistent-ram-mech
**** Linux下用kexec实现快速重启
http://blog.sina.com.cn/s/blog_a5855c1e01017bxq.html
http://blog.chinaunix.net/uid-10328574-id-2951119.html
<深入浅出> schedule函数核心
http://blog.csdn.net/chenyu105/article/details/7068758
IEEE 802.15.4
http://baike.baidu.com/link?url=4f22uTFXDm9t85tmSs_XfFWkPkmnLFIGbF6k9IfS0RbDnvZBVDwbt5CIID55SqzPKKZJDpE-VQmhgHJXUgIphK
Linux下查看文件和文件夹大小
http://www.cnblogs.com/benio/archive/2010/10/13/1849946.html
hexdump——Linux系统的二进制文件查看工具
http://www.cnblogs.com/gamesky/archive/2013/06/24/3152540.html
**** Ext4文件系统架构分析(一)
http://blog.chinaunix.net/uid-26430381-id-4559491.html
/dev/loop与设备文件系统
http://www.tuicool.com/articles/YFJN32N
借助loop device与losetup命令制作硬盘镜像
http://blog.csdn.net/bokee/article/details/6835082
http://itlab.idcquan.com/linux/set/942370.html
F2FS文件系统架构与原理分析(二)——磁盘布局
http://blog.chinaunix.net/uid-26430381-id-4559486.html
linux下的文件系统ext2的文档资料
http://wenku.baidu.com/view/b6f84883ec3a87c24028c4fe.html?re=view
Linux启动时对命令行参数的解析
http://blog.csdn.net/eric_tao/article/details/5708894
linux mkfs命令参数及用法详解---linux格式化文件系统命令(包括swap分区)
http://blog.csdn.net/asx20042005/article/details/7264867

深入解析 ext2 文件系统
http://blog.chinaunix.net/uid-24774106-id-3266816.html
ext3、ext4的orphan inode机制分析
http://blog.chinaunix.net/uid-52662-id-2107877.html
http://wenku.baidu.com/link?url=0aYHOYWi438YBtvyVnIq-TocPPsTUmDD-RtBci6fZMlzFJLVhuNtgTt9BH8G-5Pk3fS5yxsYqbUxd-NV_aVIx9YjhoZK_hwpcWphbeCuw5q
ext3 journal block device 源代码分析
http://wenku.baidu.com/view/af0ce42c0066f5335a8121d2.html
**** 使用 FUSE 开发自己的文件系统
http://www.ibm.com/developerworks/cn/linux/l-fuse/
http://wenku.baidu.com/view/da96043310661ed9ad51f3bb.html
http://blog.sina.com.cn/s/blog_53689eaf0100ycib.html
http://sourceforge.net/p/fuse/wiki/Main_Page/
http://fuse.sourceforge.net
FUSE - implementing filesystems in user space
http://lwn.net/Articles/68104/
Linux那些事儿之我是Block层(4)浓缩就是精华?(一)
http://blog.csdn.net/fudan_abc/article/details/1953830
注册块设备的过程分析
http://blog.chinaunix.net/uid-28236237-id-4047985.html
linux内核md源代码解读 二 md模块初始化
http://www.bianceng.cn/OS/Linux/201403/40255.htm
http://neil.brown.name/blog/
http://blog.csdn.net/liumangxiong/article/details/12305995
**** Linux 内核中的 Device Mapper 机制
http://www.ibm.com/developerworks/cn/linux/l-devmapper/
http://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html
http://blog.csdn.net/richardysteven/article/details/7937249
性能调优攻略
http://blog.csdn.net/liumangxiong/article/details/7995079
linux内核wait_queue深入分析
http://www.cnblogs.com/xmphoenix/archive/2011/11/20/2256419.html
Big List Of 20 Common Bottlenecks
http://highscalability.com/blog/2012/5/16/big-list-of-20-common-bottlenecks.html
Linux逻辑卷管理LVM详解
http://blog.csdn.net/ikikik2002/article/details/5187276
Linux日志文件系统及性能分析
http://www.ibm.com/developerworks/cn/linux/l-jfs/
使用异步 I/O 大大提高应用程序的性能
http://www.ibm.com/developerworks/cn/linux/l-async/
一个IO的传奇一生（13）—— Linux中的MD开源RAID（1）
http://www.tuicool.com/articles/YRveA3

http://alanwu.blog.51cto.com/3652632/d-8
raid的实现
http://blog.csdn.net/ikikik2002/article/details/5178403
查看Linux系统是否使用RAID阵列信息
http://blog.itpub.net/29500582/viewspace-1391030/
RAID命令使用手册
http://wenku.baidu.com/link?url=hUEBFt94_DPyoFvVAmQZYEhP8g8zlOT4hkOSQ4TOR-1iYq3lruQKmWBoecPAclz96nbWaOONeupv3aH2WLEhhHT4t5pxGvbJl04C9BJSDqi
Linux软RAID及mdadm命令
http://wenku.baidu.com/view/5c0d9c4658f5f61fb636666d.html?re=view
linux fdisk命令使用
http://blog.chinaunix.net/uid-23929712-id-2650378.html
Kernel NTFS Driver and ntfs-3g
http://felix-lin.com/linux/kernel-ntfs-driver-and-ntfs-3g/
**** Linux ALSA声卡驱动之一：ALSA架构简介
http://blog.csdn.net/droidphone/article/details/6271122
http://www.alsa-project.org/
使用 GStreamer 进行多用途的多媒体处理
http://www.cnetnews.com.cn/2008/0610/917799.shtml
**** Linux 音频系统简析
http://www.cnbeta.com/articles/112155.htm
http://www.techradar.com/news/audio/linux-audio-explained-685419/1
linux内存操作--ioremap和mmap学习笔记
http://blog.csdn.net/codectq/article/details/25658813
linux tune2fs命令详解
http://blog.csdn.net/zhenwenxian/article/details/5874797
SYSCALL_DEFINE3 宏定义(转
http://blog.sina.com.cn/s/blog_6639d0fc01017dkq.html
http://m.blog.csdn.net/blog/longbiao831/38068831
Linux下/dev/mem和/dev/kmem及操作gpio实例
http://blog.csdn.net/williamwanglei/article/details/8636564
MTD系列 - 关于linux MTD的一些理解
http://blog.csdn.net/lizhiguo0532/article/details/6007636
http://blog.csdn.net/bugouyonggan/article/details/9167213
python 正则表达式
http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html
shell
http://bbs.chinaunix.net/thread-391751-1-1.html
Ubuntu完全教程，让你成为Ubuntu高手！
http://www.cnblogs.com/dutlei/archive/2012/11/20/2778327.html
arduino
http://www.arduino.cn/thread-1083-1-1.html
ARM汇编指令
http://blog.chinaunix.net/uid-25067956-id-398205.html
linux CPU动态调频
http://blog.csdn.net/leerobin83/article/details/7476386
Android CPU Frequency Using Interactive Governor
http://bamboopuppy.com/android-cpu-frequency-using-interactive-governor/
GPU GFLOPS
http://kyokojap.myweb.hinet.net/gpu_gflops/
Linux芯片级移植与底层驱动（基于3.7.4内核）
http://blog.csdn.net/21cnbao/article/details/8545088
**** linux调度器（一）——概述
http://blog.csdn.net/wudongxu/article/details/8573904
Load Average (系统负载)
http://blog.csdn.net/evenness/article/details/7658221
http://www.cnblogs.com/kaituorensheng/p/3602805.html

内核通知链原理及机制
http://blog.chinaunix.net/uid-25871104-id-3086446.html ·
Mac 下如何安装Python模块
http://www.xuebuyuan.com/2035620.html
http://blog.sina.com.cn/s/blog_a046022d0102v6fn.html
**** Linux动态频率调节系统CPUFreq之一：概述
http://blog.csdn.net/droidphone/article/details/9346981
‪The Chromium Projects‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬
https://www.chromium.org/developers/speed-infra/tracing
https://docs.google.com/document/d/1l0N1B4L4D94andL1BY39Rs_yXU8ktJBrKbt9EvOb-Oc/edit?pli=1#
https://docs.google.com/document/d/1QADiFe0ss7Ydq-LUNOPpIf6z4KXGuWs_ygxiJxoMZKo/edit
https://github.com/google/trace-viewer/blob/master/trace_viewer/build/trace2html.py

https://www.chromium.org/developers/telemetry/profiling
The Trace Event Profiling Tool
https://www.chromium.org/developers/how-tos/trace-event-profiling-tool
https://www.chromium.org/developers/how-tos/trace-event-profiling-tool/recording-tracing-runs

Django框架_入门
http://wenku.baidu.com/link?url=dgXKFGFEoz1kfDG-eY50-3ymbf9R7rV4Ef95roeLn9bR4tI9hJ1QTjgrTU3Bg8WJn5iBn_2dXameXnvbhJv0VxSxkXKgND7-ksNlb0RjWbG
Python 3.3 中GUI的方案:PyQT+Eric
PINCTRL子系统
http://www.360doc.com/content/14/0914/22/426085_409500256.shtml
常用开源OS
http://laoyaoba.com/ss6/html/97/n-549297.html
Android下打印调试堆栈方法
http://blog.csdn.net/freshui/article/details/9456889
Linux内核性能分析Trace-cmd 和 kernelshark
http://jingyan.baidu.com/article/84b4f565cf13fe60f6da323b.html
http://people.redhat.com/srostedt/kernelshark/HTML/
http://lwn.net/Articles/425583/
Summary of Energy-Aware Scheduling workshop, Linux Kernel Summit 2014
http://www.linaro.org/blog/core-dump/summary-energy-aware-scheduling-workshop-linux-kernel-summit-2014/
**** 转载]Linux内核调试方法
 http://blog.sina.com.cn/s/blog_6f55491501018e7e.html
The dynamic debugging interface
https://lwn.net/Articles/434833/
**** 内核配置与裁剪浅析
http://www.cnblogs.com/kulin/archive/2013/01/04/linux-core.html
Linux启动时对命令行参数的解析
http://blog.csdn.net/Eric_tao/article/details/5708894
sparsemem memory model
http://lwn.net/Articles/134804/
Android L Memory Foot Print Analysis

https://wiki.linaro.org/Platform/Android/MemoryFootprintAnalysis

零页面机制在缺页中断中的作用
http://blog.csdn.net/dog250/article/details/5303577

Adding Traces to Chromium/WebKit/Javascript
https://www.chromium.org/developers/how-tos/trace-event-profiling-tool/tracing-event-instrumentation
**** The Linux Kernel HOWTO
http://www.faqs.org/docs/Linux-HOWTO/Kernel-HOWTO.html
minSdkVersion、targetSdkVersion、targetApiLevel的区别
 http://blog.sina.com.cn/s/blog_4e345ce70100v8ut.html

swap分区开启及swappiness设置方法。
http://bbs.hiapk.com/thread-1108248-1-1.html

Android学习之Service命令的妙用
http://www.cnblogs.com/eustoma/archive/2012/04/27/2473351.html
**** linux内核启动第一阶段分析-2.6.36
http://blog.chinaunix.net/uid-20672257-id-2379743.html
 linux内核启动第二阶段分析-setup_arch()函数
http://blog.chinaunix.net/uid-20672257-id-2379680.html
linux内核启动第二阶段分析
http://blog.chinaunix.net/uid-20672257-id-2239898.html
linux内核启动解压过程分析
http://blog.chinaunix.net/uid-20672257-id-2239587.html
Uevent 上报event事件给上层的详细讲解
http://blog.csdn.net/sunweizhong1024/article/details/7928530
Linux 下的notifier chain 机制的注册和触发讲解
http://blog.csdn.net/sunweizhong1024?viewmode=contents
深入理解Linux 2.6的initramfs机制(上)-转一台湾大牛
http://hi.baidu.com/toniya/item/da1a25453b6da135fa8960a6
linux2.6内核initrd机制解析
http://blog.csdn.net/wesleyhe/article/details/6934197
android_graphics文档更新
http://source.android.com/devices/graphics/architecture.html
**** prink和console
使用logwrapper工具将可执行程序的输出写入日志系统
http://blog.csdn.net/dengxiayehu/article/details/6966976
浅析terminal创建时ptmx和pts关系
http://blog.csdn.net/unbutun/article/details/7930773
从printXX看tty设备
http://blog.csdn.net/unbutun/article/details/7943559
printk与 uart console关系分析(草稿)
http://blog.csdn.net/swingboard/article/details/9302001
linux终端设备uart驱动分析
http://blog.chinaunix.net/uid-22621462-id-1772029.html

目前基本确认了不管是sh命令，还是驱动的printk应该都是在关了中断的下打印的，

具体代码如下：

Kernel中的printk：（kernel/printk.c）
printk
       vprintk
              local_irq_save
              console_unlock
                     call_console_drivers
                            _call_console_drivers
                                   __call_console_drivers
con->write // asoc_console_write
而 con->write 则是 (arch/arm/mach_leopard/asoc_serial.c) 中注册的。
platform_driver_probe
       asoc_serial_probe
              uart_add_one_port
                     uart_configure_port
                            register_console // asoc_console
**** Linux内核符号表

http://blog.csdn.net/ylyuanlu/article/details/12583325
linux 3.5.4 ptrace源码分析分析（系列一）
http://blog.csdn.net/shen332401890/article/details/17297551
Android系统性能调优工具介绍
http://blog.csdn.net/innost/article/details/9008691
深入理解Android Wi-Fi,NFC和GPS卷
http://blog.csdn.net/innost?viewmode=contents
深入理解SELinux SEAndroid（第一部分）
http://blog.csdn.net/innost/article/details/19299937
SEAndroid保险机制对Android属性访问的保护分析
http://blog.csdn.net/luoshengyang/article/details/38102011
mmap那些事之android property实现
http://blog.csdn.net/xiaojsj111/article/details/11518419

linux oops产生过程之dump_backtrace

http://blog.csdn.net/xiaojsj111/article/details/14229985
eclipse failed to create the java virtual machine 问题图文解析
http://blog.csdn.net/yuanfei_1988/article/details/5919168
document.addEventListener理解
http://blog.csdn.net/aaawqqq/article/details/20632501
**** Ext3文件系统读写过程分析
http://alanwu.blog.51cto.com/3652632/1106506
Linux内核的文件预读(readahead)
http://blog.chinaunix.net/uid-667478-id-2384354.html
Secrets of the Ftrace function tracer
http://lwn.net/Articles/365835/
http://lwn.net/Articles/370423/
linux设备：cdev和kobj_map
http://blog.chinaunix.net/uid-26921272-id-3422993.html
Linux资源管理-IO优先级
http://www.cnblogs.com/wang_yb/p/3957913.html
**** Using the TRACE_EVENT() macro
http://lyl19.blog.163.com/blog/static/1942720552013324105447858/
http://lyl19.blog.163.com/blog/static/1942720552013324105310232/
http://lwn.net/Articles/379903/
linux work queue及并发可管理工作队列
http://blog.csdn.net/brucexu1978/article/details/7173100
http://blog.csdn.net/brucexu1978/article/details/7173100
**** 使用cgroup来控制io 二度
LINUX 内核 2&cedil;6&cedil;26 说明文档 ioprio
http://www.doc88.com/p-714686377930.html
Bio Throttling support for block IO controller
http://lwn.net/Articles/403200/
blk-throttle: lockless bio processing for no throttle rule group
http://lwn.net/Articles/443834/
**** linux的CFQ调度器解析(1)

http://blog.csdn.net/majieyue/article/details/7402184
http://blog.csdn.net/vanbreaker/article/details/8299491
http://www.linux-mag.com/id/7572/
http://blog.chinaunix.net/uid-23438246-id-3349808.html
http://blog.csdn.net/yuyin86/article/details/16923069
Cgroups 学习笔记[6] – blkio 子系
http://www.elmerzhang.com/2012/12/cgroups-learning-6-blkio-subsystem/
ionice使用说明与参数详析
http://xficc.blog.51cto.com/1189288/1549669
http://blog.chinaunix.net/uid-20788636-id-4451420.html
http://tiewei.github.io/devops/howto-use-cgroup/
Chapter 3. Subsystems and Tunable Parameters
https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch-Subsystems_and_Tunable_Parameters.html
Chapter 1. Introduction to Control Groups
https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html
Linux cgroup机制分析之框架分析
http://blog.csdn.net/linweig/article/details/5456679
Optimizing stable pages
http://lwn.net/Articles/528031/
2012 linux storage, filesystem and mm summit总结（文件系统和i/o部分）
http://blog.csdn.net/ustcxjt/article/details/7794375
blk-throttle: Throttle buffered WRITEs in balance_dirty_pages()
http://lwn.net/Articles/449535/
**** Linux 日志文件系统 详细介绍
http://blog.pipul.org/2013/02/linux-the-journaling-block-device/?replytocom=292
http://en.wikipedia.org/wiki/Journaling_block_device
 JBD2(journaling block device 2)系统分析（八）
http://blog.chinaunix.net/uid/8653017/abstract/1.html
Device Tree Usage
http://devicetree.org/Device_Tree_Usage
A deep dive into CMA
http://lwn.net/Articles/450286/
http://lwn.net/Articles/486301/

http://lwn.net/Articles/447405/
http://lwn.net/Articles/479297/
http://blog.csdn.net/21cnbao/article/details/7309757
**** DMA buffer sharing in 3.3
http://lwn.net/Articles/474819/
http://www.linuxtv.org/downloads/v4l-dvb-apis/dmabuf.html
**** Device Tree（二）：基本概念
http://blog.csdn.net/mrwangwang/article/details/35568329
http://blog.csdn.net/mrwangwang/article/details/36181131
Linux内核之mmc子系统-sdio
http://blog.csdn.net/mrwangwang/article/details/35997153
 start_kernel()之 build_all_zonelists(void *data)
http://blog.chinaunix.net/uid-23024886-id-2570364.html
**** Ext4 Disk Layout
https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout
非线性映射
http://blog.csdn.net/cq062364/article/details/38499937
http://lwn.net/Articles/24468/
Linux 2.6 内存反向映射机制 Reverse Mapping
http://www.cnblogs.com/visayafan/archive/2011/12/24/2300758.html

linux内核驱动中打开文件

http://www.360doc.com/content/12/1224/10/3478092_255969804.shtml
**** The Video4Linux2 API: an introduction
http://lwn.net/Articles/203924/
http://linuxtv.org/downloads/v4l-dvb-apis/
http://lwn.net/Articles/466304/

Fast interprocess communication revisited
http://lwn.net/Articles/466304/
sched_setscheduler() - Unix, Linux System Call
http://www.tutorialspoint.com/unix_system_calls/sched_setscheduler.htm
General MTD documentation
http://www.linux-mtd.infradead.org/doc/general.html
http://en.wikipedia.org/wiki/Flash_file_system#Translation_layers
**** F2FS文件系统架构与原理分析(三)
http://blog.chinaunix.net/uid-27714502-id-3904202.html
http://en.wikipedia.org/wiki/F2FS
http://lwn.net/Articles/518988/
http://lwn.net/Articles/353411/
http://lwn.net/Articles/190222/
pagemap的解读
http://blog.sina.com.cn/s/blog_628cc2b70101c8zu.html
Linux /proc第一篇---->/proc/pid记录了什么
http://www.oschina.net/question/565065_77182
浅谈Android开机启动速度优化（含应用程序启动速度优化）
http://blog.csdn.net/pillarbuaa/article/details/41445235
pstore: new filesystem interface to platform persistent storage
linux mount (挂载命令)详解
http://lwn.net/Articles/421297/
How To Analyse Output Of /proc/meminfo | Linux
http://www.techpaste.com/2012/06/21/analyse-output-procmeminfo-linux/
http://lwn.net/Articles/28309/
http://lwn.net/Articles/28345/

http://tutu.spaces.eepw.com.cn/articles/article/item/70737
Linux 2.6内核中新的锁机制--RCU

http://www.ibm.com/developerworks/cn/linux/l-rcu/
**** Kmemleak检测工具介绍
http://blog.csdn.net/lobbve/article/details/23208817
http://linux.cn/article-3682-1.html
http://www.linuxjournal.com/content/linux-kernel-testing-and-debugging?page=0,3

http://blog.csdn.net/zwcq82/article/details/7495306
arm abi
http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf

meminfo vmstat procrank top等详解

http://blog.csdn.net/arnoldlu/article/details/8443794
www.docin.com/p-727444015.html

Windows-tree命令生成目录树
http://blog.csdn.net/hu330459076/article/details/7656485
**** 避免物理内存碎片化 - ZONE_MOVABLE
http://blog.csdn.net/kickxxx/article/details/8722404
**** Linux Kernel Testing and Debugging
 http://www.linuxjournal.com/content/linux-kernel-testing-and-debugging?page=0,2
**** Linux进程地址空间详解
http://blog.chinaunix.net/uid-27213819-id-3783177.html
http://my.oschina.net/u/1770090/blog/263326
*** Android
**** uWeave
RFC 7049 Concise Binary Object Representation
http://cbor.io
Password-authenticated key agreement
https://en.wikipedia.org/wiki/Password-authenticated_key_agreement
http://www.di.ens.fr/~mabdalla/papers/AbPo05a-letter.pdf
**** CDD
http://source.android.com/compatibility/cdd.html
daydream:
http://www.11773.com/PullMyTongue/155256.html
http://www.engadget.com/2016/05/18/googles-new-vr-system/
http://arstechnica.com/gadgets/2016/05/android-vr-os-gets-a-virtual-reality-mode-and-vr-ready-smartphones/

http://arstechnica.com/gaming/2013/01/how-fast-does-virtual-reality-have-to-be-to-look-like-actual-reality/
http://arstechnica.com/gadgets/2016/05/the-third-android-n-preview-is-here-and-it-should-be-stable-enough-to-use/
http://arstechnica.com/gadgets/2016/02/report-google-planning-a-standalone-vr-headset/
**** Android N
https://developer.android.com/preview/api-overview.html
https://developer.android.com/guide/index.html
https://developer.android.com/guide/components/fundamentals.html

Vulkan Graphics API
https://developer.android.com/ndk/guides/graphics/index.html?utm_campaign=io16&utm_source=anddev&utm_medium=blog
https://www.khronos.org/assets/uploads/developers/library/overview/Vk_201602_Overview_Feb16.pdf

https://developer.android.com/training/monitoring-device-state/doze-standby.html#assessing_your_app
https://developer.android.com/preview/features/background-optimization.html
https://developer.android.com/reference/android/app/job/JobScheduler.html
https://developer.android.com/preview/behavior-changes.html
https://developer.android.com/reference/android/os/PowerManager.WakeLock.html
https://developer.android.com/reference/android/app/AlarmManager.html
https://developer.android.com/training/monitoring-device-state/doze-standby.html#assessing_your_app
https://developer.android.com/preview/features/multi-window.html
https://developer.android.com/guide/components/recents.html
https://developer.android.com/guide/components/intents-filters.html
https://developer.android.com/guide/topics/resources/runtime-changes.html
https://developer.android.com/guide/components/tasks-and-back-stack.html



https://developer.android.com/guide/topics/resources/providing-resources.html

OpenGL 矩阵变换（讲的太好了~！）
http://blog.csdn.net/lyx2007825/article/details/8792475

OPGL Insight
http://www.seas.upenn.edu/~pcozzi/OpenGLInsights/OpenGLInsights-TileBasedArchitectures.pdf
**** Android VR
https://developers.google.com/vr/android/

http://android-developers.blogspot.hk/2016/05/google-io-2016-develop-grow-earn.html
http://android-developers.blogspot.hk/2016/05/whats-new-in-android-n-release-virtual-reality-android-studio.html

https://vr.google.com/cardboard/developers/

http://unity3d.com/cn/get-unity/download

https://developers.google.com/vr/

https://developers.google.com/vr/android/samples/treasure-hunt#extend_gvractivity

http://stormzhang.com/android/2015/03/01/android-reference-local-aar/

http://android-developers.blogspot.hk/2015/10/bringing-google-cardboard-and-vr-to.html

INSTALL_FAILED_NO_MATCHING_ABIS when install apk
http://stackoverflow.com/questions/24572052/install-failed-no-matching-abis-when-install-apk


GOOGLE VR SDK开发VR游戏，VR播放器浅析之一
http://www.2cto.com/kf/201603/495471.html


https://en.wikipedia.org/wiki/Quaternion
https://en.wikipedia.org/wiki/Panning_(camera)
https://en.wikipedia.org/wiki/Ambisonics
https://github.com/google/spatial-media/blob/master/docs/spatial-audio-rfc.md#semantics
https://github.com/google/spatial-media/tree/master/spatialmedia
**** VR GAME
https://en.wikipedia.org/wiki/Id_Tech_4
https://en.wikipedia.org/wiki/Game_engine
https://en.wikipedia.org/wiki/List_of_game_engines
https://en.wikipedia.org/wiki/Cocos2d
https://en.wikipedia.org/wiki/LibGDX
https://en.wikipedia.org/wiki/OGRE
**** Vulkan
https://github.com/KhronosGroup

How to POST JSON data with Curl from Terminal/Commandline to Test Spring REST?
http://stackoverflow.com/questions/7172784/how-to-post-json-data-with-curl-from-terminal-commandline-to-test-spring-rest
 SOA记录和NS记录的通俗解释
http://bbs.51cto.com/thread-908637-1.html
名词解释:DNS,A记录,子域名,CNAME别名,PTR,MX,TXT,SRV,TTL
http://blog.csdn.net/chenfei_5201213/article/details/7614781
connman
https://en.wikipedia.org/wiki/ConnMan
http://lwn.net/Articles/456967/
http://www.ubuntugeek.com/connection-manager-connman-managing-internet-connections-in-linux.html
https://en.wikipedia.org/wiki/NetworkManager
https://en.wikipedia.org/wiki/HAL_(software)
https://en.wikipedia.org/wiki/Udev

https://en.wikipedia.org/wiki/Wireless_LAN
**** Latency Mitigation Strategies
https://web.archive.org/web/20140719085135/http://www.altdev.co/2013/02/22/latency-mitigation-strategies/
https://en.wikipedia.org/wiki/John_Carmack

https://www.twentymilliseconds.com
https://www.youtube.com/watch?v=WvtEXMlQQtI
http://blogs.valvesoftware.com/abrash/latency-the-sine-qua-non-of-ar-and-vr/
http://blogs.valvesoftware.com/abrash/when-it-comes-to-resolution-its-all-relative/
http://blogs.valvesoftware.com/abrash/why-you-wont-see-hard-ar-anytime-soon/
http://blogs.valvesoftware.com/abrash/two-possible-paths-into-the-future-of-wearable-computing-part-1-vr/
OLED vs. LED: Which is the better TV technology?
http://www.digitaltrends.com/home-theater/oled-vs-led-which-is-the-better-tv-technology/#:r6O2ZVb2uOKXYA
Raster scan
https://en.wikipedia.org/wiki/Raster_scan
https://en.wikipedia.org/wiki/Vertical_blanking_interval
具体的ATW的原理可参考：
http://m.blog.csdn.net/article/details?id=50667507
http://www.myexception.cn/other/1883027.html
http://it.sohu.com/20151113/n426374638.shtml
VR可能永远不会成功？这都怪你的穴居人大脑
http://news.sohu.com/20160525/n451315970.shtml
virtual reality experiences using smartphones.
http://projects.ict.usc.edu/mxr/diy/fov2go/
**** OpenStack
https://en.wikipedia.org/wiki/OpenStack
global shutter和rolling shutter，全局快门与卷帘式快门
http://www.xuebuyuan.com/2201085.html
http://wenku.baidu.com/link?url=lsFDQ3f-8Ow7fo75E2VN2Fjmnzc_DC53qMLkMwdCOfkQ7Wi50SLzik8XuhFWYCRVD5Kq2QzsgngcHx9yQ86eAOaNQfEAT9_LBSKBKLYsi3e

Screen tearing
https://en.wikipedia.org/wiki/Screen_tearing
Virtual reality
https://en.wikipedia.org/wiki/Virtual_reality
http://data-reality.com/comparison-of-best-vr-headsets-morpheus-vs-rift-vs-vive/
http://data-reality.com/virtual-reality-headsets-comparison/
**** WEAVE:
https://weave.googlesource.com/weave/libuweave/+/master/docs/
There is a libweave sample for Raspberry Pi 2 at https://codelabs.developers.google.com/codelabs/weave-rpi/index.html - maybe that might help a little bit...

https://weave.googlesource.com/weave/libuweave/+/master/README.md
ext3、ext4 orphan inode机制分析
http://wenku.baidu.com/link?url=0aYHOYWi438YBtvyVnIq-TocPPsTUmDD-RtBci6fZMlzFJLVhuNtgTt9BH8G-5Pk3fS5yxsYqbUxd-NV_aVIx9YjhoZK_hwpcWphbeCuw5q
ext3 journal block device 源代码分析
http://wenku.baidu.com/view/af0ce42c0066f5335a8121d2.html
**** Android的服务（Service）（一）生命周期
http://blog.csdn.net/hehui1860/article/details/37530641
android IPC通信中的UID和PID识别
http://blog.csdn.net/windskier/article/details/6921672
Memory compaction
http://lwn.net/Articles/368869/
Short topics in memory management
http://lwn.net/Articles/224829/
**** Android调试工具之adbs
http://www.cnblogs.com/eustoma/archive/2012/04/27/2473365.html
android性能测试工具之dumpsys
http://www.cnblogs.com/eustoma/archive/2012/04/27/2473377.html
 Linux下进程信息的深入分析
http://www.cnblogs.com/eustoma/archive/2012/04/27/2473175.html
Android getevent/senevent
http://blog.csdn.net/lichaoandy/article/details/6565893
Android中native进程内存泄露的调试技巧
http://blog.csdn.net/sucjhwaxp/article/details/8118522
本文链接地址: http://www.redwolf-blog.com/?p=1233
Android Debuggerd的分析及使用方法
http://blog.csdn.net/wonview/article/details/8446862
 /proc/sysrq-trigger
http://blog.chinaunix.net/uid-25508301-id-3213857.html
http://www.ibm.com/developerworks/cn/linux/l-cn-sysrq/
ROM优化技巧（二）
http://bbs.gfan.com/android-4792424-1-1.html
android system签名
http://blog.csdn.net/chen_chun_guang/article/details/6325833

http://blog.csdn.net/chen_chun_guang/article/details/6325833
Kernel panic 信息分析方法
http://book.51cto.com/art/201112/308324.htm
http://www.cnblogs.com/sdphome/archive/2012/03/05/2380703.html
http://routeadd-net202.114.6.yulei.blog.chinaunix.net/uid-21100425-id-4627305.html

linux I2C
http://blog.csdn.net/hongjiujing/article/details/4098547
**** android anr
http://blog.163.com/fenglang_2006/blog/static/133662318201162993919871/
OpenEmbedded入门（一）：OpenEmbedded简介
http://os.chinaunix.net/a2009/0116/990/000000990346.shtml
Modifying a Dynamic Library Without Changing the Source Code
http://www.linuxjournal.com/article/7795

http://www.cnblogs.com/guaiguai/archive/2010/06/11/1756427.html

http://blog.csdn.net/maray/article/details/5454839
How to generate a stacktrace when my gcc C++ app crashes
http://stackoverflow.com/questions/77005/how-to-generate-a-stacktrace-when-my-gcc-c-app-crashes?lq=1
**** AndroidManifest.xml文件详解
http://www.cnblogs.com/andriod-html5/archive/2012/05/21/2539418.html
一个简单的自定义ClassLoader的实现
http://www.cnblogs.com/sunsonbaby/archive/2004/12/20/79314.html
 一个bug引发的linux smp 血案（二）
http://routeadd-net202.114.6.yulei.blog.chinaunix.net/uid-25171069-id-3212735.html
c语言经典题目集中解答
http://routeadd-net202.114.6.yulei.blog.chinaunix.net/uid-25171069-id-3184670.html
http://routeadd-net202.114.6.yulei.blog.chinaunix.net/uid-25171069-id-3184665.html
Android启动器（Launcher）开发详解
http://www.2cto.com/kf/201306/218257.html
Android_launcher的源码详细分析
http://blog.csdn.net/hbzh2008/article/details/8979443
ARM Linux 3.x的设备树（Device Tree）
http://blog.csdn.net/21cnbao/article/details/8457546
Windows 下用 repo 下载Android源码
http://www.cnblogs.com/witxjp/archive/2011/03/25/1995328.html
Linux 关机重启流程分析

http://www.ibm.com/developerworks/cn/linux/embed/l-rb/
Total Commander基础使用教程

http://www.jiaocheng8.com/ruanjian/totalcommander/375.html
基于ARM 平台的Linux 内核Panic 机制分析及优化
http://www.wenlun.com/paperfree/1205/12050180045.html
__builtin_extract_return_addr 更多gcc的东西见
http://blog.csdn.net/unbutun/article/details/5717088
**** android 中的klogd
在android的init中调用klog_init （android/system/core/libcutils/klog.c）
mknod(name, S_IFCHR | 0600, (1 << 8) | 11) 使用　"/dev/__kmsg__"
该设备节点是在（kernel/drivers/char/mem.c）中注册了这个驱动，
       [11] = { "kmsg", 0, &kmsg_fops, NULL },
调用klog_write会最终调用kmsg_fops中kmsg_writev 会写到printk的内部buffer中。

Logcat中的打印会不会打印到printk使用的buffer，而是打印到（drivers/staging/android/logger.c）中定义的几个buffer中。

Sh中使用的打印输出是在 (/dev/console)
service_start
       open_console (/dev/console)
是否打开这个串口是由init.rc中的service的属性决定， 当service属性有console， 在init.rc中sh的定义如下。
service console /system/bin/sh
    class core
    console
disabled

/dev/console 是在/drivers/tty/tty_io.c的tty_init 中
console_fops->open
tty_open
       tty_lookup_driver
              console_device
                     c->device // 这里就是前一步register_console的 asoc_console
                            uart_console_device
                                   p->tty_driver
        tty->ops->open(tty, filp) // uart_ops 在uart_register_driver中初始化
                     uart_open
                            uart_startup
                                   uart_port_startup
                                          uport->ops->startup // asoc_uart_pops 这个ops是在asoc_init_port中初始化的
                                                 asoc_startup
p->tty_driver是在arch/arm/mach_leopard/asoc_serial.c 注册的。
asoc_serial_init
uart_register_driver
       tty_register_driver


shell写数据
console_fops->write
redirected_tty_write
        tty_write
                do_tty_write
                        ld->ops->write  //  tty_ldisc_N_TTY
                        n_tty_write
**** Android横竖屏切换总结
http://blog.csdn.net/jiangxinyu/article/details/8600407
Quickly find which file(s) belongs to a specific inode number
http://unix.stackexchange.com/questions/35292/quickly-find-which-files-belongs-to-a-specific-inode-number
Debugfs
http://lwn.net/Articles/115405/
Ext4 Howto
https://ext4.wiki.kernel.org/index.php/Ext4_Howto
ext3、ext4的orphan inode机制分析
Journaling file system

http://en.wikipedia.org/wiki/Journaling_file_system
http://www.ibm.com/developerworks/library/l-journaling-filesystems/index.html

http://en.wikipedia.org/wiki/Ext4
ext4的fsync性能和nodelalloc参数的分析
http://blog.csdn.net/evilcode/article/details/7006925
http://thinksrc.com/2011/06/24/ext4%E7%9A%84fsync%E6%80%A7%E8%83%BD%E5%92%8Cnodelalloc%E5%8F%82%E6%95%B0%E7%9A%84%E5%88%86%E6%9E%90/
理解ext4，第一部分(extents)
http://blog.csdn.net/vah101/article/details/7426143
7.1. Tuning Considerations for File Systems

https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html-single/Performance_Tuning_Guide/index.html#idm21576544
**** The Android ION memory allocator
http://blog.csdn.net/thegameisfives/article/details/7308458
http://blog.csdn.net/liuxiaochen77/article/details/8472076
http://blog.csdn.net/tjy1985/article/details/7554437
http://lwn.net/Articles/472984/
http://lwn.net/Articles/480055/
**** android 内存泄漏分析过程详解
http://blog.csdn.net/fulinwsuafcie/article/details/38595677

dma-buf: mmap support
http://lwn.net/Articles/493077/
磁盘阵列 锁定
http://baike.baidu.com/link?url=US7wL9uAXAKuLowhj7E9esIxJDdhov-Ku_MyjcieRZh9Gdopd1KfP9yICDTNJOtLRkZYrtXqhuasV98HVYweqxyxOhl1ffXtShvR2zjk56_o2ibIFrM7feHSbRZJUjir

http://www.snia.org/sites/default/files/SNIA_DDF_Technical_Position_v2.0.pdf

md.txt
**** systrace:
如何使用systrace做性能分析
http://blog.csdn.net/papenghan/article/details/8434476

http://developer.android.com/tools/help/systrace.html
http://developer.android.com/tools/debugging/systrace.html
**** android ZRAM & KSM
http://source.android.com/devices/tech/low-ram.html
http://lwn.net/Articles/306704/
http://lwn.net/Articles/330589/
Transcendent memory in a nutshell
http://lwn.net/Articles/454795/
http://lwn.net/Articles/475681
zcache: a compressed page cache
http://lwn.net/Articles/545244
http://lwn.net/Articles/397574/ http://askubuntu.com/questions/471912/zram-vs-zswap-vs-zcache-ultimate-guide-when-to-use-which-one
Memory management when failure is not an option

http://lwn.net/Articles/634983/

Virtual filesystem layer changes, past and future
http://lwn.net/Articles/636730/
ANR 分析
http://wenku.baidu.com/link?url=5XPvk9QLmUw-HWo6zrj7o3CK5yhRrb_lB-z-RQK__Kf8cBfajVov-52KYbX7OHks2ALit3Snjc-kyIPS3ULKp_uQe4XNkDFE3XRksj0Llla

Memory Analysis for Android Applications
http://android-developers.blogspot.com/2011/03/memory-analysis-for-android.html
Android内存管理机制之一：lowmemorykiller
http://blog.tianya.cn/post-3738007-34463302-1.shtml
**** Android 性能优化 五 性能分析工具dumpsys的使用
http://blog.csdn.net/androiddevelop/article/details/37689339
https://source.android.com/devices/input/dumpsys.html
http://developer.android.com/training/articles/memory.html
http://stackoverflow.com/questions/2298208/how-do-i-discover-memory-usage-of-my-application-in-android

Entries in /proc/meminfo
http://stackoverflow.com/questions/658411/entries-in-proc-meminfo
*** network
**** mDNS
https://en.wikipedia.org/wiki/Multicast_DNS
https://tools.ietf.org/html/rfc6762
Zero-configuration networking
https://en.wikipedia.org/wiki/Zero-configuration_networking
https://en.wikipedia.org/wiki/Name_Service_Switch
Brillo
BRILLO: 将系统移植到RASPBERRY PI 2B(树莓派)上
http://www.brobwind.com/archives/96

https://www.chromium.org/developers/design-documents/tpm-usage#TOC-Rollback-Prevention
http://www.chromium.org/chromium-os/chromiumos-design-docs/recovery-mode
https://www.chromium.org/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery
http://www.chromium.org/chromium-os/chromiumos-design-docs/developer-mode

Google创意实验室制作的一个镜像，使RaspberryPi成为一个网页制作服务器
http://googlecreativelab.github.io/coder/
http://www.guokr.com/post/510229/
**** cURL
https://en.wikipedia.org/wiki/CURL
https://curl.haxx.se
https://github.com/curl/curl.git
https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol
https://en.wikipedia.org/wiki/Constrained_Application_Protocol
https://en.wikipedia.org/wiki/MQTT
Byte serving
https://en.wikipedia.org/wiki/Byte_serving
List of HTTP header fields
https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#transfer-encoding-response-header

Language binding
https://en.wikipedia.org/wiki/Language_binding

Component	Typical Linux implementation	Description
HTTP(S) client	libcurl +
HTTP wrapper	For making HTTP/HTTPS calls to the Weave web service.
HTTP(S) server	libmicrohttpd + wrapper	To expose local API surfaces
Network and WiFi mgmt	wpa_supplicant, hostapd	List network interfaces, create WiFi AP, open sockets
Local Discovery	avahi	DNS-SD (mDNS) discovery
TLS support	openssl	Handle TLS management, e.g. openssl
BLE module	bluez	BLE support for peripheral mode
**** WEAVE
https://codelabs.developers.google.com/codelabs/brillo-your-product/#0
https://developers.google.com/weave/v1/reference/model-manifest#adding_a_model_manifest_via_the_weave_developer_console
https://developers.google.com/weave/guides/device-dev/getting-started#system_requirements
https://weave.googlesource.com/weave/libweave/+/master/README.md
https://weave.googlesource.com/weave/libweave/+/master/examples/daemon/README.md
https://www.googleapis.com/auth/weave.app
https://weave.google.com/console/#control
DNSmasq
http://baike.baidu.com/link?url=y3MzCYJ3E_todHqTtkR2rNdqIfj9Kll8Tyh10KKSW8jFe_gczcZmVqK4eapL_xRA4HsMsN8yrI_w16dQiOJBMa
http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html
**** OAuth 2.0 Playground
https://developers.google.com/oauthplayground/
# OAuth 2.0 client id. client_id=
251090581729-ibu9pvq4f94rc8gkejtsrdd810p159qd.apps.googleusercontent.com
# OAuth 2.0 client secret. client_secret=
g047ACP5rH0LkCf5345jSnZb
# API key. api_key=
AIzaSyD5Ky09Wl9z9H01xd6vEixXNaaTNK_8YxM
http://instaweave.devrel.pub
OAuth
https://en.wikipedia.org/wiki/OAuth
The OAuth 2.0 Authorization Framework
https://tools.ietf.org/html/rfc6749
OAuth2.0简介
http://wiki.open.qq.com/wiki/mobile/OAuth2.0简介
理解OAuth 2.0
http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html
**** Avahi (software)
https://en.wikipedia.org/wiki/Avahi_(software)
https://github.com/lathiat/avahi
Linux上的avahi-daemon Service服务
http://www.askmaclean.com/archives/tag/linux
Dynamic Configuration of IPv4 Link-Local Addresses
https://tools.ietf.org/html/rfc3927
Multicast DNS
https://tools.ietf.org/html/rfc6762
DNS-Based Service Discovery
https://tools.ietf.org/html/rfc6763
http://www.dns-sd.org
The mDNS multicast address is 224.0.0.251
Each host listens on the mDNS port, 5353
Zero-configuration networking
https://en.wikipedia.org/wiki/Zero-configuration_networking
Multicast DNS
https://en.wikipedia.org/wiki/Multicast_DNS
http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xml
**** XMPP
https://en.wikipedia.org/wiki/XMPP
http://blog.csdn.net/wbw1985/article/details/5502272
Extensible Messaging and Presence Protocol (XMPP): Core
https://tools.ietf.org/html/rfc6120
http://www.jabber.org
https://xmpp.net
http://swift.im/downloads.html
http://swift.im

https://chinwag.im
zhangdongfeng@chinwag.im zhangdf1
https://blah.im/index.html
zhangdongfeng@blah.im
https://en.wikipedia.org/wiki/Google_Talk
https://en.wikipedia.org/wiki/Comparison_of_instant_messaging_clients
https://en.wikipedia.org/wiki/Pidgin_(software)
https://pidgin.im
https://en.wikipedia.org/wiki/Adium
HTTP协议之multipart/form-data请求分析
http://blog.csdn.net/xiaojianpitt/article/details/6856536
curl.1 the man page
https://curl.haxx.se/docs/manpage.html
XAMPP
https://en.wikipedia.org/wiki/XAMPP
**** Wireless Zero Configuration
https://en.wikipedia.org/wiki/Wireless_Zero_Configuration
http://www.baike.com/wiki/Zeroconf
Domain Name System
https://en.wikipedia.org/wiki/Domain_Name_System#DNS_message_format
https://tools.ietf.org/html/rfc1035
Lightweight Directory Access Protocol
https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol
A client starts an LDAP session by connecting to an LDAP server, called a Directory System Agent (DSA), by default on TCP and UDP port 389

WS-Discovery
https://en.wikipedia.org/wiki/WS-Discovery
It operates over TCP and UDP port 3702 and uses IP multicast address 239.255.255.250.

https://github.com/lathiat/avahi
Overlay：
https://en.wikipedia.org/wiki/Overlay_(programming)
http://sourceware.org/binutils/docs/ld/Overlay-Description.html
https://en.wikipedia.org/wiki/Chain_loading s
**** TLS
The Transport Layer Security (TLS) Protocol
http://tools.ietf.org/html/rfc5246
Datagram Transport Layer Security Version 1.2
http://tools.ietf.org/html/rfc6347
HMAC: Keyed-Hashing for Message Authentication
http://tools.ietf.org/html/rfc2104
Transport Layer Security (TLS) Extensions: Extension Definitions
http://tools.ietf.org/html/rfc6066
Transport Layer Security Protocol Compression Methods
http://tools.ietf.org/html/rfc3749
  AES-CCM Cipher Suites for Transport Layer Security (TLS)
http://tools.ietf.org/html/rfc6655
HTTP Over TLS
http://www.ietf.org/rfc/rfc2818.txt
**** mbed TLS
https://en.wikipedia.org/wiki/Mbed_TLS
https://tls.mbed.org/download-archive
**** NAT与NAT穿透(一)
http://blog.csdn.net/ustcgy/article/details/5652268
Peer-to-Peer (P2P) Architecture:
          Definition, Taxonomies, Examples, and Applicability
http://tools.ietf.org/html/rfc5694
State of Peer-to-Peer (P2P) Communication across  Network Address Translators (NATs)
http://tools.ietf.org/html/rfc5128
Traditional IP Network Address Translator (Traditional NAT)
https://tools.ietf.org/html/rfc3022

Peer-to-Peer(P2P) communication
                across Network Address Translators(NATs)
https://tools.ietf.org/html/draft-ford-midcom-p2p-03

Network Address Translation (NAT) Behavioral Requirements for Unicast UDP
https://tools.ietf.org/html/rfc4787
NAT Behavioral Requirements for TCP
https://tools.ietf.org/html/rfc5382
NAT Behavioral Requirements for ICMP
https://tools.ietf.org/html/rfc5508
Interactive Connectivity Establishment (ICE):
     A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols
https://tools.ietf.org/html/rfc5245

DNS64: DNS Extensions for Network Address Translation
                   from IPv6 Clients to IPv4 Servers
https://tools.ietf.org/html/rfc6147

https://www.jool.mx/en/dns64.html
NAT64：
https://en.wikipedia.org/wiki/NAT64

apt-get install bind9
etc/bind/named.conf.options
options {
        (...)

        # Listening on IPv6 is off by default.
        listen-on-v6 { any; };

        # This is the key. Note that you can write multiple of these if you need
        # more IPv6 prefixes.
        # "64:ff9b::/96" has to be the same as Jool's `pool6`.
        dns64 64:ff9b::/96 {
                # Options per prefix (if you need them) here.
                # More info here: https://kb.isc.org/article/AA-01031
        };
};

http://namsep.blogspot.hk/2015/07/raspberry-pi-debian-nat64-dns64-joolmx.html

  Explicit Address Mappings for Stateless IP/ICMP Translation
https://tools.ietf.org/html/rfc7757

IPv6 Addressing of IPv4/IPv6 Translators
https://tools.ietf.org/html/rfc6052

https://www.jool.mx/en/index.html
https://github.com/NICMx/Jool/tree/v3.4.2
https://www.jool.mx/en/intro-xlat.html
https://www.jool.mx/en/intro-jool.html

464XLAT: Combination of Stateful and Stateless Translation
http://tools.ietf.org/html/rfc6877

Stateful NAT64: Network Address and Protocol Translation
                   from IPv6 Clients to IPv4 Servers

https://tools.ietf.org/html/rfc6146

Experiences from an IPv6-Only Network
https://tools.ietf.org/html/rfc6586

IP/ICMP Translation Algorithm
https://tools.ietf.org/html/rfc6145

Configuring NAT64 and DNS64
https://technet.microsoft.com/en-us/library/ee406236.aspx

NAT46
The China Education and Research Network (CERNET) IVI Translation Design and Deployment for the IPv4/IPv6 Coexistence and Transition
https://tools.ietf.org/html/rfc6219

https://github.com/ayourtch/nat46
Mapping of Address and Port using Translation (MAP-T)
https://tools.ietf.org/html/rfc7599
6to4
Connection of IPv6 Domains via IPv4 Clouds
https://tools.ietf.org/html/rfc3056
RFC 3068 / An Anycast Prefix for 6to4 Relay Routers
http://www.faqs.org/rfcs/rfc3068.html

112.91.148.197
[2002:705b:94c5::1]
sudo ifconfig sit0 up
sudo ifconfig sit0 add 2002:705b:94c5::1/16
sudo route -A inet6 add default gw ::192.88.99.1 dev sit0

softap：
sudo route -A inet6 add 2002:705b:94c5::/64 dev wlan0

http://www.kfu.com/~nsayer/6to4/
https://6to4.nro.net
https://6to4.nro.net/6to4_reverse/non_2002/index.html
Free DNS
https://www.internic.net/whois.html
https://en.wikipedia.org/wiki/Domain_Name_System
https://en.wikipedia.org/wiki/DNS_zone_transfer
https://en.wikipedia.org/wiki/Hurricane_Electric

http://cs.now.cn/html/FAQ/Domain/yumingjiexi/201510/10-9433.html
d769968

https://dns.he.net
112.91.148.197

DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION
https://tools.ietf.org/html/rfc1035

Linode免费DNS使用方法和He.net稳定功能强大的DNS解析服务
http://www.freehao123.com/linode-he-net/

DNS64
https://www.jool.mx/en/dns64.html
linux系统dig和nslookup的安装
http://www.71j.cn/archives/115
http://www.jb51.net/LINUXjishu/422671.html

6lowpan_router
http://teamarin.net/2015/03/03/ipv6-brewed-coffee-bluetooth-smart/


ssh -6 -l pi 2001:470:19:f5d::4

wlan0     Link encap:Ethernet  HWaddr e8:4e:06:34:f1:19
          inet addr:192.168.0.121  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::9828:2551:442d:c23b/64 Scope:Link
          inet6 addr: 2001:470:19:f5d::4/128 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:46 errors
IPv6 Tunnel Broker
https://datatracker.ietf.org/doc/rfc3053

tcpdump -t -n -s 512 -vv ip6 or proto ipv6

Hurricane Electric Free IPv6 Tunnel Broker
https://tunnelbroker.net

https://dns.he.net

https://forums.he.net/index.php?PHPSESSID=ulafarljbi8amhge174qfe6lj3&board=2.0

sudo ifconfig sit0 up
sudo ifconfig sit0 inet6 tunnel ::216.218.221.6
sudo ifconfig sit1 up
sudo ifconfig sit1 inet6 add 2001:470:18:115d::2/64
sudo route -A inet6 add ::/0 dev sit1
sudo route -A inet6 add 2001:470:19:115d::/64 dev wlan0


sudo modprobe bluetooth_6lowpan
sudo echo 1 >  /sys/kernel/debug/bluetooth/6lowpan_enable
sudo echo "connect 00:72:B6:0D:94:D7 1” > /sys/kernel/debug/bluetooth/6lowpan_control
sudo route -A inet6 add 2001:470:19:115d::/64 dev bt0
tcpdump -t -n -i bt0 -s 512 -vv ip6 or proto ipv6

softap：
sudo route -A inet6 add 2001:470:19:115d::/64 dev wlan0
Bluetooth：
sudo route -A inet6 add 2001:470:19:115d:272:b6ff:fe0d:94d7 dev bt0

2001:470:19:115d:272:b6ff:fe0d:94d7

sudo ping6 2001:470:19:115d:272:b6ff:fe0d:94d7

tcpdump -t -n -i bt0 -s 512 -vv ip6 or proto ipv6
ssh -l pi  112.91.148.197
ssh  -6 -l pi 2001:470:18:115d::2
vnc也可以使用ipv6地址

zhangdongfeng-2.tunnel.tserv20.hkg1.ipv6.he.net

Guidelines for 64-bit Global Identifier (EUI-64) General
http://standards.ieee.org/develop/regauth/tut/eui64.pdf

http://www.deepspace6.net/docs/ipv6_status_page_apps.html#http
http://www.deepspace6.net/docs/iproute2tunnel-en.html

RPI-Wireless-Hotspot
http://elinux.org/RPI-Wireless-Hotspot
https://www.raspberrypi.org/forums/viewtopic.php?f=91&t=54946
需要替换hostapd
Raspberry Pi Static IP Address
http://www.suntimebox.com/raspberry-pi-tutorial-course/week-3/day-5/
http://elinux.org/RPi_Setting_up_a_static_IP_in_Debian
http://raspberrypi.stackexchange.com/questions/38834/how-to-prevent-etc-resolv-conf-from-being-overwritten
auto eth0
iface eth0 inet static
address 112.91.148.197
netmask 255.255.255.248
gateway 112.91.148.193
dns-nameservers 221.5.88.88

SSID  My_AP
wpa_passphrase=My_Passphrase
从零开始,把Raspberry Pi打造成双栈11n无线路由器,支持教育网原生IPv6
http://blog.csdn.net/cyuyan112233/article/details/44568509
sudo echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
超级详细的iptables介绍
http://blog.csdn.net/sdytlm/article/details/6544913/
https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html

RaspVPN: Raspberry Pi + SoftAP + OpenVPN
http://shumeipai.nxez.com/2014/01/03/raspvpn-raspberry-pi-softap-openvpn.html
http://willings.me/article/raspberry-pi-softap-openvpn/?utm_source=tuicool&utm_medium=referral

macosx:
http://ipv6int.net/systems/mac_os_x-ipv6.html
Transition Mechanisms for IPv6 Hosts and Routers
http://www.faqs.org/rfcs/rfc4213.html
Teredo: Tunneling IPv6 over UDP
through Network Address Translations (NATs)
https://tools.ietf.org/html/rfc4380

https://en.wikipedia.org/wiki/Teredo_tunneling

https://en.wikipedia.org/wiki/Miredo

http://www.remlab.net/miredo/

https://github.com/darconeous/miredo-osx
   Teredo for MacOS X：
http://www.deepdarc.com/miredo-osx（安装即可）
     tuntaposx：
http://tuntaposx.sourceforge.net
Linux的TUN/TAP编程
http://blog.chinaunix.net/uid-317451-id-92474.html

http://stackoverflow.com/questions/6646495/how-do-you-make-ipv6-default-in-chrome-for-mac

https://tsukkomi.org/post/free-ipv6-again-teredo

Architectural Implications of NA
https://www.rfc-editor.org/rfc/rfc2993.txt

Multiprotocol Extensions for BGP-4
http://www.faqs.org/rfcs/rfc2283.html
Transmission of IPv6 over IPv4 Domains without Explicit Tunnels
http://www.faqs.org/rfcs/rfc2529.html
Transition Mechanisms for IPv6 Hosts and Routers
http://www.faqs.org/rfcs/rfc2893.html
Use of BGP-4 Multiprotocol Extensions for IPv6 Inter-Domain Routing
http://www.faqs.org/rfcs/rfc2545.html

- ipv6.he.net
- dns.he.net
https://www.sixxs.net/main/
https://www.sixxs.net/presentations/

Unique Local IPv6 Unicast Addresses
https://tools.ietf.org/html/rfc4193
Unicast-Prefix-based IPv6 Multicast Addresses
https://tools.ietf.org/html/rfc3306
Address Allocation for Private Internets
https://tools.ietf.org/html/rfc1918
Special-Purpose IP Address Registries
https://tools.ietf.org/html/rfc6890

Initial IPv6 Sub-TLA ID Assignments
https://tools.ietf.org/html/rfc2928
IPv6 Benchmarking Methodology for Network Interconnect Devices
https://tools.ietf.org/html/rfc5180
IPv6 Addressing of IPv4/IPv6 Translators
https://tools.ietf.org/html/rfc6052
IPv6 Address Prefix Reserved for Documentation
https://tools.ietf.org/html/rfc3849
Connection of IPv6 Domains via IPv4 Clouds
https://tools.ietf.org/html/rfc3056
Deprecating the Anycast Prefix for 6to4 Relay Routers
https://tools.ietf.org/html/rfc7526
Requirements for Internet Hosts -- Communication Layers
https://tools.ietf.org/html/rfc1122#section-3.2.1.3
An Incremental Carrier-Grade NAT (CGN) for IPv6 Transition
https://tools.ietf.org/html/rfc6264

Benchmarking Methodology for Network Interconnect Devices
https://tools.ietf.org/html/rfc2544

DNS IPv6 Transport Operational Guidelines
https://tools.ietf.org/html/rfc3901
Basic Socket Interface Extensions for IPv6
https://tools.ietf.org/html/rfc3493
Default Address Selection for Internet Protocol Version 6
https://tools.ietf.org/html/rfc6724
Application Aspects of IPv6 Transition
https://tools.ietf.org/html/rfc4038
IPv6 over BLUETOOTH(R) Low Energy
https://tools.ietf.org/html/rfc7668
Neighbor Discovery Optimization for IPv6 over Low-Power Wireless Personal Area Networks
https://tools.ietf.org/html/rfc6775
Multi-Link Subnet Issues
https://tools.ietf.org/html/rfc4903
IPv6 Stateless Address Autoconfiguration
https://tools.ietf.org/html/rfc4862
Significance of IPv6 Interface Identifiers
https://tools.ietf.org/html/rfc7136
Router
   Solicitation messages as described in [RFC4861], Section 6.3.7.
For non-link-local addresses, 6LNs SHOULD NOT be configured to embed
   the Bluetooth device address in the IID by default.  Alternative
   schemes such as Cryptographically Generated Addresses (CGAs)
   [RFC3972], privacy extensions [RFC4941], Hash-Based Addresses (HBAs)
   [RFC5535], DHCPv6 [RFC3315], or static, semantically opaque addresses
   [RFC7217] SHOULD be used by default.
IPv6 prefix for numbering the
   Bluetooth LE network is out of scope of this document, but can be,
   for example, accomplished via DHCPv6 Prefix Delegation [RFC3633] or
   by using Unique Local IPv6 Unicast Addresses (ULAs) [RFC4193].

IPv6 Router Advertisement Options for DNS Configuration (RFC 6106)
NAT-PT, RFC 2766
Neighbor Discovery Protocol (NDP) is defined in RFCs 2461[7] and 2462[8].
IPv6功能测试
http://wenku.baidu.com/link?url=cpRtm9x-Dr8YXRHlInkYmoyBNMbCLHQhUt6bE5aMe9gpij88NosK7E5LdmGQEOpfXN6I2dRnXxe0KvYAT6MgGcGsx5GZR38LLDBqw-sf2oa

A guide to the confusing Internet of Things standards world
http://www.networkworld.com/article/2456421/internet-of-things/a-guide-to-the-confusing-internet-of-things-standards-world.html
6LoWPAN for Bluetooth low energy on OpenWRT
https://devzone.nordicsemi.com/blogs/663/6lowpan-for-bluetooth-low-energy-on-openwrt/

IPv6系列小实验之1：6to4隧道基本配置
http://edges.blog.51cto.com/blog/705035/324737

IPv6过渡技术之 6to4 自动隧道
http://blog.sina.com.cn/s/blog_5ec353710101e45y.html
Linux IPv6 Router: RADVD + DHCPv6
http://blog.csdn.net/l0605020112/article/details/18225143
OMA LWM2M
https://en.wikipedia.org/wiki/OMA_LWM2M

http://www.faqs.org/faqs/macintosh/ZTerm/part1/
**** MQTT协议详解一
http://www.xuebuyuan.com/1951015.html
http://mqtt.org/documentation
蓝牙智能IPv6((IPv6 over Bluetooth Smart)奠定物联网基础
http://www.chinaaet.com/article/3000007680
https://devzone.nordicsemi.com/blogs/663/6lowpan-for-bluetooth-low-energy-on-openwrt/
**** IPV6
http://pcedu.pconline.com.cn/671/6712896_all.html#content_page_2
https://en.wikipedia.org/wiki/IPv6
https://en.wikipedia.org/wiki/IPv6_address
https://en.wikipedia.org/wiki/IPv6_deployment
https://en.wikipedia.org/wiki/IPv6_transition_mechanism
https://en.wikipedia.org/wiki/NAT64

https://en.wikipedia.org/wiki/IPv6_address#IPv6_addresses_in_the_Domain_Name_System

http://ipv6-test.com
http://www.worldipv6launch.org
http://ipv6day.cn
http://ip.bieringer.de

IPV6相关RFC文档

http://docs.oracle.com/cd/E19253-01/819-7058/ipv6-ref-47/index.html

http://blog.csdn.net/l0605020112/article/details/42154157

https://en.wikipedia.org/wiki/Supernetwork
https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing
https://en.wikipedia.org/wiki/Network_address_translation

http://ipv6.com/articles/general/IPv6-Addressing.htm

http://ipv6int.net/ipv6/index.html

http://ipv6int.net/systems/mac_os_x-ipv6.html

IP Version 6 Addressing Architecture
http://tools.ietf.org/html/rfc4291
The Constrained Application Protocol
https://datatracker.ietf.org/doc/rfc7252/

IPv6 Stateless Address Autoconfiguration
https://tools.ietf.org/html/rfc4862
Significance of IPv6 Interface Identifiers
https://tools.ietf.org/html/rfc7136
IP Version 6 Addressing Architectur
https://tools.ietf.org/html/rfc4291
Internet Protocol, Version 6
https://tools.ietf.org/html/rfc2460
IP Version 6 Addressing Architectur
https://tools.ietf.org/html/rfc4291

Assigned Internet Protocol Numbers
http://www.iana.org/protocols
http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml#protocol-numbers-1

IPv6 Stateless Address Autoconfiguration
https://tools.ietf.org/html/rfc4862
Neighbor Discovery for IP version 6
http://tools.ietf.org/html/rfc4861
Multicast Listener Discovery (MLD) for IPv6
https://tools.ietf.org/html/rfc3810
Internet Control Message Protocol (ICMPv6)
https://tools.ietf.org/html/rfc4443
Peer-to-Peer (P2P)
http://tools.ietf.org/html/rfc5128
http://blog.csdn.net/ustcgy/article/details/5646755
http://www.peer-to-peerwg.org/tech/nat/
**** 中文RFC文档
http://www.cnpaf.net/class/RfcAll/

如何查看外网IP地址_百度经验
http://jingyan.baidu.com/article/e52e3615beb08340c60c51d2.html
Linux wext和nl80211接口简介
http://blog.csdn.net/dickjtk/article/details/11862815
**** NAT原理与NAT穿越
http://www.cnblogs.com/bo083/articles/2170189.html

http://blog.sina.com.cn/s/blog_6151984a0100exc6.html
iptables详解
http://blog.chinaunix.net/uid-22780578-id-3346350.html
http://www.linuxso.com/linuxpeixun/10332.html
linux双网卡NAT共享上网
http://www.2cto.com/os/201209/152871.html
linux下dhcp服务器配置
http://blog.chinaunix.net/uid-25324849-id-224853.html
[HOWTO] - SETUP DHCPD (SERVER) ON MAC OS X (WORKSTATION)
http://macosx.com/threads/howto-setup-dhcpd-server-on-mac-os-x-workstation.14022/
http://isc.org/products/DHCP/
Using Mac OS X as a DHCP Server
http://www.aleph0.com/computing/macosx/dhcp-setup/
http://www.cyberciti.biz/faq/howto-configure-macosx-as-nat-router/

对比Mac OS上的PF与iptables
http://blog.csdn.net/dog250/article/details/8944111
CES
https://mp.weixin.qq.com/s?__biz=MjM5MDA5MTY2MA==&mid=401360805&idx=1&sn=ab3fe57330bd24a6ed5bbfd5969e2291&scene=1&srcid=0104676UmKvpt33XKvNUhdc3&key=41ecb04b0511100359127b2a3fddfeb6740ab2d17d72d11ef2621f867bf31fa612b811130d55b7231dff7f0b1cd84ead&ascene=0&uin=MTkwOTI5ODA4Mg%3D%3D&devicetype=iMac+MacBookAir6%2C2+OSX+OSX+10.10.2+build(14C1510)&version=11020201&pass_ticket=m3I%2FipuSRm6Sr%2FYHc6Bi22MznnIKOsEiTw2RYXqG4FcDg4MuVDTrDZgHsCNxFtyi
BroadCom
http://www.broadcom.com/application/internet_of_things.php
http://home.eeworld.com.cn/my/space-uid-216477-blogid-242586.html
**** TCP协议详解（理论篇）
http://www.cnblogs.com/kzloser/articles/2582957.html
http://www.2cto.com/net/201208/149347.html
ptype_base和ptype_all学习笔记
http://blog.chinaunix.net/uid-20779306-id-1845681.html
GSO: Generic Segmentation Offload
http://lwn.net/Articles/189970/
netpoll浅析
http://blog.csdn.net/lucien_cc/article/details/11731501
netconsole（通过网络传输dmesg）的实现
http://blog.csdn.net/lostspeed/article/details/6248153
linux 内核tcp数据发送的实现
http://www.pagefault.info/?p=3
http://docs.google.com/fileview?id=0BwW2sFmZEQNCZWM2MzcwNWQtYjhlNS00NGJlLThmYzgtZTJlNTZiNDk4MzYy&hl=enn

http://blog.csdn.net/zhangskd/article/details/16879781
**** LwIP协议栈源码详解
http://wenku.baidu.com/link?url=x7n8dzfrPdcP_Cf4heu0nOvk4tmlQmC2oqZs0A9cay-en6ywpezMBW4uyEwkSq5Rx9Iwu5DuWa5XnkCRXQwsaJOBROEFZWq5SpOyf4r61a7
关于开启lwIP协议栈的调试输出LWIP_DEBUGF
http://blog.csdn.net/ypist/article/details/6765634
UDP打洞原理
http://blog.csdn.net/jdh99/article/details/6667648
http://blog.csdn.net/mirkerson/article/details/7912188
2011官方Wifi_Direct协议介绍

http://wenku.baidu.com/link?url=O-2qJwSbtVA764OZqXzefpf3Nt_gbPtPHFdOmBdi-T3onMXyUV3Nh6WRoA8pB4P6I_lrGIF5jYvoy6CeFb_MhmOnQ0_vrwzr1IMPHPGA53e

http://blog.csdn.net/think_soft/article/details/8220736
omnigraffle 注册机For Mac 注册机
http://www.uzzf.com/soft/91710.html
StarUML 版本破解
http://blog.csdn.net/mergades/article/details/46662413
http://argouml.tigris.org/
http://www.visual-paradigm.com/
http://www.omnigroup.com/applications/omnigraffle/pro/
http://en.wikipedia.org/wiki/list_of_uml_tools

实验: 应用StarUML对C++工程进行UML双向
http://blog.csdn.net/lostspeed/article/details/6248153

google 人工智能引擎
http://www.tensorflow.org
张量
http://baike.baidu.com/link?url=J3BMyqt3WtGWoECkocMMS4gxIGwbfDscNAfn0EnrkaZh2h_QQ-VpoeeUXkCakq6ZRTtZJWmUnNm_gOV2b5oUJy9flqj3V9_D5dc5IVBv6ebeBULB00fq7xuxE_aDLkhEvAM3yhu_BAaVajxb8kUUj_

Derivative
https://en.wikipedia.org/wiki/Derivative
第四代语言
http://baike.baidu.com/link?url=gSAGB9v4IZYo6lpSJ1fWI87po8W5iwo_INKR2WeV_ba-_DdMypgoFzP-lQKPlnr8GAhegdjPiIj3g7Niw32zjq
SMIL
http://baike.baidu.com/link?url=DPxvjVMWszGX86Qorc6VUH055BLU-9DpQIJwf-fl90IkiUsA2E9sQIlBbD53d02-u4lV-x_1C-gaMNECzYUEva
Mike's PBX Cookbook
http://pbxbook.com/other/mac-tty.html
qpsk
http://baike.baidu.com/link?url=Y6GW4xbYkzrwevTcUml2eSRArwcPEeIVgYAohQr2nvNPzFLkhETez1NOxtcLCgxEjAe6cyU6H7FG4J8G8W3X4q
每天一个linux命令（60）：scp命令
http://www.cnblogs.com/peida/archive/2013/03/15/2960802.html

SYN Cookie的原理和实现
http://blog.csdn.net/zhangskd/article/details/16986931
**** TCP/IP

IPERF
https://iperf.fr
https://github.com/esnet/iperf
http://blog.csdn.net/robertsong2004/article/details/40920345
LWIP+IPERF
http://permalink.gmane.org/gmane.network.lwip.general/13787
https://people.ee.ethz.ch/~czingerl/doc/Iperf_Task.c
Linux iperf 用法介绍
http://blog.chinaunix.net/uid-9185047-id-464909.html
Iperf 源代码分析（五）
http://blog.csdn.net/willon_tom/article/details/4470214 K
TCP/IP详解学习笔记 这位仁兄写得太好了
http://www.cnblogs.com/fengzanfeng/articles/1339347.html
gcc-arm-embedded
https://launchpad.net/gcc-arm-embedded

arm-none-linux-gnueabi交叉工具链安装 ,介绍，区别总结
http://www.bubuko.com/infodetail-667810.html
Design and Implementation of the LwIP TCPIP Stack
http://wenku.baidu.com/link?url=KAFlwngnnJiA5fyK65_IomqpRCNEAwUI4a8oLV-DF6LJjDmN30JllGDOE2lzfCtxAwChvM3pTbBeyv2ijlWIfnwKNtZewBoOBJumdVOX-L3
**** 几个国外免费公共DNS解析服务器
http://wenku.baidu.com/link?url=3Xrhvl_lrOqSZbwIZwXBE0GEq4Db5v_bSYHikS0NdsF1q4WDG4dmYhcx7M1opeV2cmqK72krK_UkSiGATbjfAB1vqSM1vhXHG7COHaFIAsa
五个好用的网络协议分析工具（附下载）(1)
http://netsecurity.51cto.com/art/201103/246601.htm
http://network.51cto.com/art/201401/426792.htm
https://1.na.dl.wireshark.org/osx/Wireshark%202.0.0%20Intel%2064.dmg
详细讲解局域网的四种IP广播地址
http://www.enet.com.cn/article/2008/0908/A20080908355544.shtml
端口号
http://baike.baidu.com/link?url=u2n_xUYMB3TFM9XrnZM_KBw8f05O-_JWA55EwAnM3qJIbyUz_t99uGebCFh-KRwA
mdns
http://baike.baidu.com/link?url=cQnxnRYITkR7Xfa1m2cwB_dnXf_-6-VEtG02IIbGEfo-SGcXqfjXj_6eun8zMV2XplE56gUinX2ljHV-NpZlN_
组播
http://baike.baidu.com/view/492256.htm
TCP和UDP的135、137、138、139、445端口的作用
http://blog.csdn.net/johnson4303/article/details/7661086
224.0.0.252 本地链路多播名称解析
http://jingyan.baidu.com/article/046a7b3ee9776ff9c27fa9f4.html
内网总有发往224.0.0.22的数据存在
http://blog.chinaunix.net/uid-20363270-id-1962249.html
Internet组管理协议
http://blog.csdn.net/johnson4303/article/details/7661086
常见网络端口对照表(Excel)
http://wenku.baidu.com/link?url=gLN020I1kfu2GVr30tcUm5tZTc4bk8ERrD61vseyDBTgFVIFDiQERiiQCfDMutaW7gOF4LX-WlGAvwImugN2s-8Erkm-dAlZrHBKHhi7nu_
网络协议分析(免费下载)
http://wenku.baidu.com/link?url=r_WEahKGQHO7s0eFKnl3aP59gwLd-npbNctFwoF_A6klsD-ZLI6L9LKaxEDYkKfddeSQTfm95pPKD2cyHRW4VzR6D2PwKUFf34tDErs9IJ_
MAC地址
http://baike.baidu.com/link?url=6nDCtUAWxjIUPanE2DsEHBcFPH_REaGdCDyRDH0lhmVRdzTEE5vPdrZSpq9O_gHE0XWDbOL4wj8W0dvNKbQklK
https://en.wikipedia.org/wiki/MAC_address
RESTful
http://baike.baidu.com/link?url=qj42n30jS2FHXMiZ0tPSSryFu31G4yniX6M7HejbbWXHY7Zn-vfAElOPGAA21aBpdEZkGFzl2MKVBjR5ZD43Wq
RESTful API 设计指南
http://www.ruanyifeng.com/blog/2014/05/restful_api.html
我所理解的RESTful Web API [设计篇]

http://www.cnblogs.com/artech/p/3506553.html
tornado 中文文档
http://demo.pythoner.com/itt2zh/ch1.html
Tornado源码分析之http服务器篇
http://kenby.iteye.com/blog/1159621
tornado 教程
http://demo.pythoner.com/itt2zh/index.html
Datagram Transport Layer Security
https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security
Constrained Application Protocol
https://en.wikipedia.org/wiki/Constrained_Application_Protocol
认识 Markdown
http://sspai.com/25137
<深入浅出> linux内核 RCU （一）经典RCU
http://blog.csdn.net/chenyu105/article/details/7910269
*** tools
**** 在Emacs下用C/C++编程
http://blog.chinaunix.net/uid-9478057-id-2002272.html
http://www.caole.net/diary/emacs_write_cpp.html
使用gtags、etags、cscope、grep浏览源代码
http://blog.csdn.net/wuyao721/article/details/3059242
Cscope在emacs中的配置与使用
http://www.cnblogs.com/jtf-china/articles/2077922.html
一年成为Emacs高手(像神一样使用编辑器)
http://blog.csdn.net/redguardtoo/article/details/7222501/
https://www.emacswiki.org
https://github.com/purcell/emacs.d
(require 'ido)
(ido-mode t)
(require 'xcscope)
(add-hook 'c-mode-common-hook 'cscope-minor-mode)
https://www.emacswiki.org/emacs/EmacsWiki
**** Org-mode 简明手册
http://orgmode.org
http://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html
暴增 Emacs 生产力的十大最佳插件
http://www.linuxidc.com/Linux/2016-01/127456.htm
A Package in a league of its own: Helm
http://tuhdo.github.io/helm-intro.html

https://www.emacswiki.org/emacs/FindFileInProject
**** emacs
https://www.emacswiki.org/emacs/SiteMap

Quickly finding project files using Emacs EDE
http://stackoverflow.com/questions/23950534/quickly-finding-project-files-using-emacs-ede

The function to show current file's full path in mini buffer
http://stackoverflow.com/questions/3669511/the-function-to-show-current-files-full-path-in-mini-buffer
Imenu显示符号列表
http://www.gnu.org/software/emacs/manual/html_node/emacs/Imenu.html
InteractivelyDoThings
http://stackoverflow.com/questions/7394289/how-can-i-more-easily-switch-between-buffers-in-emacs
https://www.emacswiki.org/emacs/InteractivelyDoThings
Searching for marked (selected) text in Emacs

git clone https://github.com/purcell/emacs.d.git ~/.emacs.d


find frameworks/ packages/ bionic/ dalvik/ bootable/ libcore/ -name '*.c' -print -o -name '*.h' -print -o -name '*.cpp' -print -o -name '*.java' -print > cscope.files

cscope –b –q -k

find frameworks/ packages/ bionic/ dalvik/ bootable/ libcore/ -name '*.c' -print -o -name '*.h' -print -o -name '*.cpp' -print -o -name '*.java' –print | xargs etags -a

manual
http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html#SEC_Contents

Emacs dired 模式
http://blog.csdn.net/cxmanzhao/article/details/5685016

emacs 快捷键（包括C／C++模式）
http://www.cnblogs.com/xinxianshi/archive/2011/07/20/2157264.html
emacs + cscope 的使用
http://blog.chinaunix.net/uid-20788636-id-1841254.html

emacs 使用 之 cedet
http://blog.csdn.net/hnhbdss/article/details/6831846

Virtual Sensors
http://electronicdesign.com/ios/understanding-virtual-sensors-sensor-fusion-context-aware-applications
**** jd-gui
github.com/java-decompiler/jd-gui
**** MAC OS X 连接tty串口脚本
http://blog.csdn.net/delicioustian/article/details/7193989
Mac-Yosemite FRDM-K64F KDS/KSDK debug setup using pyOCD and gdb
https://developer.mbed.org/forum/platform-38-FRDM-K64F-community/topic/17088/

MIMO
http://baike.baidu.com/link?url=pcFWXaEAYfY-fOgfIxAcRmf_HOMBH8Dbn5SFWXOFtmJxQGOTELtm-pYxipM1yl2CeLZiAIl8FnsMLdjIa60Ohu37syX0NJtiwhYDfnhvU2_
特性阻抗
http://baike.baidu.com/link?url=YkUPX9iGTi_CbHfgiO3gguNgNJCukwXzoH0gIaHx-2qH0F-qqTnB5WmV-gGDV1n781A5yfPH6p_uSufV1hOMbq
**** sublime txt：
https://github.com/sublimehq/Packages
TI
http://www.ti.com/lsds/ti/wireless_connectivity/6lowpan/overview.page?paramCriteria=no&DCMP=PPC_Google_TI&k_clickid=0946638a-d9ea-4e2b-84f8-14ba573873c2&utm_source=GOOGLE&utm_medium=cpc&utm_term=6lowpan&utm_campaign=LPR%20%7C%20WW%20%7C%20Search%20%7C%20Wireless_Precision_LPRF&gclid=CjwKEAiAk7O0BRD9_Ka2w_PhwSkSJAAmKswxG0XlbkxgdDTGZ8xhvJjP9Jsn5GVp4vqmAvNR3IrafhoC7bnw_wcB
http://www.ti.com/lit/wp/swry013/swry013.pdf
蓝牙4.0BLE cc2540 usb-dongle的 SmartRF Packet Sniffer 抓取数据方法 【原创，多图】
http://blog.csdn.net/mzy202/article/details/32408223
http://www.ti.com/tool/packet-sniffer
Open Source Projects - MSP430
http://processors.wiki.ti.com/index.php/Open_Source_Projects_-_MSP430
蓝牙4.0BLE开发板 cc2540 cc2541 开发板资料更新日志
http://www.amomcu.com/forum.php?mod=viewthread&tid=24
Simplelink平台BLE芯片CC2640详解
http://www.ti.com.cn/product/cn/cc2640
**** wpa_supplicant无线网络配置
http://blog.sina.com.cn/s/blog_55465b470100l73l.html
WICED™ Hot Sheet
https://community.broadcom.com/docs/DOC-1513
https://community.broadcom.com/docs/DOC-1168
https://community.broadcom.com/community/wiced-wifi

http://www.broadcom.com/products/wireless-connectivity/wireless-lan/bcm943362wcd4_evb

http://www.broadcom.com/collateral/pb/WICED-PB101-R.pdf

https://www.broadcom.com/products/wireless-connectivity/wireless-lan/bcm943362wcd4
http://www.mouser.hk/new/broadcom/broadcom-bcm943362wcd4/

https://community.broadcom.com/community/wiced-smart/wiced-smart-documentation

http://wireless.electronicspecifier.com/wireless/bcm4390-broadcom-delivers-single-chip-wi-fi-solution-for-embedded-devices
**** Sumblime Text 2 常用插件以及安装方法
使用Sublime Text3+Ctags+Cscope替代Source Insight
http://wbond.net/sublime_packages/package_control
https://packagecontrol.io/installation
http://www.hphq.net/Marketing/8.html
http://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&tn=baidu&wd=sublime2%20mac%20安装%20ctags&rsv_pq=86dc409b00009d8f&rsv_t=e699MZpm8tChuXZYUinzMsL8LwijUpuUufNlWDLuHZGbTjl68mwumOq5%2Bxc&rsv_enter=1&rsv_sug3=6&rsv_sug2=0&inputT=2273&rsv_sug4=2686

http://blog.csdn.net/u012459917/article/details/17306599

https://www.zybuluo.com/lanxinyuchs/note/33551
使用Package Control组件安装
也可以安装package control组件，然后直接在线安装：
1	按Ctrl+`调出console（注：安装有QQ输入法的这个快捷键会有冲突的，输入法属性设置-输入法管理-取消热键切换至QQ拼音）
2	粘贴以下代码到底部命令行并回车：
3	import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())
重启Sublime Text 2。

Configuration
4	To set the cscope path, Select "Preferences -> Settings User", this will open preferences.sublime-settings file. Add the following line in that file."CscopeSublime_executable": "/usr/local/bin/cscope"
5	 Using in your project
1	Create Cscope Database at the root of the project
2	find . -name "*" -print > cscope.files
3
4	cscope -b -q
5	 
Now you are all set to go
shortcuts
    command panel:  Ctrl + \
    Look up symbol: Ctrl + L  Ctrl + S
    Symbol Definition: Ctrl + L Ctrl + D
**** 常用vi编辑器命令行
http://www.cnblogs.com/junw_china/articles/1708967.html
C 语言中文网
http://see.xidian.edu.cn/cpp/html/326.html
linxu syscall查表
http://syscalls.kernelgrok.com/

深入理解Android之设备加密Device Encryption
http://blog.csdn.net/innost/article/details/44519775
国际名校公开课  斯坦福大学公开课：广义相对论
http://open.163.com/special/opencourse/ensteinstheory.html
InitScriptStatusActions
https://wiki.ubuntu.com/InitScriptStatusActions
linux screen 命令详解
http://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html
*** mcu
**** marvel：
http://www.marvell.com/microcontrollers/aws-iot-starter-kit/
Marvell推出业界首款支持Google Weave的MCU平台
http://www.ctiforum.com/news/world/472870.html

https://item.taobao.com/item.htm?spm=a230r.1.14.8.f4FIXo&id=524435891020&ns=1&abbucket=16#detail

https://developers.google.com/weave/guides/device-dev/getting-started#enable_the_product_name_api
**** DragonBoard 410c
Website: http://www.weaviate.com
Github: http://github.com/weaviate
Mailing: http://eepurl.com/bRsMir
Twitter: http://twitter.com/weaviate_iot
**** Nordic
http://infocenter.nordicsemi.com/index.jsp
https://devzone.nordicsemi.com/docs/
http://developer.nordicsemi.com
https://www.nordicsemi.com/eng/Products/nRF51-DK/(language)/eng-GB

http://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF5-SDK-for-IoT
http://www.mouser.hk/ProductDetail/Nordic-Semiconductor/nRF51-DK/?qs=%2fha2pyFaduh14VZ6EnLnToas8j4fumHPELEPCJjFWsI%3d
http://www.mouser.com/ds/2/297/nRF51-DK%20-%20User%20Guide%20v1_0-706637.pdf
http://www.mouser.hk/new/nordicsemiconductor/nordic-nrf52-dk/
https://www.nordicsemi.com/chi/node_176/2.4GHz-RF/nRFgo-Studio

http://bbs.elecfans.com/jishu_550157_1_1.html

https://www.mbed.com/en/development/hardware/boards/nordic/nrf51_dk/
https://developer.mbed.org/platforms/Nordic-nRF51822/
**** Raspberry Pi 安装VNC
http://blog.sina.com.cn/s/blog_3cb6a78c01019wl7.html
RPi VNC Server
http://elinux.org/RPi_VNC_Server
Distributing a global IPv6 prefix
file:///Users/zhangdongfeng/Downloads/nrf5_iot_sdk_3288530/documentation/html/a00090.html
Creating link-local IPv6 addresses
file:///Users/zhangdongfeng/Downloads/nrf5_iot_sdk_3288530/documentation/html/a00088.html
**** raspberrypi
http://www.raspberrypi.org/documentation/
http://elinux.org/RPi_Hub
http://elinux.org/RPi_USB_Bluetooth_adapters
http://elinux.org/RPi_Hardware_Basic_Setup#Connecting_Together
http://elinux.org/RPi_Easy_SD_Card_Setup

https://github.com/raspberrypi/linux.git
https://github.com/raspberrypi


使用 UART 作为 Raspberry Pi 的终端
http://www.tuicool.com/articles/Ir22my
NOOBS v1.3.2 installation Process Snapshots
http://www.cpmspectrepi.webspace.virginmedia.com/raspberry_pi/MoinMoinExport/NOOBSinstallV132.html
https://www.raspberrypi.org/forums/viewtopic.php?f=28&t=77210
http://www.cpmspectrepi.webspace.virginmedia.com/raspberry_pi/raspiidx.htm

https://www.raspberrypi.org/documentation/setup/
https://www.raspberrypi.org/downloads
https://www.raspberrypi.org/downloads/noobs/

https://developer.ubuntu.com/en/snappy/start/#snappy-raspi2
https://ubuntu-mate.org/raspberry-pi/

DKMS简介
http://www.cnblogs.com/wwang/category/269350.html
用make-kpkg简化Ubuntu系统的内核编译过程
http://www.cnblogs.com/wwang/archive/2011/01/07/1929486.html

Raspberry pi cannot ping router or internet addresses over wifi bridge
http://superuser.com/questions/682034/raspberry-pi-cannot-ping-router-or-internet-addresses-over-wifi-bridge

Weave on a RaspberryPi
https://github.com/weaveworks/weave/issues/495
**** ATMEL
http://www.atmel.com/products/wireless/wifi/
http://www.atmel.com/Images/Atmel-42491-WILC1000B-MUT_Datasheet.pdf
**** STM32：
http://www.st.com/web/en/catalog/mmc/FM141/SC1169/SS1577/LN1877?icmp=ln1877_pron_pr_jun2014&sc=stm32f411-pr
http://elinux.org/STM32
**** CC3200：

http://processors.wiki.ti.com/index.php/CC31xx_%26_CC32xx
http://processors.wiki.ti.com/index.php/CC32xx_Quick_Start_Guide
http://processors.wiki.ti.com/index.php/CC32xx_Getting_Started
http://processors.wiki.ti.com/index.php/CC31xx_%26_CC32xx_UniFlash_Quick_Start_Guide
http://processors.wiki.ti.com/index.php/CC31xx_%26_CC32xx_UniFlash#Service_Pack_Programming

http://processors.wiki.ti.com/index.php/CC32xx_SDK_Sample_Applications
http://www.ti.com/product/cc3200
http://processors.wiki.ti.com/index.php/CC31xx_%26_CC32xx
http://www.ti.com/tool/uniflash
http://processors.wiki.ti.com/index.php/CC31xx_%26_CC32xx_Cloud_Ecosystem
http://processors.wiki.ti.com/index.php/TI-RTOS


http://www.ti.com/tool/wifistarter
https://play.google.com/store/apps/details?id=com.pandaos.smartconfig
http://processors.wiki.ti.com/index.php/CC31xx_&_CC32xx_Provisioning

http://www.ti.com/tool/TIDC-CC3200CAMBOOST?keyMatch=wi-FI&tisearch=Search-EN-Products
http://www.ti.com/tool/CC3200-LAUNCHXL?keyMatch=wi-FI&tisearch=Search-EN-Products
http://www.ti.com/tool/TIDC-BLE-TO-WIFI-IOT-GATEWAY?keyMatch=wi-FI&tisearch=Search-EN-Products

http://processors.wiki.ti.com/index.php/CC32xx_Getting_Started
http://processors.wiki.ti.com/index.php/CC31xx_%26_CC32xx_Advanced_App_Notes

http://software-dl.ti.com/ecs/cc31xx/APIs/public/cc32xx_peripherals/latest/html/index.html
**** FRDM-K64F板开发笔记汇总（11.25update）
http://www.nxpic.org/module/forum/thread-602394-1-1.html

http://www.nxpic.org/module/forum/thread-602321-1-1.html
https://www.segger.com/opensda.html
https://www.segger.com/jlink-software.html
FreeRTOS移植MAPS-K22开发板
http://www.nxpic.org/module/forum/thread-603163-1-1.html
FRDM-K64F资料+开发笔记
http://www.nxpic.org/module/forum/thread-599239-1-1.html
**** KW41Z: Kinetis Bluetooth Low Energy & 802.15.4无线MCU
http://www.nxp.com/zh-Hans/products/microcontrollers-and-processors/arm-processors/kinetis-cortex-m/w系列/kinetis-bluetooth-low-energy-802.15.4-wireless-mcu:KW41Z?lang_cd=zh-Hans

https://github.com/ErichStyger/mcuoneclipse/tree/master/Examples/Eclipse/FRDM-K64F/FRDM-K64F_Demo
https://community.freescale.com/thread/328159
http://mcuoneclipse.com/2014/03/30/getting-bluetooth-working-with-jy-mcu-bt_board-v1-06/
*** software
**** libevent:
https://github.com/libevent/libevent.git
http://libevent.org
https://en.wikipedia.org/wiki/Libevent
http://www.kegel.com/c10k.html
http://www.wangafu.net/~nickm/libevent-book/

用C++11的std::async代替线程的创建
http://www.tuicool.com/articles/6j2u2qa
**** TUTK
https://en.wikipedia.org/wiki/Network_address_translation
C5KAA96WZXVMSNPGUHYJ
EHUA8D7WPDBMUMPGUHEJ
CDYU997MPTVWUM6GYH41
CDPU997WK9BWUM6GYHM1
ETUA997CPHB49NPGYHC1

export LD_LIBRARY_PATH=/home/pi/TUTK_Kalay_Platform_SDK_2.1.3/Lib/Linux/Arm_BCM2836_4.8.3:$LD_LIBRARY_PATH

export LD_LIBRARY_PATH=/home/ac/TUTK_Kalay_Platform_SDK_2.1.3/Lib/Linux/x86:$ LD_LIBRARY_PATH
**** frdm_k64f/
https://www.mbed.com/en/development/hardware/boards/freescale/frdm_k64f/
http://www.freescale.com/products/arm-processors/kinetis-cortex-m/k-series/k6x-ethernet-mcus/freescale-freedom-development-platform-for-kinetis-k64-k63-and-k24-mcus:FRDM-K64F
https://developer.mbed.org/platforms/FRDM-K64F/
https://developer.mbed.org/forum/platform-38-FRDM-K64F-community/
http://www.nxp.com/products/microcontrollers-and-processors/arm-processors/kinetis-cortex-m/k-series/k6x-ethernet-mcus/kinetis-k64-120-mhz-ethernet-usb-256kb-sram-mcus:K64_120?tab=Documentation_Tab&pspll=1?SelectedAsset=Documentation&ProdMetaId=PID/DC/K64_120&fromPSP=true&assetLockedForNavigation=true&componentId=2&leftNavCode=1&pageSize=25&Documentation=Documentation/00610Ksd1nd``Data%20Sheets&linkline=Data%20Sheets&fpsp=1#

https://github.com/mbedmicro/CMSIS-DAP
https://developer.mbed.org/handbook/Firmware-FRDM-K64F

https://developer.mbed.org/handbook/mbed-SDK
https://developer.mbed.org/handbook/mbed-library-internals
https://developer.mbed.org/handbook/mbed-SDK-porting

https://developer.mbed.org/handbook/SerialPC
https://developer.mbed.org/handbook/Terminals
https://developer.mbed.org/handbook/mbed-Compiler

https://github.com/mbedmicro/mbed.git
https://github.com/mbedmicro/mbed
https://developer.mbed.org
https://www.mbed.com/zh-cn/
https://github.com/mbedmicro/mbed
**** OpenSDA
https://docs.mbed.com/docs/debugging-on-mbed/en/latest/
https://github.com/mbedmicro/pyOCD
https://docs.mbed.com/docs/debugging-on-mbed/en/latest/Debugging/pyOCD/
https://docs.mbed.com/docs/debugging-on-mbed/en/latest/Debugging/debugging_microbit/

https://docs.mbed.com/docs/debugging-on-mbed/en/latest/Debugging/debugging_microbit/


How to use pyOCD for new target MCU like W7500
http://blog.wiznettechnology.com/2015/07/22/how-to-use-pyocd-for-new-target-mcu-like-w7500/
How to use GDB on Eclipse with pyOCD
http://blog.wiznettechnology.com/2015/07/31/how-to-use-gdb-on-eclipse-with-pyocd/

OpenSDA：
http://www.nxp.com/zh-Hans/products/software-and-tools/run-time-software/kinetis-software-and-tools/ides-for-kinetis-mcus/opensda-serial-and-debug-adapter:OPENSDA
https://community.freescale.com/docs/DOC-100720
git clone https://github.com/mbedmicro/CMSIS-DAP.git
https://community.freescale.com/docs/DOC-100720

https://developer.mbed.org/handbook/cmsis-dap-interface-firmware
http://mcuoneclipse.com/category/eclipse-2/
http://mcuoneclipse.com/2015/03/22/openocdcmsis-dap-debugging-with-eclipse-and-without-an-ide/
http://mcuoneclipse.com/2013/10/22/using-the-frdm-kl25z-with-cmsis-dap-to-program-non-freescale-arm-microcontrollers/
**** Open On-Chip Debugger (OpenOCD)
Open on-chip debugger (OpenOCD) can be downloaded in source form from http://sourceforge.net/projects/openocd/files/openocd/0.7.0/ and compiled locally.
To build OpenOCD for FTDI interface, download the FTDI driver library (x86 [32-bit] zip version) from http://www.ftdichip.com/Drivers/D2XX.htm.
CMSIS-DAP拾遗补缺
http://blog.sina.com.cn/s/blog_4680937f0101ss1z.html
OpenOCD/CMSIS-DAP Debugging with Eclipse and without an IDE
http://mcuoneclipse.com/2015/03/22/openocdcmsis-dap-debugging-with-eclipse-and-without-an-ide/

mbed平台的HDK(Hardware Development Kit)支持CMSIS DAP。
源代码在：‪https://github.com/mbedmicro/mbed/tree/master/workspace_tools/debugger‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬
目前是针对mbed的，要支持其它的基于CMSIS DAP的debug adapter，添加一下USB VID和PID就可以。
**** ThreadX
http://wenku.baidu.com/link?url=dgnTkxMpedJxxMI1H1wnxoymhOzGhTsmq8Ou9rHGSsX7BzrWRFjH7jY1TB8H5hvU8p1gETapUCUE9a0rZI0WBv5A-zDSx_VWQOL29gtMoga
http://baike.baidu.com/link?url=R4QpEtDcXGGT2cVYnM-TIHAcV_Q6efS5WfgpflUHkagVJofYOwEkZuAdz-_0_pTX79k0v3n88rLPw__f8gbgRK
http://www.threadx.com
http://wenku.baidu.com/link?url=b4FOL1i3fbh5QXtpVkaTH8ZU_VVH7mUNMoBLXIAM8thGS1YFFKNvyRTddeKgb1RohYWO6GUVqUzov3vaMjILzmJwpEqktMPHcxRwcO2BZwW

Thread协议
http://www.nxp.com/zh-Hans/pages/thread-networking-protocol:THREAD-NETWORKING-PROTOCOL?lang_cd=zh-Hans
 https://en.wikipedia.org/wiki/Thread_(network_protocol)
http://threadgroup.org/resources/most-popular
**** FT2232H- USB转串口 SPI JTAG
http://china.npicp.com/tradeinfo/offerdetail/41-1350-4698-3823500.html
**** CMSIS
http://wenku.baidu.com/link?url=Jgbp-K3frW7dRpwsOj0oV8HkoszrzSZS7PhQLcOhWRb47LKgZ292LJY7yghIYTU7X780MQ7pCnPua-iouMv1BvBBtL_2m5D3PtqmpqnGZLy
OV788
http://www.wpgholdings.com/news/detail/zhcn/program/J0223
UCOS
https://en.wikipedia.org/wiki/Micro-Controller_Operating_Systems
http://micrium.com/rtos/ucosii/overview/
**** 系统架构设计师
http://wenku.baidu.com/link?url=3pWGOojHApLnzctiXjTYlPsrqHD7r7bcrTYpuh6s09hqPsww8yN6I4NqTYVhl1X-H6p02_1TVDjXrjbZe8TDY64g7lxWfUz53T0qbQqtg73
*** os
**** mbed:
https://www.mbed.com/en/development/hardware/boards/freescale/frdm_k64f/

https://docs.mbed.com/docs/getting-started-mbed-os/en/latest/
https://docs.mbed.com/docs/getting-started-mbed-os/en/latest/installation/
https://docs.mbed.com/docs/getting-started-mbed-os/en/latest/FirstProjectmbedOS/

https://docs.mbed.com/docs/getting-started-mbed-os/en/latest/GetTheCode/
https://github.com/ARMmbed/mbed-client-examples
https://github.com/ARMmbed/mbed-client-examples#mbed-build-instructions
https://github.com/ARMmbed/mbed-example-network
https://github.com/ARMmbed/mbed-thread-example
https://github.com/ARMmbed/mbed-client-example-6lowpan

https://connector.mbed.com
https://connector.mbed.com/#credentials
https://github.com/ARMmbed

https://docs.mbed.com/docs/getting-started-mbed-os/en/latest/FurtherReading/
https://www.mbed.com/en/development/software/mbed-os/

https://www.mbed.com/en/development/software/mbed-client/#Example_applications_of_mbed_Client_using_mbed_Device_Connector_Service

https://docs.mbed.com/docs/debugging-on-mbed/en/latest/
https://github.com/mbedmicro/pyOCD
https://docs.mbed.com/docs/debugging-on-mbed/en/latest/Debugging/pyOCD/
https://docs.mbed.com/docs/debugging-on-mbed/en/latest/Debugging/debugging_microbit/

https://docs.mbed.com/docs/mbed-client-guide/en/latest/

https://yotta.mbed.com
http://yottadocs.mbed.com/#installing
http://yottadocs.mbed.com/tutorial/tutorial.html
http://yottadocs.mbed.com/#installing-on-osx
https://github.com/armmbed/homebrew-formulae
https://github.com/ARMmbed/yotta_osx_installer/releases/download/v0.0.4/yotta_osx_installer_v0.0.4.dmg
http://yottadocs.mbed.com/tutorial/testing.html

https://docs.mbed.com/docs/getting-started-mbed-os/en/latest/Full_Guide/networking/
https://docs.mbed.com/docs/arm-ipv66lowpan-stack/en/latest/index.html

python workspace_tools/make.py -m K64F -t GCC_ARM -d /Volumes/MBED -s /dev/tty.usbmodem1422 -p 0
https://www.mbed.com/en/development/software/tools/testing/

https://developer.mbed.org/handbook/mbed-SDK https://developer.mbed.org/handbook/mbed-library-internals
https://developer.mbed.org/handbook/mbed-tools

https://developer.mbed.org/cookbook/Homepage
http://savannah.nongnu.org/projects/lwip/
https://developer.mbed.org/handbook/Ethernet-Interface
https://developer.mbed.org/cookbook/Websockets-Server
http://www.tornadoweb.org/documentation/index.html
http://www.tornadoweb.org/en/stable/guide.html
https://developer.mbed.org/cookbook/Websockets
http://demo.pythoner.com/itt2zh/ch1.html

http://www.ti.com/product/CC2640/toolssoftware

https://github.com/mbedmicro/mbed
https://github.com/ARMmbed/mbed-drivers.git
https://github.com/mbedmicro/mbed.git
https://github.com/mbedmicro/mbed
https://developer.mbed.org
https://www.mbed.com/zh-cn/
https://github.com/mbedmicro/mbed
**** 实时嵌入式操作系统 NuttX
http://www.2cto.com/os/201404/294602.html
http://docs.huihoo.com/nuttx/NuttxUserGuide.html
LiteOS: A Unix-like Operating System for
http://www.liteos.net

http://wenku.baidu.com/link?url=ArnV_IaWvSHIas6LR_Atcx8VyqJQ30A2ugKcCA3sVDwcUsTeIEaxT9sy6cehI-Gd1bbun64xCawtwTF0mreHt152qqx7Ff-nhsxnyXBJYya

http://www.oiotc.cc
http://wiki.oiotc.cc/index.php?title=Liteos#Liteos_Kernel.E5.BC.80.E5.8F.91.E6.89.8B.E5.86.8C
**** RT-Thread
http://www.rt-thread.org/page/31.html
https://github.com/RT-Thread/rt-thread
http://baike.baidu.com/link?url=FtZ792WarPoEvo0V1dT07nMpfvJ2siY5Ju9HP-z96ZSAvgwIEBsQ8-KXABmpe8n-22MvM-DFak-hFsyXYgKM2_
https://en.wikipedia.org/wiki/RT-Thread
**** contiki-os
http://www.contiki-os.org
**** FreeRTOS 和uCOS II的简单比较
http://www.amobbs.com/thread-3242784-1-1.html

http://shop.freertos.org/FreeRTOS_tutorial_books_and_reference_manuals_s/1825.htm
http://wenku.baidu.com/link?url=V0Yu3bopzW-5u75o0_6gX4MVbu1n9WKfGNEq20zRAzUzKJowLIkoYbjU4pjvHlUFOCn2tTjqwHgQeBwK2nGTLaE9rnFyC6jW7e1Rz_iwtwm
MQXRTCSUG(中文)
http://www.docin.com/p-562054509.html
**** FreeRTOS:
http://www.eefocus.com/embedded/350447/r0
http://www.freertos.org
http://sourceforge.net/projects/freertos/

http://percepio.com

https://en.wikipedia.org/wiki/Real-time_operating_system

http://www.freertos.org/FreeRTOS-Plus/Nabto/getting_started_with_FreeRTOS_Plus_Nabto.shtml

http://www.jb51.net/softjc/33896.html

http://www.freertos.org/FreeRTOS-quick-start-guide.html#page_top
http://www.freertos.org/porting-a-freertos-demo-to-different-hardware.html

http://www.freertos.org/FreeRTOS-for-K60-Cortex-M4-with-web-server.html
http://www.nxp.com/products/microcontrollers-and-processors/arm-processors/kinetis-cortex-m/k-series/k6x-ethernet-mcus:K60_ETHERNET_CRYPTO_MCU?cof=0&am=0
http://www.nxp.com/products/software-and-tools/run-time-software/kinetis-software-and-tools/development-platforms-with-mbed/software-development-kit-for-kinetis-mcus:KINETIS-SDK
http://www.nxp.com/products/software-and-tools/run-time-software/kinetis-software-and-tools/ides-for-kinetis-mcus/kinetis-design-studio-integrated-development-environment-ide:KDS_IDE
*** BLUETOOTH
https://en.wikipedia.org/wiki/Bluetooth_low_energy

https://en.wikipedia.org/wiki/ANT_(network)
https://en.wikipedia.org/wiki/IEEE_802.15
https://en.wikipedia.org/wiki/Bluetooth

https://www.bluetooth.com/what-is-bluetooth-technology/bluetooth-technology-basics
https://www.bluetooth.com/specifications/adopted-specifications
https://developer.bluetooth.org/TechnologyOverview/Pages/Baseband.aspx
蓝牙核心技术概述
http://blog.csdn.net/xubin341719/article/details/38305331
GATT协议
http://blog.sina.com.cn/s/blog_69b5d2a50101gp0u.html
**** Bluetooth stack
http://micrium.com/rtos/clarinox-blue/overview/
https://en.wikipedia.org/wiki/Bluetooth_stack
http://blog.csdn.net/zhjr1220/article/details/8081150

A fork of the lwBT stack
https://github.com/lwalkera/lwBT
http://read.pudn.com/downloads141/sourcecode/windows/610246/lwbt/doc/lwbt-doc.pdf
http://blog.csdn.net/zhjr1220/article/details/8082545

https://code.google.com/archive/p/blue-machines/

dotstack
dotstack has FreeRTOS, uOS, Linux, Android, and no RTOS integration. Min RAM requirement for SPP 3KB with RTOS and app
http://searanllc.com/wp-content/uploads/2014/dotstack-product-brief-2014-11-26.pdf

BTStack，可以拿到源代码（非商业应用免费，我们可以学习），支持BR/EDR和BLE双模。
https://bluekitchen-gmbh.com/


GNURadio 软件无线电
2. GNURadio，软件无线电的开源代码，里面有一些RF、vocoder有关的开源实现，说不定有用得着的地方（官网好像打不开了）。
https://github.com/gnuradio/gnuradio
https://github.com/greatscottgadgets/gr-bluetooth
http://gnuradio.squarespace.com

3. 一款BLE的开源平台。
http://en.t-firefly.com/en/firesmart/fireble/

TI Dual-Mode Bluetooth® Stack
http://www.ti.com/tool/tibluetoothstack-sdk
http://processors.wiki.ti.com/index.php/CC256x_QFN_EM_User_Guide
TI dual-mode Bluetooth® stack on TM4C MCU
http://www.ti.com/tool/CC256XM4BTBLESW

http://www.stonestreetone.com/Portals/32/PDF/Bluetopia.pdf
用FTS分析蓝牙数据包
http://blog.sina.com.cn/s/articlelist_1773523621_7_1.html
蓝牙抓包软件
http://www.docin.com/p-884386387.html
**** 6LoWPAN
https://github.com/ARMmbed/sal-stack-nanostack
http://docs.mbed.com/projects/arm-ipv66lowpan-stack/
http://www.ti.com/lit/wp/swry013/swry013.pdf
Transmission of IPv6 Packets over IEEE 802.15.4 Networks
https://tools.ietf.org/html/rfc4944
**** 蓝牙mesh
http://m.elecfans.com/article/403998.html#10006-weixin-1-52626-6b3bffd01fdde4900130bc5a2751b6d1a
**** Eddystone
https://developers.google.com/beacons/
http://baike.baidu.com/item/Eddystone?fr=aladdin
http://www.zhihu.com/question/32708729

http://bbs.ednchina.com/BLOG_ARTICLE_3030322.HTM
http://stackoverflow.com/questions/18906988/what-is-the-ibeacon-bluetooth-profile/
http://www.tuicool.com/articles/JJbMZf

WIKI
https://en.wikipedia.org/wiki/MAC_address
https://en.wikipedia.org/wiki/Multicast
https://en.wikipedia.org/wiki/Internet_Group_Management_Protocol
https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol
https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol
https://en.wikipedia.org/wiki/Template_(C%2B%2B)

https://en.wikipedia.org/wiki/Real-time_operating_system
https://en.wikipedia.org/wiki/Event-driven_programming
https://en.wikipedia.org/wiki/Comparison_of_programming_paradigms
https://en.wikipedia.org/wiki/Object-oriented_programming#Criticism

https://en.wikipedia.org/wiki/Functional_programming
**** RFCOMM
https://www.2cto.com/kf/201605/510336.html
*** 语言
**** LISP
https://en.wikipedia.org/wiki/Paul_Graham_(computer_programmer)
http://www.paulgraham.com/avg.html
http://acl.readthedocs.org/en/latest/index.html
http://www.cs.northwestern.edu/academics/courses/325/readings/graham/graham-notes.html
http://download.csdn.net/detail/gogocx/1759251
http://acl.readthedocs.org/en/latest/    ANSI COMMON LISP中文版

https://en.wikipedia.org/wiki/Lisp_(programming_language)
**** SICP
https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start
https://sicpebook.wordpress.com
https://www.youtube.com/playlist?list=PLE18841CABEA24090

https://github.com/sarabander/sicp
http://dspace.mit.edu/bitstream/handle/1721.1/6064/AIM-986.pdf?sequence=2

http://www.sicpdistilled.com

https://archive.is/uTOol#selection-839.0-880.0
 https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs
https://archive.is/lcee

函数式思维
http://www.ibm.com/developerworks/cn/java/j-ft10/index.html
http://norvig.com/design-patterns/ppframe.htm?cm_mc_uid=74305266494614353758483&cm_mc_sid_50200000=1451543833

http://cs.fit.edu/~ryan/library/functional_programming/gjm.lambook88.pdf
**** clojure
https://en.wikipedia.org/wiki/Clojure
http://dev.clojure.org/display/community/Home
http://clojure.org
http://www.clojureatlas.com
http://clojure.org/getting_started
http://java.ociweb.com/mark/clojure/article.html
http://www.infoworld.com/article/2619641/java/clojure-inventor-hickey-now-aims-for-android.html
http://acl.readthedocs.org/en/latest/
http://clojure.github.io/clojure/

http://clojure-doc.org
http://clojure.org/cheatsheet
http://docs.oracle.com/javase/7/docs/api/overview-summary.html

资料总会
http://dead-knight.iteye.com/blog/1827196
http://clojure-china.org

http://clojure-doc.org/articles/tutorials/emacs.html

https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life
http://www.tuicool.com/articles/7riYJr
https://www.zhihu.com/question/25054887/answer/30621960
http://www.csdn.net/article/2012-08-07/2808276
http://www.ibm.com/developerworks/cn/java/j-jn1/

LEIN
https://github.com/technomancy/leiningen
http://stackoverflow.com/questions/15339047/how-to-define-project-clj-for-both-lein-run-and-lein-repl-to-work

RE

Clojure进阶:使用Clojure构建DSL
http://www.tuicool.com/articles/yueaU3
http://clojure-doc.org/articles/tutorials/growing_a_dsl_with_clojure.html
Clojure世界：文件IO
http://www.blogjava.net/killme2008/archive/2012/02/16/370144.html
clojure-android
http://clojure-android.info

RING
https://github.com/ring-clojure/ring/wiki/Third-Party-Libraries
https://github.com/ring-clojure/ring

http://www.liaoxuefeng.com/article/0014171500694729a42a2c8b7f245e0bd54612c88d78a03000

STORM
https://github.com/nathanmarz/storm
http://www.cnblogs.com/skyme/p/3423806.html
openssl之aes加密（源码分析 AES_encrypt 与 AES_cbc_encrypt ，加密模式）
http://blog.csdn.net/chary8088/article/details/21124495
SSL/TLS协议运行机制的概述
http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html
http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html
https://technet.microsoft.com/en-us/library/cc785811(v=ws.10).aspx

Point-to-point protocol over Ethernet
https://en.wikipedia.org/wiki/Point-to-point_protocol_over_Ethernet
LWIP
http://savannah.nongnu.org/projects/lwip/
http://lwip.wikia.com/wiki/AUTOIP
嵌入式TCPIP协议栈LWIP的并发性能优化
http://wenku.baidu.com/link?url=CPpk-aTqQV0sd-wajUQ5tO0VkohfaeUr8fF8RyiQaRJEiZYHs03ALxmgWDYJoEVP2tYnf55JjCzHPlnSRP7-x-cvsXqTH0GW21HCbShjJVm
http://xueshu.baidu.com/s?wd=paperuri%3A%2864773e1e030c4b86e0f76393c09d9d3e%29&filter=sc_long_sign&tn=SE_xueshusource_2kduw22v&sc_vurl=http%3A%2F%2Fwenku.baidu.com%2Fview%2Ffc4d7d24ccbff121dd3683e9.html&ie=utf-8
LWIP使用经验
http://blog.csdn.net/jiangjunjie_2005/article/details/26051399
*** AP
**** rk 3288 文档
https://bitbucket.org/T-Firefly/firefly-rk3288/src/3ed4dc4cc6fd8fade4e0de941d39b91baee2d1ef/RKDocs/Develop%20reference%20documents/?at=master
http://git.linux-rockchip.org/  这个应该是和rockchip有一些关系的。
https://github.com/linux-rockchip

https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git
   a) 生成补丁文件：git format-patch   -1   90a8020278c1598fafd071736a0846b38510309c
   b) 打补丁：git am 0001-ext4-fix-mmap-data-corruption-when-blocksize-pagesiz.patch
   c) 若打补丁失败，就需要手动解决冲突：
      生成冲突说明文件：git apply --reject 0001-ext4-fix-mmap-data-corruption-when-blocksize-pagesiz.patch
      查看有哪些冲突文件：git status
      手动修改冲突后，添加已解决冲突的文件：git add
  恢复失败的打补丁流程：git am --resolved

查看dtb的信息 可以使用dtc 将dtb 转为dts ，查看内部内容

dtc -I dtb  kernel.dtb -o kernel.dts
fdtdump kernel.dtb

echo userspace > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
echo 1152000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed

git push gl5209 HEAD:refs/for/zh/OWL_Integration
提交commit前进行检查
git diff --cached | ./scripts/checkpatch.pl --no-signoff -
对最后一次提交的commit进行检查
git log -p -1 | ./scripts/checkpatch.pl --no-signoff -
修正文件后修改最后一次提交的commit
git add xxx.c
git commit -amend
对单个文件进行检查
./scripts/checkpatch.pl -f drivers/tty/serial/serial-owl.c
自动格式化单个文件
./scripts/Lindent drivers/tty/serial/serial-owl.c

**** arm-trusted-firmware的路径：
  <project name="owl/private/arm-trusted-firmware " path="owl/private/arm-trusted-firmware " remote="gl5209" />
https://github.com/ARM-software/arm-trusted-firmware/    master分支，麻烦保留原始git信息

另外麻烦顺便把op-tee给加上
<project name="owl/private/op-tee/optee_os" path="owl/private/optee_os" remote="gl5209" />
 https://github.com/OP-TEE/optee_os    master分支，麻烦保留原始git信息

<project name="owl/u-boot" path="u-boot"  remote="gl5209"  />
http://git.denx.de/?p=u-boot.git   tag v2015.07，麻烦保留原始git信息

  <project name="owl/private/boot" path="owl/private/boot" remote="gl5209" />
这个仓库名就叫boot就可以了

扩频时钟(SSC)简介
http://wenku.baidu.com/link?url=jTnunTgnbCneMwo8r6cOdFBj_MbbjgN_0gxr1Wo2ilGwaz0rQ638O1zuipy5RadYIjafvZStePju_rLZ069erfQLWRhT6R61JK7ZarG5sym
**** 下载nand 代码

在android/owl目录下：git clone git@fwgitsrv:ZH/actions/GL5206/fw2/leopard.git
到android/owl/leopard/platform/drivers/newnand下make
到android/owl/leopard/platform/drivers/miscinfo下make

在android/owl/platform/drivers目录下：git clone git@fwgitsrv:ZH/actions/GL5206/fw1/atc260x_gauge.git -b GS705A_android-5.0.0_r2
到android/owl/platform/drivers/atc260x_gauge下make


echo 1 > /sys/devices/system/cpu/autoplug/usr_lock
echo 0 > /sys/devices/system/cpu/cpu1/online
echo 0 > /sys/devices/system/cpu/cpu2/online
echo 0 > /sys/devices/system/cpu/cpu3/online
**** camera详解：
http://wenku.baidu.com/link?url=DxwDeVguU_AWpaH8yfN8_nsVcRvhxfkor_aLxZ2qP93hnZj9jlsbxXr9qv_ZBlNSokHToiNHa2kJKzJOF7LN_dflQGtYHSPPRsht8-PKWu7
* misc
https://mail.actions-semi.com/exchange/
** samba win7 访问问题
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04FAA450@srv-mail-02.actions.com.cn][答复: 一个服务器访问的问题！]]
** 电话会议
如之前沟通，为确保项目进展顺利，接下来安排了每周一下午4:30双方研发周会，
沟通重点炬芯这边的情况：1.进度 2.风险，3接下来优先级（包含但不限于以上内容）。

电话拨打：0756-3673740 +（虚拟电话会议室号码）有欢迎词后输入（密码）会有滴的一声进入会议系统。

虚拟电话会议室号码    密码
      5655            1234  （默认首选）
      5666            1234
      5677            5678

** ip
*** 外网ip
auto eth0
iface eth0 inet static
address 112.91.148.197
netmask 255.255.255.248
gateway 112.91.148.193
dns-nameservers 221.5.88.88

    IP地址：221.4.209.99，子网掩码：255.255.255.224（即27位），网关：221.4.209.97
    邮件先给你，我现在上去重新连接一下线。
http://xp9802.iteye.com/blog/2120351
busybox ifconfig eth0 221.4.209.99 netmask 255.255.255.224
busybox route add default gw 221.4.209.97

** RDQA
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F3719B@srv-mail-02.actions.com.cn][答复: 关于研发流程的优化建议收集和处理]]
** WIFI密码
ACTZH-PAD-GMS1  Gms@2016
ACTZH-PAD-FW2 Actspa@2016
ACTZH-PAD-FW1 ActsFW2010
ACTZH-PAD-GMS2 201601@GMS
ACTZH-PAD-PMD PMD123456
Guest WIFI：Guest@201702
ssid="ACTZH-PAD-GMS2"   psk="201601@GMS"
ssid="ACTZH-PAD-PMD"    psk="PMD123456"
ssid="ACTZH-PAD-GMS1"   psk="Gms@2016"
ssid="ACTZH-PAD-FW1"   psk="ActsFW2010"
ssid="ACTZH-PAD-FW2"   psk="Actspa@2016"
** priv
*** 身份证
张江帆 410711200607043059
李宏 410702197902161022
张子越 410711201103060036
** 服务器密码
|      服务器ip | 性质       |   hosts指向 | jdk1.8安装情况 | 密码              |
|  192.168.4.20 | 编译服务器 | 192.168.4.3 | 已安装         | password          |
| 192.168.4.220 | 编译服务器 | 192.168.4.3 | 已安装         | password          |
|  192.168.4.19 | 编译服务器 | 192.168.4.3 | 已安装         | root/actions@2014 |
|  192.168.4.28 | 编译服务器 | 192.168.4.3 | 已安装         | password          |
|  192.168.1.27 | 编译服务器 | 192.168.4.3 | 已安装         | root/zhangdf1     |
|  192.168.1.11 | 编译服务器 | 192.168.4.3 | 已安装         | root/actions@2011 |
|   192.168.0.3 | 编译服务器 | 192.168.4.3 | ——             | root/actions@2011 |
| 192.168.4.107 | 编译服务器 | 192.168.4.3 | 已安装         |                   |
| 192.168.4.233 | 编译服务器 | 192.168.4.3 | 已安装         | password          |

交接服务器信息：
1. git代码服务器原先有两台，一台是主机（master），一台是从机（slave），后来从机改为了gerrit服务器，所以现在都是用主机下载代码。
2. gitolite代码服务器：srv-srdgit /192.168.4.3，帐号密码：root/3392353zzh
3. gerrit代码服务器：srv-srdgit-02 /192.168.4.4：root/3392353zzh
4. 还有一台旧的代码服务器：fwgitsrv：root/3392353zzh
5. 发布服务器srv-padgit-out（192.168.1.11），root/3392353zzh，
6. jenkins服务器srv-ess-jenkins（192.168.4.27）：fwint/csrd4#fw


张东风	ftp_zhangdf	ftp123456

* 出差报告

** 1114 86盒子的需求
  昨天下午小平介绍了86盒子的产品需求：远场拾音，贴在墙上（我们家中的嵌在强中那个开关或者插座）的样式，内置线性MIC（双MIC或4MIC均可接受），内嵌腔体，相当于只需要180°角度的echo dot，本身没有speak发声，通过蓝牙连接家里的BT音箱（当前需要搭配的音箱是我们ATS2825的音箱）。 细节部分小平和姚再补充一下。
    当时沟通有讨论ATJ2273B，ATS3603和ATS3605D， 我们继续梳理一下需求，然后看看我们推荐的性价比最好的IC方案以及评估软硬件的细节。

** 1110 深圳arm技术会议出差
*** arm 蓝牙ip信息
1．	我们强调的几个诉求：
A：进度慢，希望他们这一个更多PUSH内部资源，加快发现的问题的澄清，尽量降低我们正式版的风险。Craig有答应回去PUSH美国资源。
B：BQB认证：Craig承诺一定配合我们通过，我也同步SIG升级测试的风险。
C．2层板的问题：Craig承诺提高优先级，我们反馈这个是必备的功能，是必须解决的。

2．	新BT5的IP状况及信息更新：
A：Aura RF的第一个客户的工艺是TSMC 55nm，时间点是Q1，但是这个搭配的不是ARM的modem。搭配ARM modem的是SMIC55nm，但是进度有delay，已有RF的测试报告（但是Draig也没有完全肯定）,Aura RF:0.9mm^2.
B：ARM UMC55工艺的RF，已经有测试报告，回头追他们同步测试报告给我们。口头说是灵敏度比当前T40的低1~2dB。
C：BT5的架构是只有modem，对外接口是AHB，他们当前的testchip上放的是M3（第一个客户），他们内部信息的资源是M0+的性能就够了。RF面积1.9mm^2,Digital:0.4mm^2
D:ARM下一步也有规划对RF进行costdown的计划，当前目标是2018年Q3出shuttle，面积目标是0.9mm^2
*** arm其他主题
+ nb-iot
  arm后续重点耕耘的是nb-iot，也有cordio的ip。 cordio的意思是（cortex + radio）, arm认为这个量会比较大
+ 蓝牙mesh
  认为mesh会有很大的需求
+ 蓝牙5.0
  + auido over BLE
    audio over BLE 能够降低耳机功耗， 对耳机应该有较大影响
  + 室内定位
    相对于BLE 4.2   5.0的室内定位除了利用RSSI信息外， 还增加了角度信息， 更容易做室内定位
+ mbed平台
  主要讲了如何开发一个智能网关，把家庭中的各种非wifi类的设备通过智能网关连接到arm的云上
  对mbed partner会免费开放完整的资料和代码。



** 1114 大雄/老邝出差上海报告
一、大华
1、视频部门：
主要针对高端会议系统，要求4K 265编码，采用inetel方案。也在评估RK3399，认为规格不够。后续没有低端产品的规划。
机会：有分布的多MIC采集方案需求，每个端点要求6MIC，内置自己算法。也希望有无线蓝牙传输，希望可以做到46K采样规格。整个系统做到1拖20.
代办：确认炬力平台是否有合适的多MIC规格可以推荐

2、智能楼宇部门：
此部门已经基于S500方案开案，但由于出现GPU卡死问题，未能通过老化，由于大华内部有其他的安卓平台在选型中，需要尽快定位问题。
代办：提供CB6板子给他们做对换实验，跟进内部GPU卡死问题进展。

3、广告机部门：
去年成了的广告部门，自己销售成品，目前有自研和外采两种方式，自研平台目前是海思，基于安卓5.1开发，后续会引入其他更有性价比的平台；外购部分有跟深圳的几家主流玩家沟通过，包括视美泰。对S700 双屏异显，规格感兴趣，已经留了CB7给对方测试。
代办：跟进客户测试情况

二、鉴峰：
智能跑步机板卡供应商，主要提供给亿建等一线品牌。
跑步机一般是冬春季是旺季，夏秋是淡季。整个市场容量大概1KK/月。以内单为主，其中目前带彩屏的只有10%。彩屏跟普通液晶屏价差大概200左右，市场对带彩屏规格越来越接受。另外一个动感单车市场，目前约2~3KK/年，随着近年来热度增加，后续看好持续增长。

鉴峰平均每月大概50K/M，彩屏市占约50~60%。目前主要用RK3188方案，512M+4G规格，后续计划用RK3128替换。产品以屏+PCBA的模组形态出售，屏幕主要是1366X768/1024X600，接口位RGB或者EDP。通过串口跟底层单片机连接。后续升级有语音控制的想法。

机会：先从市场量最大的规格入手，以7051H跟RK3128竞争，但目前RK3188主要是32bit的DDR3，有性能的风险，需要测试客户APK的兼容性。另外由于以模组形态出售，客户需要保证售后，对方案稳定性也有要求。

代办：提供7051H样机测试


三、分众传媒：
之前上海同事有提供7039ST的平台，对他们吸引力不够。当前单屏新方案在采用RK3368， 但芯片不支持LVSD ，而且没有双屏异显。对S700的规格比较感兴趣。
目前他们一共有两个产品需求方向
1、旧款电梯广告机的升级，原本采用RTL的方案，功能是单屏实现MP3+图片，增量+替换一起，预计200K/年。由于这个有成本需求，且会采用LINUX平台，暂时推荐S500，有比较丰富的屏接口，方便扩展。
2、单屏/双屏广告机，目前采用RK3368/RK3288，此规格目前推荐了S700平台给他们测试。
代办：跟进CB6 CB7的性能评估情况。
** 1031 学习版发布
+ 安装环境
  要方便使用，最好是可以直接使用的， 比如windows下解压就可以使用
  如果环境是ubuntu的， 最好提供虚拟机
+ shell命令
  提供常见的方便调试的命令， 可以增加gpio，spi， i2c等相关命令
+ 编程首层和示例
  对平台提供的api，需要有类似变成手册和示例
** 1027 耀阳方案
两路camera可以通过如下解法：
目前的camra 是 640*480 的，  可以接受每行只去512字节数据， 其他可以丢掉
接法如下：
Nand  的d0 ~D7 接camera的 d0~d7
Nand的rb 接  camera的行同步信号hsync
Nand的其他信号不接，
Camera的Mclk接一个固定的12M始终就好， pclk不接， vsync不接
Nand控制器驱动只需要取到数据， 其他都交给软件， 不需要接到camera 的si去。

** 1026 智慧计算出差
*** 视美泰
**** 配合方式
1 对手样机可以参考A83T， 请提供一套给珠海
2 客户样机也需要提供几台给珠海，
问题重现：
基于客户样机， 炬芯会提供中性固件， 客户遇到问题后，会在中性固件上验证是否有问题， 有的话需要炬芯解决
客户可以提供他们固件，但不会提供开发环境
**** 性能要求
1.循环视频播放相同或者不同格式视频时间需大于240小时。不卡顿，不退出，不暂停。
2.USB或者CSI等摄像头须预览或者录像时间大于240小时。不卡顿，不退出，不暂停。
3.WIFI，以太网，3G能连接上网时间大于240小时。
4.音视频需要支持多种视频格式和高清视频，长时间播放无黑屏和死机现象。
5.支持双屏同/异显示（LVDS显示界面，HDMI显示视频），播放高清视频无抖动，卡顿现象。
6.USB,IIC触摸屏流畅，不断点，不卡顿。
7.强行掉电开机后必须保证能工作的有（测试次数大于4000次）：
 1. 前置USB摄像头能正常使用；
 2. 后置USB摄像头能正常使用；
 3. SD卡分区可读写
 4. U盘分区可读写
 5. WIFI自动连接，获取IP，上网；或者能与手机直连
 6. ETH 自动连接，获取IP，上网
 7. 3G自动连接，获取IP，上网
 8. BT自动连接
10.能进入android桌面，并不能恢复出厂设置。
11. USB触摸屏能正常使用
8.	WIFI，以太网ETH，3G数据通信保证不丢包，吞吐量足够大。（ping 192.xxx.xxx.xxx -n 102400 -l 10240）
9.	多个视频同时播放高清视频的解码能力，性能，音视频同步。
10.
**** 软件系统要求
1. 软件固件同时支持1G,2G DDR的容量,无需更换固件.
2. 开机时间5秒内需显示Logo，20S内进入Android桌面。任何原因关机须显示框等正常关机，时间在5秒内完全断电关机。HDMI与LVDS须同时显示,相差不得大于3S.
3. 全志三个阶段Logo需要支持不同分辨率，不同屏幕旋转状态正常显示。支持更换Logo方案。
4. 恢复出厂设置或者update升级,需要HDMI,LVDS都可以显示UI,不得黑屏.
5. 支持截屏。需要支持0,90,180,270旋转屏后的截屏保存。
6. 屏幕旋转模式须支持0,90,180,270旋转，包括3个阶段的logo显示,界面UI，视频等等都需要旋转。
7. 屏幕状态栏隐藏设置，同时支持手势方式显示或者隐藏状态栏。（如华为手机荣耀6）
8. 声音输出通道设置，可以设置自动检测和Codec，HDMI强制输出等不同通道输出。
9. 2G，3G，4G模块需要兼容性支持。支持模拟语音与数据通信。当无3G等模块插入时，须模拟3G模块，包括手机信息等，如IMEI号码等等信息供应用使用。支持3G通话，如手机操作。
10. 循环播放视频时，视频切换时黑屏时间少于1S。
11. USB外设支持：3G dongle，USB读卡器，USB触摸屏，USB摄像头：支持录像，录音。支持QQ视频通话问题。
12. 串口外设支持（包括USB转TTL，PL2303，FT2303等）：POS打印机，读卡器等外设。
13. 默认支持GooglePlay等APK。
14. 摄像头APK进入前，需要支持手动选择使用前置和后置摄像头。
15. 设置APK关于设备项目中，须加入我们特定信息：如DDR，EMMC大小，MCU版本号等等。
16. 须支持遥控盒子功能和鼠标模式。IR至少需支持Setting里面设置，Launch，浏览器和输入法正常应用。
17. 支持升级方式：USB升级，TF 升级卡升级，TF update.zip升级。其中TF update.zip升级能做到插入TF卡后,无需操作就直接升级了.
18. 支持恢复出厂方式：（无论是HDMI，LVDS，VGA输出， 恢复出厂设置需要统一通知用户，包括正在进行，成功，失败信息。）
19. 支持标准视美泰API方式。包括APK看门狗，视美泰板卡识别。
20. 支持定时开关机，加密系统。
21. 支持多家广告机发布系统：如实验室，星际，南翼和视展等等。
22. 静默安装APK。
23. 开关机指示灯定义与实现：
24. 网络优先级设置：ETH>WIFI>3G。可在设置进行选择。
25. HDMI，VGA，LVDS显示下，支持调节显示亮度，对比度和饱和度等显示设置。
26. 串口，IIC，扩展IO口，须提供接口以便支持应用层APP调用。串口支持485协议。
27. 需要支持单/双路,6/8位RGB_LVDS输出。支持双路8位 1080P，Freq=168MHz输出。
28. 支持双屏同/异显。（至少LVDS显示界面，HDMI显示视频,图片）。
29. 单WIFI 8188ETV和WIFI+BT 8723BU 模块，支持双频WIFI2.4+5G，软件能自动识别。
30. 支持TF卡/U盘进行参数配置，其中包括
        屏参设置
        屏幕旋转模式
        屏幕状态栏默认隐藏配置
        声音大小，喇叭，耳机，3G
        声音输出通道默认配置
        USB HID的VID，PID设置
        USB触摸屏原点位置
        IIC电容屏配置，IC芯片，地址，大小分辨率，原点位置（为了兼容多家IIC触摸不造成软件分支）
        WIFI AP默认名称和密码配置
        遥控器机器码厂家配置
        3G模块名称配置。（为了兼容多家3G模块不造成软件分支）
        是否支持3G模块选择。（为了支持多串口，兼容USB转TTL，PL2303，FT2303等）
        调试背光频率，相位和默认背光强度。
31. 一键恢复出厂设置。
32. 支持TF卡/U盘OTA完整固件升级。
33. Bootlogo 支持动态更改，支持旋转0 90 180 270度。
34. USB摄像头支持500W。
35. 支持假待机，关闭LVDS，eDP，HDMI，VGA等显示，声音，只是系统在后台运行。

*** 小悠游戏机掌机
7013芯片封装太大，放不到掌机的模具中
启动时间5~6s
128M nand + 128M ddr
可以不要cvbs，使用HDMI
只需要基础的linux系统
电池充放电，休眠唤醒
支持TF卡

之前游戏机规格
| 7013-功能                                                   | 备注                                                                                                                                     |
| 支持3.5寸LCD（320x240)，8寸LCD(1024x768) 正常显示，背光调节 | 2个FB，Video Layer 用DE放大，支持任意比例，Graphic 层支持原始比例或2倍放大，在8寸LCD上用1024X768和HDMI 720P 同时显示时对DDR 带宽要求较高 |
| 支持HDMI 720P，CVBS正常输出                                 | 　                                                                                                                                       |
| 支持HDMI（CVBS）和LCD 双屏异显同时输出                      | 难点：不同内容同时显示及插拔状态的检测及切换输出                                                                                         |
| 支持SNK模拟器编译运行                                       | 帧率60 FPS                                                                                                                               |
| 支持2个USB手柄                                              | 　                                                                                                                                       |
| 支持GPIO按键                                                | 　                                                                                                                                       |
| 支持摇杆和阵列按键                                          | 　                                                                                                                                       |
| 支持WAV文件声音输出                                         | 　                                                                                                                                       |
| 功耗优化                                                    | HDMI + LCD 中等亮度 + 游戏 440mA 左右                                                                                                    |
| 优化开机后2S出图                                            | 　                                                                                                                                       |
| 支持大文件附加烧录                                          | 　                                                                                                                                       |
| SDK裁剪，支持128M DDR                                       | 去掉不需要的模块，减小固件大小，加快开机速度，烧录速度                                                                                   |

目前3703的平台可以满足其规格，后续使用3703 SDK来完成支持

*** 晨芯问题
600ma的充电器，实际带载能力只有300多ma，所以充电充不进去
充电很长时间，手机低电
充电屏闪
全志，rk主控死机后，也可以充电
过放的电池，从3.2v充电到3.7v需要2个多小时

目前：
给不保存电量计的版本给经销商来验证问题
1：工程问题，充电问题，不确定是充电逻辑引起还是之前的WIFI问题导致，澄清中；
2：市场问题，联利为市场板卡整体报价比晨芯便宜，现在很多客户已经暂停，而且从我与老王的沟通来看，对市场有必拿的决心；从长期看，如果我们策略是ANDROID儿童故事持续要在3703上作投入支持完善方案的话，晨芯可能无心在7051上和原厂去竞争，再去想更多的思路，短期内也找不到更好的差异点，即使有，他们同样担心我们会想办法在3703上去实现；

10月份晨芯7051的板卡出货应该不到1K；

从最当初晨芯看到ANDROID在故事机的机会，到确认我们及联利为只专注在LINUX，开始启动项目，到后来东风的虚拟机，我们的应对也没有错误，但到现在方案公司变相错位竞争，感觉是有必要去协调了，否则将是我们几方都不得益的事情；
** 1028 联立为出差
加密文件流程，9月25号发布，1028来珠海出差才算验证完整，中间沟通应该有问题
充电过程中，按任意键会有亮屏提示，1028才发现
充电电流请他们改成800ma
** 1023 晨芯充电问题
*** 0915 出差拜访
掉apk和视频资源文件问题，
主要原因， 把apk和差不多2G的内容放在了可写的SD card分区，并且产品使用过程中会经常读写该分区，如果出现异常掉电则有风险。
使用硬开关，开机是通过异常复位来实现的， 关机走正常关机流程， 如果上次关机没有正常关机，那么开机就相当于在关机的过程中异常复位，有可能造成异常掉电。
方案没有打开异常低电的功能。
EMMC问题，目前7051是可以支持emmc和nand使用同一个固件来自适应的，后续希望这种方式，既可以降低成本，减少异常掉电风险，
*** 1023 充电问题
客户有提到如下现象：
+ 经销商报充电指示灯亮后，充电3~4小时后，不能使用正常方式开机，
+ 电池电压已经有3.9v，但不能正常开机，打印低电，这个是因为我们启动的时候有检查上次保存的电量。取电池电压对应的电量和上次保存的电量的最小值，这样处理原因有两个，1温度低的时候，电池电压可能是浮电，2电池曲线不能跳变
+ 客户工程师有重现过一次现象，把电池放电到3.0v，然后使用1A的adaptor进行充电，第二点，发现开不了机，但电池是充满的。

初步怀疑是在充电的过程中死机，导致虽然仍在充电，但由于已经死机，导致不能更新电量，从而电池电压和电量不匹配

目前的workaroud
+ minicharger下，清楚掉不掉电寄存器中保存的电量， 同时也不再使用不掉电寄存器来保存电量
+ 在minicharge状态，启动watchdog，可以挽救在这种情况下的死机

但真正的原因还是不知道， 上午夜找肖丽荣，顺伟开过会， 从客户的pmu配置的寄存器来看，就算使用1A的adptor， 黑屏的充电电流配置成1A， 也不应该出现死机的现象。

同时也不能排除平板方案就没有这个现象， 有可能平板也有， 但出现后， 长按8s就会复位， 掩盖了这个问题。 而故事机没有长按8s这个reset方法

这个还是请各位再继续思考下是否还有其他没有考虑到的， 还需要继续做哪些实验？
** 1023 邝、建雄福建出差
参考以下会议记录，有任何问题请随时通知，谢谢！

时间：2017/10/23
客户：联迪(LANDI)
客户人员：技术一部经理/硬件平台主管 肖锋，硬件工程师 张守将，采购 吴秀梅
炬芯(ACtions)人员：邝建涛，何建雄
友尚人员：Herman jin,Eric shen

状况：
1）	APOS(A8)，150K/M.Qualcomm 8909方案，采购核心板，价格200RMB+。供应商：移远，广和通，芯讯通。
2）	传统POS，40K/M.Freescale 2581方案，市场容量1KK/Y.
3）	MPOS，400K/M.Freescale K21方案，拼量，利润低。
4）	双屏收银机，Qualcomm 8953方案，新项目，预计Q4小批量，3K/M.采购核心板。15.6寸大屏LVDS接口。
5）	部分机种需要EDP接口，需要转换芯片，成本1USD以内。目前品牌东芝/龙讯达。
6）	联迪大股东是法国Ingenico，联迪主要销售国内市场。东南亚市场集团逐渐开放。
7）	员工数1800+，研发人员700+，软件约200，负责底层开发约50.
8）	项目预研后约6-8个月的开发周期，硬件评估较方便，主要是底层、软件人员团队投入大。暂时不需要demo评估测试。

后续跟进:
1）	确认沟通S700开始预研的可能性和时间表---Eric shen.
2）	确认RK等竞争对手的评估状况---Eric shen.


时间：2017/10/24
客户：星网视易(STAR-NTE)
客户人员：硬件经理 王勇，硬件工程师 李鹏锋，平台组长 邹应双，平台工程师 叶高杨
炬芯(ACtions)人员：邝建涛，何建雄
友尚人员：Herman jin,Eric shen

状况：
1）KTV点播产品，250K/Y。
主要为单机（家用）占30%+网络（娱乐，带3.5寸3T/4T普通机械硬盘）占70%。
主要方案，RK3288占90%，BCM7241占10%。
Realtek主方案样机测试中，具体料号暂时保密。
2）S700（套片，双显） 开发板基本功能测试OK，已layout.
预计11月份出样板，1月份（春节前）完成预研调试10台样机。研发周期6-9个月。

后续跟进：
1）	跟进项目进展，原厂建议样板完成贴片后寄几片同步调试沟通---Eric shen.
2）	确认完成预研后立项流程---Eric shen.
3）	跟进星网升腾瘦客户机(thin client)硬件主管洪金聪对S700的资料评估---Eric shen.


时间：2017/10/24
客户：福建冠林(AURINE)电话联系
客户人员：新产品Sourcing 刘启平
状况：
1）	楼宇安防，50K/M。主要方案新唐/ITE，加PMU套片3.0USD左右。少部分高端机种使用RK3288/RK3066.

后续跟进：
1）	提供对应新唐/ITE低成本方案资料供客户评估---Herman jin.
** 芯蓝图问题
+ wifi休眠唤不醒问题
  在这次客户打板的智伴样机中，总共发现3台， 我们内部发现一台，客户带过来的4台样机有两台是这个问题，目前发现现象跟着样机走，南方硅谷已经在debug中
  目前去掉低功耗休眠的模式，问题解决， 在没有澄清之前，先关掉这个功能
+ 0db 1KHz输出削顶问题
  这个修改的原理图，把左右声道输出耦合到一起输出，空出sio3 给其他使用，
  硬件合成会导致出现削顶， 需要软件解码后增加处理
+ 现有案子情况
  + 蓝宝贝
    芯蓝图自己的测试已经ok，解决完削顶后，预计周末上线
  + 绎趣
    凌工自己测试ok， 还没有让他们的测试测试
  + 智伴
    解决完休眠唤醒后，继续看还有没有其他问题，目前单片机还未好

+ 其他之前已经澄清的问题
  每个问题客户大概都折腾了一天
  + wifi 不工作
    这次的原理图有修改，gpio有修改过，我们发布的版型仍按照我们手上样机配置，客户未修改对
  + 固件烧写
    板子没有接电池，烧写固件错误
  + 检测不到卡
    固件烧写完成后，没有把开关拨动到正确的位置
  + 智伴问题
    就是休眠唤不醒导致的异常
** 耀阳相关的案子
*** 蓝牙指纹锁
关机功耗需要10ua， 只能通过外搭电路完成
使用4线nor，cpu跑156M，指纹识别1次，时间220ms
算法需啊哟的ram 90K左右
算法程序大小280K左右

可行
*** 人脸识别+指纹锁
****  产品形态：
  带人脸识别的指纹锁，
  使用两个camera， 一个是红外，一个是rgb的
  lcd用来回显RGB的图像，让用户对正位置，
  红外camera用来拍摄用于人脸识别的图像
****  需求
  + 关机功耗
    8节AA电池希望能够使用一年左右
    100ua带RTC供电
    没有rtc vdd耗电50ua， pmu本身耗电20ua
  + 启动时间
    希望做到2s以内，
  + 裸机系统
    如果linux系统做不到2s以内，希望跑裸机系统， 但系统我们提供支持LCD camera  usb camera驱动
  + 支持两个camera
    两个camera需要同时使用
  + 内存
    对方评估认为64M内存是可以用的。
  + 功耗
    卡拉OK录像，此时工作的模块，有录音，camera，vce编码，1080p解码，拔掉屏幕，功耗 4.2v 560ma
    主界面，拔屏， 双核  200ma
  + 需要支持简单的GUI
    这部分客户科技自己完成
  + 君正4775
    之前做过的考勤机，目前启动时间2.5s到kernel
    可能不继续使用的原因：
    价格
    原厂支持
    还是希望上自己的前后台系统
****  风险
  + uboot中支持camera
    在瑞泰车机中已经支持过在裸机中移植camera驱动，因此工作量可控
  + uboot上不支持usb 的iso传输
    所以要支持在uboot中同时使用两个camera需要较大工作量，除了控制器需要支持iso传输， 还需要修改uboot的usb  core的代码来支持iso传输。
    在uboot下支持多个camera，由于uboot本身不支持多线程，也有一定风险
  + gui问题
    整合一个简单的GUI，不支持gpu，工作量可控， uboot中的GUI显示客户可以自己完成
** 1012 3703项目出差报告
*** 大拿
**** LS360F（标案的云服务vendor）
    云服务器传输的压缩码流需要要控制在1~2Mbps，过大的话对网络性能要求太高
    大拿app sdk的内存占用（不包含代码）大概6~8M，网络情况好的时候会好一些，网络情况差的时候会大一些
    如果支持多个客户端同时查看视频数据，每增加一个会增加1M左右的内存
**** LS370A（TV camera方案）
大拿自己规划的的案子，支持双向视频聊天， 双向视频聊天使用大拿的服务器。
***** 需求：
+ 同时编码1080p和解码1080p的性能
  需要支持1080P的编码，1080P的解码以及同时1080p的显示， 现在重点需要评估性能是否满足需求。

  需要提供demo程序：
  + 读取1080p的视频源（使用文件）
  + 编码成H264
  + 同时读取H264的1080p源（使用文件）
  + 解码
  + 送显
  看同时是否可以达到要求的性能。
+ camera支持1080p
  需要20fps的， 需要外挂isp
+ 有多mic需求（5米拾音）
+ 最好是linux SDK
  3703的sdk可以满足
***** 主要风险
+ DDR带宽风险
  3703只有16bit 的DDR， 跑396MHz， 按照65%的带宽利用率计算，能提供的带宽 2*2*396*0.65 = 1030M

  目前看DDR的性能会有问题。  DDR带宽计算：
    | 功能            | 计算方法                             | 带宽需求 |

    | HDMI/LCD 1080P  | 1920*1080*4*60fps                    |  484 |
    | 1080P解码       | 1920*1080*1.75*30fps                 |  108 |
    | 1080P编码       | 1920*1080*1.75*30fps                 |  108 |
    | 2路视频单层合成 | 1920*1080*1.75*30*2 + 1920*1080*4*30 |  448 |
    | camera          | 1920*1080*1.75*30                    |  108 |
    | 系统其它部分    | os，读写文件                         |  100 |
    |                 |                                      | 1356 |

目前看DDR带宽已经基本不够了， 需要继续降低性能需求才可以，比如编码解码都降低到20fps
    | 功能           | 计算方法                           | 带宽需求 |
    | HDMI/LCD 1080P | 1920*1080*4*50fps                  |      395 |
    | 1080P解码      | 1920*1080*1.75*20fps               |      70  |
    | 1080P编码      | 1920*1080*1.75*20fps               |      70  |
    | 2路视频合成      | 1920*1080*1.75*20*2 + 1920*1080*4*20 |296 |
    | camera          | 1920*1080*1.75*20                    |  70 |
    | 系统其它部分   | os，读写文件                       | 100      |
    |                |                                    |      1001 |
勉强可以够，
如果在电视上叠加本地和远程数据的话， 肯定是不够的。

*** 联立为
联立为目前主要做的是3703的试产
+ 问题解决
  使用新发布的sdk，之前报的bug在新sdk验证已经验证解决
  爱奇艺视频老化退出问题，内部和他们也没有再抓到过现场
+ 性能问题
  之前版本遇到的apk退回后切回laucher慢问题新版本已经解决
  wifi列表扫描的性能优化，后续修改
+ 应用开发方式
  api保持了和229 sdk相同，可以很快上手，
+ 发现新的问题
  宝宝巴士apk，有时候退出的时候，背景音乐没有退掉，
+ 新的需求
  黑屏充电电流和亮屏充电电流不同，想改大亮屏充电电流，已经告知他们方法，同时也提醒了他们风险
+ 其他
  提供命令行调试apk的方法
  加密视频和Flash的验证

*** 正芯锋
**** 无线硬盘盒
***** 需求
+ softap
  小机做softap，手机上用app浏览小机上的内容
  目前3703上还没有支持softap，需要增加这部分功能，
  2293上已经有相应的功能，可以参考实现即可
+ usb硬盘
  使用外供电
+ HDMI输出
  可以通过HDMI输出UI操作菜单到电视上，来操作硬盘中内容，播放以及文件管理
+ 红外遥控
  在HDMI输出的时候，需要支持红外遥控，这个3703 上不支持，需增加
+ 两套UI支持（可选）
  设备可能会带一个4.3小屏幕，分辨率很小，在小屏幕显示的时候HDMI不显示，但这样就需要支持两套UI， 这个在目前3703中不支持，但这个需求应该不是必须的。
+ 文件系统
  需要支持 FAT/EXFATFAT32/NTFS等文件系统， 这个已经支持
+ 支持局域网共享(可选)
  使用cifs
***** 风险
暂无
***** 工作量
+ 支持softap
+ 支持应用使用不同分辨率（可选）
+ 支持cifs（可选）
**** 广告机
***** 需求
+ HDMI输出
  1080P 分辨率通过设置，设置好即可，
+ 1080P LCD
  双lvds 8bit接口
+ HDMI和LCD不同时显示
  HDMI显示的时候，LCD可以黑屏
+ 单路1080P视频性能30fps
  广告机的性能
+ 横屏显示竖屏排列的内容
  这个需要把视频解码出来的内容，做一个90度的旋转，在合成到fb中
+ 屏幕区域分块
  可以把屏幕区域分成4块，其中一块区域显示视频，另外三块区域显示图片
+ 视频切换避免黑屏
  LS370A在视频切换的时候，不需要屏幕黒一下
+ 64M 内存支持
  希望可以用64M DDR2/3
***** 风险
+ DDR带宽
  性能主要风险还是在DDR的带宽上，3703只有16bit 的DDR， 跑396MHz， 按照65%的带宽利用率计算，能提供的带宽 2*2*396*0.65 = 1030M
  DDR带宽计算：
    | 功能           | 计算方法                           | 带宽需求 |

    | HDMI/LCD 1080P  | 1920*1080*4*60fps                          |  484 |
    | 1080P解码       | 1920*1080*1.75*30fps*2                     |  216 |
    | fb视频+图片合成 | 1920*1080*1.75*30 + 1920*1080*4*30*2(读写) |  580 |
    | 系统其它部分    | os，读写文件                               |  150 |
    |                 |                                            | 1430     |
  因此在3703上不可行，需要封装出32bit ddr才可以
+ 64M DDR
| 使用者      | 描述                            | 大小 M |
| FB(reserve) | 2个1080P                        |      8 |
| Kernel代码  | 内核代码                        |     10 |
| MemFree     | 内存最低内存                    |      2 |
| Cached      | 代码运行的cache                 |     7M |
| GPU         | gpu的texture缓存                |    10M |
| GPU驱动     | 驱动使用的内存                  |     3M |
| ion         | 视频参考帧5+3  1920*1080*1.75*7 |     24 |
| 码流buffer  | H264 mp4格式（最小）            |      4 |
|             |                                 |     68 |
这里还没有计算其他内核内存，就已经不够了
Slab	8316
KernelStack	1368
PageTables	744
VmallocUsed	17884
** 0921 RT-thread
见了linaro的周新华，和RT-thread的人
+ zephyr
  目前中兴已经在使用zephyr了， rda也有开始支持zephyr。
  zephyr的mips代码的upstream可以由我们自己来做，linaro已经和zephyr组织打过招呼
  linaro在zephyr项目本身的工作还是集中在arm架构的支持上，以及dts等工作上，而不是组件这些工作。linaro的工作最终都会提交到zephyr项目中，在linaro的lite工作组可以看到一些还在内部没有提交到zephyr中的代码。
+ kernel版本
  linaro的lsk(linara stable kernel)目前最新的是4.9，会维护较长时间，目前linaro和google的合作已经开始比较紧密， linaro的kernel会逐渐的被google直接接纳， 这样使用linaro kernel适配android的话， 会更加容易一些。
  google对kernel版本的升级周期之前大概是2年左右，后续版本大概是4年左右。
+ android版本升级
  linaro目前有提供andriod版本升级的服务，要付费的，
+ rt thread
  获得了华强聚丰和思必驰的1000W融资， 据说出过故事机，有70~80k的出货
  rt-thread是一个类似zephyr的一个软件系统，除了提供核心外，还提供了文件系统，设备驱动模型等， 而不是像FreeRTOS一样只有一个核心。
  rt-thread采用的license协议类似LGPL， 修改了kernel本身的代码需要开源，自己的代码不需要开源。商用不需要付费。
  IDE支持keil iar以及gcc， 调试支持jlink，比较方便开发
  rt-thread 3.0 整合了较多的组件， 网络是lwip， 没有蓝牙相关的协议栈，目前还未开源出来，网上的开源版本还比较旧
  支持多种架构，mips主要是君正的cpu
  芯片的os适配，以及driver porting需要原厂去做，
  号称支持中天的cpu， 问了后，说只有fpga，没有实际的ic
+ 96board客户ucrobotics
  正在做rda5991来支持rt-thread
  使用了s900用来做ai，和图像相关的计算密集型算法，评价是s900目前可以用到4个neon和16个gpu的运算核心，性能比3288要好不少。
  19层的dnn网络可以在250ms内跑完。
  目前在规划使用GT7或S700做低成本的板子。

** 2017-0405
*** linaro 96board
96boards 的软件支持：
+ 优先支持的os，比如android zephyr由linaro完成
+ 社区会搞定其他大部分的OS
+ win10等os的支持，是linaro完全不知情的
linaro比较有兴趣去和百度去推动语音+zephyr+百度的DuerOS的事情

** 2017-03-23
*** 南方硅谷
+ Airkiss可以通过多次join的方式来看是否仍有问题
+ 断线问题需要有抓包数据
+ 抢带宽的问题，可以尝试使用IP的qos来解决，SSL看下有没有BB的做法
+ 更新新版驱动问题， 有修正一些bug， 看是否有改善断网的问题
+ 内存节省， 通过在driver中保留两个1.5k的buffer， 在net_input中，拷贝到zephyr中的n_buf中， n_buf可以frag分片
+ 休眠 WIFI模组，保持长连接， 连续RX  需要90多ma， 100ms唤醒1次，10ma 3.3V， 级别3， 级别10最低
+ sniffer空气抓包工具，推荐型号
+ 29号给南方硅谷板子
+ 3503 后续给南方硅谷固件， 不用给源码。
*** S700 S900支持策略
+ S700/V700/S900共用一个SDK，发布的时候同时发布，不特别区分不同IC的不同SDK发布。
+ 测试优先安排S700的SDK的发布以及测试，S700发布计划依然按照4月底计划努力，V700/S900可以后续再安排，作为第二阶段。
+ S700的开发板是CB6，S900的开发板是96Board。关于出货给客户的类似开发板子板的方糖的板子最好抄96board的设计。
+ V700的标案规格就是平板的规格。
+ 泽迪的V700先用GS700E出货，最后可以切换到现在的SDK。

*** 方糖拜访
+ S500 CB6,  S700 CB7
+ S700 linx ubutu版本已经带起
+ 方糖带起GPU加速
+ 炬芯带起硬解码
+ s700 的效果不能比S500差
+ hdmi 分辨率如何设置， 好像不支持

** 2017-02-17 LinkPlay
LinkPlay:
MTK方案：5V 300~400ma， 关掉RF 80ma 5V， 没有standby功能。
alexa 加harman  等有新客户开案

要求：
功耗降低， WIFI+5G， 需要支持WIFI休眠。

认证要求：
alexa 直接对接amazon

ASR02模组的原因：
sensory， 唤醒词收费。 echo alexa amazon
模拟容易解决。

唤醒词模型， 在ap上可以放比较大的模型。 DSP做不了大的模型。
休眠状态， WIFI不断开。  拾音。
科胜讯 唤醒词50ma。
Broadcom 43455，Ap6255。
WIFI认证只需要我们调通模组就好。 认证由linkplay搞。

亚马逊认证流程：
3天， 房间，声压计， 唤醒的， 等有很多环境。
测试唤醒， 误唤醒， 24小时不能超过3次。
环境噪音低于65db，
在云端有log。
具体指标：
近场80公分， 50db ，近场不播放音乐。
原厂 3米， 最大音量播放  85db， 人声 50db
亚马逊静音房测试。

mic的要求：
mic使用驻极体 mic， 全向。  mic的一致性要求很好， 使用特别出货测试。
一致性主要是灵敏度等参数。 ADC的动态范围。
对mic拜访，模具结构都有特别的要求。
多mic有声源定位， 但后者实际使用并不好用。 跟摆放位置， 遮挡关系都很大。

软件需求：
1 harman推荐方式
2 X1000的文档，比较全。
3 broadcom WIFI认证， BQB认证 和 WIFI long认证 君正都比较熟悉
4 哈曼 推荐了amlogic A111的芯片。 推荐。
哈曼 已经引入了这个方案进入google chrome cast。
5 音箱 95db 和 105db是两个坎。
6 SPDIF IN的要求。

mtk bsp的要求：
1 def config 客户可以自己搞定。
2 音频驱动alsa， 不需要tiny alsa， alsa util等。
3 wifi dns， dhcp， wpa， 标准socket。
4 hostapd 需要
5 busybox需要支持网络管理， 不确认是不是在busybox中。
6 wifi 测试工具。 + wifi认证固件。
7 bootloader可以用自己的。
8 BT 功能。 需要做完善。 A2DP， AVRCP ，HFP。
AVRCP 需要回声消除。  需要提供蓝牙的sdk的接口。
A2DP的发射。
9 SDIO 支持 2.0， 5G最好能够SDIO 3.0
10 WIFI的休眠唤醒。 通过WIFI唤醒CPU。 在休眠的时候需要保持链接。
11 cpu资源要求。 第一阶段不是问题。

* debug
echo 0x3a > /sys/class/i2c-adapter/i2c-0/0-0065/atc260x_reg
busybox devmem  addr
echo 7 > /proc/sys/kernel/printk
* DS
| Features                       | ATM7051H              | ATS3703                   | ATS3605                   | ATS3605D                  |
| wafer                          | GL5202E               | GL5202E                   | GL5202E                   | GL5202E                   |
| CPU                            | SMP4                  | A5 SMP4                   | A5 SMP4                   | A5 SMP4                   |
| package                        | EPAD176               | EPAD176                   | EPAD176                   | EPAD128                   |
| BondingOption                  | 0xE                   | 0xD                       | 0xC                       | 0x7                       |
| DDR3/DDR3L/DDR2                | x16                   | x16                       | x16                       | 16M DDRII                 |
| Nand                           | toggle1.0,4CE         | Normal,单CE               | Normal,单CE               | Normal,3CE                |
| RMII/SMII                      | X                     | X                         | X                         | X                         |
| SPI                            | X1                    | X2（支持SPI Nor）         | X2（支持SPI Nor）         | X2（支持SPI Nor）         |
| UART(2 wire)                   | 2wire+1X4wire         | 2wire+1X4wire             | 2wire+1X4wire             | 2wire+1X4wire             |
| sensor in                      | √                     | √                         | √                         | √                         |
| SDIO（包括复用到NAND的那一组） | X2                    | X3                        | X3                        | X3                        |
| USB                            | 2XUSB2.0              | 2XUSB2.0                  | 2XUSB2.0                  | 2XUSB2.0                  |
| CVBS                           | X                     | X                         | X                         | X                         |
| HDMI                           | √                     | √（与CMOS互斥）           | √（与CMOS互斥）           | X                         |
| I2C                            | X3                    | X3                        | X3                        | X3                        |
| I2S                            | √(支持外接codec)      | √(8线，支持外接其他codec) | √(8线，支持外接其他codec) | √(8线，支持外接其他codec) |
| PCM                            | X1                    | X1（与I2S复用）           | X1（与I2S复用）           | X1（与I2S复用）           |
| SPDIF                          | √                     | X                         | X                         | X                         |
| LCD                            | RGB/CPU/LVDS          | RGB888/CPU/LVDS           | RGB888/CPU/LVDS           | 串行RGB888/CPU/LVDS       |
| SIRQ                           | X3                    | X1                        | X1                        | X1                        |
| Matrix Key                     | 4X3                   | 4X3                       | 4X3                       | 4X3                       |
| 　                             | 　                    | 　                        | 　                        | 　                        |
| 　                             | 与ATM7051 PIN2PIN兼容 | 　                        | 　                        | 　                        |
| 制程                           | UMC55                 | UMC55                     | UMC55                     | UMC55                     |
