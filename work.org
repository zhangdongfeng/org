#+LATEX_HEADER: \usepackage{xeCJK}
#+LATEX_HEADER: \setCJKmainfont{STKaiti}
#+OPTIONS: \n:t ^:nil  toc:nil
#+TODO: TODO(t) STARTED(s) WAITING(w) | DONE(d) CANCELED(c)
* 智能语音
** 会议
*** AS216b
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EBAAE@srv-mail-02.actions.com.cn][RE: AS216B立项通过]]
*** 语音前处理预立项
[[mu4e:msgid:29180296.78481.1493370386557.JavaMail.fwint2@srd-fw-share009][会议记录:语音前处理模块项目的预立项评审第一次会议]]
*** 0424 5116预研
**** 周总
+ 需要考虑DSP给第三方开发
+ 可以做为预研项目，不需要计算ROI
+ 考虑ATJ2167
+ 不需要考虑成本，研发优先
+ 需要第三方开发DSP
*** 地平线
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB7E9@srv-mail-02.actions.com.cn][Roobo&地平线的出差记录]]
*** 迪韵 3605D
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB6AA@srv-mail-02.actions.com.cn][20170414-迪韵&火百灵客户拜访的出差报告-雷长发 .doc]]

	3605项目，初步项目名EchoLike-T1，当前的目标客户是一家江苏的，下一步期望我们在场3方客户会议，当前客户期望是3个月后能够送出过认证

	Airpaly和DLAN是WIFI音箱的标配规格，这个需要市场再落实。
	迪韵和第三方专门开了一颗ADC的IC，预计5月底能够拿到IC
规格：6路ADC，SNR spec是95dB,DR:98dB（需要实际IC测试）
	全志的G102和G202基本没有人使用，当前语音识别使用的依然是R16，全志的ADC是4路ADC，DR是106的dB（给迪韵的资料），没有实际使用过。
	4MIC的有希望能够迈过门槛，当前最好的算法还是比8MIC的差了不少，他们的对比方式，没有指标。
	CX20924是4路DMIC输入，比CX20921贵1个美金。CX20921的模块他们拿到的价格是6美金（含税，包含算法）
	彭总认为echo产品下一步会分化为2类：echo继续发展，重视其音箱规格，音效和音质部分需要加强；另一类是DOT类更简化产品，弱化speaker功能，凸显控制功能。他们更看好后者。
	当前RK也在强推3229和3066，迪韵认为3066的性能偏弱，只能配合CX20921做方案，他不看好3066.3229属于高端多6~8 MIC比较好，但是量不够。
	多MIC方案中模拟输出的MENS会因为一致性好可能成为多MIC应用下的主流。模拟输出的MENS价格也在持续走低，已经不到5倍价格了。

 乐百灵
	给我们演示了双MIC的样机效果（宣传指标：远场5m，唤醒率94%，识别率90%），唤醒不了的情况还是比较多发生（给我们的解释是里面的测试固件，其实我们手上的echo dot也一样）。
	乐百灵的这款双MIC采用的方式直接CX20921贴主板上，没有用模块。AEC没有使用ADC，直接使用的是AP出来的I2S的输出连接到CX20921上，CX20921负责下采样。同时这个方案是有音效的，音效是外挂IC，也就是说当前的AEC是从音效处理之前采集的。他给我们的说法是这样做多对性能有影响的，只是当时为了省ADC才这样做了。
	乐百灵采用的是云之声的语音识别算法，云之声将云识别算法和CX20921打包方式给乐白灵。
	唤醒词部分是他们自己的算法，他们可以更换唤醒词。咨询唤醒词的运算量，他说的他们自己的很小。他对CX20921的冷唤醒词识别不是很看好。
	他也提到了Airpaly和DLNA的需求是WIFI音箱的must需求。
	语音识别库：老朱看来认为故事机和WIFI音箱是两个不同的产品，对算法要求不同，他给我们的解释是故事机针对小孩，WIFI音箱针对大人，大人小孩的声音识别训练模型是有差异的（待确认），我们3503故事机和WIFI音箱公用语音识别的方式关注一下这个。
	乐白灵的模具因为语音识别做过多次调整，最后选择将MIC的腔体放在上偏后面，同时模具设计上对震动音箱等都有充分考虑。他的说法是这部分对算法效果影响非常大。
	他们手上有语音识别且蓝牙和WIFI切换的模具，是一款公模。比较切合我们ATS3503的WIFI音箱的方案需求。
	初步沟通准备从他们家购买单MIC和双MIC的模具作为我们标案开发使用


3605项目，初步项目名EchoLike-T1，当前的目标客户是一家江苏的，定位国外市场，资源第一步只考虑Amazon（国内市场放后面再考虑），下一步期望炬力在场3方客户会议（终端客户希望IC原厂的表态），当前客户期望是3个月后能够送出过认证
2.方案规格：已经基本有初版，迪韵前期与客户就手上已有平台讨论确认了。 IC先选定ATS3605，方案先使用NAND，DDR先预选128MB（根据预处理和sensory唤醒词算法的内存需求最终确定后再看是否需要换成64MB），WIFI模组选定博通AP6212，当前这个客户不需要LCD（但期望能够提供一个可以演示UI的DEMO用于接触更多的其他潜在客户，UI最好开放给迪韵开发和替换）；手机端配置APP使用迪韵已有的；amazon认证方式：直接迪韵配合江苏客户去过认证。
3.	当前提供的ATS3605的开发环境，根据前期的熟悉和了解，期望软件补充3个部分的内容：DLAN和AirPlay的音频接收，BT蓝牙的驱动，标准的ALSA
4.	硬件平台的要求：需要炬芯协助实现MIC阵列子板和3605的EVB板的对接；另外产品化的硬件设计，迪韵提供模具机构图，期望这个3个月送认证的硬件设计由炬芯安排；
5.	人力：算法及方案开发，迪韵当前投入1.5人。炬力当前已经调配专门的团队，有专门的驱动和内核以及硬件的负责同事。
6.	讨论到的关键路径的任务和时间点：
A．	MIC阵列模块的接口迪韵发给炬芯（4.14已经给出），炬芯评估与3605 EVB对接实现方案（飞线，修改转接子板还是需要重出板子，以及出核心板待定），承诺时间点：飞线或者简单转接子板1周搞定，如果设计修改EVB的话，需要2周时间，目标是期望以最快的方式给算法调试提供硬件平台；同时迪韵使用当前手上的3605的EVB进行算法的移植，算法移植工作量预计1周半。
B．	需求规格：迪韵发出当前规格版本，同时炬芯安排评估当前SDK是否有遗漏需要开发（当前已知的3大点已经提出），同时根据当前规格评估出方案的BOM，然后约谈3方会议。
C．	模具的3D结构信息，考虑试验样机的硬件设计，贴片（需要外包）

*** 3605D
[[mu4e:msgid:22283209.72775.1491959999616.JavaMail.fwint2@srd-fw-share009][会议记录:讨论3605D方案规划]]
*** CITS 2017
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F36F30@srv-mail-02.actions.com.cn][答复: 2017 CITE展会参观报告]]
2017cite展
出差内容：
深圳cite展（中国集成电路技术展）
关注重点是智能家居和人工智能在消费类应用。
关于智能家居，接触了海尔，tcl，创维，海信，康佳几家。
海尔的U+自定义了协议，有云接口，也有局域网内部的接口。但是侧重在云
接口上，断掉外网后的局域网小循环则放在其次。有点类似亚马逊。家电单
品突破为主。
TCL则重点放在局域网的小循环的协议上。也可以接外网云设备。感觉更多像
Control4。产品以房地产商合作的前装为主。
这也是目前智能家居的两种实现方式：一种侧重云接入为主，重视单品；另
外一种侧重本地系统的整体转换，重视开发商的前装市场。
但海尔的协议不开放，必须使用hairer的模块，wifi主要是高通4004和
realtek的。Ble用的8762，zigbee用自家的芯片不开放给外部使用。
TCL的设备物联网方面，主要和京东微联合作，因为认知家电产品京东比淘宝
买的多，所以认为京东微联比阿里小智在家电产品有更大的影响力。
其他家电视机厂：
创维，则转型向社区服务，比如o2o洗衣机和o2o付费电视。在智能家居系统
的布局相对少。
长虹，海信，康佳更多的是电视机本身的技术，如曲面屏，手机多协议推送
，或语音搜索等。
人工智能方面：
科大讯飞系摊子最大。在深圳建立产品团队，和支持团队，针对华南地区的
客户的接入和服务。同时在推广VR进入学校教学和职业教育，联合了教育资
源的公司在开发VR内容。注资淘云，整合幼教内容、语音技术和对玩具厂商
给予授权。
Intel展台上，展示了商用机器人naopaper（做展示为主），和科大的差别是
有机械的控制这块。科大体系侧重语音的人工智能，侧重消费类产品，娱乐
，教育产品。
高通的展台，人工智能这块做了Qualcomm Zeorth机器学习的引擎，其核心不
是在云，而是在本地计算。这是和前两种不同的方式。
其他的亮点：京东方转型做结合3色墨水屏的商超服务，电子标签整店替换和
后台网络控制整套解决方案。
照片分享：https://pan.baidu.com/s/1qYrZKUo
结论、感想及建议：
1，智能家居体确实各家的思路和玩法不同，包括国内外的。等各自大起来，
会出现各体系连接的过程。
2，人工智能，以语音接入方式最热，云脑的方式是目前主流，也不乏本地机
器学习的努力。人工智能第一波消费类的赚钱应该在语音方向。幼教方面已
经开始在赚钱了，内容资源和技术整合可能会是个趋势。
*** 关于智能语音在蓝牙和Wifi音箱市场上的落地
[[mu4e:msgid:2307181.71992.1491807792153.JavaMail.fwint2@srd-fw-share009][会议记录:关于智能语音在蓝牙和Wifi音箱市场上的落地]]
**** 周总
5118plus  5119 + 成本取决于核高基
5116 用来摸规格
5116C/5120 不做远场的规格
new ic（m3 + DSP）解决2mic或3mic的远场以及音效， 不仅仅只做预处理器，
用来兼顾蓝牙的语音预处理
**** 肖凯平
***** 故事机 3503
近场 （按键唤醒， 按键打断）
***** m3 + DSP + bt/wifi combo  + 解码
3503 + 远场 + 音效
类似echo 3~5米， 关键词唤醒， 关键词打断
3605D的costdown版本
***** echo 使用的经典蓝牙遥控器
**** 张洪波
***** 5116
+ 远场
  使用科胜讯cx20921， 使用sensory的唤醒词。科胜讯的功耗太高。
  打电话过程中打断， 误唤醒会比较高
+ 近场
  不需要vad vat， 使用按键就可以。在任何时候都可以按键进行识别。
***** 5116C/5120
+ 只考虑唤醒词， 不考虑蓝牙远场
+ 蓝牙播放音乐+音效需要增加70K， 5116c已经增加32k， sensory要求70k（ram + rom）
+ 只考虑蓝牙耳机的近场（非按键）
+ 远场
    本地播放+蓝牙后台连接+打断+语音识别
  远场需要绑定云
  识别的调教需要云和预处理配合才可以
***** 远场+蓝牙
蓝牙speaker
远场拾音芯片
***** WIFI音箱
m3 + DSP + bt/wifi combo  + 解码用来主打WIFI音箱。
蓝牙only音箱 + 8761就可以。 不需要加5116C， 但需要移植蓝牙音箱的功能
**** 雷长发
VAT  VAD低功耗唤醒系统
按键唤醒
静音环境下，脱离按键唤醒
放音环境下，打断
+ 蓝牙是否可以可靠的唤醒手机
+ 使用5116 + DSP远场拾音
*** 市场部会议
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04EC4F2A@srv-mail-02.actions.com.cn][答复: 2017年4月 市场部/企划部 联席会议——智能语音主题]]

** doc
聊一聊麦克风阵列技术：语音交互应该选用怎样的方案？｜深度
http://www.leiphone.com/news/201610/BSlh3Kf6wcqNCRH9.html
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EBAE8@srv-mail-02.actions.com.cn][RE: 关于多mic算法的内部评测标准？]]
** 微信
*** 0610
昨天和科胜讯的人聊几个重要的信息

1，亚马逊的音箱认证目前全球只有linkplay一家过了，搭配科胜讯双mic。第二家可能是通力，正在用科胜讯的双mic在送认证。通力内部有实验室可测亚马逊标准的测试环境。通力也在配合科胜讯的4mic算法芯片。国内大量算法公司在努力过多mic算法，至今还无成功先例。
2，双mic在国外已经满足需求，4mic的需求主要是国内的需求，性能上双mic接近echo体验，但是没有bf的效果，4mic的略好，可实现bf和唤醒方向灯的功能（非认证强制要求）。
3，亚马逊认证除了声音的认证外还有两大系列的功能性认证需求。具体是哪些，要具体产品去过。
4，关于sensory的唤醒，mtk的7688用的是250k的库，据说是去年12月的测试标准，现在测试标准还在不断加严格，上次我们看到一份3月的标准简介。据说主要差别是把人声命令降低了5db，把噪声提高了5db。所以mtk7688的可能过不了新标准了。这也是新的产品越来越难过alexa认证的原因。
5，关于科胜讯的唤醒词，在科胜讯上可放sensory的40k模型的唤醒词，但误唤醒率过不了认证，亚马逊标准3次/24小时。如果到40k的会较大误唤醒（比如，30次一天）。如果sensory认可我们使用，是可以把“alexa”和“芝麻开门”两个唤醒词的固件给我们，没有额外费用增加。

robert说法是亚马逊用的算法资源太多，之前是2.5个a53。现在压缩到2个a53。另外一个a53，做音效。一个做应用扩展。

科胜讯给了看了一家客户对比测试的报告。主要是不同噪声db级别，不同音乐db级别，不同角度的唤醒，还有某几句话的不同距离测试唤醒。

我觉得我们还是过度聚焦在多mic算法上了。问题的关键在于认证是否仅仅认证多mic算法？ 如果认证要确保亚马逊其他算法和应用有效。那么就不用再思考 3503 或者其他mcu➕dsp架构过认证这回事。这是架构性和方向性的问题


昨天CEVA的人过来演示多mic效果，是在灿芯在SMIC55做的500MHz的TL410(我们之前的TL421的速度受限于SRAM,实现部分应该有空间，待论证)芯片上跑sensory唤醒词“hello,ceva”外加4条命令同时跑Alang 4mic远场算法，我们体验的效果不好，他们解释是TL410的性能不够。另外CEVA内部有开发X2的4MIC算法，今年Q3出来，可以提供给X2客户使用。另外一个信息是alibaba一家全资子公司正在做X2的IC，目标是6MIC,今年Q4 IC出来，另外Alibaba合作一家开了TL421的一颗，预计Q3 IC出来，也是6MIC,其他老赵帮忙补充吧
*** 0622 CEVA
1. alibaba使用的X2是他和C-sky合资的公司在做的，目标6~8MIC，MCU可能就是中天的802
2. allwinner使用SDT评估，C直接编译的话效果A7和X2基本一样，后来调用CEVA优化库优势就体现出来了，他们评估6MIC的语音前处理需要X2运行400MHz，当前CEVA与他们说接受协助优化，可以再优化20~30%。
3. amazon使用X2：芯片提供是DSPG（正在研发），算法使用了双核X2，频率是800MHz，对应的算法用ARM的CPU需要跑3~4GHz，还有额外的一个X2用于低功耗设计。
4. 微纳感知评估的一个数据是ARM A9运行 1GHz的跑的算法，他们评估TL421 350MHz可以完成。他们的ADC外包用的是dophin的IP。
5.
* 耳朵IC
** X2评估
*** X2资料提到的WIFI性能
结合给的WIFI资料， 他们的WIFI的baseband（mac）部分需要的50MHz的性能。
TCP/IP, EMAC RTOS的性能需求是15MHz
*** 3503性能需求
+ 场景
  播放边下载边播放网络320Kbps的mp3数据，此时主要的功能模块（解码，网络下载，usb读卡器，文件系统同时读写）
+ 实际数据
  CPU占有率 80%， 10532毫秒内，cache miss 的时间是 3950ms
  CPU运行156M，SPI Nor的速率为48MHz  四线模式， 每次cache miss需要的时间为3.3us (相当158个cycle，没有CRC的理论最快 140个cycle）
  折算出来的cpu的性能相当于82MHz， 320Kbps的mp3解码需要50MHz， 那么此时系统需要的就是32Mhz
*** X2可以跑系统
从指令集上看，开始支持char类型为8bit，因此对C程序的可移植性不会有大的影响了。
从寄存器上看，开始有32个通用寄存器了，也比较容易跑控制逻辑代码了
性能上看core mark按照资料有4.3/MHz，相比M4k更好的。
目前给的评估环境，找不到如何使用timer和中断的方法，所以不太好测试，后续需要更多的资料和环境来测试。
*** 各个平台CoreMark对比
CoreMark对比如下：
| IC         | Cpu/Clk        | Compile&argument                                            | Code       |   CoreMark | CoreMark/MHz |
| Cordio-tc2 | Cortex-M0+ 32M | ARM Compiler 5.06 update 1 --cpu Cortex-M0+ -O3 -Otime      | RAM        |  64.513404 |        2.016 |
| Cordio-tc2 | Cortex-M0+ 32M | ARM Compiler 5.06 update 1 --cpu Cortex-M0+ -O3             | RAM        |  39.142952 |        1.223 |
| 3503       | MIPS4K 150M    | /mips-2014.11/bin/mips-sde-elf-gcc (GCC4.9.1) -mips32r2 -Os | SNOR/Cache | 333.333333 |        2.222 |
| 3503       | MIPS4K 150M    | /mips-2014.11/bin/mips-sde-elf-gcc (GCC4.9.1) -mips32r2 -Os | RAM        | 333.333333 |        2.222 |
| NXP K64f   | Cortex-M4 120M | ARM Compiler 5.06 update 1 -O3 -Otime                       | EFLASH     | 283.889283 |        2.366 |
| NXP K64f   | Cortex-M4 120M | ARM Compiler 5.06 update 1 -O3 -Otime                       | RAM        | 218.658892 |        1.822 |
|5202e|	Cortex-A5 Single-Core 960M|	arm-linux-androideabi-4.7 -march=armv7-a -mthumb -Os	|ddr|	1676.727029|	1.747|

分析：
+ 编译参数有较大影响。修改编译参数前后后Cordio-tc2上CoreMark相差较大。
+ 3503在SNOR和RAM中运行结果相同。因为CoreMark代码规模不大（<16Kbytes），可以全部缓冲在cache中。
+ K64f在flash中运行的效率高过在ram中运行。因为M4是哈佛结构，在flash中运行能充分利用取指和取数据走不同的总线的优势。
+ 5202e的CoreMark偏低。
+ Ceva x2在simulator上运行的结果可能参考意义不大。

*** 架构建议也评估下 单核 + spi nor 执行代码 + 内部Sram的方案
主要考虑如下：
**** spi nor性能可能好于sdr ram的性能
+ spi nor 和 sdr ram的基本性能可能只有不到2倍的差距
  sdr 用 166MHz  16bit
  spi nor 最快的已经有  80MHz DDR模式  8bit
  在cache line的size为64byte的情况下，性能差距已经不到2倍

  龚建给SDR的4线 nor的数据：
  #+begin_quote
  SPI NOR最快的模式，就是下面的AXH模式，如下时序：地址以4IO的模式发送，不用发EB的Command
  需要的SPI Cycle是12的地址Cycle+64*8/4(64Byte的Cache Line)=140Cycle。GD SPI时钟最快的Fast Read是120MHz。
  #+end_quote
  钟旭给的sdr ram的数据:
  #+begin_quote
  1、SDR在没有命令拥塞的情况下：
  最快：  3+64/2=35cycle；
  最慢：  3+3+3+64/2+2=43cycle；
  2、如果有命令拥塞（其他master读写命令在命令队列里等着）的情况下：
  最坏的情况：所有命令都是读写切换且同一个bank的情况
  (3+3+3+32*8/16+2)*4+(3+3+3+64/2+2)=151 cycle;
  #+end_quote
+ 使用spi cache跑代码可以充分利用x2 的哈佛结构
  从前面测试的coremark的数据就可以看出，哈佛结构对性能影响很大，这样的话，spi cache和sdr ram的2倍不到的性能会继续缩小
  | NXP K64f | Cortex-M4 120M | ARM Compiler 5.06 update 1 -O3 -Otime | EFLASH | 283.889283 | 2.366 |
   | NXP K64f | Cortex-M4 120M | ARM Compiler 5.06 update 1 -O3 -Otime | RAM | 218.658892 | 1.822 |
+ X2的MSS（存储子系统架构）会更容易碰到sd ram的读写切换情况
  X2的MSS支持如下特性：
  指令预取，会最多预取4个fetch line， 每个fetch line是128bit
  cache miss是非阻塞的， ICACHE 和 DCACHE都可以发出多个outstanding的请求
  考虑这种特性的话， sdr ram的优势会进一步降低， 有可能比spi nor还慢
**** 可以把性能要求较高的部分放到sram中来充分利用DSP的性能
相对于sd ram， 片内做一定量的sram， 在有特别的性能需求的时候， 可以跑程序和数据放在sram上跑，
sram 的性能会显著的比sdr ram好很多

** mail
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791BFF@srv-mail-02.actions.com.cn][RE: 关于“耳朵”SOC IC的立项准备工作]]
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791CCA@srv-mail-02.actions.com.cn][RE: CEVA X2评估]]
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791D19@srv-mail-02.actions.com.cn][耳朵SOC的DSP选型评估]]
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791D13@srv-mail-02.actions.com.cn][转发: TL420&TL421&X2的信息]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906329E0E@srv-mail-02.actions.com.cn][X2 license]]
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791CEC@srv-mail-02.actions.com.cn][FW: TL420&TL421&X2的信息]]
** doc
*** CEVA X2
**** CEVA-X2 Block Diagram
***** Program Control Unit
The Program Control Unit (PCU) is divided into three sub-units: the Dispatcher, the Interrupt handler, and the Program Sequencer.
The Dispatcher aligns the instructions from the program memory and dispatches them to the different units. It includes an instruction queue and manages 16-bit and 32-bit instruction alignment.
The interrupt handler handles incoming interrupts, and changes the program counter accordingly.
The Program Sequencer ensures proper program flow, whether sequential or non-sequential. It manages the Program Counter (PC) and has various mechanisms for different types of noncontinuous instructions:
• Branch Mechanism: Manages all branches, subroutine calls, and subroutine return operations
• Branch Target Buffer (BTB): Minimizes the penalty for change of flow execution
• Branch Prediction Mechanism: Predicts the target address to minimize the penalty
of branches and changes of flow
• Exception Handling: Manages all software/hardware interrupts and resets acceptance
***** Scalar Processing Unit
The Scalar Processing Unit (SPU) handles all of the scalar computations and bit- manipulation operations, and provides efficient OOB C-compiler support for both control and DSP-oriented operations. The SPU consists of two separate computational sub-units named SPUx. The sub-units are independent and can execute instructions in parallel to other sub-units
***** Load and Store Unit
The Load and Store Unit (LSU) is responsible for all data memory accesses. The unit is divided into two sub-units, the LS0 and LS1, which are capable of loading and storing from/ to the data memory using various addressing modes.
The LSU supports a load bandwidth of up to 128 bits per cycle and, in parallel, supports a store bandwidth of up to 128 bits per cycle
The LSU generates two independent 32-bit addresses in each cycle, according to the following addressing modes:
• Indirect addressing, including post-modification
• Indexed, using a base register and an immediate value or a pointer, including post-modification
• Direct, fully embedded in the instruction (long direct)
• Stack, using a Stack Pointer (SP) register for pushing and popping to/from the software stack
**** Memory Subsystem
The CEVA-X2 Memory Subsystem (MSS) is an extended system that can be easily adapted for full SoC integration. The MSS consists of the following:
• Program Memory Subsystem (PMSS): Contains an optional L1 program memory and four-way cache
• Data Memory Subsystem (DMSS): Contains L1 data memory and an optional cache

While the core accesses the L1 memories and cache with no wait-states, accessing the
external memories may require several wait-states.

The CEVA-X2 supports up to 4 GB of memory space, and has up to eight separate physical interfaces (up to seven for data memory and one for program memory). This enables the core to simultaneously access both the program and data memories in parallel with Tightly Coupled Extensions (TCE). The MSS provides the core with simultaneous accesses to one instruction fetch stream and one data fetch stream. The PCU accesses the program memory, and the LSU accesses the data memory.

The MSS contains standard interfaces for connecting the core to external devices and/or peripherals. These interfaces include three AXI master ports for data and one AXI master port for program, four optional AXI slave ports for external masters, a hardware accelerator connection to the data memory, and an APB3 port. All of the ports are fully compliant with Advanced Microcontroller Bus Architecture (AMBA).

The CEVA-X2 supports 4 GB of data memory space and 4 GB of program memory space. Up to two 32-bit data addresses can be issued in every cycle to the data memory, as well as a single 32-bit program address to the program memory.

Program memory access is always aligned as a single 128-bit line (fetch-line). The fetch-line is fetched only when it is required by the PCU. Because the Dispatcher in the PCU is responsible for aligning them, instructions within the program memory are not aligned.

The CEVA-X2 DMSS uses Data DMA (DDMA) to transfer data between the local memory and an external memory, without interfering with core execution. In addition, the DMSS implements a special DMA Queue manager (QMAN) mechanism that enables the user to activate the DDMA without core intervention and without having to use real-time software.
**** Register File
The CEVA-X2 contains a General Register File (GRF) that consists of 32 32-bit registers. The registers are referred to as r0 through 63

The Predicate Register File (PRF) consists of the scalar predicate registers, which are used for scalar operations and load/store operations. Each predicate can be used as a multiple predicate for SIMD load/store and for SIMD operations to conditionally mask individual SIMD operations.
The CEVA-X2 includes 15 dual scalar predicate registers marked as prX.b(2). Each predicate register is a dual bit, and can be used for conditional execution of instructions.

The Address Register File (ARF) consists of a stack pointer, modulo registers, and step registers

The System Register File (SRF) consists of registers that control the program execution (for example, of the Program Counter (PC)) and return registers from subroutines and interrupts (retreg, retregi, and retregn). These registers are primarily used by the PCU.
**** Scalar Processing Unit
The Scalar Processing Unit (SPU) consists of two independent units named SPUx. The functional units perform independent operations in parallel, each according to the specific instruction within the instruction packet.
Each SPU instruction within the instruction packet can be independently conditional, based on one of 15 predicate registers. For single instruction multiple data (SIMD) type instructions, each operation can be masked separately (for more details, see Section 4.4).
The SPUs incorporate three execution stages. As a result, various instructions take a different number of cycles to execute. The number of stages an instruction requires for execution determines the cycle penalty before the result can be used by another instruction.
**** Load and Store Unit
The Load and Store Unit (LSU) does the following:
• Generates the address for the data
• Performs the data memory load and store operations
• Unpacks and packs the loaded and stored data
• Writes/reads it to/from the internal registers of the processor
The LSU includes two load and store units named LS0 and LS1. LS0 is used for loading data from the memory, and LS1 is used for storing data into the memory.
The LS0 and LS1 units support the following main mechanisms:
• Linear address generation of a 32-bit address according to one of the addressing modes. The address points to a byte location in the data memory space.
• Read bandwidth is 128 and write bandwidth is 128 bits for the SPU, LSU, and PCU units. This enables both the LS0 and LS1 to read and write their maximum bandwidth with byte alignment.
• Two types of address register modifications are available: linear modification and modulo modification. Each LSU can modify the general registers or the stack pointer.

The LS0 and LS1 units are connected to a common General Register File (GRF). The GRF contains 32-bit registers, general registers, step registers, and a stack-pointer register.

The LSU includes three mode registers that control the behavior of the post-modification and address-generation mechanisms.
All of the LSU instructions can be conditional using one of the predicate registers. The SPU contains dedicated instructions that can affect the predicate registers. In addition, dual short (S2) type load and store instructions can be predicated using the dual predicates to mask the load and store operations. This enables the LSU to load and store only part of the dual short according to the dual predicates.
**** Memory Accesses
***** Unaligned Memory Access
Unaligned data memory access is fully supported by the hardware without any core stall cycles. The ability to support aligned and unaligned accesses without penalty can have the advantage of fewer instructions, which leads to increased core performance and reduced code size.
***** LSU Operations
The LSU can manipulate the loaded and stored data types. In load operations, the LSU can read one data element from memory, change the element type, and then write it to the processor register. In store operations, the LSU can read the data element from the processor register, change the element type, and then store it to memory.
***** Read-after-Write Sequence
The write buffer adds latency to the write transactions; however, it must be transparent to the core read transactions. An address-match mechanism enables stalling the core reading data that is not yet written to memory.
**** Program Control Unit
***** Introduction
The Program Control Unit (PCU) handles the program memory interface, the alignment of instruction packets from the program memory, the dispatching of instructions to the various functional units, and the execution flow of instruction packets in the core.
Dedicated mechanisms in the PCU support both sequential and non-sequential instruction flows. The latter occurs due to branches and interrupts.
***** Instruction Dispatcher
The encoding scheme of the core is VLIW. This implies that an instruction packet is comprised of one or several instructions, where each instruction is associated with one of the core’s functional units. Each instruction occupies one slot in the instruction packet.
The instruction dispatcher identifies the instructions that form the instruction packet, and then issues each instruction to the functional unit(s) with which it is associated.
****** Alignment Unit
The Alignment unit identifies the instruction packet, and then loads it to the instruction register.
The instruction packet opcodes that are fetched from the program memory are stored in a temporary buffer, called the instruction queue
During sequential operations, the Alignment unit selects a group of 32 bits from the queue. The number of double-words (DWs) selected is determined by the fetch-line width, which is either four or eight DWs.
****** Dispatch Unit
The Dispatch unit issues all of the instructions that have to be executed in the current cycle (that is, the instruction packet) to the appropriate functional units. Immediate extension indications are also issued to the functional units by the Dispatch unit.
The input to the Dispatch unit is the instruction register, which is loaded by the alignment unit.
***** Program Sequencer
The Program Sequencer controls the fetching of instruction packets from the program memory, as well as all of the aspects of sequential and non-sequential instruction flows in the core.
The following elements form the Program Sequencer:
• Instruction Fetch Unit (IFU)
• Instruction decoder (for PCU instructions)
• Branch mechanism
• Branch target buffer mechanism (BTB)
• Interrupt handler
****** Instruction Fetch Unit
During each instruction fetch, four or eight consecutive DWs (core-type dependent) are fetched from the program memory: the DW at the current address, and seven (three) additional DWs from the addresses that immediately follow. The set of fetched DWs is called a fetch-line and its width is 128/256 bits.
The first address of the fetch-line must be a multiple of the fetch width. Instruction packet addresses can point to any word address within the fetch-line. Because the shortest instruction packet can be a word (two bytes), byte-address resolution is not needed for program memory addressing, which means that the LSB of the instruction packet address is always cleared.
******* Sequential Fetch Mechanism
Sequential fetching of instruction packets is performed when the core executes a sequential block of instruction packets.
During sequential operation, successive fetch-lines are read from memory. Each fetch-line contains one or more instruction packets.Because the number of instructions that are executed in parallel constantly varies, instruction packets are often fetched several cycles in advance (that is, ahead of the cycle during which they are needed).
A set of four registers, called the queue, is implemented in the program sequencer. Each fetched line is loaded to one of the queue’s registers, which provides temporary storage for instruction packets that are fetched in advance of their execution. The width of the queue registers is identical to the width of the fetch-line

Program memory fetches are not initiated every cycle. The fetch mechanism determines when to issue a program memory fetch, depending on the state of the queue.
The sequential fetch mechanism ensures correct and continuous program flow, and prevents overflow in the queue. In every cycle, this mechanism decides whether to issue a new fetch. The decision is based on the following information:
• The status of the queue (the number of valid words in the queue).
• The number of words that the current instruction packet consumes.
• The currently active fetches (because a fetch operation takes two cycles, the mechanism keeps track of fetches that were initiated in the two preceding cycles).
******* Non-SequentialFetchMechanism
A non-sequential instruction flow is an event in which the normal sequential flow of instruction packets is suspended, and an instruction packet from a different address is fetched. The non-sequential fetch mechanism generates all of the non-sequential addresses.
****** Program Sequencer Register Access
The set of directly accessible Program Sequencer registers is referred to as the Sequencer Register File (SRF).
****** Branch Mechanism
The target address of a branch-type instruction can be specified in the following ways:
• An absolute address encoded within the instruction opcode
• A relative offset (relative to the address of the branch instruction), encoded within the instruction opcode
• An absolute address specified within a GRF register
• An absolute address specified within one of the return registers

All of these instructions are multi-cycle. These instructions take several cycles to execute for the following reasons:
• Fetching the opcode of the instruction packet at the target address takes two cycles.
• The status of the condition (predicate register) is known only at a late pipeline stage.
To minimize the cycle penalty of these instructions, the following dedicated mechanisms are implemented in the PCU:
• Delay slots
• Branch prediction mechanisms: either using a Branch Target Buffer (BTB),
******* Delay Slots in Branch Instructions
The programmer can use up to four instruction packets in delay slots in most branch instructions.
The instruction packets in the delay slots must be composed of single-cycle instructions that do not break the pipeline. In addition, instruction packets in delay slots are non-interruptible.
******* Branch Target Buffer(BTB)
he BTB mechanism calculates the target address based on the current address. Its operation is done before any information is extracted from the instruction packet, and is based solely on the current fetch address and the past behavior of this fetched address. The BTB size is configurable for 128 or 256 entries.
******* Static Branch Prediction Support
If the taken/not-taken switch in the syntax is omitted, the default behavior for the branch instructions that are subjected to branch prediction is:
• Not-taken when the instruction is predicated
• Taken when no predicate is used

Determining whether a certain branch is mostly taken or not-taken is generally not as straightforward as in this example. To efficiently determine the best prediction switch for every branch, a profiler utility can be run on the code, and the selection of the prediction switches can be based on these statistics.

Correct prediction can reduce the cycle count of the branch by two cycles, and incorrect prediction can increase it by two cycles.
******* Call and Return Instructions
During the execution of a call instruction, the return address is written to an internal register, which is called retreg (return register). When a return instruction is executed, the return address is taken from the retreg register.
******* Target Instruction Packet Alignment
The target of a branch instruction can be located anywhere within a fetch-line, and instruction packets can cross fetch-line boundaries. If the instruction packet at the target of the branch crosses a fetch-line boundary, two lines must be fetched before execution of the instruction packet can begin.

The additional single-cycle penalty can be avoided by aligning instruction packets to the fetch-line boundaries that are targets of branch instructions and originally cross a fetch-line boundary. This can be done by padding the instruction packet preceding the target instruction packet with parallel nop instructions,
******* Exception Handling
The core supports the following interrupts:
• Six hardware maskable interrupts (INT0, INT1, INT2, INT3, INT4, and VINT)
• Four software maskable interrupts (trap{t0}, trap{t1}, trap{t2}, and trap{t3})
• One non-maskable interrupt (NMI)
• One non-maskable software interrupt (trap)
• One emulation software interrupt (trape)
• Two hardware breakpoint interrupts (BI and PABP)
******** Interrupt Latency and Non-Interruptible States
Latency of the NMI, INT0, INT1, INT2, INT3, INT4, VINT and BI interrupts is two cycles, assuming that the core is in an interruptible state. The interrupt latency is calculated as the number of cycles between the assertion of the interrupt request and activation of the appropriate interrupt acknowledge signal.

The penalty for the hardware interrupts (NMI, INT0, INT1, INT2, INT3, INT4, VINT, and BI) is five cycles, assuming that the processor is in an interruptible state. The interrupt penalty is calculated as the number of cycles in which the core does not execute any instructions.
**** Pipeline
The following is a description of the common stages:
• IF: Instruction Fetch, which is divided into two sub-stages: IF1 and IF2
• D: Dispatch/Decode, which is divided into two sub-stages: D1 and D2
• A: Address Generation, one stage
• M: Memory Access, one stage
• E: Scalar Execution, which is divided into four sub-stages: E1, E2, E3, and E4
***** Instruction Fetch Stages
Instruction fetch execution operates over two stages, IF1 and IF2:
• IF1: During this stage, the program address is issued by the PCU. The program address is decoded by the MSS and a memory read is initiated.
• IF2: This stage is dedicated for program memory access. The fetch-line is registered in the instruction queue at the end of this stage. The size of the fetch-line is either 128 bits or 256 bits.
***** Dispatch/Decode Stages
Dispatch/decode execution operates over two stages, D1 and D2:
• D1: The core selects a packet of 16, 32, 48, or 64 bits from the queue. This packet contains the instruction packet that is either the next instruction or a group of instructions that should be executed in parallel. At the end of this stage, the instruction packet register is loaded with the instruction packet.
• D2: In this stage, each instruction within the instruction packet register is dispatched to the appropriate unit in the core.
***** Address Generation Stages
Address generation execution operates over two stages, A and M:
• A: The core reads the relevant registers and performs address and modulo calculation and read/write strobe generation. The pointer’s post-modification value is calculated.
• M: Address post-modification results are written to the register file and data memory is accessed. Registers are read from the register file into the SPUs.
***** Scalar Execution Stages
Scalar execution operates over four stages, E1, E2, E3, and E4:
• E1: Single-stage scalar operations are executed.
• E2: Dual-stage scalar operations (multiply) are completed.
• E3: Accumulation is performed on MAC-type operations.
• E4: Results are written to the register file.
*** MSS
**** overview
The CEVA-X1/CEVA-X2 MSS supports up to 4 GB of unified memory space for program memory (PMEM) and 4 GB for data memory (DMEM), and has up to four separate physical interfaces: up to three for data memory and one for program memory. This enables the core to simultaneously access both the program and data memories.
The MSS provides the CEVA-X1/CEVA-X2 DSP core with simultaneous accesses to one instruction fetch stream and two data fetch streams. The Load Store Unit (LSU) is responsible for accessing the data memory, and the Program Control Unit (PCU) is responsible for accessing the program memory.
The CEVA-X1/CEVA-X2 MSS can access two different types of memories: internal memories, also referred to as local memories (on-chip), and external memories (which might be located on-chip and/or off-chip). While the core accesses the internal memories with no wait-states, accessing the external memories might require several wait-states.
The CEVA-X1/CEVA-X2 MSS contains standard interfaces for connecting the core to external devices and/or peripherals. These interfaces include up to four AXI master ports (program and data), up to four AXI slave ports, and an APB3 port. All of the ports are fully compliant with the Advanced Microcontroller Bus Architecture (AMBA). The MSS also contains JTAG and APB3 interfaces for debug support.
**** Program Memory Subsystem
The PMSS supports highly predictable execution times as well as less predictable execution times. Software designers can have complete control over the location of the instructions within the PMSS; for example, time-critical code can run from either the local memory or from a locked cache-line, while less-time-critical code can run either from the cache or from the external memory directly. This enables them to benefit from both the highly predictable execution provided by a local memory, as well as the flexible software development capabilities provided by a cache.

The PMSS is connected to an external memory controller via an AMBA4 interface. The cache consists of a memory set that holds the actual cached line data, as well as a tag memory, which is used to determine whether an address is cached and whether the instruction is valid. Tightly Coupled Memory (TCM) is also supported and is accessed with zero wait-states
***** Feature List
The PMSS supports the following main features:
● 4 GB program memory linear space
● Configurable TCM memory size
● Software and hardware pre-fetch capability
● Program DMA (PDMA)
● Four-way set-associative instruction cache
● Cache software operations (invalidation, pre-fetch, lock, and unlock)
● MP_PORT_WIDTH bit-wide AXI master port
● Optional ECC; one error correction and two error detections on all RAM and cache blocks
● Non-blocking cache and fetch-line access
***** Program Memory Controller
The Program Memory Controller (PMC) is responsible for controlling access to the TCM, the cache, and the external memory from the core.
For core access, the PMC receives a program address and a read indication. The address is only applied to the set and tag memories if the address falls outside of the TCM boundary.
When no TCM address is accessed, the program fetch-line is either served to the core queue with zero latency (for a cache hit), or fetched from the external memory (for a cache miss or non-cacheable region).
In any core access to a non-TCM address space, the PMC checks the cacheable attribute of the corresponding IACU region. When the address is mapped to a cacheable region, the tag data of each way is compared with the requested address, and the result (combined with the valid state) is used to determine a hit/miss. When the address is mapped to a non-cacheable region, the PMC sends the request to the EPP.
***** Internal Program Memory
The internal program memory contains the program fetch-lines that are read whenever a fetch-line is requested by the core. The PMSS consists of a TCM and an instruction cache. Both the TCM and the instruction cache (on a hit) are accessed with zero wait-states.
***** L1 Instruction Cache
● Optional four-way set-associative cache
● Zero-cycle stall on a hit
● Hardware-configurable size
● Pseudo-LRU replacement policy
● Hardware pre-fetch
● Miss pipeline support
● Non-blocking read support
****** Handling Cache Misses
******* Read Misses
L1IC read misses initiated by the core (as well as pre-fetches) are handled by requesting a cache-line fill from the external memory. A cache-line fill is requested from the EPP, and then the returned cache-line is written to the way specified by the L1IC replacement algorithm (the victim way).
If the request was initiated by the core and each cache-line contains two core fetch-lines, the requested fetch-line is requested first using a WRAP transaction from the AXI and served to the core directly and to the cache.
If the request was to abort, the cache-line request is aborted if the AXI transaction was not yet initiated, or it is written only to the cache if it was already sent to the AXI.
******* Non-Blocking Read Miss
To serve the core with the requested data as soon as it is available, the cache- line fills requests from the EPP using a WRAP burst request, where the core-requested fetch-line arrives first and is served to the core, while the rest of the cache-lines arrive on the following beats into the cache without interfering with the core. When the cache-line request was initiated by a software operation, the cache-line fill still uses a WRAP burst request that is started from the beginning of the cache-line.
******* Program Direct Memory Access
The Program Memory Controller includes a direct memory access unit (PDMA) that performs downloads from the external memory to internal program memory.
***** External Program Port
The external memory is accessed in the following cases:
● A cache miss occurs. The PMC requests a cache-line (using a four-beat WRAP burst) from the external port.
● The core requests an instruction from an address that is outside of the TCM range, and the requested address is to a non-cacheable region (or the cache is disabled) using a two-beat WRAP burst.
● The PDMA download reads from external memory and writes to the internal memory.
● When the OCEM accesses the EPP for a read or write, the OCEM uses a one-beat burst for write accesses and a two-beat burst for read accesses.
**** Data Memory Subsystem
****** Overview
The Data Memory Subsystem (DMSS) provides data from either the local memory or the external memory to the CEVA-X1/CEVA-X2 core.
The DMSS is both hardware- and software-configurable, which enables hardware and software designers to have complete control over its structure, functionality, and performance. End users have control over the availability of different components (such as the number of AMBA ports and the size of the local RAMs).
The DMSS supports highly predictable execution times by placing data in the local memory. Software designers can have complete control over the location of the data within the DMSS; for example, time-critical data can run from the local memory, while less-time-critical data can run from the external memory.
The DMSS is designed to achieve a balance between high performance, small area, and low power consumption, which enables it to be used in a wide variety of systems and applications.
The DMSS is subdivided into the IDM and the external memory:
● The IDM, which is part of the MSS, contains a relatively small amount of memory, and is also referred to as the local memory.
● The external memory can be located on-chip and/or off-chip, and is accessed via one of the AXIm0/AXIm1 master ports or the External Data Port (EDP).
The CEVA-X1/CEVA-X2 core can issue a load and store operation simultaneously:
● The L (load) unit connects to the DMSS using an LD_WIDTH-bit read bus.
● The S (store) unit connects to the DMSS using an ST_WIDTH-bit write bus.
The SPU accesses the data memory without any alignment restriction.
****** feature list
******* Non-Blocking Write Support
The L1 cache supports non-blocking writes. This means that, after a write miss, the core is not stopped and the cache-line fill process is continued in parallel with the core normal operation.
******* Non-Blocking Read Support
The L1 cache supports non-blocking reads. This means that, after a read miss, the cache-line fill request starts from the core-requested address (using a WRAP request) and will serve it to the core.
This prevents the core from halting while the rest of the data is written to the cache-line. The cache-line fill process is continued in parallel with the core’s normal operation.
****** Internal Data Memory
Because multiple sources can access the IDM simultaneously, it is divided into either two or four blocks to reduce the possibility of conflicts between the various accesses. Two or four blocks are selected during IP installation. If a block and/or bank conflict occurs, a wait cycle is inserted to the non-granted source(s).
The IDM can be configured as follows:
● 512 KB, 256 KB, 128 KB or 64 KB memory size configuration.
● Two or four block memory structure (the various units can transfer data located in various blocks without conflicts).
● Total block memory width is 2 x LD_WIDTH bits.
● Each block is composed of N= LD_WIDTH/16 memory banks. The addresses are interleaved over the banks within each block, in the same row boundaries.
● Each bank is 32 bits wide (4-byte write enabled).
****** Data Write Buffer
The CEVA-X1/CEVA-X2 core issues the address and controls (that is, read/write and size) in the M stage of the pipeline. The data in write transactions is available in the E3 stage, three cycles later. An address delay mechanism is implemented to ensure the proper functionality of the memory during write transactions.
An address delay is used to synchronize the data with its respective address. When ready, the address (along with the data and transaction attributes) is pushed into one of the queue buffers that administer the pending write transactions. The WB queue reduces core wait cycles that can occur as a result of memory bank conflicts.
The WB unit is divided into the following functional blocks:
● LS address delay line
● One queue
● LS read-after-write and strong ordering (RAW/SO) match blocks

The WB queue has two entries, each containing a single element that is comprised of a 32-bit address, ST_WIDTH-bit data, and attributes. The queue has one input port and two output ports (WBA, WBB). All writes to an IDM memory bank, as well as all writes to the external memory, are written in the order they occur in the core, but later IDM writes can be written before earlier writes to the external memory if the external port is not available.
****** L1 Data Cache
The L1 Data Cache (L1DC) is responsible for servicing data accesses from the core for L1DC-cacheable data. The main L1DC features are:
● Optional two/four-way set-associative cache
● Zero-cycle stall for way hit
● Write-Through and Copy-Back write policy
● Hardware-configurable size and structure
● Pseudo-LRU victim way selection
● Software pre-fetch, invalidate, flush, lock, and unlock of cache entries
● Hardware pre-fetch
● Miss pipelining support
● Non-blocking read and write support
● Cross tags unaligned support
******* Non-Blocking Cache
L1DC read and write accesses are non-blocking cache accesses, which means that the core is only stopped when the MSS cannot accept data from the core or cannot provide the core with the requested data. It is not stopped when the L1DC is busy with internal operations (for example, cache-line fill or software operations).
****** Queue and Buffer Managers
The CEVA-X1/CEVA-X2 data memory subsystem (DMSS) implements a special DMA manager (DMAN) that enables users to activate the DDMA without using real-time software.
The DMAN is composed of two main components:
● Queue Manager (QMAN): Manages queues of DMA tasks by selecting the next task to be executed by the DDMA.
For more details, see Section 3.14.1.
● Buffer Manager (BMAN): Implements FIFO-based memory management by sending source and/or destination buffer status indications to the QMAN.
**** Memory Subsystem Programming Model

*** Tensilica
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791ED1@srv-mail-02.actions.com.cn][转发:Tensilica DSP的资料]]
*** 3605D
**** 开发
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F1035B7155@srv-mail-02.actions.com.cn][答复: GS700E 拉一个开发分支同步LS370A(GL5202E)]]
**** 规格
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A902BF@srv-mail-02.actions.com.cn][LS360F MRD]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749063297F5@srv-mail-02.actions.com.cn][转发: 发送电子邮件: US282A ASET工具调音说明_V2.2_20170331.pdf, ASET在线调试工具usb通信协议.doc]]

**** 火百灵
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311027918C2@srv-mail-02.actions.com.cn][火百灵方案的规格]]
***** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0514426C@srv-mail-02.actions.com.cn][火百灵&PVo的KT案子深圳会议]]
***** TODO [[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791BE3@srv-mail-02.actions.com.cn][RE: ATS3605 EVB对接CX20810的驱动调试]]
***** TODO [[mu4e:msgid:tencent_15169A6E2DED8EBA56372239@qq.com][回复：答复: 回复：答复:  ATS3605软件需求总结]]
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791B13@srv-mail-02.actions.com.cn][转发: 火百灵方案的规格]]
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791B12@srv-mail-02.actions.com.cn][转发: AP6356S datasheet_V1.1_03182015(1).pdf]]

**** alsalib
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10353B84F@srv-mail-02.actions.com.cn][alsalib使用文档]]
**** TODO 64M 内存确认
**** 架构评估
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C3EB@srv-mail-02.actions.com.cn][LS3605D_方案架构评估报告]]
**** 播放器
https://en.wikipedia.org/wiki/Media_player_(software)
***** VLC
https://en.wikipedia.org/wiki/VLC_media_player
https://wiki.videolan.org/LibVLC
https://wiki.videolan.org/VLC_media_player/
***** MPlayer
https://en.wikipedia.org/wiki/MPlayer
****** MPlayer can play many formats, including:[9]
Physical media: CDs, DVDs, Video CDs, Blu-ray discs
Container formats: 3GP, AVI, ASF, FLV, Matroska, MOV (QuickTime), MP4, NUT, Ogg, OGM, RealMedia, Bink
****** Video formats:
Cinepak, DV, H.263, H.264/MPEG-4 AVC, HuffYUV, Indeo, MJPEG, MPEG-1, MPEG-2, MPEG-4 Part 2, RealVideo, Sorenson, Theora, WMV, Bink
****** Audio formats:
AAC, AC3, ALAC, AMR, DTS, FLAC, Intel Music Coder, Monkey's Audio, MP3, Musepack, RealAudio, Shorten, Speex, Vorbis, WMA, Bink
****** Subtitle formats:
AQTitle, ASS/SSA, CC, JACOsub, MicroDVD, MPsub, OGM, PJS, RT, Sami, SRT, SubViewer, VOBsub, VPlayer
****** Image formats:
BMP, JPEG, MNG, PCX, PTX, TGA, TIFF, SGI, Sun Raster
****** Protocols:
RTP, RTSP, HTTP, FTP, MMS, Netstream (mpst://), SMB, ffmpeg:// (Uses FFmpeg's protocol implementations)
****** output driver
MPlayer can also use a variety of output driver protocols to display video,
including VDPAU, the X video extension, OpenGL, DirectX, Direct3D, Quartz Compositor, VESA, Framebuffer, SDL and rarer ones such as ASCII art (using AAlib and libcaca) and Blinkenlights. It can also be used to display TV from a TV card using the device tv://channel, or play and capture radio channels via radio://channel|frequency.
****** Interface and graphical front-ends
Gnome-MPlayer v1.0.9 on GNOME with the "Adwaita" Dark theme
Like GStreamer, MPlayer is a command-line application and there are a couple of front-ends available, which use GUI widgets of GTK+, Qt or some other widget library. When not using these front-ends, mplayer can still display video in a window (with no visible controls on it), and is controlled using a keyboard.
GTK+-based are gmplayer (official[10][11]) and Gnome-MPlayer
Qt-based are SMPlayer and KMPlayer, among others.
Cocoa-based are MPlayer OS X Extended and MPlayerX[12]
***** GStreamer
https://en.wikipedia.org/wiki/GStreamer
****** Video acceleration
Through special plugins provided by Texas Instruments, GStreamer makes use of hardware acceleration provided by e.g. Texas Instruments DaVinci.
There are various SIP blocks that can do the computations to decode certain video codecs, such as PureVideo, UVD, QuickSync Video, TI Ducati and more. Such needs to be supported by the device driver, which in turn provides one or multiple interfaces, like VDPAU, VAAPI, Distributed Codec Engine or DXVA to end-user software like MPlayer to access this hardware and offload computation to it.

It is possible to use Video Coding Engine with GStreamer through the OpenMAX IL wrapper plugin gst-omx.[17] This is for example possible on the Raspberry Pi.[18]
The SIP core present on some Texas Instruments SoCs is also accessible through GStreamer: gst-dmai, gst-openmax, gst-dsp.[19]
VDPAU and VAAPI are supported with GNOME Videos >= 2.28.0 and GStreamer >= 0.10.26 since 2010[20]
******* VDPAU
Video Decode and Presentation API for Unix (VDPAU) is a royalty-free application programming interface (API) as well as its implementation as free and open-source library (libvdpau) distributed under the MIT License.[1]

The VDPAU interface is to be implemented by device drivers, such as Nvidia GeForce driver, nouveau, amdgpu, to offer end-user software, such as VLC media player or GStreamer, a standardized access to available video decompression acceleration hardware in the form of application-specific integrated circuit blocks on graphics processing units (GPU), such as Nvidia PureVideo or Unified Video Decoder and make use of it.
******* VAAPI
Video Acceleration API (VA API) is a royalty-free API as well as its implementation as free and open-source library (libVA) distributed under the MIT License.

The VA API interface is to be implemented by device drivers to offer end-user software, such as VLC media player or GStreamer, access to available video acceleration hardware, such as PureVideo (through the libva-vdpau driver, which implements VA API in terms of VDPAU) or Unified Video Decoder.

The API enables and provides access to hardware-accelerated video processing, using hardware such as graphics processing units (GPU) to accelerate video encoding and decoding by offloading processing from the central processing unit (CPU).
****** Media formats
The Good, Bad and Ugly GStreamer plugins mentioned earlier provide, alongside processing elements/filters of all kinds, support for a wide variety of file formats, protocols and multimedia codecs.

In addition to those, support for more than a hundred compression formats (including MPEG-1, MPEG-2, MPEG-4, H.261, H.263, H.264, RealVideo, MP3, WMV, FLV, etc.[22][23]) is transparently provided through the GStreamer FFmpeg/libav plug-in. See the Libav and FFmpeg pages for a complete list of media formats provided by these plug-ins.

***** OpenMAX
https://en.wikipedia.org/wiki/OpenMAX#Integration_layer
****** OpenMAX AL
https://www.khronos.org/openmax/al/
******* profile
******** DATA ACCESS
Playback of audio and video files Y
Rendering of image sources Y
Recording and storage of audio and video sources Y
Capture and storage of image sources Y
Support for various media container formats Y
Specify a stream source (local/remote file, memory/flash, etc.) Y
Identify data sources by name, such as URL/URI, or by file handle Y
Respect DRM Y
Select an input source from among a multitude of available inputs Y
Select an output destination from among a multitude of available outputs
******** DEVICE CAMERA
Camera flash activation Y
Camera Effects Y
Exposure settings (exposure time, aperture and ISO sensitivity) Y
Focus control (including macro-focus on/off) Y
White balance control Y
Optical and digital zoom
******** PLAYBACK, RECORDING AND PROCESSING CONTROLS
“VCR-type” playback modes: play, pause, stop, rewind, fast-forward Y
Play multiple sounds at a given time Y
Playback of raw PCM audio Y
Playback of sampled audio encoded in a form other than raw PCM
Playback of mono and stereo sampled audio Y
Volume control Y
Audio balance control Y
Audio pan control Y
End-to-end looping of audio/video content Y
Audio/video segment looping Y
Seeking to a seek point (such as chapter) Y
Route media to multiple simultaneous outputs Y
Set a sound’s priority Y
Audio equalization Y
Audio recording from a microphone or on-device line-in jack Y
Audio recording from another software component Y
Record audio to a non-PCM format Y
Recording modes: record and stop Y
Query the estimated size of the output image based on current image settings
******** PER-APPLICATION SETTINGS
Use key-value pairs to query and set both the codec and non-codec configurations of the underlying media engine
******** PER-OBJECT SETTINGS
Set video encoder properties: frame rate, bitrate (constant/variable), size, resolution, duration limit and codec format
Set audio encoder properties: bitrate (constant/variable), channel count, duration limit, sampling frequency, codec format, size, and resolution
Set image encoder properties: codec format, size and resolution
Set and query image/video encoder special effects, if supported. Effects include, but are
not limited to, “monochrome”, “sepia”, “emboss”, “paintbrush”, “solarize”, “red-eye Y reduction”, “cartoon” and “negative”
******** METADATA
Extract metadata from media files and embedded media streams
Insert/edit metadata in recorded media content
******** EVENT AND ERROR NOTIFICATIONS
Callbacks for periodic media positioning (such as for progress bar) Y
Callback alerts when playback is in a prescribed position (such as for looping) Y
Callbacks for error conditions
******** CAPABILITY QUERIES
Enumerate and query the capabilities of available input sources
Enumerate and query the capabilities of available output destinations
Query the API version number
Query capabilities of the OpenMAX AL implementation
******** MISCELLANEOUS
Query the degree to which an OpenMAX AL implementation is based on OpenMAX IL: none, partial or full
Extensibility
Minimum 16-bit PCM audio output
******** To create an object process:
• Create and realize an engine object if one has not been created already.
• Obtain the XAEngineItf interface from this object.
• Call the appropriate object creation method of this interface.
• If the call succeeds, the method will return an XAObjectItf interface of the new object.
• After working with the object, call the Destroy() method of the XAObjectItf to free the object and
its resources.
******** The Relationship Between Objects and Interfaces
The set of interfaces exposed by an object is determined by three factors:
• The object’s type
• The interfaces requested by the application during the object’s creation
• The interfaces added and removed by the application during the object’s lifetime
******* Object Overview
OpenMAX AL represents entities in its architecture as objects, including:
• Engine Object
• Media Objects
• Metadata Extractor Object
• Audio Output Mix Objects
• Camera Objects
• LED Array Objects
• Radio Objects
• Vibration Control Objects
******** Engine Object
The engine object is the entry point to the OpenMAX AL API. This object enables you to create all the other objects used in OpenMAX AL.
The engine object is special in the sense that it is created using a global function, xaCreateEngine
The engine object represents the system’s various multimedia-related devices via unique device IDs. It supports the enumeration of audio input, audio output, camera, radio, LED and vibrator devices as well as mechanisms to query their capabilities.
******** Media Objects
A media object implements a multimedia use case by performing some media processing task given a prescribed set of inputs and outputs. Media objects include (but are not limited to) objects that present and capture media streams, often referred to as players and recorders, respectively. They operate on audio, video, and image data or some combination of them.
The following characteristics define a media object:
• The operation it performs, denoted by the creation method used to instantiate the media object.
• The inputs it draws data from, denoted as its data sources and specified at media object creation.
• The outputs it sends data to, denoted as its data sinks and specified at media object creation.
******** Metadata Extractor Object
Player objects support reading of the metadata of the media content and recorder objects support writing metadata. However, sometimes it is useful just to be able to read metadata without having to be able to playback the media.
Metadata Extractor object can be used for reading metadata without allocating resources for media playback.
******** Audio Output Mix Object
The API allows for routing of audio to multiple audio outputs and includes an audio output mix object that facilitates this functionality. The application retrieves an output mix object from the engine and may specify that output mix as the sink for a media object.
******** Camera Object
Control of one of the device’s cameras is handled via the Camera object. The number of cameras supported by a device and their capabilities can be retrieved from the media engine via the XACameraCapabilitiesItf interface. A camera I/O device exposes the XACameraItf interface, which is used to control camera features such as flash, focusing, metering, exposure compensation, sensitivity, shutter speed, aperture, white balance, and zoom. The camera I/O object is connected to a media recorder media object to capture still images or video.
******** Display Regions
Conceptually OpenMAX AL maintains three separate notions relating to the visual output:
• Display: Corresponds to the entire logical screen area (or “desktop”). The display is provided by the native windowing manager in the form of a native handle. All interaction with this entity is handled exclusively via native interfaces using the native handle (not via OpenMAX AL). Multiple media objects may operate on the same display.
• Window: Corresponds to the window within the display. A window may be sized to encompass the entire display and yet it is considered an independent entity (for instance, a fullsize window may be later sized down to a region less than the entire display or have other windows on top of or behind it). The window is provided by the native windowing manager in the form of a native handle. All interaction with this entity is handled exclusively via native interfaces using the native handle (not via the OpenMAX AL). Multiple media objects may operate on the same window.
• Region: Corresponds to the area within the native window where the media object presents its output. This may include the entire window area or be some subset of the window area. The region is specific to a particular media objec
******* OpenMAX AL Use Cases
------------
******** Audio and Video Playback
------------------
[[./pic/屏幕快照 2017-05-26 下午11.33.12.png]]

****** Implementations
Android 4.0 and later exposes OpenMAX AL as part of its NDK (Native Development Kit).[15]
LIM OpenMAX is an open source implementation of OpenMAX AL and OpenMAX IL for Linux
Bellagio is an open source OpenMAX IL implementation for Linux maintained by STMicroelectronics.[16]
Tizonia is an open source OpenMAX IL implementation for Linux[17]
GStreamer (GST) is an open source multimedia framework used by several application, and it can use OpenMAX IL modules with its "gst-omx" module.[18]
C-only, optimized for NEON (Cortex A8) and SIMD (for ARM11 cores using ARMv6 architecture) optimized OpenMAX DL libraries are available at [1][19]
******* Bellagio
http://omxil.sourceforge.net

****** Comparison with OpenSL ES
OpenSL ES (Open Sound Library for Embedded Systems) is another Khronos Group API that also provides an audio library for the same target market as OpenMAX AL. OpenSL ES and OpenMAX AL share the same common architecture and have a few common features:

Audio playback and recording
Basic MIDI playback
Metadata extraction

**** qq物联
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906260A58@srv-mail-02.actions.com.cn][答复: 关于QQ物联SDK依赖库]]
**** cx20810
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791AB8@srv-mail-02.actions.com.cn][ATS3605 EVB对接CX20810的驱动调试]]
**** open WRT
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C400@srv-mail-02.actions.com.cn][openwrt_sqlite]]
***** share lib 空间优化
https://stackoverflow.com/questions/31354641/c-reduce-library-size-by-excluding-unnecessary-functions-programmatically
https://stackoverflow.com/questions/8021470/how-to-optimize-size-of-shared-library

****** elf
https://docs.oracle.com/cd/E19683-01/817-3677/6mj8mbtc9/index.html#chapter6-73709

*** as216B
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311027918A8@srv-mail-02.actions.com.cn][AS216B项目开发进展]]
AS216B项目的代码已经上传到svn代码服务器：
http://srv-fw:8080/SVN2/AS216B/trunk/AS216B
* 设计决策
** ATS3605D
*** 20170606 ATS3605D带camera的无屏方案
**** 需求
+ 按照产品规格需求， 需要能够单向显示视频，双向语音聊天。
+ 要能做到16M的nor
+ 使用64M的ddr
**** 可选方案
***** LS3703平台 + 地平线通话
+ 统计了3703的各个文件的情况
  + 裁掉不必要的视频，显示，GPU，以及各个应用。保留camera，播放框架，播放器，网络以及 uc适配框架。 此时需要的空间为11.5M大小
  + stageFright本身占用给的空间为 1.7M， 播放器依赖2M   camear 1M
  + 地平线的通话部分总共需要13M的空间（没有计算地平线的图像识别的）
  + 总共需要大概25M的空间， 使用squash fs的方式压缩率按照60%计算的话，需要15M的nor才够
+ 如果在加上微信故事机需要的功能，内核3M大小，百科问答这部分（我记得这部分有几兆大小，主要是tts库大，以及提示音什么的），16M的nor是不够放的。
***** 3703 BSP + 故事机规格 + qq物联
这个技术路线是按照nor最小的方式来做的， 如果这个也不能做到16M的话， 意义就不大，还是回到3703的平台
**** 关于平台的讨论
+ 只所以这次比较纠结的原因，就是我们没有一个足够小的， 整合了音视频，GUI显示的nor的平台，其他这个就是3605D平台规划完成的任务
+ 3703平台在使用SLC nand的时候，功能是足够强大的， 相对来说，资源使用也比较紧凑。
  在使用128M DDR的时候，可以支持播放1080P视频（参考帧11）的时候，还可以录像800*600
  支持双向视频通话
  整合同样的功能， android的实现还是相对比较紧凑的，并没有过多浪费， 使用Linux不做特别深度优化，并不会更小。
+ 开发方式上看， 3703 支持两种方式:
  android NDK的开发(地平线的功能使用的这种方式）
  UC的应用框架开发（机器人的各个应用功能使用的这种方式）
+ 初步简单估计，使用UC的音视频框架相对stagefright + openMax的音视频框架预计能够节省的的空间估计小于5M， 在nor上应该小于3M。
**** 后续3605D
+ 设计之初就考虑以16M的nor为主要考虑
+ 整合音视频， camera，GUI，和显示框架，一切以nor空间，和ram空间为主要考虑
+ 音视频框架目前比较看比较成熟的，size比较好的， 仍然是stagefright + OpenMax IL的框架
  但需要进一步优化，去除掉对android的一些底层机制的依赖， 来进一步压缩size。
  去除掉一些不必要支持的功能，
+ uc目前使用的那套框架可以作为add on的方式整合进来， uc的音视频从大小上看，应该仍是最优的，再空间非常紧张的时候，是可以作为另外一个替代使用的。
  从单纯size这个维度看，uc的音视频框架还是有较大价值的
+ uc的应用框架，GUI框架，和音视频框架需要再整合进来的时候，做一定的分割， 应该允许只使用比如音视频框架，而不使用其他部分。
+ SDK希望能够做到通过配置来使用不同的音视频底层。 可以考虑通过不同安装包的方式来add on
+ 3605D的目标至少要做到音频+camera + QQ物联不能超过16M的nor。
****  姚& 周总意见
[[mu4e:msgid:DB539A2A09F34D4B9989A23D1D3BF4FE016F5394@srv-mail-02.actions.com.cn][答复: 关于3605d 平台方案规格的一些讨论]]
有两件事情我们要尽可能杜绝

１．开发一个标案，开发完再接下一个案子的时候自己都不愿意基于上一个标案
开发了，这是一种犯罪啊。基于这样的方式做研发的公司，不死上帝都觉得不公
平啊。

２．一个开发平台也好，一个标案平台也好，随着时间的推移不能简单地是功能
越来越多，但越来越不健康，三年以后平台不是变好了而是变差了。如果有崭新
的需求来旧平台不堪重负就应该果断重构，让旧平台健康的留在原来的领域。平
台的健康很重要，不断的乱打ｐａｔｃｈ和优化应付当前的紧急任务，回头不整
理，放任自流，这样的研发结果一定不会让公司发展的好。

q
** 5118B
*** 5118B ROM独立
已经初步讨论了做法，主要由以下几点：
+ rom中的baseband代码， 目前需要的延时，关中断，以及memcpy memset等常用函数，可以通过自己实现的方式来完成， 延时不再使用cpu counter，而是保留一个timer给rom用
  初步看ROM中的代码没有依赖OS的其他系统原语
+ rom的工程需要独立于SDK编译， 与SDK的直接的接口通过提供独立的符号表
+ ROM中使用的RAM，需要集中到一起，定位到整个RAM空间的开始，或者末尾，不要把RAM空间割裂，这样会便于开发和LInk的处理。
+ nor上的baseband代码和ROM中的baseband代码直接是通过一个函数表来交互的， nor上的部分，有依赖os相关以及SDK部分相关的接口， 不同的OS需要适配这部分
+ rom中的代码的patch机制是通过固定的函数表来实现的， 这个不同的os都比较容易支持
+ rom中需要的malloc接口，由于是在中断中调用的，同时还不清楚最高使用的内存大小，这个接口的实现建议在sdk中实现
+ ROM代码调整后，需要在zephyr和gl5118 sdk中都需要验证， 前者可以使用ic来验证，后者需要使用fpga验证，并且需要送测
+ 时间上， zephyr这边先开始，预计2周时间可以提供rom版本，之后就可以两边并行修改和验证
* 支持工作
** v700
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B530E9@srv-mail-02.actions.com.cn][答复: V700分体机闪屏抖屏问题]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749062609E9@srv-mail-02.actions.com.cn][答复: 【V700】小辣椒-视频播放问题]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD062031C81@srv-mail-02.actions.com.cn][答复: 雅士V700生产问题汇总]]
[[mu4e:msgid:1215223C59CBD54AA38F93133AF342D503DF5EE0@srv-mail-02.actions.com.cn][答复: V700: 屏幕同比缩放显示]]
** S900
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061654A7@srv-mail-02.actions.com.cn][答复: 深圳图麟科技计划采用贵公司S900系列芯片，请给予必要的技术支持]]
*** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0514420A@srv-mail-02.actions.com.cn][VR unity行业apk咨询]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEB692@srv-mail-02.actions.com.cn][答复: S900配置PMU SGPIO端口]]
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B051446FE@srv-mail-02.actions.com.cn][答复: S900电量计相关问题讨论]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52C78@srv-mail-02.actions.com.cn][答复: S900电量计相关问题讨论]]
*** TODO [[mu4e:msgid:0E3AB831E505F842818BA4F9798C30A4016F275B@srv-mail-02.actions.com.cn][答复: 答复: 答复: 答复: OpenMaxIL]]
** S700
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52AF4@srv-mail-02.actions.com.cn][答复: 【CB7】【CVBS】兼容性问题]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52AAD@srv-mail-02.actions.com.cn][答复: 【瑞泰】【S700】【CVBS】客户添加cvbs导致gpu异常，系统卡死在android动画]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEB59A@srv-mail-02.actions.com.cn][S700 gpu&core调频调压修改]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52D9B@srv-mail-02.actions.com.cn][S700 cb6 开机进入桌面插入耳机点击触摸屏有噪音]]
*** TODO [[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52A47@srv-mail-02.actions.com.cn][【瑞泰】【S700】【显示】 S700平台cvbsout功能需求]]
*** TODO [[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEB3ED@srv-mail-02.actions.com.cn][答复: 答复: 【众联科技】【S700】【WIFI】Miracast sink不稳定问题]]
**** TODO [[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52B3E@srv-mail-02.actions.com.cn][答复: s700 usb转sata上电问题patch]]
** S500
** TODO [[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B5330D@srv-mail-02.actions.com.cn][答复: S500&S700 HDMI为主显开机后插入支持EDID自适应最高分辨率]]
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F1035B7749@srv-mail-02.actions.com.cn][答复: S500&S700 HDMI热插拔分辨率]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B5299C@srv-mail-02.actions.com.cn][答复: 【方糖】【S500】【显示】开机logo不正常]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52B84@srv-mail-02.actions.com.cn][答复: S500 领芯 台式机 插USB口的3G或4G模块上网黑屏死机]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52F99@srv-mail-02.actions.com.cn][答复: 2603C 的A版B版的问题]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52E17@srv-mail-02.actions.com.cn][【全星】【59plus】【HDMI】客户自带HDMI显示器不能点亮]]
** 7059
大华案子
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B05145027@srv-mail-02.actions.com.cn][答复: 2603C 的A版B版的问题]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52E17@srv-mail-02.actions.com.cn][【全星】【59plus】【HDMI】客户自带HDMI显示器不能点亮]]
[[mu4e:msgid:1215223C59CBD54AA38F93133AF342D503DF5B3F@srv-mail-02.actions.com.cn][答复: 7059 - I2C 2 时钟配置无效问题]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEB6E3@srv-mail-02.actions.com.cn][转发: 7059C 调试10.1寸屏MIPI屏资料]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B52A9E@srv-mail-02.actions.com.cn][转发: 关于7059/S500 广告机 老化视频时 视频暂停的问题 setVideoSurfaceTexture failed: -22]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906329A27@srv-mail-02.actions.com.cn][答复: 写特定mac地址后系统kernel panic问题]]
** 7051
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEB17A@srv-mail-02.actions.com.cn][【7051】降低给视频播放预留的内存大小]]

* 预研工作
** android O
https://www.ithome.com/html/android/309497.htm
https://en.wikipedia.org/wiki/Android_O
* vendor
** 富迪
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791856@srv-mail-02.actions.com.cn][FW: 拜访富迪的出差报告]]
** TODO [[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F7490625FFF6@srv-mail-02.actions.com.cn][答复: 我已与您共享文件CK803]]
** 96board
[[mu4e:msgid:45C9CD6E9A1F8E40A999E51EF137BF15324B7C@srv-mail-02.actions.com.cn][about Linaro 96board-IoT Edition for Actions ATS3503]]
** 科胜讯
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EBAF5@srv-mail-02.actions.com.cn][RE: Actions与Conexant技术支持对接]]
** broadcom
蓝牙语音遥控器
[[mu4e:msgid:2017050817343430007115@yippee-elec.com][回复:<矩芯/意天> 提供语音遥控器头端补丁]]
** mbed
是的，mbed OS 5 可以用了
https://makerdiary.co/introducing-mbed-os-5/
https://makerdiary.co/open-hardware-nrf52832-mdk/
** 庆科
mico
http://developer.mico.io
** 4G模块
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04FA9EC7@srv-mail-02.actions.com.cn][问个4G模块的事]]
** 易观
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB93C@srv-mail-02.actions.com.cn][易观：智能语音应用专题分析——中国人工智能行业系列分析2017V11.pdf]]
** st
iot sdk
http://www.st.com/zh/evaluation-tools/b-l475e-iot01a.html
** 南方硅谷
*** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B049D58F4@srv-mail-02.actions.com.cn][答复: 有关南方硅谷Wifi 模组采购]]
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8FB81@srv-mail-02.actions.com.cn][有关公司WIFI  IP  外购的可能性]]
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0503D310@srv-mail-02.actions.com.cn][ATS3503炬芯和南方硅谷的加快协同开发的会议说明]]
** google
*** GMS
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A246DF@srv-mail-02.actions.com.cn][转发: Pegatron 3PL Newsletter]]
*** TODO Android O
http://www.androidcentral.com/android-o
JSON Web Token - 在Web应用间安全地传递信息
http://blog.leapoahead.com/2015/09/06/understanding-jwt/
*** google cloud
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10336C94F@srv-mail-02.actions.com.cn][转发: Google Follow-up]]
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10336C94E@srv-mail-02.actions.com.cn][转发: Google Cloud Follow-up (Google I/O Launch)]]
*** speech api
http://blog.laobubu.net/546
https://cloud.google.com/speech/
https://cloud.google.com/speech/docs/how-to
** arm
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB4FB@srv-mail-02.actions.com.cn][ARM的AD5 IP的介绍和效果演示]]
** baidu
*** 百度语音 asr
**** key
App ID: 9345458
API Key: mG95q1G6tQNgj3HkeKTMncW1
Secret Key: df6c11e2c11837c9453f21982766528b

("access_token"
 "24.38056c3ed01c466c5f60e8574be1b6aa.2592000.1491111095.282335-9345458"
 "session_key"
 "9mzdCPw6/Hqv7jUAHFcC0PV7eQffG2TPRzOTaQpQsmZ9o8HL28vlp5fdQivsGEhBtMIfK/k2qq2gKq3k1lTEuNVRcfl8"
 "scope"
 "public audio_voice_assistant_get audio_tts_post wise_adapt lebo_resource_base lightservice_public hetu_basic lightcms_map_poi kaidian_kaidian wangrantest_test wangrantest_test1 bnstest_test1 bnstest_test2 ApsMisTest_Test权限 vis-classify_flower"
 "refresh_token"
 "25.adc3662ac8277f931d20a1bd9e5f10a6.315360000.1803879095.282335-9345458"
 "session_secret" "c4f5b77109726d468d85e9bbe36b352f" "expires_in" 2592000)

**** lisp code
(setf drakma:*header-stream* *standard-output*)

(let ((stream (drakma:http-request "https://openapi.baidu.com/oauth/2.0/token"
                                   :method :post
                                   :close nil
                                   :want-stream t
                                   :parameters
                                   '(("grant_type" . "client_credentials")
                                     ("client_id" .
                                      "mG95q1G6tQNgj3HkeKTMncW1")
                                     ("client_secret" .
                                      "df6c11e2c11837c9453f21982766528b")))))
  (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
  (yason:parse stream :object-as :plist))


(let ((stream (drakma:http-request "http://vop.baidu.com/server_api"
                                   :method :post
                                   :close nil
                                   :want-stream t
                                   :content #p "/Users/zhangdongfeng/Desktop/2017/3503/baidu/Baidu_Voice_RestApi_SampleCode/sample/test.pcm"
                                   :content-type "audio/pcm;rate=8000"
                                   :content-length 52512
                                   :parameters
                                   '(("cuid" . "serial987654321")
                                     ("token" .
                                      "24.38056c3ed01c466c5f60e8574be1b6aa.2592000.1491111095.282335-9345458")))))
  (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
  (yason:parse stream :object-as :plist))

(defun get-voice-upload-json ()
  (let* ((pcm (file-at-once #p "/Users/zhangdongfeng/Desktop/2017/3503/baidu/Baidu_Voice_RestApi_SampleCode/sample/test.pcm" :element-type 'unsigned-byte )))
    (with-output-to-string (s)
      (yason:encode
       (alexandria:plist-hash-table
       `("format"  "pcm" "rate" 8000  "channel" 1
                    "cuid" "serial987654321"
                    "token" "24.38056c3ed01c466c5f60e8574be1b6aa.2592000.1491111095.282335-9345458"
                    "speech" ,(cl-base64:usb8-array-to-base64-string pcm)
                    "len" ,(length pcm))
        :test #'equal)
       s))))

(let ((stream (drakma:http-request "http://vop.baidu.com/server_api"
                                   :method :post
                                   :close nil
                                   :want-stream t
                                   :content (get-voice-upload-json)
                                   :content-type "application/json"
                                   :content-length (length (get-voice-upload-json))
                                   )))
  (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
  (yason:parse stream :object-as :plist))

(let ((stream (drakma:http-request "http://vop.baidu.com/server_api"
                                       :method :post
                                       :close nil
                                       :want-stream t
                                       :content #p "/Users/zhangdongfeng/Desktop/2017/3503/roobo/RECORD.AMR"
                                       :content-type "audio/amr;rate=8000"
                                       :content-length 15174
                                       :parameters
                                       '(("cuid" . "serial987654321")
                                         ("token" .
                                          "24.38056c3ed01c466c5f60e8574be1b6aa.2592000.1491111095.282335-9345458")))))
      (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
      (yason:parse stream :object-as :plist))

**** REST API定义
http://yuyin.baidu.com/docs/asr/57
postman
https://www.getpostman.com
*** 语义理解
http://yuyin.baidu.com/docs/asr/65
语义理解目前不支持rest api接口。
http://yuyin.baidu.com/bbs/q/891
{\"raw_text\":\"北京明天天气\",
\"parsed_text\":\"北京 明天 天气\",
\"results\":[{
\"domain\":\"weather\",
\"intent\":\"query\",
\"score\":1,
\"object\":{
\"date\": \"2013-09-25,2013-09-25\",
\"region\":\"北京\"
}}]}
*** 度秘
[[mu4e:msgid:BAF1FE2D-1EB4-4EE7-8EF8-75D7998F6DA8@actions-semi.com][Fwd: 度秘SDK!]]
阅读了SDK的文档，还是提供的sdk的方式， 没有rest api的方式

** microsoft
*** azure
https://docs.microsoft.com/zh-cn/azure/
https://docsmsftpdfs.blob.core.windows.net/guides/azure/azure-developer-guide.pdf
https://azure.microsoft.com/zh-cn/services/machine-learning/
Docker
http://baike.baidu.com/link?url=oeOvRCGBYVeUhnlbtFwp6r1NmPy7nikE7Ihx7WKX4CfGUeVM6kUS2-RMllLkR7IRLOTAFolu4Tu2kkVvRwQixq
X509
http://baike.baidu.com/item/x509?sefr=cr
IOT
** huawei
*** liteos
【链接】HuaweiLiteOS快速入门
http://developer.huawei.com/ict/cn/site-iot/article/liteos-start
东东  21:15:39
【链接】LITEOS/LiteOS_Kernel
https://github.com/LITEOS/LiteOS_Kernel
只有kernel开源， 没有看到其他部分， 不支持mips
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F37DB8@srv-mail-02.actions.com.cn][转发: 炬芯科技的芯片移植liteos和对接hilink协议]]
** amazon
*** avs
rest api
https://developer.amazon.com/public/solutions/alexa/alexa-voice-service/content/avs-api-overview
sample code
https://github.com/alexa/alexa-avs-sample-app
/Users/zhangdongfeng/Desktop/tmp/aws/alexa-avs-sample-app/samples/companionService
npm start
/Users/zhangdongfeng/Desktop/tmp/aws/alexa-avs-sample-app/samples/javaclient
mvn exec:exec
** aliyun
账号
1qaz2wsx12
2wsx1qaz

Access key:
LTAIqcDTW9H51JB4
secret:
28gxbtkHkGJsEFw7ChuXEkcRldtUjb

https://help.aliyun.com/document_detail/32290.html?spm=5176.doc49179.2.8.cctgre
*** iot
https://open.aliplus.com/docs/open/module/wifi/spec.html
阿里提供的是sdk，不是http的开放api， 需要移植操作系统的接口

** 搜狗
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F37C05@srv-mail-02.actions.com.cn][转发: 搜狗语音demo]]
[[mu4e:msgid:8052E2BCBBC3F246AF9C6B50C39BCFBAD04CB74F@SOGOUBJMB08.sogou-inc.com][答复: 搜狗炬芯语音需求讨论]]
** mediawin
[[mu4e:msgid:201704221354103646803@media-win.com][Re: RE: 关于炬芯-迪韵的4MIC的项目]]

 alsa的示例程序只要能实现录音和播放即可。可参考http://blog.csdn.net/zd394071264/article/details/8300045。
 avs的示例程序可参考树莓派开源代码，参照androidCompanionApp部分，改用c/c++封装。对应示例链接：https://github.com/alexa/alexa-avs-sample-app。

是的，根据亚马逊AVS API说明，结合树莓派的示例代码进行封装。需要注意的
是，音频需要分帧（10ms）实时上传，最好不要采用一次性发送到AVS的方式，
以提高响应速度。
** mips
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74905FFA609@srv-mail-02.actions.com.cn][转发: MIPS Core requirement, 工具链介绍]]
** 地平线
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB7E9@srv-mail-02.actions.com.cn][Roobo&地平线的出差记录]]
** 科大讯飞
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10336D07B@srv-mail-02.actions.com.cn][答复: 科大讯飞与全志科技签订战略合作协议 - 集微网:老杳微信号laoyaoshow]]
** img
[[mu4e:msgid:44C4BD37C5E50146BE0A8676C5F6CF032283D802@HHMAIL01.hh.imgtec.org][RE: PowerVR update for 8XE/8XEP and AI]]
** 京东
joylink_dev_sdk 在 ubuntu 运行时资源占用情况:
包括子设备部分:
ram:4-6K
rom:184K
*** 开发者中心
http://devsmart.jd.com/dev/openDocDir#
京东微联是京东针对未来智慧生活而全力打造的智能平台，其目标是帮助智能硬件厂家打造体验更好的智能硬件产品，为消费者提供一站式的智能产品体验。通过微联App，用户可以对不同品牌智能产品进行远程控制，并实现产品之间的联动。同时针对个人健康情况，记录运动、睡眠等信息，进行完整的数据收集，提供个性服务。随着智能化时代的来临，京东微联致力于为您提供简单、快乐的智能生活体验。
京东微联在首届亚洲消费电子展（CES Asia）众多参选产品中脱颖而出，获得“最佳智能家居产品”大奖。作为京东在万物互联时代的入口级产品，微联将帮助用户实现智慧生活体验的梦想。
该应用可实现的功能包括：一个App控制所有智能设备，智能设备的便捷发现和配置，随时随地的远程管理，众多穿戴设备、健康设备的接入以及个人健康档案生成等。同时还可以设置不同的应用场景，在智能家居的场景中，我们可支持空调、净化器、电饭煲、净水机、灯光、插座等智能设备的远程控制，在智慧健康的场景中，我们可支持手环、血糖仪、体脂仪等智能设备的数据收集，为您实现一手掌控简单智能生活的愿望。

开放服务是将京东微联的数据通过JOS(京东开放服务)接口暴露给第三方开发者。第三方开发者接入京东智能云开放服务， 通过既有的接口开发出与微联类似功能的三方应用。用户可以不使用京东微联而使用三方开发者自己开发的APP就能获取该用户在京东微联绑定的设备列表、，控制授权设备等功能。
*** ECC-ECDH
http://blog.sina.com.cn/s/blog_55a9111c01011zxz.html
.ECDH:
       ECC算法用途比RSA还猛，不仅可以加解密、签名验证。还可以与DH结合使用，用于密钥磋商，这个密钥交换算法称为ECDH。交换双方可以在不共享任何秘密的情况下协商出一个密钥。ECC是建立在基于椭圆曲线的离散对数问题上的密码体制，给定椭圆曲线上的一个点P，一个整数k，求解Q=kP很容易；给定一个点P、Q，知道Q=kP，求整数k确是一个难题。ECDH即建立在此数学难题之上。密钥磋商过程：
       假设密钥交换双方为Alice、Bob，其有共享曲线参数（椭圆曲线E、阶N、基点G）。
1) Alice生成随机整数a，计算A=a*G。Bob生成随机整数b，计算B=b*G。
2) Alice将A传递给Bob。A的传递可以公开，即攻击者可以获取A。由于椭圆曲线的离散对数问题是难题，所以攻击者不可以通过A、G计算出a。Bob将B传递给Alice。同理，B的传递可以公开。
3 ) Bob收到Alice传递的A，计算Q=b*A
4) Alice收到Bob传递的B，计算Q‘=a*B
Alice、Bob双方即得Q=b*A=b*(a*G)=(b*a)*G=(a*b)*G=a*(b*G)=a*B=Q' (交换律和结合律)，即双方得到一致的密钥Q。

** wise automotive
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8FDEB@srv-mail-02.actions.com.cn][转发: WISE AUTOMOTIVE 介绍资料]]

* 3503
** amr 16K编码
*** 20170703 地平线
如微信沟通，关于AMR 16KHz 编码的问题，需要炬芯的同事帮忙尽快更新一下～从我们专业的角度看，16KHz是主流的方式，且与8KHz比较有诸多优点～
以下为我们总结的点供参考：推荐采用amr-wb 16Khz的理由:
+  在语音识别领域，目前主流都是采用16KHz， 16bit的语音数据进行语音识别， 8KHz, 16bit目前主要是应用在电信客服等少数领域，后续也有逐步被16KHz替换掉的趋势；AR/VR会采用32KHz采样；
+ 相比于8KHz采样， 16KHz的语音包含更多语音信息， 在MOS指标上也要有明显提升；
+ 在噪声鲁邦性上16KHz采样语音要明显优于8KHz， 很多生活场景、玩具电机噪声都分布在2KHz一下，相比于16KHz采样语音，8KHz语音更容易受到干扰；针对远场语音识别， DOA，BF等算法采用 16KHz采样的语音都要由于8KHz采样语音；
+ 16KHz在语音识别的情况下，可以提取更多频带信息，在目前深度学习的框架下，相比于8KHz语音模型可以更好的建模语音特征；
+ 语音本身传输带宽比较小，调整为16KHz采样后，带宽增加也不多，但是可以明显提升语音识别性能。
*** 各种格式对比
| speex | 最佳的语音识别算法                                       |
| msbc  | 特征提取，msbc是不可逆的，不能还原声音，做大数据分析困难 |
| amr   | 肯定不适合做语音识别，流量和网络存储开销大               |
** 蓝牙地址
*** TODO [[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906260C5B@srv-mail-02.actions.com.cn][ZS350A SN和蓝牙mac地址在产线上该如何烧写]]
** WIFI 兼容性
** zephyr中文文档
http://www.96boards.net/forum.php?mod=viewthread&tid=38
http://iot-fans.xyz/zephyr/doc/v1.6.0/index.html
** 发布文档
*** TODO 入门指南
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F1035B6F53@srv-mail-02.actions.com.cn][答复: ZS350A 发布文档准备]]
*** 数据烧写工具
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B05144321@srv-mail-02.actions.com.cn][数据烧写工具使用指南]]
*** 用户手册
[[mu4e:msgid:1215223C59CBD54AA38F93133AF342D503DF5D17@srv-mail-02.actions.com.cn][答复: ZS350A 发布文档准备]]
*** wifi测试手册
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749063298C9@srv-mail-02.actions.com.cn][答复: ZS350A 发布文档准备]]
** TODO 需改进
AirKiss协议实现不标准， 增加了basee64编码
json实现不标准，修改了基本语义
解码库里有很多重复代码
在parser和解码库中存在重复功能。 对代码量有影响。
** 蓝牙空间
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D5D7A@srv-mail-02.actions.com.cn][zs350a增加蓝牙功能后memory资源占用]]
** 功耗数据
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D58DB@srv-mail-02.actions.com.cn][答复: 【测试结果确认】ZS350A_ATS3503_XLT_JQRHB功耗&续航指标测试]]
** mqtt粘包问题
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103465985@srv-mail-02.actions.com.cn][答复: 关于mqtt粘包的修改]]
** 不烧写序列号
[[mu4e:msgid:0E3AB831E505F842818BA4F9798C30A4016F2641@srv-mail-02.actions.com.cn][转发:  关于如何避免烧写设备序列号]]
** 网络性能设计
*** [[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F7490626097F@srv-mail-02.actions.com.cn][答复: 关于网络卡顿的设计和优化]]
+ 边下边播
  在有卡存在的情况下, 会在播放的时候， 同时下载到卡上， 网络性能和写卡的性能大于播放器消耗码流的速度的时候， 可以有效的避免播放卡顿
+ 网络缓冲区的零拷贝
 从网络驱动开始， wifi驱动 + 网络协议栈 + 网络流buffer + 播放器码流buffer 都使用同一个buffer，都使用同一个网络buffer， 最大限度的使用内存
+ TCP 重传支持
  在zephyr中没有重传的支持， 增加了重传机制， 在丢包情况下
+ TCP 窗口优化
  结合内存情况设置合理的TCP的滑动窗口， 在各个场景，较好的平衡性能，缓冲以及满足重传时间间隔要求
+ tcp的ACK包，以及mqtt 心跳包使用保留的小buffer
  避免网络数据包被接受的音乐数据长时间占住后， 不能及时回复响应
  同时也可以节省更多的大的网络buffer给音乐数据
** wifi性能分析

[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D4E7F@srv-mail-02.actions.com.cn][在线播放网络影响分析]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906329AB3@srv-mail-02.actions.com.cn][答复: ZS350A 发布文档准备]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F7490632988A@srv-mail-02.actions.com.cn][ZS350A在线播放高码率卡顿情况分析]]
cache miss
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906329B13@srv-mail-02.actions.com.cn][答复: spi 2x mode]]
1、环境：EVB_004板子，code在spi nor；

Tcp rx：500kbps（包长590），1Mbps（包长1514）统计tcp data数据

测试环境：spi_1x,spi_2x, spi_4x, spi clock 48MHz，代码在spi nor中，
(spi_2x, spi_4x屏蔽房环境, spi_1x之前办公区测试)；

spi_xxspi clocktcp iperf rx   cache miss   一次miss spi cs
               (Kbps)         （次/秒）    时间
api_1x48MHz    500            70000        12us
spi_2x48MHz    800            120000       6.3us
Spi4x 48MHz    1200           200000       3.3us


*** 在线播放卡顿分类：
+ ap与机子之间wifi传输存在丢包，导致wifi包重传,甚至导致tcp层重传，重传导致300~700ms之间没数据传输；卡顿情况编号：1,9,10,13;
这种情况，向南方硅谷了解，跟干扰，天线好坏有关；
+ 网络传输延迟，即发出了ack，服务器收到ack后发出数据包，到收到数据包的时间长达200~700ms不等，而传输快的情况，从发出ack到收到数据包，20ms就可以了；卡顿情况编号：4,6,7,11,12,13；
+ 网络丢包，即数据包在服务器到ap之间传输就丢了，导致后面数据包重传，抓到的一个重传后收到已是1.3秒之后；卡顿情况编号12；
+ 连续多次卡顿，主要是这段时间内网络传输延迟引起；卡顿情况编号：13；
+ 部分空中包抓不到，从抓包前后编号及时间间隔，算出这段时间传输的数据速率低于音乐播放码率，引起卡顿；卡顿情况编号：2,3,5,8;
+ 对于单独一、两次网络延迟的情况，理论上加大tcp window，让跟多的数据包在服务器与机子之间传输，可以一定程度减小收到包的时延。对于一段时间内多次传输时延，还没想到规避办法；
   对于网络丢包，除了缓存足够数据等到重传包的到来，暂时没有其它办法规避；

向南方硅谷了解的wifi相关情况：
+ Wifi传输使用退避算法，会一直等待空气空闲，复杂环境下，会一直等待，等待时间不确定，可能会很长；
+ Wifi多次重传，有时连续重传多次间隔都很小，有时重传间隔会大，看到一个第3次重传已经是400多ms之后，重传是由于发出数据包没收到ack，只要回ack，另一端收到的概率很大，主要是收不到发出的数据，跟干扰，天线好坏有关，这个现象只能说是和干扰，硬件RF性能相关，因为回ack都是硬件做的；
+ Ap发送一个数据包，多次重传后都收不到ack，就会丢掉这个包，传输下一个包，retry次数ap各不同，这个没有spec规定，测试同一个ap，都抓到两次不同的重传情况，一次在10ms秒就重传了6次，一次在400ms内才重传了3次；
播放音乐码率：128kbps，不卡顿需要的收包频率约100ms收到一个数据包
** 二维码
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D4E25@srv-mail-02.actions.com.cn][发送电子邮件: ACTS3503011_27.jpg]]
二维码烧写指令：storyapp set_sn ACTS3503011_27
二维码烧写指令：storyapp set_sn ACTS3503026_38
清除ap 信息的指令：storyapp clear_ap_info
清除音量设置指令：storyapp set_config AUDIOUT_VOLUME
关闭半小时自动关机指令：storyapp set_config AUTO_POWERDOWN false
** 项目计划
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74905FFA9E6@srv-mail-02.actions.com.cn][发送电子邮件: ZS350A项目计划.pdf]]
** 开发
*** jtag调试
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10336CE0E@srv-mail-02.actions.com.cn][答复: 会议记录:US282F SDK培训(一)]]
** hardware
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74905FFA154@srv-mail-02.actions.com.cn][GPIO配置]]
** 规格
*** 规格简介
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74905FF9A31@srv-mail-02.actions.com.cn][ZS350A方案规格简介]]
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F155DAE9@srv-mail-02.actions.com.cn][Fwd: 发送电子邮件: ZS350A_SPEC V1.0.xlsx]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74905FF9BFF@srv-mail-02.actions.com.cn][答复: GL5118Plus对CPU速度和RAM增加的需求讨论]]

** 3503语音接口定义
+ 语音识别接口支持 POST 方式
+ 需要支持片段语音识别的模式，整段语音可以分成多个片段上传进行识别
+ 原始语音的录音格式目前只支持  8k/16k 采样率 16bit 位深的单声道语音
+ 压缩格式支持：pcm（不压缩）、wav、opus、speex、amr
+ 系统支持语言种类：中文（zh）
*** 语音上传模式

语音数据直接放在 HTTP-BODY 中，控制参数以及相关统计信息通过 REST 参数传递，REST参数说明：
| 字段名  | 数据类型 | 可需 | 描述                                                        |   |   |
| cuid    | string   | 必填 | 用户 ID，推荐使用设备mac 地址/手机IMEI 等设备唯一性参数     |   |   |
| token   | string   | 必填 | 开发者身份验证密钥                                          |   |   |
| lan     | string   | 选填 | 语种选择，中文=zh，不区分大小写，默认中文 |   |   |
| offset  | int      | 必填 | 语音片段在本次识别中的偏移                                  |   |   |
| is_last | boolean  | 必填 | 当前语音片段是否是最后一段                                  |   |   |


语音数据的采样率和压缩格式在 HTTP-HEADER 里的 content-type 表明，例：

Content-Type:audio/amr;rate=8000
Content-length 请填写语音片段长度。

*** 下行接口定义

返回的结果，采用 JSON 格式封装，如果识别成功，识别结果放在 JSON的“result”字段中，统一采用 utf-8 方式编码。

| 字段名  | 数据类型 | 可需 | 描述                   |
| err_no  | int      | 必填 | 错误码                 |
| err_msg | string   | 必填 | 必填错误码描述         |
| result  | string   | 必填 | 识别结果               |
| url     | string   | 必填 | 百科问答的结果音频文件 |

string 类型utf-8 编码

*** 错误码解释
| 错误码 | 含义               |
|   3300 | 输入参数不正确     |
|   3301 | 识别错误           |
|   3302 | 验证失败           |
|   3303 | 语音服务器后端问题 |

** roobo
     请使用这个账号。注意：这个是测试环境的账号，接的URL地址为ros.roobo.net。切记
     agentId： U4NTc4YTQ2MjhlYz
     token：89330257fc00279373b7c1e979aa8d0e7636

*** testcode

**** asr
(setf drakma:*header-stream* *standard-output*)
     (let ((stream (drakma:http-request "http://ros.roobo.net/voice/v1/asr"
                                       :method :post
                                       :close nil
                                       :want-stream t
                                       :content #p "/Users/zhangdongfeng/Desktop/2017/3503/baidu/Baidu_Voice_RestApi_SampleCode/sample/test.pcm"
                                       :content-type "audio/pcm;bit=16;rate=8000"
                                       :content-length 52512
                                       :parameters
                                       '(("agentId" . "U4NTc4YTQ2MjhlYz")
                                         ("lang" . "cmn-CHN")
                                         ("sessionId" . "serial987654321")
                                         ("token" .
                                          "89330257fc00279373b7c1e979aa8d0e7636")))))
      (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
      (yason:parse stream :object-as :plist))

(let ((stream (drakma:http-request "http://ros.roobo.net/voice/v1/asr"
                                       :method :post
                                       :close nil
                                       :want-stream t
                                       :content #p "/Users/zhangdongfeng/Desktop/2017/3503/roobo/RECORD.AMR"
                                       :content-type "audio/amr;rate=8000"
                                       :content-length 15174
                                       :parameters
                                       '(("agentId" . "U4NTc4YTQ2MjhlYz")
                                         ("lang" . "cmn-CHN")
                                         ("sessionId" . "serial987654321")
                                         ("token" .
                                          "89330257fc00279373b7c1e979aa8d0e7636")))))
      (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
      (yason:parse stream :object-as :plist))
**** tts
(let ((stream (drakma:http-request "http://ros.roobo.net/voice/v1/tts"
                                       :method :post
                                       :close nil
                                       :want-stream t
                                       :content "今天天气怎么样"
                                       :content-type "audio/pcm;bit=16;rate=8000"
                                       :content-length (trivial-utf-8:UTF-8-BYTE-LENGTH "今天天气怎么样")
                                       :external-format-out :utf-8
                                       :parameters
                                       '(("agentId" . "U4NTc4YTQ2MjhlYz")
                                         ("lang" . "cmn-CHN")
                                         ("sessionId" . "serial987654321")
                                         ("token" .
                                          "89330257fc00279373b7c1e979aa8d0e7636")))))
      (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
      (yason:parse stream :object-as :plist))

**** query
(let ((stream (drakma:http-request "http://ros.roobo.net/voice/v1/query"
                                       :method :post
                                       :close nil
                                       :want-stream t
                                       :content #p "/Users/zhangdongfeng/Desktop/2017/3503/roobo/RECORD.AMR"
                                       :content-type "audio/amr;rate=8000"
                                       :content-length 15174
                                       :parameters
                                       '(("agentId" . "U4NTc4YTQ2MjhlYz")
                                         ("lang" . "cmn-CHN")
                                         ("sessionId" . "serial987654321")
                                         ("token" .
                                          "89330257fc00279373b7c1e979aa8d0e7636")))))
      (setf (flexi-streams:flexi-stream-external-format stream) :utf-8)
      (yason:parse stream :object-as :plist))

 ip.addr == 60.205.122.156
** mqtt
*** mqtt_api.h
#ifndef __HEADER_H__
#define __HEADER_H__
/*loop_mode_t - player mode
 *  REPEAT_ONE: repeat one
 *  REPEAT_ALL: repeat all
 * This enum is used in send_loop_mode as a argument
 */
typedef enum {
        REPEAT_ONE,
        REPEAT_ALL
}loop_mode_t;

/*play_status_t - player status
 *  PLAY: playing status
 *  PAUSE: pause status
 * This enum is used in send_play_status as a argument
 */
typedef enum {
        PLAY,
        PAUSE
}play_status_t;


/*music_track_info_t - the struct describes a track(music or story) for normal play or download
 *  @track_id: track id of the music or story
 *  @play_url: url of the music or story
 *  @download_url: download url of the music or story
 * This struct describes a music or story to play or download
 */
typedef struct{
        int track_id;
        char *play_url;
        char *download_url;
}music_track_info_t;

/*demand_music_info_t - the struct describes a track(music or story) on demand
 *  @voice_url: url of the notify voice
 *  @url: url of the music or story
 *  @track_id: track id of the music or story
 * This struct describes a music or story on demand
 */
typedef struct {
        char *voice_url;
        char *url;
        int track_id;
}demand_music_info_t;

/**track_list_t - list of tracks
 *  @name: list name
 *  @id: list id
 *  @size: list size
 *  @trackIDs: track id array in this list
 * This struct describes a track list. It is used for play list operations.
 */
typedef struct {
        char *name;
        int id;
        int size;
        int *trackIDs;
}track_list_t;

/**command_type_t - received server message , command type
 * This enum describes simple command types.
 */
typedef enum {
        Play,
        Pause,
        Resume,
        Next,
        Prev,
        SetVolume,
        GetVolume,
        SetLoopMode,
        GetLoopMode,
        GetCurrentTrack,
        GetSysInfo,
        SetPowerOff,
        GetPlayStatus,
        GetOnlineStatus,
        SetPlayTrackListId,
        GetPlayTrackListId,
        GetTracksById,
        GetPlayProgress
}command_type_t;

/**Sys_info_t - sys info
 * This struct describes system information.
 */
typedef struct SysInfo {
        char ssid[64];
        char fw_version[64];
        bool is_charging;
        int battery_vol;
        int storage_total;
        int storage_free;
}Sys_info_t;


/**play_list_arg_t - argument for SetPlayTrackListId command
 * @ids: id array
 * @size: id array size
 * This struct describes list ids to set.
 * SetPlayTrackListId can set one or more lists at one time
 */
typedef struct {
        int *ids;
        int size;
}play_list_arg_t;

/**play_list_arg_t - argument for Play command
 * @list_id: list id
 * @track_id£º track id
 * @play_url: play url
 * @download_url£º download url
 *
 */
typedef struct {
        int list_id;
        int track_id;
        char *play_url;
        char *download_url;
}play_track_arg_t;

/**fw_info_t - firmware information
 * @version: firmware version
 * @url£º firmware download url
 * This struct is used to transform fw information
 */
typedef struct {
        char *version;
        char *url;
}fw_info_t;

/**track_type_t - track type
 * MUSIC_TYPE: music or story normal type
 * DEMAND_TYPE£º on demand type
 * VOICE_TYPE: voice type
 * This enum is used in send_current_track as an argument
 */
typedef enum {
        MUSIC_TYPE,
        DEMAND_TYPE,
        VOICE_TYPE
}track_type_t;

/**download_state_t - download state
 * DOWNLOAD_STATE_SUCCESS:
 * DOWNLOAD_STATE_ERROR:
 * DOWNLOAD_STATE_FULL:
 * This enum is used in send_download_state as an argument
 */
typedef enum {
        DOWNLOAD_STATE_SUCCESS,
        DOWNLOAD_STATE_ERROR,
        DOWNLOAD_STATE_FULL
}download_state_t;

/**************************APIs***************************************/
/*DOC:
 * 1. send_xxx APIs are realised in the lib,
 *    the upper app can use them directly.
 * 2. on_receive_xxx APIs are callback functions used in the lib,
 *    the upper app must realised them all.
 * 3. some simple commands are parsed in on_receive_command, the other commands are
 *    parsed to different on_receive_xxx callbacks.
 */



/*on_receive_command - SET²Ù×÷----¸ù¾Ý²»Í¬µÄÉèÖÃÃüÁî£¬´«Èë»Øµ÷µÄarg²ÎÊýÒ²ÊÇ²»Í¬µÄ

 *Play:               ´«Èë²ÎÊýÎªplay_track_arg_tÀàÐÍµÄÖ¸Õë£¬ÆäÖÐ´æ´¢ÐèÒª²¥·ÅµÄtrackÐÅÏ¢¡£
 *Pause/Resume/Next/Prev£º´«Èë²ÎÊýÎªNULL£¬½øÐÐÏàÓ¦µÄ²Ù×÷¡£
 *SetVolume£º         ´«Èë²ÎÊýÎªintÐÍÖ¸Õëint *vol£¬¼´ÎªÐèÒªÉèÖÃµÄvolume¡£
 *SetLoopMode£º       ´«Èë²ÎÊýÎªintÐÍÖ¸Õë£¬×ª»¯Îªloop_mode_tÀàÐÍ½øÐÐ´¦Àí¡£
 *SetPowerOff£º       ´«Èë²ÎÊýÎªNULL£¬½øÐÐ¹Ø»ú²Ù×÷¡£
 *SetPlayTrackListId: ´«Èë²ÎÊýÎªstruct play_list_arg_tÀàÐÍ£¬ÉèÖÃÐ¡»ú¶ËÒª²¥·ÅµÄÁÐ±íids¡£
*/

/*on_receive_command - GET²Ù×÷----´«Èë²ÎÊý¶¼ÎªNULL, ÐèÒªµ÷ÓÃ¶ÔÓ¦µÄsendÃüÁî·¢ËÍÏàÓ¦µÄ×´Ì¬¸ø·þÎñÆ÷

 *GetVolume:	»ñÈ¡ÒôÁ¿£¬°Ñµ±Ç°ÒôÁ¿Í¨¹ýsend_volume½Ó¿Ú·¢³öÈ¥¡£
 *GetLoopMode£º	»ñÈ¡²¥·ÅÄ£Ê½£¬°Ñµ±Ç°modeÍ¨¹ýsend_loop_mode·¢³ö¡£
 *GetCurrentTrack:»ñÈ¡µ±Ç°²¥·ÅµÄtrackÐÅÏ¢£¬ÐèÒªÔÚ»Øµ÷ÖÐµ÷ÓÃsend_current_music·¢ËÍ³öÈ¥¡£
 *GetSysInfo£º	»ñÈ¡µ½Ð¡»úÐÅÏ¢ºóÍ¨¹ýsend_sys_info·¢³öÀ´¡£
 *GetPlayStatus: »ñÈ¡²¥·Å×´Ì¬£¬Í¨¹ýsend_play_statusÀ´·¢ËÍ¡£
 *GetOnlineStatus£º»ñÈ¡Ð¡»úÊÇ·ñÔÚÏß£¬ÊÕµ½Õâ¸öÃüÁîÖ»ÐèÒªsend_online_status¼´¿É¡£
 *GetPlayTrackListId£º»ñÈ¡Ð¡»ú¶ËÒª²¥·ÅµÄÁÐ±íids,µ÷ÓÃsend_play_list_id·¢ËÍ³öÈ¥¡£
 */
void on_receive_command(command_type_t cmd, void *arg);

/* on_receive_emoji - Ð¡»ú½ÓÊÕµ½ÁË±íÇéÏûÏ¢¡£
 * on_receive_text_message - Ð¡»ú½ÓÊÕµ½ÁËÎÄ×ÖÏûÏ¢¡£
 * on_receive_voice_message - Ð¡»ú½ÓÊÕµ½ÁËÁôÑÔÏûÏ¢¡£
 * on_receive_image_message - Ð¡»ú½ÓÊÕµ½ÁËÍ¼Æ¬ÏûÏ¢¡£
 * on_receive_video_message - Ð¡»ú½ÓÊÕµ½ÁËÊÓÆµÏûÏ¢¡£
 * on_receive_demand_music - Ð¡»ú½ÓÊÕµ½ÁËµã²¥ÏûÏ¢¡£
 * send_message_download_success - Í¨Öª·þÎñÆ÷ÏûÏ¢×ÊÔ´ÒÑ¾­ÏÂÔØ
 */
void on_receive_emoji(char *url);
void on_receive_text_message(char *text, char *nickname, char *avatar, int64_t timestamp);
void on_receive_voice_message(char *url, char *nickname, char *avatar, int64_t timestamp);
void on_receive_image_message(char *url, char *nickname, char *avatar, int64_t timestamp);
void on_receive_video_message(char *url, char *nickname, char *avatar, int64_t timestamp);
void on_receive_demand_music(demand_music_info_t *musicInfo);
void on_receive_demand_music_online(demand_music_info_t *musicInfo);
void send_message_download_success(char *resUrl);

/*get_track_info_by_id - Ð¡»ú·¢ËÍÏûÏ¢µ½·þÎñÆ÷ÒÔ»ñÈ¡¸úidÏà¹ØµÄtrack info
 *get_track_info_array_by_id - Óëget_track_info_by_idÀàËÆ£¬Ò»´Î»ñÈ¡¶à¸öµÄ½Ó¿Ú
 *on_receive_track_info - Ð¡»ú½ÓÊÕµ½ÁË·þÎñÆ÷·µ»ØµÄtrack infoÏûÏ¢
 *on_receive_track_info_array - Óëon_receive_track_infoÀàËÆ£¬Ò»´Î½ÓÊÕ¶à¸öµÄ½Ó¿Ú
 *
 */
void get_track_info_by_id(int track_id);
void get_track_info_array_by_id(int *ids, int size);
void on_receive_track_info(music_track_info_t *info);
void on_receive_track_info_array(music_track_info_t *info, int size);



/* username: ÓÃÓÚMQTT·þÎñÆ÷Á¬½ÓÐí¿ÉÑéÖ¤£¬·ÇÑéÖ¤·½Ê½Á¬½ÓÖ±½ÓÌîNULL
 * password£ºÓÃÓÚMQTT·þÎñÆ÷Á¬½ÓÐí¿ÉÑéÖ¤£¬·ÇÑéÖ¤·½Ê½Á¬½ÓÖ±½ÓÌîNULL
 * ×¢Òâ£ºÊÇ·ñ´«ÈëusernameºÍpasswordÐè¸ù¾ÝMQTT·þÎñÆ÷ÅäÖÃÀ´¾ö¶¨¡£
 */
void client_lib_open(char *srv_addr, char *id, char *username, char *password);
void client_lib_close(void);
void on_server_connect(void);
void on_server_disconnect(void);


void send_online_status(void);


void send_current_track(int list_id, int track_id, track_type_t type);


void send_demand_music_broadcast(int track_id);


void send_download_success(int track_id, char *url);
void send_download_error(int track_id, char *url);
void send_download_full(int track_id, char *url);

void send_download_state(download_state_t type, int *ids, int size);

/*Ð¡»úÆäËûÏà¹Ø×´Ì¬´ð¸´*/
void send_volume(int vol);
void send_loop_mode(loop_mode_t mode);
void send_play_status(play_status_t status);
void send_play_progress(int time);
void send_sys_info(Sys_info_t *info);

/*Ð¡»ú»ñÈ¡listµÄ²Ù×÷*/
void get_list_by_id(int list_id);
void on_receive_list(track_list_t *list);

/*Ô¤ÖÃlist²Ù×÷*/
void send_predefine_list(track_list_t *list);
void on_receive_predefine_list_id(char *name, int list_id);
void send_preset_list(track_list_t *list);

/*Í¬²½list²Ù×÷*/
void send_sync_list_request(void);
void on_receive_update_list_id(int *listIDs, int size);
void on_receive_add_list_id(int listID, char *name);
void on_receive_deleted_list_id(int *listIDs, int size);

/*·¢ËÍ²¥·ÅÁÐ±í,Ð¡»ú½ÓÊÕµ½GetPlayTrackListIdÃüÁîºóµÄ´ð¸´*/
void send_play_list_id(int *listIDs, int size);
void send_voice_media_id(char *media_id);

/*´ÓlistÀïÅúÁ¿Ìí¼Ó£¬É¾³ýtrackÎÄ¼þ*/
void on_delete_track_by_id(int list_id, int *trackIDs, int size);
void on_add_track_by_id(int list_id, int *trackIDs, int size);

/*OTA ²Ù×÷*/
void on_receive_upgrade_firmware(fw_info_t *fw);
void send_upgrade_start(void);
void send_upgrade_stop(void);

void send_change_listid(int listid);
void send_wifi_success(void);

/***********************customer extension APIs*****************************/

/**
 *DOC:
 *	the customer-extending message should be follow these rules below:
 *	1.it must be a JSON string
 *	2.it should include the key-value: {"cmd" : "customer", ...}
 */

/*send_customer_message - send customer-extending message
 *@data: message data point
 *@length: message data length
 */
void send_customer_message(char *data, int length);

/*on_receive_customer_message - when the lib received a customer-extending message,
 *				this callback will be called
 *@data: message data point
 *@length: message data length
 */
void on_receive_customer_message(char *data, int length);

void get_track_info_for_collector(int trackid);
void on_receive_track_info_for_collector(int sourceId, int duration, int customerId);

void send_test_result(char *result);
void on_receive_test_mode(char *url);

void on_receive_get_initial_track_list(int tracklistId);
void on_receive_play_tracks(int *trackIds,int size);

/* »ØÓ¦·þÎñÆ÷¶ËgetTracksÃüÁî£¬·µ»Ø¹ÊÊÂ»úÁÐ±íÄÚÈÝ */
void send_tracks_list_content(int trackListId, int *trackIds, int size);

#endif //__HEADER_H__

*** 自己搭建服务器格式
注：以下json格式为伪格式，字段和字符型的值的引号都忽略了

1.订阅topic希望加上应用名
例如：小机端订阅 storybox/mac地址/server 和 storybox/mac地址/server/page
服务端订阅 storybox/+/client 和 storybox/+/server/page

2.远程设置
1）音量调节
发起方：页面
接收方：小机
格式：{ cmd:setVolume, value:50}

2）远程关机
发起方：页面
接收方：小机
格式：{ cmd:setPoweroff}

3)主动询问音量
发起方：页面
接收方：小机
格式：{ cmd:getVolume}

4)小机音量，这里2种情况：主动询问后的回答及小机音量变化
发起方：小机
接收方：页面
格式：{volume:50}
{"volume":38}

3.故事机信息显示
1）主动询问故事机信息
发起方：页面
接收方：小机
格式：{ cmd:getBoxInfo}

2)故事机信息
发起方：小机
接收方：页面
格式：{boxInfo:{net:xxx,cardAvailable:xxx,cardTotal:xxx, electricity:xxx,firmwareVersion:xxx}}
{"boxInfo":{"net":"ess","cardAvailable":208,"cardTotal":300, "electricity":80,"firmwareVersion":"34343434"}}

4.设备的上下线管理
1)设备上线，设备上线及
发起方：小机
接收方：服务器和页面
格式：{onlineStatus:on}
{"onlineStatus":"on"}


2)设备下线
发起方：小机
接收方：服务器和页面
格式：{onlineStatus:off}
{"onlineStatus":"off"}

3)设备掉线
发起方：小机
接收方：服务器和页面
格式：{onlineStatus:abnormal}
{"onlineStatus":"abnormal"}

4）主动询问设备是否在线
发起方：页面
接收方：小机
格式：{ cmd:getOnlineStatus}
小机答复: {"onlineStatus":"online"}


8.上线时列表及信息同步
1)设备主动询问需要同步的列表
发起方：小机
接收方：服务器
格式：    {"cmd":"getUpdateListId"}
服务器回复：{ cmd:setUpdateListId,trackListIds:[1,2,3,4]}
和 SetPlayTrackListId



在新增一个列表时 {cmd:addList,trackListId:xxx,name:xxx}
移除一个列表 {cmd:delList,trackListId:xxx}

2)
发起方：小机
接收方：服务器
格式：{ cmd:getList,trackListId:xxx}  {"cmd":"getList","trackListId":1}
服务器回复：{cmd:setList, trackListId:xxx,name:xxx,trackIds:[1,2,3]}



3)设备在线时编辑列表后服务器发送
发起方：服务器
接收方：小机
格式：{cmd:listAddTrack, trackListId:xxx,trackIds:[1,2,3]}
{cmd:listRemoveTrack,trackListId:xxx,trackIds:[1,2,3]}


11.文件下载功能
1)文件下载成功后
发起方：小机
接收方：服务器/页面
格式：{downloadStatus:xxx,trackId:1, url:xxxx}  xxx为success,error,full
{"downloadStatus":"success","trackId":203, "url":"xxxx"}

2)批量文件下载成功后
发起方：小机
接收方：服务器/页面
格式：{downloadStatus:xxx,trackIds:[1,2,3]}  xxx为success,error,full
{"downloadStatus":"success","trackIds":[1,2,3]}

12.正在播放状态显示& 遥控公仔功能
1)页面主动向小机请求获取当前歌曲
发起方：页面
接收方：小机
格式：{cmd:getTrack} 获取当前播放歌曲，或者点播歌曲。


2)页面主动向小机请求获取当前播放状态
发起方：页面
接收方：小机
格式：{cmd:getPlayStatus} playing pause

3)小机播放状态改变
发起方：小机
接收方：页面
格式：{playStatus:xxx}  xxx为playing,pause
{"playStatus":"playing"}

4)小机播放歌曲的改变，这里也是页面主动向小机请求获取当前歌曲的答复
发起方：小机
接收方：页面
格式：返回{trackListId:5,trackId:1,type:0} type=0普通列表播放 1点播 2留言
type=1和2时，trackListId保持原值返回

当播放列表改变时,消息: {"changedTrackListId":3}


5)发起方：页面
接收方：小机
格式：
下一首 {cmd:forward}
上一首 {cmd:backward}
暂停 {cmd:pause}
继续播放 {cmd:resume}

6）播放列表设置
发起方：页面
接收方：小机
格式：{cmd:setPlayTrackLists,trackListIds:[3,4,5]}


小机从服务端拿track的信息
{ cmd:getTrackInfo， trackId:xxx}   id为trackid

{"cmd":"getTrackInfo","trackId":7161457}
服务端回复
{cmd:trackInfo,id:xxx,title:xxx,url:xxx,downloadUrl:xxx}

批量询问track信息
{"cmd":"getTrackInfoArray","trackIds":[3,4,5]}
答复
{cmd:trackInfoArray,data:[ {id:xxx,title:xxx,url:xxx,downloadUrl:xxx}]}

小机从服务端拿回传需要的信息
{ cmd:getTrackInfoForCollector， trackId:xxx}   id为trackid
服务端回复
{cmd:trackInfoForCollector,sourceId:xxx,duration:100,customerId:0,appKey:xxx,appSecret:xxx}  sourceId为厂商的资源id


7)页面主动询问播放列表
发起方：页面
接收方：小机
格式：{cmd:getPlayTrackListId}
答复：{playTrackListIds:[3,4,5]}
{"playTrackListIds":[25,26]}


8)播放歌
发起方：页面
接收方：小机
格式：{cmd:playTrack,trackListId:5,trackId:1,url:xxx,downloadUrl:xxx}


9)播放网络上的歌曲
发起方：页面
接收方：小机
格式：{cmd:playTracks,trackIds:[1,2,3]}


14. 留言功能
发起方：服务器
接收方：小机
格式：{cmd:playVoice,url:xxx}

发起方：小机
接收方：服务端
格式：{voiceMediaId:xxx}
{"voiceMediaId":"z7xJObuOFDNZT4HKHAlOMK8KafN32MPFgaBoHQJkONPXR4_AYXNx7OFRwjJTxmhi"}

15.点播
发起方：服务器
接收方：小机
格式：{cmd:demandMusic,voiceUrl:xxx,trackId:5,url:xxx}

开始播放点播
发起方：小机
接收方：服务器
格式：{cmd:startDemandMusic,trackId:5}

在线点播
发起方：服务器
接收方：小机
格式：{cmd:demandMusicOnline,trackId:5,url:xxx}



18.预置功能开发
1）初始化列表
发起方：小机
接收方：服务器
格式：{cmd:initTrackList,trackListId:0,name:xxx,trackIds:[1,2,3]}

{"cmd":"initTrackList","trackListId":0,"name":"国学","trackIds":[1,2,3,4,5]}

2)初始化结果
发起方：服务器
接收方：小机
格式：{cmd: initret,trackListId: 32,name:国学}


3)询问小机初始列表内容
发起方：页面
接收方：小机
格式：{"cmd":"getInitialTrackList","trackListId":32}

4)小机答复初始列表内容
发起方：小机
接收方：服务器
格式：{"cmd":"initialTrackList","trackListId":32,"trackIds":[1,2,3,4,5]}



19.设置播放模式
发起方：页面
接收方：小机
{ cmd:setMode, value:xxx}   xxx为 repeat one，repeat all

主动询问播放模式
发起方：页面
接收方：小机
格式：{ cmd:getMode}

播放模式变化，这里也包括主动询问后的答复
发起方：小机
接收方：页面
格式：{ mode:xxx}

播放表情
{cmd:playVoiceEmoji,voiceUrl:xxx}



OTA升级
{cmd:"upgrade","versionName":"xx","firmwareUrl":"xxx"}


开始升级
发起方：小机
接收方：服务器和页面
格式：{onlineStatus:off-for-upgrade}      （废弃{cmd:"startUpgrade"} ）


5)升级失败后重新上线
发起方：小机
接收方：服务器和页面
格式：{onlineStatus:on-upgrade-failed}    （废弃{upgradeResult:success} success/failed）

网络配置成功后的消息
{"configWifi":"success"}

让设备进入测试模式
{"cmd":"startTestMode","url":"xxx"}

设备测试完回传测试报告
{"cmd":"quitTestMode","content":"xxx"}


页面询问故事机列表内容
{"cmd":"getTracks","trackListId":x} x是大于0的整数（代表普通列表）和-1（代表在线列表）
故事机返回内容
{"cmd":"trackListContent","trackListId":x,"trackIds":[1,2,3]}

*** doc
http://blog.csdn.net/jiesa/article/details/50635222
MQTT Version 3.1.1
http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html
MQTT driver for cl-async
https://github.com/ivan4th/cl-mqtt
cl-async - Asynchronous operations for Common Lisp
http://quickdocs.org/cl-async/
(load "/Users/zhangdongfeng/quicklisp/dists/quicklisp/software/slime-v2.18/contrib/swank-listener-hooks.lisp")
Welcome to the libuv API documentation¶
http://docs.libuv.org/en/v1.x/


https://github.com/eclipse/mosquitto

https://mosquitto.org/download/

transfer-encoding:chunked的含义
http://blog.csdn.net/whatday/article/details/7571451

*** testcode
    (load "/Users/zhangdongfeng/quicklisp/dists/quicklisp/software/slime-v2.18/contrib/swank-listener-hooks.lisp")
    (ql:quickload 'cl-async-repl)
    (as-repl:start-async-repl)


brew services start mosquitto


(defun test-it (host port)
           (bb:alet ((conn (mqtt:connect
                            host
                            :port port
                            :on-message #'(lambda (message)
                                            (format t "~%RECEIVED: ~s~%"
                                                    (babel:octets-to-string
                                                     (mqtt:mqtt-message-payload message)
                                                     :encoding :utf-8))))))
             (bb:walk
               (mqtt:subscribe conn "/a/#")
               (mqtt:subscribe conn "/b/#")
               (mqtt:publish conn "/a/b" "whatever1")
               (mqtt:unsubscribe conn "/a/#")
               (mqtt:publish conn "/a/b" "whatever2")
               (mqtt:publish conn "/b/c" "foobar")
               (as:with-delay (1)
                 (mqtt:disconnect conn))))
           (values))



(test-it "120.76.40.40" 1883 "WWW18_46")
http://we.qq.com/d/
AQCb4nXBUj4HcGMN9ChjHlDCmgaPMjjXDgmNJbz6
WWW18_46

storybox/WWW18_46/server/#
storybox/WWW18_46/client

** 在线播放音乐性能
在线播放音乐测试数据
1、	测试条件
Nbuf及tcp配置：
CONFIG_NET_NBUF_RX_COUNT=18	/* 接收头buf个数 */
CONFIG_NET_NBUF_TX_COUNT=8		/* 发送头buf个数 */
CONFIG_NET_NBUF_DATA_COUNT=18	/* 数据buf个数 */
每一个发送的数据需要一个RX buf和一个 DATA buf；
每个接收的数据包需要一个TX buf和一个DATA buf；
Tcp包长配置，MSS:1460，一个tcp包最大的负载数据长度。
Tcp windown: 1024*3（尝试过加大windown到1024*6，抗网络抖动效果与1024*3没差异）

测试网络：
采用公网接口使用android机子搭建http服务器：112.91.148.197，测试320kbs、192kbps码率

直接播放微信点播的音乐：测试32kbps码率，
http://fdfs.xmcdn.com/group15/M00/10/D7/wKgDZVVmyd2Qz25sAAQlePPVts4468.mp3

2、	在线播放音乐流畅条件
音乐码率（kbps）	每秒需要数据量（Kbyte）	每秒需要tcp包数（个）	每包平均间隔（ms）
32	4	2.8	357
192	24	16.8	59.5
320	40	28	35.7

3、	各种码率的分析
32kbps音乐：
没出现声音卡顿情况，即使使用平板连接相同ap，下载文件（下载速率到400Kbyte/s）
接收分配data buf有5%需要等待，回应ack分配data buf有50%需要等待，多数情况下data buf剩余0~2个，播放时看到最多剩余6个，收到很多非tcp的数据包，recv很多，ack回应很好，表示不是http获取的数据，出现tcp丢包情况也没导致声音卡顿。由于有很多非tcp的数据包，统计的接收包间隔参考性不大。

192kbps音乐：
在没有干扰情况下能流畅播放，制造干扰（平板连接相同ap下载文件，平板连接相同信道的其它ap下载文件，pc通过网线连接相同ap下载文件）会导致声音卡顿。流畅播放时，data buf剩余多为0个，接收、回应ack分配data buf约80%需要等待，等待从50~100ms不等，接收包间隔多数位于50~60ms，当出现多次间隔超100ms，很快就会产生声音卡顿。

320kbsp音乐：
在没有干扰情况下能流畅播放，制造干扰（平板连接相同ap下载文件，平板连接相同信道的其它ap下载文件，pc通过网线连接相同ap下载文件）会导致声音卡顿。流畅播放时，data buf剩余多为0个，接收、回应ack分配data buf约70%需要等待，等待时间多为20~50ms，接收包间隔多数位于20~50ms。

在播放高码率音乐时，在网络流畅情况下，data buf都被音频数据占住，导致网络收发数据需要等待data buf，只要网络流畅，数据包在时间上均匀到达，播放能流程。一旦出现网络延时，丢包，数据包不能及时到达，就会出现声音卡顿。

** WIFI问题
+ airkiss配对时，获取到需要配对的ap及密码后，自动配对过程中出现找不到ap；
+ 连接上ap使用的时候，有时出现自动断开ap的连接；
+ wifi抢占信道资源的使用，资源有限，没能缓存较多数据，当wifi所在信道较多人使用时，wifi接收数据包产生延时，导致在线播放音乐卡顿，最好能增强wifi抢占信道资源的能力；
** code
 void dump_mem(const void *buf, int size)
{
    int i;
    for (i = 0; i < size; i++ ) {
        printk("%02x ",*((unsigned char *)buf + i));
        if (i % 16 == 15) {
            printk("\n");
        }
    }

    printk("\n");
}

** 5118 plus 需求

* 3703
** spec
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749063298B7@srv-mail-02.actions.com.cn][LS370A spec]]
请查收附件最新量产版本以及视频通话P2P开发文档。
[[mu4e:msgid:c29199ddc1534f1aaff425c78118a2ef@hobot.cc][答复: LS370A IOS支持集成准备]]
** TODO [[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F7490625FE93@srv-mail-02.actions.com.cn][请帮忙统一开通下访问权限]]
** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C3A6@srv-mail-02.actions.com.cn][发送电子邮件: LS370A_meminfo分析.xls]]
[[mu4e:msgid:27615070.3131.1495501734427.JavaMail.fwint2@srd-fw-share009][会议记录:关于工业级产品专项的信息进展沟通和讨论]]
** nor 空间
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C3DF@srv-mail-02.actions.com.cn][答复: LS370A_统计nand存储空间分配]]

** 发布tag
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906260D55@srv-mail-02.actions.com.cn][转发: LS370A集成完毕通知（TAG_LS370A_3400_170527）]]
* 代码笔记
** zephyr
*** storyapp
**** sairapp_main_loop
***** _start_sair();
+ netstream = stream_create(TYPE_NET_STREAM,&sair->request);
  + stream = netstream_create(type,parama);
    + stream = mem_malloc(sizeof(struct __stream));
    + k_fifo_init(&stream->netinfo.netbuffifo);
    + http_ctx = &stream->netinfo.http_ctx;
    + http_init(http_ctx);
      + http_ctx->settings.on_body = on_body;
        http_ctx->settings.on_chunk_complete = on_chunk_complete;
        http_ctx->settings.on_chunk_header = on_chunk_header;
        http_ctx->settings.on_headers_complete = on_headers_complete;
        http_ctx->settings.on_header_field = on_header_field;
        http_ctx->settings.on_header_value = on_header_value;
        http_ctx->settings.on_message_begin = on_message_begin;
        http_ctx->settings.on_message_complete = on_message_complete;
        http_ctx->settings.on_status = on_status;
        http_ctx->settings.on_url = on_url;
    + iface = net_if_get_default();
    + rc = tcp_set_local_addr(&http_ctx->tcp_ctx,
    + stream->netinfo.request = request;
      stream->open = netstream_open;
      stream->read = netstream_read;
      stream->seek = netstream_seek;
      stream->tell = netstream_tell;
      stream->write = netstream_write;
      stream->close = netstream_close;
      stream->destroy = netstream_destroy;
+ res = stream_open(netstream, MODE_OUT);
  + http_ctx = &handle->netinfo.http_ctx;
  + http_reset_ctx(http_ctx);
  + rc = http_send_post(http_ctx,handle->netinfo.request);
  + int http_send_request
    + rc = http_parse_url(&parser,request->url,temp_buffer, &port);
      + ret = http_parser_parse_url(url, strlen(url), false,u);
      + net_dns_resolve(ip_addr,&in_addr_t);
        + struct dns_context ctx;
        + dns_init(&ctx);
        + rc = net_context_get(AF_INET, SOCK_DGRAM, IPPROTO_UDP, &net_ctx);
        + iface = net_if_get_default();
        + net_ipaddr_copy(&local_addr.sin_addr, &iface->ipv4.unicast[0].address.in_addr);
        + rc = net_context_bind(net_ctx, (struct sockaddr *)&local_addr,
        + ctx.net_ctx = net_ctx;
          ctx.timeout = APP_SLEEP_MSECS;
          ctx.dns_server = (struct sockaddr *)&dns_server_addr;
          ctx.elements = MAX_ADDRESSES;
          ctx.query_type = DNS_QUERY_TYPE_A;
          ctx.address.ipv4 = addresses;
          ctx.name = name;
        + rc = dns_resolve(&ctx);
          + net_context_recv(ctx->net_ctx, cb_recv, K_NO_WAIT, ctx);
          + rc = dns_msg_pack_qname(&dns_qname->len, dns_qname->data,
          + rc = dns_write(ctx, dns_data, dns_id, dns_qname);
      + net_addr_ntop(AF_INET, &in_addr_t, ip_addr, NET_IPV4_ADDR_LEN);
    + rc = tcp_connect(&http_ctx->tcp_ctx, temp_buffer,port);
      + rc = net_context_get(family, SOCK_STREAM, IPPROTO_TCP, &ctx->net_ctx);
      + rc = net_context_bind(ctx->net_ctx, &ctx->local_sock, addr_len);
      + rc = set_addr(&server_sock, server_addr, server_port);
      + rc = net_context_connect(ctx->net_ctx, &server_sock, addr_len, NULL,
      + net_context_recv(ctx->net_ctx, recv_cb, K_NO_WAIT, ctx))
    + tx = net_nbuf_get_tx(http_ctx->tcp_ctx.net_ctx, K_FOREVER);
    + net_nbuf_append(tx, strlen(request->http_head), (uint8_t *)request->http_head,
    + rc = net_context_send(tx, NULL, http_ctx->tcp_ctx.timeout,
+ audio_recoder_start(netstream,ECODE_TYPE_AMR,8);
  + recordservice_init(stream,enc_type,sample_rate_khz))
    + recorder = (struct record_service_t *)record_service->private_data;
    + recorder->outputstream = stream;
    + recorder->encoder = _encoder_init();
      + struct audio_encoder_t* encoder = create_audio_encoder();
        + encoder->open = encoder_open;
          encoder->generate_head_info = encoder_generate_head_info;
          encoder->frame_encode = encoder_frame_encode;
          encoder->close = encoder_close;
      + res = encoder->open(encoder);
      + static int encoder_open(void* handle)
        + overlay_section_init(OVERLAY_ID_LIBENCAMR);
        + ret = audio_encoder_ops(&encoder->libhandle, AE_CMD_OPEN, (uint32_t)param);
    + recorder->out_buf = mem_malloc(ENCODE_BUFFER_SIZE);
    + recorder->audioin = _audioin_init(sample_rate_khz);
      + struct audioin_handle * audioin = audioin_device_open(sample_rate_khz);
        + audio_in_enable(handle->dev, &ain_setting, &adc_setting);
          + audio_in_init_clk();
          + audio_in_set_gain(adc_setting->gain);
          + audio_in_set_rate(adc_setting->sample_rate);
          + audio_in_enable_ain(ain_setting);
        + audio_in_pcmbuf_config(handle->dev, &pcmbuf_setting);
  + srv_manager_register_service(record_service)
  + record_service->tid = k_thread_spawn(music_share_stack_area, sizeof(music_share_stack_area), recordservice_main_loop,
  + msg.type = MSG_START_RECORD;
  + send_async_msg(APP_ID_eRECORD_SERVICE, &msg);
***** recordservice_main_loop
+ case MSG_START_RECORD:
+ audio_record();
  + struct record_service_t * recorder = (struct record_service_t *)record_service->private_data;
  + struct audioin_handle * audioin = (struct audioin_handle *)recorder->audioin;
  + ret = audioin_start_record(audioin);
    + audio_in_input(audioin->dev,(uint16_t *)audioin->pcm_buf, INTTERN_PCM_BUFFER_SIZE/2);
      + start_adc_dma(pcm_buf, data_cnt);
  + ret = recorder->encoder->generate_head_info(recorder->encoder,recorder->outputstream);
  + while(recorder->running)
  + ret = audioin_get_pcm_data(audioin,&recorder->in_buf,ENCODE_PCM_SIZE);
  + ret = recorder->encoder->frame_encode(recorder->encoder,
  + ret = stream_write(recorder->outputstream,recorder->out_buf,bytes_used);
  + audioin_stop_record(audioin);
  + audioin_device_close(audioin);
+ case MSG_EXIT_APP:
+ recordservice_exit();
***** _stop_and_send_sair();
+ audio_recoder_stop();
  + app_manager_exit_app(APP_ID_RECORD_SERVICE);
+ res = stream_close(netstream);
***** _play_sair_response(&msg);
**** mqtt
***** mqtt_service_start
+ case MSG_WIFI_CONNECT_FINISHED:
+ mqtt_service_start
  + _mqtt_service_init
  + mqtt_service->tid = k_thread_spawn(mqtt_service_stack_area, sizeof(mqtt_service_stack_area), mqttservice_main_loop,
***** mqttservice_main_loop
  + res = get_mqtt_client_id(client_id);
  + get_mqtt_server_addr(server_addr);
  + res = mqtt_open(client_id, server_addr, SRV_PORT);
    + rc = reconnect_mqtt_tcp(&client_ctx.mqtt_ctx.net_ctx, srv_addr, server_port);
    + client_ctx.mqtt_ctx.connect = connect_cb;
      client_ctx.mqtt_ctx.disconnect = disconnect_cb;
      client_ctx.mqtt_ctx.malformed = malformed_cb;
      client_ctx.mqtt_ctx.pingresp = ping_respond_cb;
      client_ctx.mqtt_ctx.publish_tx = publish_tx_cb;
      client_ctx.mqtt_ctx.publish_rx = publish_rx_cb;
    + rc = mqtt_init(&client_ctx.mqtt_ctx, MQTT_APP_PUBLISHER_SUBSCRIBER);
      + (void)net_context_recv(ctx->net_ctx, mqtt_recv, K_NO_WAIT, ctx);
      + case MQTT_APP_PUBLISHER_SUBSCRIBER:
        + ctx->rcv = mqtt_publisher_subscriber_parser;
      + case MQTT_APP_PUBLISHER:
        + ctx->rcv = mqtt_publisher_parser;
      + case MQTT_APP_SUBSCRIBER:
        + ctx->rcv = mqtt_subscriber_parser;
    + k_delayed_work_init(&client_ctx.mqtt_ping_timeout, mqtt_ping_timeout);
      k_delayed_work_init(&client_ctx.mqtt_keep_timeout, mqtt_keep_timeout);
    + rc = try_to_connect(&client_ctx);
      + rc = mqtt_tx_connect(&client_ctx->mqtt_ctx, &client_ctx->connect_msg);
        + rc = mqtt_pack_connect(data->data, &data->len, MSG_SIZE, msg);
        + tx = net_nbuf_get_tx(ctx->net_ctx, ctx->net_timeout);
        + rc = net_context_send(tx, NULL, ctx->net_timeout, NULL, NULL);
  + while switch(msg.type)
    + case MSG_MQTT_MESSAGE_RECEIVED:
    + res = _mqtt_on_message_received(&msg);
    + case MSG_MQTT_MESSAGE_CONNECT:
    + mqtt_on_connect();
    + case MSG_MQTT_SEND_PINGREQ:
    + mqtt_send_ping_request();
    + case MSG_MQTT_SERVICE_RESTART:
***** mqtt_recv
+ mqtt->rcv(mqtt, buf);
+ int mqtt_publisher_subscriber_parser(struct mqtt_ctx *ctx, struct net_buf *rx)
  + data = rx;
  + pkt_type = MQTT_PACKET_TYPE(data->data[0]);
  + switch (pkt_type) {
  + case MQTT_CONNACK:
  + rc = mqtt_rx_connack(ctx, data, ctx->clean_session);
  + case MQTT_PUBLISH:
  + rc = mqtt_rx_publish(ctx, data);
    + rc = mqtt_unpack_publish(rx->data, rx->len, &msg);
    + rc = ctx->publish_rx(ctx, &msg, msg.pkt_id, MQTT_PUBLISH);
    + int publish_rx_cb(struct mqtt_ctx *mqtt_ctx, struct mqtt_publish_msg *msg,
    + notiyf_msg.type = MSG_MQTT_MESSAGE_RECEIVED;
    + send_async_msg(APP_ID_MQTT_SERVICE,&notiyf_msg);
  + case MQTT_PUBREL:
  + rc = mqtt_rx_pubrel(ctx, data);
  + case MQTT_PINGRESP:
  + rc = mqtt_rx_pingresp(ctx, data);
  + case MQTT_SUBACK:
  + rc = mqtt_rx_suback(ctx, data);
  + case MQTT_PUBACK:
  + rc = mqtt_rx_puback(ctx, data);
  + case MQTT_PUBREC:
  + rc = mqtt_rx_pubrec(ctx, data);
  + case MQTT_PUBCOMP:
  + rc = mqtt_rx_pubcomp(ctx, data);
***** _mqtt_on_message_received
+ unpack_message(mqtt_msg->msg, mqtt_msg->msg_len);
  + if (!strcmp(cmd, "playTrack")){
                unpack_play_track(data,length);
        } else if (!strcmp(cmd, "pause")){
                on_receive_command(Pause, (void *)NULL);
        } else if (!strcmp(cmd, "resume")){
                on_receive_command(Resume, (void *)NULL);
        } else if (!strcmp(cmd, "forward")){
                on_receive_command(Next, (void *)NULL);
        } else if (!strcmp(cmd, "backward")){
                on_receive_command(Prev, (void *)NULL);
        } else if (!strcmp(cmd, "setVolume")){
                unpack_set_volume(data, length);
        } else if (!strcmp(cmd, "getVolume")){
                on_receive_command(GetVolume, (void *)NULL);
        } else if (!strcmp(cmd, "setMode")){
                unpack_set_mode(data,length);
        } else if (!strcmp(cmd, "getMode")){
                on_receive_command(GetLoopMode, (void *)NULL);
        } else if (!strcmp(cmd, "getTrack")){
                on_receive_command(GetCurrentTrack, (void *)NULL);
        } else if (!strcmp(cmd, "getBoxInfo")){
                on_receive_command(GetSysInfo, (void *)NULL);
        } else if (!strcmp(cmd, "setPoweroff")){
                on_receive_command(SetPowerOff, (void *)NULL);
        } else if (!strcmp(cmd, "getPlayStatus")){
                on_receive_command(GetPlayStatus, (void *)NULL);
        } else if (!strcmp(cmd, "getOnlineStatus")){
                on_receive_command(GetOnlineStatus, (void *)NULL);
        } else if (!strcmp(cmd, "setPlayTrackLists")){
                unpack_play_list_id(data,length);
        } else if (!strcmp(cmd, "getPlayTrackListId")){
                on_receive_command(GetPlayTrackListId, (void *)NULL);
        } else if (!strcmp(cmd, "playVoice")){
                unpack_play_voice(data, length);
        } else if (!strcmp(cmd, "demandMusic")){
                unpack_demand_music(data, length);
        } else if (!strcmp(cmd, "demandMusicOnline")){
                unpack_demandonline_music(data, length);
        } else if (!strcmp(cmd, "trackInfo")){
                unpack_track_info(data, length);
        } else if (!strcmp(cmd, "trackInfoArray")){
                unpack_track_info_array(data, length);
        } else if (!strcmp(cmd, "initret")){
                unpack_predefine_list_id(data, length);
        } else if (!strcmp(cmd, "setList")){
                unpack_track_list(data, length);
        } else if (!strcmp(cmd, "setUpdateListId")){
                unpack_update_list_id(data, length);
        } else if (!strcmp(cmd, "addList")){
                unpack_add_list_id(data, length);
        } else if (!strcmp(cmd, "delList")){
                unpack_delete_list_id(data, length);
        } else if (!strcmp(cmd, "listAddTrack")){
                unpack_add_track_by_id(data, length);
        } else if (!strcmp(cmd, "listRemoveTrack")){
                unpack_delete_track_by_id(data, length);
        } else if (!strcmp(cmd, "playVoiceEmoji")){
                unpack_play_voice_emoji(data, length);
        } else if (!strcmp(cmd, "upgrade")){
                unpack_upgrade_firmware(data, length);
        } else if (!strcmp(cmd, "trackInfoForCollector")){
                unpack_track_info_for_collector(data, length);
        } else if (!strcmp(cmd, "startTestMode")){
                unpack_test_command(data, length);
        } else if (!strcmp(cmd, "getInitialTrackList")) {
                unpack_get_initial_track_list(data, length);
        } else if (!strcmp(cmd, "playTracks")) {
                unpack_play_tracks(data, length);
        } else if (!strcmp(cmd, "getTracks")){
                unpack_get_tracks_command(data, length);


***** async_publish(char *msg, int len)
+ struct mqtt_publish_msg *pub_msg = &client_ctx.pub_msg;
+ pub_msg->msg = msg;
        pub_msg->msg_len = len;
        pub_msg->qos = client_ctx.qos;
        pub_msg->topic = client_ctx.pub_topic;
        pub_msg->topic_len = strlen(client_ctx.pub_topic);
        pub_msg->pkt_id = sys_rand32_get();
+ rc = mqtt_tx_publish(&client_ctx.mqtt_ctx, &client_ctx.pub_msg);
  + rc = mqtt_pack_publish(data->data, &data->len, data->size, msg);
  + tx = net_nbuf_get_tx(ctx->net_ctx, ctx->net_timeout);
  + rc = net_context_send(tx, NULL, ctx->net_timeout, NULL, NULL);
*** bluetooth
**** doc
***** gatt
Bluetooth Low Energy 介绍 低功耗蓝牙介绍
http://www.cnblogs.com/cb168/articles/4844010.html
***** avdtp
http://blog.sina.com.cn/s/blog_69b5d2a50101elze.html
***** 蓝牙电话本
http://www.eefocus.com/majianhui/blog/09-12/182431_fe385.html
http://www.eefocus.com/majianhui/blog/cate_4037_0.html
***** bluedroid
http://source.android.com/devices/bluetooth.html
http://www.cnblogs.com/hzl6255/p/3887547.html
使用btproxy对蓝牙设备进行安全分析
http://www.freebuf.com/articles/wireless/77389.html
***** spec
http://oscar.iitb.ac.in/onsiteDocumentsDirectory/Bluetooth/Bluetooth/index.html
****** 蓝牙协议的命令和事件
http://blog.csdn.net/zhaohc_nj/article/details/7990695
http://blog.chinaunix.net/uid-21411227-id-2780269.html
http://blog.chinaunix.net/uid-21411227-id-2779815.html
****** baseband
http://www.cnblogs.com/hzl6255/p/3840641.html
The link control layer carries out higher-level operations such as inquiry and paging and manages multiple links with different devices and even different piconets. It does this through a set of state machines, which drive the baseband through the following stages to establish links:
1.      Host requests inquiry.
2.      Inquiry is sent using the inquiry hopping sequence.
3.      Inquiry scanning devices respond to the inquiry scan with FHS packets that contain all the information needed to connect with them.
4.      The contents of the FHS packets are passed back to the host.
5.      The host requests connection to one of the devices that responded to the inquiry.
6.      Paging is used to initiate a connection with the selected device.
7.      If the selected device is page scanning it responds to the page.
8.      If the page-scanning device accepts the connection it will begin hopping using the Master’s frequency hopping sequence and timing.
****** hci
http://www.cnblogs.com/hzl6255/p/3800257.html

Command分为六种类型(case OGF)
~0x01 链路控制命令(Link Control Commands)
~0x02 链路政策命令(Link Policy Commands)
~0x03 控制和基带命令(Control & Baseband Commands)
~0x04 信息命令(Informational Parameters)
~0x05 状态命令(Status Parameters)
~0x06 测试命令(Testing Commands)
~0x3F 厂商调试命令(Reserved)

****** l2cap
http://www.cnblogs.com/hzl6255/p/3801732.html
The Logical Link Control and Adaptation Protocol (L2CAP) takes data from the higher layers of the Bluetooth stack and from applications and sends it over the lower layers of the stack.  L2CAP passes packets either to the Host Controller Interface (HCI), or in a host-less system, L2CAP passes packets directly to the Link Manager.  The following figure shows the L2CAP’s position in the Bluetooth stack.
a)      Multiplexing between different higher layer protocols, allowing them to share lower layer links
b)      Segmentation and reassembly to allow transfer of larger packets than lower layers support
c)      Group management, providing one-way transmission to a group of other Bluetooth devices
d)     Quality of service management for higher layer protocols.
http://oscar.iitb.ac.in/onsiteDocumentsDirectory/Bluetooth/Bluetooth/Help/Logical%20Link%20Control%20and%20Adaptation%20Protocol_files/image008.gif
****** HFP
http://www.cnblogs.com/hzl6255/p/3819113.html
****** RFCOMM
http://www.cnblogs.com/hzl6255/p/3811013.html
****** sdp
http://www.cnblogs.com/hzl6255/p/3826558.html
****** lmp
http://www.cnblogs.com/hzl6255/p/3857353.html
http://article.yeeyan.org/view/jianermei/51468
http://oscar.iitb.ac.in/onsiteDocumentsDirectory/Bluetooth/Bluetooth/Help/Link%20Management%20Protocol.htm
1) Attaching slaves to piconets, and allocating their active member addresses.
2) Breaking connections to detach Slaves from a piconet.
3) Configuring the link including Master/Slave switches
4) Establishing ACL and SCO links.
5) Putting connections into Low Power modes: Hold, Sniff and Park.
6) Controlling test modes.
****** ble
http://www.cnblogs.com/hzl6255/p/4127138.html
******* ll
http://www.cnblogs.com/hzl6255/p/4127403.html
******* gap
http://www.cnblogs.com/hzl6255/p/4133596.html
GAP有如下四个目的
- Profile Role
- 可发现模式和过程
- 连接模式和过程
- 安全模式和过程
******* att
http://www.cnblogs.com/hzl6255/p/4141505.html
Attribute PDUs有六种类型
- Requests      : Client->Server, 请求回应
- Responses     : Server->Client, 响应请求.
- Commands      : Client->Server, 命令
- Notifications : Server->Client, 服务端通知
- Indications   : Server->Client, 请求确认
- Confirmations : Client->Server, Ind确认
******* gatt
http://www.cnblogs.com/hzl6255/p/4158363.html
GATT中最上层是Profile，Profile由一个或多个服务(Service)组成
服务是由Characteristics组成，或是其他服务的引用(Reference)
Characteristic包含一个值(Value)，可能包含该Value的相关信息

GATT中定义了11项Feature
1.  Server Configuration
2.  Primary Service Discovery
3.  Relationship Discovery
4.  Characteristic Discovery
5.  Characteristic Descriptor Discovery
6.  Reading a Characteristic Value
7.  Writing a Characteristic Value
8.  Notification of a Characteristic Value
9.  Indication of a Characteristic Value
10. Reading a Characteristic Descriptor
11. Writing a Characteristic Descriptor
每个Feature都有对应的过程和子过程，这些过程描述了如何使用ATT来实现各自的功能

**** a2dp
***** bt_a2dp_init
+ bt_avdtp_register(&avdtp_cb);
+ static struct bt_avdtp_event_cb avdtp_cb = {
        .ind = &cb_ind,
        .cfm = &cb_cfm
***** bt_avdtp_l2cap_accept
+ static struct bt_l2cap_chan_ops ops = {
  .connected = bt_avdtp_l2cap_connected,
  .disconnected = bt_avdtp_l2cap_disconnected,
  .recv = bt_avdtp_l2cap_recv,

**** handsfree
***** handsfree_enable();
+ static struct bt_hfp_hf_cb hf_cb = {
  .connected = connected,
  .disconnected = disconnected,
+ err = bt_hfp_hf_register(& hf_cb);
  + bt_hf = cb;
+ hfp_hf_init();
  + static struct bt_rfcomm_server chan = {
    .channel = BT_RFCOMM_CHAN_HFP_HF,
    .accept = bt_hfp_hf_accept,
  + bt_rfcomm_server_register(&chan);
    + (rfcomm_server_lookup_channel(server->channel)) {
    + server->_next = servers;
***** bt_hfp_hf_accept(struct bt_conn *conn, struct bt_rfcomm_dlc **dlc)
        + static struct bt_rfcomm_dlc_ops ops = {
          .connected = hfp_hf_connected,
          .disconnected = hfp_hf_disconnected,
          .recv = hfp_hf_recv,
        + struct bt_hfp_hf *hf = &bt_hfp_hf_pool[i];
          hf->at.buf = hf->hf_buffer;
          hf->at.buf_max_len = HF_MAX_BUF_LEN;
          hf->rfcomm_dlc.ops = &ops;
          hf->rfcomm_dlc.mtu = BLUETOOTH_HFP_MAX_MTU;
          *dlc = &hf->rfcomm_dlc;
*****  rfcomm_dlc_connected(dlc);
      + dlc->state = BT_RFCOMM_STATE_CONNECTED;
      + rfcomm_send_msc(dlc, BT_RFCOMM_MSG_CMD_CR);
      + k_thread_spawn(dlc->stack, sizeof(dlc->stack), rfcomm_dlc_tx_thread,
      + dlc->ops->connected(dlc);
      + .connected = hfp_hf_connected,
        + struct bt_hfp_hf *hf = CONTAINER_OF(dlc, struct bt_hfp_hf, rfcomm_dlc);
        + hf_slc_establish(hf);
          + err = hfp_hf_send_cmd(hf, brsf_resp, brsf_finish, "AT+BRSF=%u",
            + at_register(&hf->at, resp, finish);
            + ret = bt_rfcomm_dlc_send(&hf->rfcomm_dlc, buf);
              + net_buf_put(&dlc->tx_queue, buf);
*****  hfp_hf_recv
- at_parse_input(&hf->at, buf)
  + parser_cb[at->state](at, buf);
  + static handle_parse_input_t parser_cb[] = {
  + at_state_start, /* AT_STATE_START */
  + at_state_start_cr, /* AT_STATE_START_CR */
  + at_state_start_lf, /* AT_STATE_START_LF */
  + at_state_get_cmd_string, /* AT_STATE_GET_CMD_STRING */
  + at_state_process_cmd, /* AT_STATE_PROCESS_CMD */
  + at_state_get_result_string, /* AT_STATE_GET_RESULT_STRING */
  + at_state_process_result, /* AT_STATE_PROCESS_RESULT */
  + at_state_unsolicited_cmd /* AT_STATE_UNSOLICITED_CMD */

***** rfcomm_recv
  + struct bt_rfcomm_session *session = RFCOMM_SESSION(chan);
  + dlci = BT_RFCOMM_GET_DLCI(hdr->address);
  + frame_type = BT_RFCOMM_GET_FRAME_TYPE(hdr->control);
  + rfcomm_check_fcs(fcs_len, buf->data, fcs)
  + switch (frame_type) {
  + case BT_RFCOMM_SABM:
  + rfcomm_handle_sabm(session, dlci);
    + dlc = rfcomm_dlcs_lookup_dlci(session->dlcs, dlci);
    + dlc = rfcomm_dlc_accept(session, dlci);
      + channel = BT_RFCOMM_GET_CHANNEL(dlci);
      + server = rfcomm_server_lookup_channel(channel);
      + server->accept(session->br_chan.chan.conn, &dlc) < 0) {
      + static int bt_hfp_hf_accept(struct bt_conn *conn, struct bt_rfcomm_dlc **dlc)
        + static struct bt_rfcomm_dlc_ops ops = {
          .connected = hfp_hf_connected,
          .disconnected = hfp_hf_disconnected,
          .recv = hfp_hf_recv,
        + struct bt_hfp_hf *hf = &bt_hfp_hf_pool[i];
          hf->at.buf = hf->hf_buffer;
          hf->at.buf_max_len = HF_MAX_BUF_LEN;
          hf->rfcomm_dlc.ops = &ops;
          hf->rfcomm_dlc.mtu = BLUETOOTH_HFP_MAX_MTU;
          *dlc = &hf->rfcomm_dlc;
      + rfcomm_dlc_init(dlc, session, dlci, BT_RFCOMM_ROLE_ACCEPTOR);
        + dlc->dlci = dlci;
          dlc->session = session;
          dlc->rx_credit = RFCOMM_DEFAULT_CREDIT;
          dlc->state = BT_RFCOMM_STATE_INIT;
          dlc->role = role;
    + result = rfcomm_dlc_security(dlc);
    + rfcomm_send_ua(session, dlci) < 0) {
      + buf = bt_l2cap_create_pdu(&rfcomm_session_pool, K_FOREVER);
      + cr = BT_RFCOMM_RESP_CR(session->role);
        hdr->address = BT_RFCOMM_SET_ADDR(dlci, cr);
        hdr->control = BT_RFCOMM_SET_CTRL(BT_RFCOMM_UA,
        hdr->length = BT_RFCOMM_SET_LEN_8(0);
    + rfcomm_dlc_connected(dlc);
      + dlc->state = BT_RFCOMM_STATE_CONNECTED;
      + rfcomm_send_msc(dlc, BT_RFCOMM_MSG_CMD_CR);
      + k_thread_spawn(dlc->stack, sizeof(dlc->stack), rfcomm_dlc_tx_thread,
      + dlc->ops->connected(dlc);
      + .connected = hfp_hf_connected,
        + struct bt_hfp_hf *hf = CONTAINER_OF(dlc, struct bt_hfp_hf, rfcomm_dlc);
        + hf_slc_establish(hf);
          + err = hfp_hf_send_cmd(hf, brsf_resp, brsf_finish, "AT+BRSF=%u",
            + at_register(&hf->at, resp, finish);
            + ret = bt_rfcomm_dlc_send(&hf->rfcomm_dlc, buf);
              + net_buf_put(&dlc->tx_queue, buf);
  + case BT_RFCOMM_UIH:
    + rfcomm_handle_msg(session, buf);
    + rfcomm_handle_data(session, buf, dlci,
      + dlc = rfcomm_dlcs_lookup_dlci(session->dlcs, dlci);
      + dlc->ops->recv(dlc, buf);
      + static void hfp_hf_recv(struct bt_rfcomm_dlc *dlc, struct net_buf *buf)
  + case BT_RFCOMM_DISC:
    + rfcomm_handle_disc(session, dlci);
  + case BT_RFCOMM_UA:
    + rfcomm_handle_ua(session, dlci);
  + case BT_RFCOMM_DM:
    + rfcomm_handle_dm(session, dlci);
***** rfcomm_accept
+ session = rfcomm_session_new(BT_RFCOMM_ROLE_ACCEPTOR);
  + static struct bt_l2cap_chan_ops ops = {
    .connected = rfcomm_connected,
    .disconnected = rfcomm_disconnected,
    .recv = rfcomm_recv,
    .encrypt_change = rfcomm_encrypt_change,
  + struct bt_rfcomm_session *session = &bt_rfcomm_pool[i];
  + session->br_chan.chan.ops = &ops;
    session->br_chan.rx.mtu	= CONFIG_BLUETOOTH_RFCOMM_L2CAP_MTU;
    session->state = BT_RFCOMM_STATE_INIT;
    session->role = role;

***** bt_l2cap_br_connected
+ if (fchan->accept(conn, &chan) < 0) {
+ rfcomm_accept
  + session = rfcomm_session_new(BT_RFCOMM_ROLE_ACCEPTOR);
    + static struct bt_l2cap_chan_ops ops = {
      .connected = rfcomm_connected,
      .disconnected = rfcomm_disconnected,
      .recv = rfcomm_recv,
      .encrypt_change = rfcomm_encrypt_change,
    + struct bt_rfcomm_session *session = &bt_rfcomm_pool[i];
    + session->br_chan.chan.ops = &ops;
      session->br_chan.rx.mtu	= CONFIG_BLUETOOTH_RFCOMM_L2CAP_MTU;
      session->state = BT_RFCOMM_STATE_INIT;
      session->role = role;
  + l2cap_br_chan_add(conn, chan, NULL)
    + struct bt_l2cap_br_chan *ch = l2cap_br_chan_alloc_cid(conn, chan);
    + bt_l2cap_chan_add(conn, chan, destroy);
  + connect_fixed_channel(ch);
    + chan->chan.ops->connected(&chan->chan);
    + rfcomm_connected
      + rfcomm_send_sabm(session, 0);
*****  bt_l2cap_br_recv(struct bt_conn *conn, struct net_buf *buf)
+ cid = sys_le16_to_cpu(hdr->cid);
+ chan = bt_l2cap_br_lookup_rx_cid(conn, cid);
+ check_fixed_channel(chan);
+ chan->ops->recv(chan, buf);
+ rfcomm_recv,
  + struct bt_rfcomm_session *session = RFCOMM_SESSION(chan);
  + dlci = BT_RFCOMM_GET_DLCI(hdr->address);
  + frame_type = BT_RFCOMM_GET_FRAME_TYPE(hdr->control);
  + rfcomm_check_fcs(fcs_len, buf->data, fcs)
  + switch (frame_type) {
  + case BT_RFCOMM_SABM:
  + rfcomm_handle_sabm(session, dlci);
    + dlc = rfcomm_dlcs_lookup_dlci(session->dlcs, dlci);
    + dlc = rfcomm_dlc_accept(session, dlci);
      + channel = BT_RFCOMM_GET_CHANNEL(dlci);
      + server = rfcomm_server_lookup_channel(channel);
      + server->accept(session->br_chan.chan.conn, &dlc) < 0) {
      + static int bt_hfp_hf_accept(struct bt_conn *conn, struct bt_rfcomm_dlc **dlc)
        + static struct bt_rfcomm_dlc_ops ops = {
          .connected = hfp_hf_connected,
          .disconnected = hfp_hf_disconnected,
          .recv = hfp_hf_recv,
        + struct bt_hfp_hf *hf = &bt_hfp_hf_pool[i];
          hf->at.buf = hf->hf_buffer;
          hf->at.buf_max_len = HF_MAX_BUF_LEN;
          hf->rfcomm_dlc.ops = &ops;
          hf->rfcomm_dlc.mtu = BLUETOOTH_HFP_MAX_MTU;
          *dlc = &hf->rfcomm_dlc;
      + rfcomm_dlc_init(dlc, session, dlci, BT_RFCOMM_ROLE_ACCEPTOR);
        + dlc->dlci = dlci;
          dlc->session = session;
          dlc->rx_credit = RFCOMM_DEFAULT_CREDIT;
          dlc->state = BT_RFCOMM_STATE_INIT;
          dlc->role = role;
    + result = rfcomm_dlc_security(dlc);
    + rfcomm_send_ua(session, dlci) < 0) {
      + buf = bt_l2cap_create_pdu(&rfcomm_session_pool, K_FOREVER);
      + cr = BT_RFCOMM_RESP_CR(session->role);
        hdr->address = BT_RFCOMM_SET_ADDR(dlci, cr);
        hdr->control = BT_RFCOMM_SET_CTRL(BT_RFCOMM_UA,
        hdr->length = BT_RFCOMM_SET_LEN_8(0);
    + rfcomm_dlc_connected(dlc);
      + dlc->state = BT_RFCOMM_STATE_CONNECTED;
      + rfcomm_send_msc(dlc, BT_RFCOMM_MSG_CMD_CR);
      + k_thread_spawn(dlc->stack, sizeof(dlc->stack), rfcomm_dlc_tx_thread,
      + dlc->ops->connected(dlc);
      + .connected = hfp_hf_connected,
        + struct bt_hfp_hf *hf = CONTAINER_OF(dlc, struct bt_hfp_hf, rfcomm_dlc);
        + hf_slc_establish(hf);
          + err = hfp_hf_send_cmd(hf, brsf_resp, brsf_finish, "AT+BRSF=%u",
            + at_register(&hf->at, resp, finish);
            + ret = bt_rfcomm_dlc_send(&hf->rfcomm_dlc, buf);
              + net_buf_put(&dlc->tx_queue, buf);
  + case BT_RFCOMM_UIH:
    + rfcomm_handle_msg(session, buf);
    + rfcomm_handle_data(session, buf, dlci,
  + case BT_RFCOMM_DISC:
    + rfcomm_handle_disc(session, dlci);
  + case BT_RFCOMM_UA:
    + rfcomm_handle_ua(session, dlci);
  + case BT_RFCOMM_DM:
    + rfcomm_handle_dm(session, dlci);

***** bt_rfcomm_init
+ static struct bt_l2cap_server server = {
               .psm       = BT_L2CAP_PSM_RFCOMM,
               .accept    = rfcomm_accept,
               .sec_level = BT_SECURITY_LOW,
+ bt_l2cap_br_server_register(&server);

**** gap/gatt
***** doc
Bluetooth Low Energy 介绍 低功耗蓝牙介绍
http://www.cnblogs.com/cb168/articles/4844010.html

|ANP| Alert Notification Profile|
| ANS| Alert Notification Service|
| BAS| Battery Service|
| BLP| Blood Pressure Profile|
| BLS| Blood Pressure Service|
| CPP| Cycling Power Profile|
| CPS| Cycling Power Service|
| CSCP| Cycling Speed and Cadence Profile|
| CSCS| Cycling Speed and Cadence Service|
| CTS| Current Time Service|
| DIS| Device Information Service|
| FMP| Find Me Profile|
| GLP| Glucose Profile|
|HIDS| HID Service|
| HOGP| HID over GATT Profile|
| HTP| Health Thermometer Profile|
| HTS| Health Thermometer Service|
| HRP| Heart Rate Profile|
| HRS| Heart Rate Service|
| IAS| Immediate Alert Service|
| LLS| Link Loss Service|
| LNP| Location and Navigation Profile|
| LNS| Location and Navigation Service|
| NDCS| Next DST Change Service|
| PASP| Phone Alert Status Profile|
| PASS| Phone Alert Status Service|
| PXP| Proximity Profile|
| RSCP| Running Speed and Cadence Profile|
| RSCS| Running Speed and Cadence Service|
|RTUS| Reference Time Update Service|
| ScPP| Scan Parameters Profile|
| ScPS| Scan Parameters Service|
| TIP| Time Profile|
| TPS| Tx Power Service |
***** peripheral_hids/main
+ gap_init(DEVICE_NAME, HOG_APPEARANCE);
  + gap_name = name;
  + gap_appearance = appearance;
  + bt_gatt_register(attrs, ARRAY_SIZE(attrs));
    + int bt_gatt_register(struct bt_gatt_attr *attrs, size_t count)
    + static struct bt_gatt_attr *db;
    + db = attrs;
    + attrs->handle = ++handle;
+ bas_init();
  + bt_gatt_register(attrs, ARRAY_SIZE(attrs));
+ dis_init(CONFIG_SOC, "Manufacturer");
  + bt_gatt_register(attrs, ARRAY_SIZE(attrs));
+ hog_init();
***** bt_att_accept
+       static struct bt_l2cap_chan_ops ops = {
   .connected = bt_att_connected,
   .disconnected = bt_att_disconnected,
   .recv = bt_att_recv,
+ for (i = 0; i < ARRAY_SIZE(bt_req_pool); i++) {
+ att->chan.chan.ops = &ops;
+ *chan = &att->chan.chan;
***** bt_att_connected
+ bt_gatt_connected(ch->chan.conn);
  + bt_gatt_foreach_attr(0x0001, 0xffff, connected_cb, conn);
    + for (attr = db; attr; attr = bt_gatt_attr_next(attr)) {
    + if (func(attr, user_data) == BT_GATT_ITER_STOP) {
      + static uint8_t connected_cb(const struct bt_gatt_attr *attr, void *user_data)
***** bt_att_recv
+ for (i = 0; i < ARRAY_SIZE(handlers); i++) {
+ err = handlers[i].func(att, buf);
****** handlers
static const struct {
        uint8_t  op;
        uint8_t  (*func)(struct bt_att *att, struct net_buf *buf);
        uint8_t  expect_len;
} handlers[] = {
+ { BT_ATT_OP_ERROR_RSP, att_error_rsp,
+ { BT_ATT_OP_MTU_REQ, att_mtu_req,
+ { BT_ATT_OP_MTU_RSP, att_mtu_rsp,
+ { BT_ATT_OP_FIND_INFO_REQ, att_find_info_req,
+ { BT_ATT_OP_FIND_INFO_RSP, att_handle_find_info_rsp,
+ { BT_ATT_OP_FIND_TYPE_REQ, att_find_type_req,
+ { BT_ATT_OP_FIND_TYPE_RSP, att_handle_find_type_rsp,
+ { BT_ATT_OP_READ_TYPE_REQ, att_read_type_req,
+ { BT_ATT_OP_READ_TYPE_RSP, att_handle_read_type_rsp,
****** { BT_ATT_OP_READ_REQ, att_read_req,
  + handle = sys_le16_to_cpu(req->handle);
  + att_read_rsp(att, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
  + struct read_data data;
  + data.buf = bt_att_create_pdu(conn, rsp, 0);
  + data.att = att;
    data.offset = offset;
  + bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    + static uint8_t read_cb(const struct bt_gatt_attr *attr, void *user_data)
    + data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
    + data->err = check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
    + read = attr->read(conn, attr, data->buf->data + data->buf->len,
    + net_buf_add(data->buf, read);
  + bt_l2cap_send(conn, BT_L2CAP_CID_ATT, data.buf);
+ { BT_ATT_OP_READ_RSP, att_handle_read_rsp,
+ { BT_ATT_OP_READ_BLOB_REQ, att_read_blob_req,
+ { BT_ATT_OP_READ_BLOB_RSP, att_handle_read_blob_rsp,
+ { BT_ATT_OP_READ_MULT_REQ, att_read_mult_req,
+ { BT_ATT_OP_READ_MULT_RSP, att_handle_read_mult_rsp,
+ { BT_ATT_OP_READ_GROUP_REQ, att_read_group_req,
+ { BT_ATT_OP_WRITE_REQ, att_write_req,
+ { BT_ATT_OP_WRITE_RSP, att_handle_write_rsp, 0 },
+ { BT_ATT_OP_PREPARE_WRITE_REQ, att_prepare_write_req,
+ { BT_ATT_OP_PREPARE_WRITE_RSP, att_handle_prepare_write_rsp,
+ { BT_ATT_OP_EXEC_WRITE_REQ, att_exec_write_req,
+ { BT_ATT_OP_EXEC_WRITE_RSP, att_handle_exec_write_rsp, 0 },
+ { BT_ATT_OP_NOTIFY, att_notify,
+ { BT_ATT_OP_INDICATE, att_indicate,
+ { BT_ATT_OP_CONFIRM, att_confirm, 0 },
+ { BT_ATT_OP_WRITE_CMD, att_write_cmd,
+ { BT_ATT_OP_SIGNED_WRITE_CMD, att_signed_write_cmd,
**** beacon
+ main
  + bt_enable(bt_ready);
  +

**** hci_core
***** doc
蓝牙核心技术概述（四）：蓝牙协议规范（HCI、L2CAP、SDP、RFOCMM）
http://blog.csdn.net/xubin341719/article/details/38305331
***** bt_enable
+ struct bt_dev bt_dev = {
        .ncmd_sem      = K_SEM_INITIALIZER(bt_dev.ncmd_sem, 1, 1),
        .cmd_tx_queue  = K_FIFO_INITIALIZER(bt_dev.cmd_tx_queue),
        .rx_queue      = K_FIFO_INITIALIZER(bt_dev.rx_queue),

+ bt_enable(bt_ready);
  + k_thread_spawn(cmd_tx_thread_stack, sizeof(cmd_tx_thread_stack),
                     (k_thread_entry_t)hci_cmd_tx_thread, NULL, NULL, NULL,
  + k_thread_spawn(rx_thread_stack, sizeof(rx_thread_stack),
                    (k_thread_entry_t)hci_rx_thread, cb, NULL, NULL,

***** bt_hci_cmd_send_sync
int bt_hci_cmd_send_sync(uint16_t opcode, struct net_buf *buf,
+ buf = bt_hci_cmd_create(opcode, 0);
  + buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
  + cmd(buf)->type = BT_BUF_CMD;
        cmd(buf)->opcode = opcode;
        cmd(buf)->sync = NULL;
        hdr = net_buf_add(buf, sizeof(*hdr));
        hdr->opcode = sys_cpu_to_le16(opcode);
        hdr->param_len = param_len;
+ k_sem_init(&sync_sem, 0, 1);
        cmd(buf)->sync = &sync_sem;
+ net_buf_put(&bt_dev.cmd_tx_queue, buf);
+ k_sem_take(&sync_sem, K_FOREVER);
***** bt_conn_init();
    + bt_att_init();
      + static struct bt_l2cap_fixed_chan chan = {
         .cid		= BT_L2CAP_CID_ATT,
         .accept		= bt_att_accept,
      + bt_l2cap_le_fixed_chan_register(&chan);
        + chan->_next = le_channels;
        + channels = chan;
    + bt_smp_init();
      + static struct bt_l2cap_fixed_chan chan = {
            .cid		= BT_L2CAP_CID_SMP,
            .accept		= bt_smp_accept,
      + bt_l2cap_le_fixed_chan_register(&chan);
      + static struct bt_l2cap_fixed_chan br_chan = {
                    .cid		= BT_L2CAP_CID_BR_SMP,
                    .accept		= bt_smp_br_accept,
      + bt_l2cap_br_fixed_chan_register(&br_chan);
      + static struct bt_pub_key_cb pub_key_cb = {
            .func           = bt_smp_pkey_ready,
      + bt_pub_key_gen(&pub_key_cb);
        + new_cb->_next = pub_key_cb;
        + pub_key_cb = new_cb;
        + bt_hci_cmd_send_sync(BT_HCI_OP_LE_P256_PUBLIC_KEY, NULL, NULL);
        + cb->func(NULL);
    + bt_l2cap_init();
      + static struct bt_l2cap_fixed_chan chan = {
            .cid	= BT_L2CAP_CID_LE_SIG,
            .accept	= l2cap_accept,
      + bt_l2cap_le_fixed_chan_register(&chan);
      + bt_l2cap_br_init();
        + static struct bt_l2cap_fixed_chan chan_br = {
                    .cid	= BT_L2CAP_CID_BR_SIG,
                    .accept = l2cap_br_accept,
        + bt_l2cap_br_fixed_chan_register(&chan_br);
        + bt_rfcomm_init();
          + static struct bt_l2cap_server server = {
           .psm       = BT_L2CAP_PSM_RFCOMM,
           .accept    = rfcomm_accept,
           .sec_level = BT_SECURITY_LOW,
          + bt_l2cap_br_server_register(&server);
            + l2cap_br_server_lookup_psm(server->psm)
            + server->_next = br_servers;
            + br_servers = server;
        + bt_avdtp_init();
          + static struct bt_l2cap_server avdtp_l2cap = {
             .psm = BT_L2CAP_PSM_AVDTP,
             .sec_level = BT_SECURITY_MEDIUM,
             .accept = bt_avdtp_l2cap_accept,
          + bt_l2cap_br_server_register(&avdtp_l2cap);
        + bt_sdp_init();
          + static struct bt_l2cap_server server = {
              .psm = SDP_PSM,
              .accept = bt_sdp_accept,
          + bt_l2cap_br_server_register(&server);
        + bt_a2dp_init();
          + bt_avdtp_register(& avdtp_cb);
            + event_cb = cb;
    + background_scan_init();
***** hci_rx_thread
  + static void hci_rx_thread(bt_ready_cb_t ready_cb)
    + ready_cb(bt_init());//用户回调
      + static int bt_init(void)
        + bt_hci_ecc_init();
        + err = drv->open();
          + static int h4_open(void)
        + err = hci_init();
          + common_init();
            + bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
            + hci_reset_complete(rsp);
              + atomic_set(bt_dev.flags, BIT(BT_DEV_ENABLE));
            + prng_init(&prng);
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
            + read_local_features_complete(rsp);
              + struct bt_hci_rp_read_local_features *rp = (void *)buf->data;
              + memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
            + read_local_ver_complete(rsp);
              + bt_dev.hci_version = rp->hci_version;
              + bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
              + bt_dev.lmp_version = rp->lmp_version;
              + bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
              + bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
            + read_bdaddr_complete(rsp);
              + bt_addr_copy(&bt_dev.id_addr.a, &rp->bdaddr);
              + bt_dev.id_addr.type = BT_ADDR_LE_PUBLIC;
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
            + set_flow_control();
              + bt_hci_cmd_create(BT_HCI_OP_HOST_BUFFER_SIZE,
              + struct bt_hci_cp_host_buffer_size *hbs;
              + hbs->acl_amtu = sys_cpu_to_le16(CONFIG_BLUETOOTH_L2CAP_IN_MTU +
              + hbs->acl_pkts = sys_cpu_to_le16(CONFIG_BLUETOOTH_ACL_IN_COUNT);
              + err = bt_hci_cmd_send_sync(BT_HCI_OP_HOST_BUFFER_SIZE, buf, NULL);
              + buf = bt_hci_cmd_create(BT_HCI_OP_SET_CTL_TO_HOST_FLOW, 1);
          + le_init();
            + bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
            + read_le_features_complete(rsp);
              + struct bt_hci_rp_le_read_local_features *rp = (void *)buf->data;
              + memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
            + bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE, NULL, &rsp);
            + le_read_buffer_size_complete(rsp);
              + bt_dev.le.mtu = sys_le16_to_cpu(rp->le_max_len);
              + k_sem_init(&bt_dev.le.pkts, rp->le_max_num, rp->le_max_num);
            + if (BT_FEAT_BREDR(bt_dev.features)) {
              + bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
            + bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
            + bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
              + struct bt_hci_cp_le_set_event_mask *cp_mask;
            + bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
          + br_init();
            + bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &buf);
            + read_buffer_size_complete(buf);
              + bt_dev.br.mtu = sys_le16_to_cpu(rp->acl_max_len);
              + k_sem_init(&bt_dev.br.pkts, pkts, pkts);
            + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_SSP_MODE, buf, NULL);
            + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_INQUIRY_MODE, buf, NULL);
            + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_LOCAL_NAME, buf, NULL);
            + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_PAGE_TIMEOUT, buf, NULL);
            + if (BT_FEAT_SC(bt_dev.features)) {
              + bt_hci_cmd_send_sync(BT_HCI_OP_WRITE_SC_HOST_SUPP, buf,
          + set_static_addr();
            + bt_storage->read(NULL, BT_STORAGE_ID_ADDR,
            + bt_addr_le_create_static(&bt_dev.id_addr);
              + create_random_addr(addr);
              + BT_ADDR_SET_STATIC(&addr->a);
            + set_random_address(&bt_dev.id_addr.a);
              + bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
          + show_dev_info();
        + err = bt_conn_init();
          + bt_att_init();
            + static struct bt_l2cap_fixed_chan chan = {
               .cid		= BT_L2CAP_CID_ATT,
               .accept		= bt_att_accept,
            + bt_l2cap_le_fixed_chan_register(&chan);
              + chan->_next = le_channels;
              + channels = chan;
          + bt_smp_init();
            + static struct bt_l2cap_fixed_chan chan = {
                  .cid		= BT_L2CAP_CID_SMP,
                  .accept		= bt_smp_accept,
            + bt_l2cap_le_fixed_chan_register(&chan);
            + static struct bt_l2cap_fixed_chan br_chan = {
                          .cid		= BT_L2CAP_CID_BR_SMP,
                          .accept		= bt_smp_br_accept,
            + bt_l2cap_br_fixed_chan_register(&br_chan);
            + static struct bt_pub_key_cb pub_key_cb = {
                  .func           = bt_smp_pkey_ready,
            + bt_pub_key_gen(&pub_key_cb);
              + new_cb->_next = pub_key_cb;
              + pub_key_cb = new_cb;
              + bt_hci_cmd_send_sync(BT_HCI_OP_LE_P256_PUBLIC_KEY, NULL, NULL);
              + cb->func(NULL);
          + bt_l2cap_init();
            + static struct bt_l2cap_fixed_chan chan = {
                  .cid	= BT_L2CAP_CID_LE_SIG,
                  .accept	= l2cap_accept,
            + bt_l2cap_le_fixed_chan_register(&chan);
            + bt_l2cap_br_init();
              + static struct bt_l2cap_fixed_chan chan_br = {
                          .cid	= BT_L2CAP_CID_BR_SIG,
                          .accept = l2cap_br_accept,
              + bt_l2cap_br_fixed_chan_register(&chan_br);
              + bt_rfcomm_init();
                + static struct bt_l2cap_server server = {
                 .psm       = BT_L2CAP_PSM_RFCOMM,
                 .accept    = rfcomm_accept,
                 .sec_level = BT_SECURITY_LOW,
                + bt_l2cap_br_server_register(&server);
                  + l2cap_br_server_lookup_psm(server->psm)
                  + server->_next = br_servers;
                  + br_servers = server;
              + bt_avdtp_init();
                + static struct bt_l2cap_server avdtp_l2cap = {
                   .psm = BT_L2CAP_PSM_AVDTP,
                   .sec_level = BT_SECURITY_MEDIUM,
                   .accept = bt_avdtp_l2cap_accept,
                + bt_l2cap_br_server_register(&avdtp_l2cap);
              + bt_sdp_init();
                + static struct bt_l2cap_server server = {
                    .psm = SDP_PSM,
                    .accept = bt_sdp_accept,
                + bt_l2cap_br_server_register(&server);
              + bt_a2dp_init();
                + bt_avdtp_register(& avdtp_cb);
                  + event_cb = cb;
          + background_scan_init();
        + bt_monitor_send(BT_MONITOR_OPEN_INDEX, NULL, 0);
          + bt_le_scan_update(false);
    + while (1) {
      + buf = net_buf_get(&bt_dev.rx_queue, K_FOREVER);
      + case BT_BUF_ACL_IN:
        + hci_acl(buf);
          + handle = sys_le16_to_cpu(hdr->handle);
          + conn = bt_conn_lookup_handle(acl(buf)->handle);
            + for (i = 0; i < ARRAY_SIZE(conns); i++) {
              + return bt_conn_ref(&conns[i]);
          + bt_conn_recv(conn, buf, flags);
            + memcpy(net_buf_add(conn->rx, buf->len), buf->data, buf->len);
                conn->rx_len -= buf->len;
            + bt_l2cap_recv(conn, buf);
              + if (conn->type == BT_CONN_TYPE_BR) {
                bt_l2cap_br_recv(conn, buf);
              + cid = sys_le16_to_cpu(hdr->cid);
              + chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
              + l2cap_chan_recv(chan, buf);
                + if (L2CAP_LE_CID_IS_DYN(ch->rx.cid)) {
                  + l2cap_chan_le_recv(ch, buf);
                + chan->ops->recv(chan, buf);
      + case BT_BUF_EVT:
        + hci_event(buf);
***** l2cap_chan_le_recv
+ chan->_sdu = chan->chan.ops->alloc_buf(&chan->chan);
+ bt_l2cap_chan_disconnect(&chan->chan);
+ chan->chan.ops->recv(&chan->chan, chan->_sdu);
***** hci_acl
 + hci_acl(buf);
   + handle = sys_le16_to_cpu(hdr->handle);
     + conn = bt_conn_lookup_handle(acl(buf)->handle);
       + for (i = 0; i < ARRAY_SIZE(conns); i++) {
         + return bt_conn_ref(&conns[i]);
     + bt_conn_recv(conn, buf, flags);
       + memcpy(net_buf_add(conn->rx, buf->len), buf->data, buf->len);
           conn->rx_len -= buf->len;
       + bt_l2cap_recv(conn, buf);
         + if (conn->type == BT_CONN_TYPE_BR) {
         + bt_l2cap_br_recv(conn, buf);
           + check_fixed_channel(chan);
             + if (br_chan->rx.cid < L2CAP_BR_CID_DYN_START) {
             + connect_fixed_channel(br_chan);
               + chan->chan.ops->connected(&chan->chan);
           + chan->ops->recv(chan, buf);
         + cid = sys_le16_to_cpu(hdr->cid);
         + chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
         + l2cap_chan_recv(chan, buf);
           + if (L2CAP_LE_CID_IS_DYN(ch->rx.cid)) {
             + l2cap_chan_le_recv(ch, buf);
           + chan->ops->recv(chan, buf);
             + .recv = l2cap_recv,
***** le_conn_req
  + le_conn_req(l2cap, hdr->ident, buf);
    + psm = sys_le16_to_cpu(req->psm);
      scid = sys_le16_to_cpu(req->scid);
      mtu = sys_le16_to_cpu(req->mtu);
      mps = sys_le16_to_cpu(req->mps);
      credits = sys_le16_to_cpu(req->credits);
    + server = l2cap_server_lookup_psm(psm);
    + if (conn->sec_level < server->sec_level) {
    + if (server->accept(conn, &chan) < 0) { //server
    + l2cap_chan_add(conn, chan, l2cap_chan_destroy)
      + struct bt_l2cap_le_chan *ch = l2cap_chan_alloc_cid(conn, chan);
      + bt_l2cap_chan_add(conn, chan, destroy);
    + l2cap_chan_tx_init(ch);
        ch->tx.cid = scid;
        ch->tx.mps = mps;
        ch->tx.mtu = mtu;
        l2cap_chan_tx_give_credits(ch, credits);
        l2cap_chan_rx_init(ch);
        l2cap_chan_rx_give_credits(ch, L2CAP_LE_MAX_CREDITS);
        chan->psm = server->psm;
    + bt_l2cap_chan_set_state(chan, BT_L2CAP_CONNECTED);
      + chan->state = state;
    + if (chan->ops && chan->ops->connected) {
                        chan->ops->connected(chan); //server
    + bt_l2cap_send(conn, BT_L2CAP_CID_LE_SIG, buf);

***** l2cap_recv(struct bt_l2cap_chan *chan, struct net_buf *buf)
+ case BT_L2CAP_CONN_PARAM_RSP:
  + le_conn_param_rsp(l2cap, buf);
+ case BT_L2CAP_CONN_PARAM_REQ:
  + le_conn_param_update_req(l2cap, hdr->ident, buf);
+ case BT_L2CAP_LE_CONN_REQ:
  + le_conn_req(l2cap, hdr->ident, buf);
    + psm = sys_le16_to_cpu(req->psm);
      scid = sys_le16_to_cpu(req->scid);
      mtu = sys_le16_to_cpu(req->mtu);
      mps = sys_le16_to_cpu(req->mps);
      credits = sys_le16_to_cpu(req->credits);
    + server = l2cap_server_lookup_psm(psm);
    + if (conn->sec_level < server->sec_level) {
    + if (server->accept(conn, &chan) < 0) {
    + l2cap_chan_add(conn, chan, l2cap_chan_destroy)
      + struct bt_l2cap_le_chan *ch = l2cap_chan_alloc_cid(conn, chan);
      + bt_l2cap_chan_add(conn, chan, destroy);
    + l2cap_chan_tx_init(ch);
        ch->tx.cid = scid;
        ch->tx.mps = mps;
        ch->tx.mtu = mtu;
        l2cap_chan_tx_give_credits(ch, credits);
        l2cap_chan_rx_init(ch);
        l2cap_chan_rx_give_credits(ch, L2CAP_LE_MAX_CREDITS);
        chan->psm = server->psm;
    + bt_l2cap_chan_set_state(chan, BT_L2CAP_CONNECTED);
      + chan->state = state;
    + if (chan->ops && chan->ops->connected) {
                        chan->ops->connected(chan); //server
    + bt_l2cap_send(conn, BT_L2CAP_CID_LE_SIG, buf);
+ case BT_L2CAP_LE_CONN_RSP:
  + le_conn_rsp(l2cap, hdr->ident, buf);
+ case BT_L2CAP_DISCONN_REQ:
  + le_disconn_req(l2cap, hdr->ident, buf);
+ case BT_L2CAP_DISCONN_RSP:
  + le_disconn_rsp(l2cap, hdr->ident, buf);
+ case BT_L2CAP_LE_CREDITS:
  + le_credits(l2cap, hdr->ident, buf);
+ case BT_L2CAP_CMD_REJECT:
  + reject_cmd(l2cap, hdr->ident, buf);
***** le_conn_complete
     + le_conn_complete(buf);
       + id_addr = find_id_addr(&evt->peer_addr);
       + conn = bt_conn_lookup_state_le(id_addr, BT_CONN_CONNECT);
       + atomic_clear_bit(bt_dev.flags, BT_DEV_ADVERTISING);
       + conn->handle   = handle;
         bt_addr_le_copy(&conn->le.dst, id_addr);
         conn->le.interval = sys_le16_to_cpu(evt->interval);
         conn->le.latency = sys_le16_to_cpu(evt->latency);
         conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
         conn->role = evt->role;
       + if (conn->role == BT_HCI_ROLE_SLAVE) {
         bt_addr_le_copy(&conn->le.init_addr, &evt->peer_addr);
         bt_addr_le_copy(&conn->le.resp_addr, &bt_dev.id_addr);
       + bt_conn_set_state(conn, BT_CONN_CONNECTED);
         + case BT_CONN_CONNECTED:
         + k_fifo_init(&conn->tx_queue);
         + k_thread_spawn(conn->stack, sizeof(conn->stack), conn_tx_thread,
         + bt_l2cap_connected(conn);
           + fchan = le_channels;
           + if (fchan->accept(conn, &chan) < 0) {
             + .accept	= l2cap_accept,// channel
               + static struct bt_l2cap_chan_ops ops = {
                 .connected = l2cap_connected,
                 .disconnected = l2cap_disconnected,
                 .recv = l2cap_recv,
               + l2cap->chan.chan.ops = &ops;
                 *chan = &l2cap->chan.chan;
           + l2cap_chan_add(conn, chan, NULL)
             + struct bt_l2cap_le_chan *ch = l2cap_chan_alloc_cid(conn, chan);
             + bt_l2cap_chan_add(conn, chan, destroy);
           + chan->ops->connected(chan);
             + l2cap_connected(struct bt_l2cap_chan *chan)
         + notify_connected(conn);
           + for (cb = callback_list; cb; cb = cb->_next) {
             + cb->connected(conn, conn->err);
***** hci_event
        + br/edr
          + case BT_HCI_EVT_CONN_REQUEST:
                  conn_req(buf);
          + case BT_HCI_EVT_CONN_COMPLETE:
                  conn_complete(buf);
          + case BT_HCI_EVT_PIN_CODE_REQ:
                  pin_code_req(buf);
          + case BT_HCI_EVT_LINK_KEY_NOTIFY:
                  link_key_notify(buf);
          + case BT_HCI_EVT_LINK_KEY_REQ:
                  link_key_req(buf);
          + case BT_HCI_EVT_IO_CAPA_RESP:
                  io_capa_resp(buf);
          + case BT_HCI_EVT_IO_CAPA_REQ:
                  io_capa_req(buf);
          + case BT_HCI_EVT_SSP_COMPLETE:
                  ssp_complete(buf);
          + case BT_HCI_EVT_USER_CONFIRM_REQ:
                  user_confirm_req(buf);
          + case BT_HCI_EVT_USER_PASSKEY_NOTIFY:
                  user_passkey_notify(buf);
          + case BT_HCI_EVT_USER_PASSKEY_REQ:
                  user_passkey_req(buf);
          + case BT_HCI_EVT_INQUIRY_COMPLETE:
                  inquiry_complete(buf);
          + case BT_HCI_EVT_INQUIRY_RESULT_WITH_RSSI:
                  inquiry_result_with_rssi(buf);
          + case BT_HCI_EVT_EXTENDED_INQUIRY_RESULT:
                  extended_inquiry_result(buf);
          + case BT_HCI_EVT_REMOTE_NAME_REQ_COMPLETE:
                  remote_name_request_complete(buf);
          + case BT_HCI_EVT_AUTH_COMPLETE:
                  auth_complete(buf);
          + case BT_HCI_EVT_REMOTE_FEATURES:
                  read_remote_features_complete(buf);
          + case BT_HCI_EVT_REMOTE_EXT_FEATURES:
                  read_remote_ext_features_complete(buf);
          + case BT_HCI_EVT_ROLE_CHANGE:
                  role_change(buf);
        case BT_HCI_EVT_DISCONN_COMPLETE:
                hci_disconn_complete(buf);
        + smp/br
          + case BT_HCI_EVT_ENCRYPT_CHANGE:
                  hci_encrypt_change(buf);
          + case BT_HCI_EVT_ENCRYPT_KEY_REFRESH_COMPLETE:
                  hci_encrypt_key_refresh_complete(buf);
        + le
          + case BT_HCI_EVT_LE_META_EVENT:
            + hci_le_meta_event(buf);
              + case BT_HCI_EVT_LE_CONN_COMPLETE:
                + le_conn_complete(buf);
                  + id_addr = find_id_addr(&evt->peer_addr);
                  + conn = bt_conn_lookup_state_le(id_addr, BT_CONN_CONNECT);
                  + atomic_clear_bit(bt_dev.flags, BT_DEV_ADVERTISING);
                  + conn->handle   = handle;
                    bt_addr_le_copy(&conn->le.dst, id_addr);
                    conn->le.interval = sys_le16_to_cpu(evt->interval);
                    conn->le.latency = sys_le16_to_cpu(evt->latency);
                    conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
                    conn->role = evt->role;
                  + if (conn->role == BT_HCI_ROLE_SLAVE) {
                    bt_addr_le_copy(&conn->le.init_addr, &evt->peer_addr);
                    bt_addr_le_copy(&conn->le.resp_addr, &bt_dev.id_addr);
                  + bt_conn_set_state(conn, BT_CONN_CONNECTED);
                    + case BT_CONN_CONNECTED:
                    + k_fifo_init(&conn->tx_queue);
                    + k_thread_spawn(conn->stack, sizeof(conn->stack), conn_tx_thread,
                    + bt_l2cap_connected(conn);
                      + fchan = le_channels;
                      + if (fchan->accept(conn, &chan) < 0) {
                        + .accept	= l2cap_accept,
                          + static struct bt_l2cap_chan_ops ops = {
                            .connected = l2cap_connected,
                            .disconnected = l2cap_disconnected,
                            .recv = l2cap_recv,
                          + l2cap->chan.chan.ops = &ops;
                            *chan = &l2cap->chan.chan;
                      + l2cap_chan_add(conn, chan, NULL)
                        + struct bt_l2cap_le_chan *ch = l2cap_chan_alloc_cid(conn, chan);
                        + bt_l2cap_chan_add(conn, chan, destroy);
                      + chan->ops->connected(chan);
                        + l2cap_connected(struct bt_l2cap_chan *chan)
                    + notify_connected(conn);
                      + for (cb = callback_list; cb; cb = cb->_next) {
                        + cb->connected(conn, conn->err);
              + case BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE:
                + le_conn_update_complete(buf);
              + case BT_HCI_EV_LE_REMOTE_FEAT_COMPLETE:
                + le_remote_feat_complete(buf);
              + case BT_HCI_EVT_LE_CONN_PARAM_REQ:
                + le_conn_param_req(buf);
              + case BT_HCI_EVT_LE_LTK_REQUEST:
                + le_ltk_request(buf);
              + case BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE:
                + le_pkey_complete(buf);
              + case BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE:
                + le_dhkey_complete(buf);
              + case BT_HCI_EVT_LE_ADVERTISING_REPORT:
                + le_adv_report(buf);
                  + check_pending_conn(addr, &info->addr, info->evt_type);
***** bt_le_adv_start
+ set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
+ bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
+ set_advertise_enable(true);
  + bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
+ atomic_set_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING);

**** monitor.c
SYS_INIT(bt_monitor_init, PRE_KERNEL_1, MONITOR_INIT_PRIORITY);
使用串口来做debug monitor， bluetooht的时间命令都会发往这个串口
config BLUETOOTH_DEBUG_MONITOR
config BLUETOOTH_MONITOR_ON_DEV_NAME
string "Device Name of Bluetooth monitor logging UART"

+ void bt_log(int prio, const char *fmt, ...)
  + bt_monitor_send(BT_MONITOR_SYSTEM_NOTE, buf, len);
    + monitor_send(&hdr, sizeof(hdr));
      + uart_poll_out(monitor_dev, *buf++);
**** h4.c
***** init
static struct bt_hci_driver drv = {
        .name		= "H:4",
        .bus		= BT_HCI_DRIVER_BUS_UART,
        .open		= h4_open,
        .send		= h4_send,
};
+ SYS_INIT(_bt_uart_init, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEVICE);
  + h4_dev = device_get_binding(CONFIG_BLUETOOTH_UART_ON_DEV_NAME);
    + bt_hci_driver_register(&drv);
      + bt_dev.drv = drv;
        + bt_monitor_new_index(BT_MONITOR_TYPE_PRIMARY, drv->bus,
                                     BT_ADDR_ANY, drv->name ? drv->name : "bt0");
          + bt_monitor_send(BT_MONITOR_NEW_INDEX, &pkt, sizeof(pkt));
***** isr
+ static int h4_open(void)
  + uart_irq_callback_set(h4_dev, bt_uart_isr);
  + uart_irq_rx_enable(h4_dev);

+ static void bt_uart_isr(struct device *unused)
  + read = h4_read(h4_dev, &type, sizeof(type), 0);
    + int h4_read(struct device *uart, uint8_t *buf,  size_t len, size_t min)
      + rx = uart_fifo_read(uart, buf, len);
  + case H4_EVT:
  + buf = h4_evt_recv(&remaining);
    + struct bt_hci_evt_hdr hdr;
    + h4_read(h4_dev, (void *)&hdr, sizeof(hdr), sizeof(hdr));
    + *remaining = hdr.len;
    + buf = bt_buf_get_evt(hdr.evt, K_NO_WAIT);
  + case H4_ACL:
  + buf = h4_acl_recv(&remaining);
    + struct bt_hci_acl_hdr hdr;
    + h4_read(h4_dev, (void *)&hdr, sizeof(hdr), sizeof(hdr));
    + buf = bt_buf_get_acl(K_NO_WAIT);
    + *remaining = sys_le16_to_cpu(hdr.len);
  + read = h4_read(h4_dev, net_buf_tail(buf), remaining, 0);
  + bt_recv(buf);
    + bt_monitor_send(bt_monitor_opcode(buf), buf->data, buf->len);
    + if (bt_buf_get_type(buf) == BT_BUF_ACL_IN) {
      + net_buf_put(&bt_dev.rx_queue, buf);
        + return 0;
    + case BT_HCI_EVT_CMD_COMPLETE:
      net_buf_pull(buf, sizeof(*hdr));
      + hci_cmd_complete(buf);
        + struct bt_hci_evt_cmd_complete *evt = (void *)buf->data;
        + hci_cmd_done(opcode, status, buf);
        + if (cmd(sent)->sync) {        k_sem_give(sem);
    + case BT_HCI_EVT_CMD_STATUS:
      net_buf_pull(buf, sizeof(*hdr));
      + hci_cmd_status(buf);
    + case BT_HCI_EVT_NUM_COMPLETED_PACKETS:
      net_buf_pull(buf, sizeof(*hdr));
      + hci_num_completed_packets(buf);

**** nble
+ DEVICE_INIT(bt_nble, "", _bt_nble_init, NULL, NULL, POST_KERNEL,
            CONFIG_KERNEL_INIT_PRIORITY_DEVICE);
+ _bt_nble_init(struct device *unused)
  + nble_dev = device_get_binding(CONFIG_NBLE_UART_ON_DEV_NAME);

+ bt_enable(bt_ready_cb_t cb)
  + nble_open(void)
    + k_thread_spawn(rx_thread_stack, sizeof(rx_thread_stack),
                        (k_thread_entry_t)rx_thread,
      + uart_irq_callback_set(nble_dev, bt_uart_isr);

+ bt_uart_isr(struct device *unused)
  + hdr_bytes += uart_fifo_read(nble_dev,
  + buf = net_buf_alloc(&rx_pool, K_NO_WAIT);
  + read = uart_fifo_read(nble_dev, net_buf_tail(buf), hdr.len);
  + net_buf_put(&rx_queue, buf);

+ static void rx_thread(void)
  + rpc_deserialize(buf);
    + case SIG_TYPE_S:
    + deserialize_s(uint8_t fn_index, struct net_buf *buf)
      + deserialize_struct(buf, &struct_ptr, &struct_length);
      + m_fct_s[fn_index](struct_data);

*** mem
k_mem_pool_alloc(struct k_mem_pool *pool, struct k_mem_block *block,
  offset = compute_block_set_index(pool, size);
  found_block = get_block_recursive(pool, offset, offset);
    found = get_existing_block(&(fr_table[index]), &i);
      *unused_block_index = i;
    defrag(pool, pool->nr_of_block_sets - 1, start_index);
    larger_block = get_block_recursive(pool, index - 1, start_index);

defrag(pool, pool->nr_of_block_sets - 1, start_index);
*** net
**** net_conn_input
**** net_rx_thread
+ net_if_init();
+ while (1) {
+ buf = net_buf_get(&rx_queue, K_FOREVER);
+ processing_data(buf, false);
  + process_data(buf, is_loopback)
    + process_ipv4_pkt(buf);
      + net_nbuf_set_ip_hdr_len(buf, sizeof(struct net_ipv4_hdr));
      + case IPPROTO_ICMP:
        verdict = process_icmpv4_pkt(buf, hdr);
      + case IPPROTO_UDP:
        verdict = net_conn_input(IPPROTO_UDP, buf);
      + case IPPROTO_TCP:
        verdict = net_conn_input(IPPROTO_TCP, buf);
+ k_yield();

**** net_init
+ net_shell_init();
  + SHELL_REGISTER(NET_SHELL_MODULE, net_commands);
+ net_nbuf_init();
+ net_context_init();
+ l2_init();
  + net_arp_init();
+ l3_init();
  + net_conn_init();
  + net_udp_init();
  + net_tcp_init();
    + k_sem_init(&tcp_lock, 0, UINT_MAX);
  + net_route_init();
+ net_mgmt_event_init();
  + k_thread_spawn(mgmt_stack, sizeof(mgmt_stack),
  + (k_thread_entry_t)mgmt_thread, NULL, NULL, NULL,
  + K_PRIO_COOP(CONFIG_NET_MGMT_EVENT_THREAD_PRIO), 0, 0);
+ init_rx_queue();
  + k_fifo_init(&rx_queue);
  + rx_tid = k_thread_spawn(rx_stack, sizeof(rx_stack),
  + (k_thread_entry_t)net_rx_thread,

SYS_INIT(net_init, POST_KERNEL, CONFIG_NET_INIT_PRIO);
**** eth_callback
  eth_rx(iface);
    ENET_ReadFrame(ENET, &context->enet_handle, NULL, 0);
    src = context->frame_buf;
    pkt_buf = net_nbuf_get_reserve_data(0);
    net_buf_frag_insert(prev_frag, pkt_buf);
    frag_len = net_buf_tailroom(pkt_buf);
    memcpy(pkt_buf->data, src, frag_len);
    net_buf_add(pkt_buf, frag_len);
    net_recv_data(context->iface, buf);
      net_nbuf_set_iface(buf, iface);
      net_buf_put(&rx_queue, buf);

struct eth_context {
        struct net_if *iface;
        enet_handle_t enet_handle;
        struct k_sem tx_buf_sem;
        uint8_t mac_addr[6];
        uint8_t frame_buf[1500];
};
**** net_if
ENET_SetCallback(&context->enet_handle, eth_callback, dev);
ENET_ReceiveIRQHandler(ENET, &context->enet_handle);

NET_DEVICE_INIT(eth_ksdk_0, CONFIG_ETH_KSDK_0_NAME,
                eth_0_init, &eth_0_context,
                NULL, CONFIG_ETH_INIT_PRIORITY, &api_funcs_0,
                ETHERNET_L2, NET_L2_GET_CTX_TYPE(ETHERNET_L2), 1500);

#define NET_IF_GET_NAME(dev_name, sfx) (__net_if_##dev_name##_##sfx)
#define NET_IF_GET(dev_name, sfx)					\
        ((struct net_if *)&NET_IF_GET_NAME(dev_name, sfx))

#define NET_IF_INIT(dev_name, sfx, _l2, _mtu)				\
        static struct net_if (NET_IF_GET_NAME(dev_name, sfx)) __used	\
        __attribute__((__section__(".net_if.data"))) = {		\
                .dev = &(__device_##dev_name),				\
                .l2 = &(NET_L2_GET_NAME(_l2)),				\
                .l2_data = &(NET_L2_GET_DATA(dev_name, sfx)),		\
                .mtu = _mtu,						\
        };								\
        NET_STACK_INFO_ADDR(TX,						\
                            dev_name,					\
                            CONFIG_NET_TX_STACK_SIZE,			\
                            CONFIG_NET_TX_STACK_SIZE,			\
                            NET_IF_GET(dev_name, sfx)->tx_stack,	\
                            sfx)


/* Network device initialization macros */

#define NET_DEVICE_INIT(dev_name, drv_name, init_fn,		\
                        data, cfg_info, prio, api, l2,		\
                        l2_ctx_type, mtu)			\
        DEVICE_AND_API_INIT(dev_name, drv_name, init_fn, data,	\
                            cfg_info, POST_KERNEL, prio, api);	\
        NET_L2_DATA_INIT(dev_name, 0, l2_ctx_type);		\
        NET_IF_INIT(dev_name, 0, l2, mtu)

struct net_if *net_if_lookup_by_dev(struct device *dev);
struct net_if *net_if_get_default(void);
struct net_if_addr *net_if_ipv4_addr_lookup(const struct in_addr *addr,
struct net_if_addr *net_if_ipv4_addr_add(struct net_if *iface,
struct net_if_router *net_if_ipv4_router_lookup(struct net_if *iface,
struct net_if_router *net_if_ipv4_router_add(struct net_if *iface,
static inline void net_if_ipv4_set_netmask(struct net_if *iface,
static inline void net_if_ipv4_set_gw(struct net_if *iface,
void net_if_register_link_cb(struct net_if_link_cb *link,



NET_L2_INIT(ETHERNET_L2, ethernet_recv, ethernet_send, ethernet_reserve);

#define NET_L2_GET_NAME(_name) (__net_l2_##_name)
#define NET_L2_INIT(_name, _recv_fn, _send_fn, _reserve_fn)		\
        const struct net_l2 const (NET_L2_GET_NAME(_name)) __used	\
        __attribute__((__section__(".net_l2.init"))) = {		\
                .recv = (_recv_fn),					\
                .send = (_send_fn),					\
                .reserve = (_reserve_fn),				\
        }

#define NET_L2_DATA_INIT(name, sfx, ctx_type)				\
        static ctx_type NET_L2_GET_DATA(name, sfx) __used		\
        __attribute__((__section__(".net_l2.data")));
**** net_buf
NET_BUF_POOL_DEFINE(rx_buffers, NBUF_RX_COUNT, 0, sizeof(struct net_nbuf),
                    free_rx_bufs_func);
NET_BUF_POOL_DEFINE(tx_buffers, NBUF_TX_COUNT, 0, sizeof(struct net_nbuf),
                    free_tx_bufs_func);

/* The data fragment pool is for storing network data. */
NET_BUF_POOL_DEFINE(data_buffers, NBUF_DATA_COUNT, NBUF_DATA_LEN,
                    NBUF_USER_DATA_LEN, free_data_bufs_func);



NET_BUF_POOL_DEFINE(pool_name, buf_count, buf_size, user_data_size, NULL);
#define NET_BUF_POOL_DEFINE(_name, _count, _size, _ud_size, _destroy)        \
        static struct {                                                      \
                struct net_buf buf;                                          \
                uint8_t data[_size] __net_buf_align;                         \
                uint8_t ud[ROUND_UP(_ud_size, 4)] __net_buf_align;           \
        } _net_buf_pool_##_name[_count] __noinit;                            \
        static struct net_buf_pool _name =                                   \
                NET_BUF_POOL_INITIALIZER(_name, _net_buf_pool_##_name,       \
                                         _count, _size, _ud_size, _destroy)

#define NET_BUF_POOL_INITIALIZER(_pool, _bufs, _count, _size, _ud_size,      \
                                 _destroy)                                   \
        {                                                                    \
                .free = K_LIFO_INITIALIZER(_pool.free),                      \
                .__bufs = (struct net_buf *)_bufs,                           \
                .buf_count = _count,                                         \
                .uninit_count = _count,                                      \
                .buf_size = _size,                                           \
                .user_data_size = _ud_size,                                  \
                .destroy = _destroy,                                         \
        }



struct net_buf {
        union {
                /** FIFO uses first 4 bytes itself, reserve space */
                int _unused;

                /** Fragments associated with this buffer. */
                struct net_buf *frags;
        };

        /** List pointer used for TCP retransmit buffering */
        sys_snode_t sent_list;

        /** Reference count. */
        uint8_t ref;

        /** Bit-field of buffer flags. */
        uint8_t flags;

        /** Where the buffer should go when freed up. */
        struct net_buf_pool *pool;

        /* Union for convenience access to the net_buf_simple members, also
         * preserving the old API.
         */
        union {
                /* The ABI of this struct must match net_buf_simple */
                struct {
                        /** Pointer to the start of data in the buffer. */
                        uint8_t *data;

                        /** Length of the data behind the data pointer. */
                        uint16_t len;

                        /** Amount of data that this buffer can store. */
                        uint16_t size;
                };

                struct net_buf_simple b;
        };

        /** Start of the data storage. Not to be accessed directly
         *  (the data pointer should be used instead).
         */
        uint8_t __buf[0] __net_buf_align;
};

struct net_buf_pool {
        /** LIFO to place the buffer into when free */
        struct k_lifo free;

        /** Number of buffers in pool */
        const uint16_t buf_count;

        /** Number of uninitialized buffers */
        uint16_t uninit_count;

        /** Data size of each buffer in the pool */
        const uint16_t buf_size;

        /** Size of the user data associated with each buffer. */
        const uint16_t user_data_size;

        /** Optional destroy callback when buffer is freed. */
        void (*const destroy)(struct net_buf *buf);

        /** Helper to access the start of storage (for net_buf_pool_init) */
        struct net_buf * const __bufs;
};


struct net_nbuf {
        /** Network connection context */
        struct net_context *context;

        /** Network context token that user can set. This is passed
         * to user callback when data has been sent.
         */
        void *token;

        /** Network interface */
        struct net_if *iface;

        /** @cond ignore */
        uint8_t *appdata;	/* application data starts here */
        uint8_t *next_hdr;	/* where is the next header */

        /* Filled by layer 2 when network packet is received. */
        struct net_linkaddr lladdr_src;
        struct net_linkaddr lladdr_dst;

        uint16_t appdatalen;
        uint16_t reserve;	/* length of the protocol headers */
        uint8_t ll_reserve;	/* link layer header length */
        uint8_t family;		/* IPv4 vs IPv6 */
        uint8_t ip_hdr_len;	/* pre-filled in order to avoid func call */
        uint8_t ext_len;	/* length of extension headers */
        uint8_t ext_bitmap;

#if defined(CONFIG_NET_IPV6)
        uint8_t ext_opt_len; /* IPv6 ND option length */
#endif

#if defined(CONFIG_NET_TCP)
        bool buf_sent; /* Is this net_buf sent or not */
#endif
        /* @endcond */
};


buf = net_buf_alloc(&pool_name, timeout);
   buf = k_lifo_get(&pool->free, timeout);

net_if_ipv6_addr_add(net_if_get_default(), &in6addr_my,
net_context_get(AF_INET6, SOCK_DGRAM, IPPROTO_UDP, &context);
net_context_bind(context, (struct sockaddr *)&my_addr6);

net_context_recv
  recv_udp(context, cb, timeout, user_data);
    context->recv_cb = cb;
    net_conn_register(net_context_get_ip_proto(context),

context->recv_cb = cb;
  udp_received(struct net_context *context,struct net_buf *buf,
    reply_buf = net_nbuf_get_tx(context);
    header_len = net_nbuf_appdata(buf) - tmp->data;
    frag = net_nbuf_get_data(context);
   net_nbuf_unref(buf);
*** shell

static struct shell_cmd net_commands[] = {
        /* Keep the commands in alphabetical order */
        { "conn", shell_cmd_conn, NULL },
        { "help", shell_cmd_help, NULL },
        { "iface", shell_cmd_iface, NULL },
        { "mem", shell_cmd_mem, NULL },
        { "ping", shell_cmd_ping, NULL },
        { "route", shell_cmd_route, NULL },
        { "stacks", shell_cmd_stacks, NULL },
        { "stats", shell_cmd_stats, NULL },
        { NULL, NULL, NULL }
}


net_shell_init
  SHELL_REGISTER(NET_SHELL_MODULE, net_commands);

shell
  cmd = k_fifo_get(&cmds_queue, K_FOREVER);
  argc = line2argv(cmd->line, argv, ARRAY_SIZE(argv));
  cb = get_cb(argc, argv);
        shell_module = &__shell_cmd_start[module];
        for (i = 0; shell_module->commands[i].cmd_name; i++) {
                if (!strcmp(command, shell_module->commands[i].cmd_name)) {
                        return shell_module->commands[i].cb;
  cb(argc, argv) < 0



void shell_init(const char *str)
  k_thread_spawn(stack, STACKSIZE, shell, NULL, NULL, NULL,
  uart_register_input(&avail_queue, &cmds_queue, completion)
    console_input_init()
      uart_irq_rx_disable(uart_console_dev);
      uart_irq_tx_disable(uart_console_dev);
      uart_irq_callback_set(uart_console_dev, uart_console_isr);


uart_console_init,
  uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  uart_console_hook_install();
    __stdout_hook_install(console_out);
    __printk_hook_install(console_out);


void uart_console_isr(struct device *unused)
  read_uart
    rx = uart_fifo_read(uart, buf, size);
    cmd = k_fifo_get(avail_queue, K_NO_WAIT);
    k_fifo_put(lines_queue, cmd);
** Android
*** vold
fs_mgr_mount_all//init.rc
    fs_mgr_setup_verity(&fstab->recs[i]);
        read_verity_metadata(fstab->blk_device,
        fd = open("/dev/device-mapper", O_RDWR)
        create_verity_device(io, mount_point, fd)
        get_verity_device_name(io, mount_point, fd, &verity_blk_name)
        verify_table(verity_table_signature,
        load_verity_table(io, mount_point, fstab->blk_device, fd, verity_table) < 0)
        resume_verity_table(io, mount_point, fd)

NetlinkListener::onDataAvailable
    NetlinkEvent *evt = new NetlinkEvent();
    evt->decode(mBuffer, count, mFormat)
    onEvent(evt);
        evt->getSubsystem();
        if (!strcmp(subsys, "block")) {
            vm->handleBlockEvent(evt);
                case NetlinkEvent::Action::kAdd:
                    disk = new android::vold::Disk(eventPath, device,
                        CreateDeviceNode(mDevPath, mDevice);
                            mknod(cpath, mode, dev)
                    disk->create();
                        notifyEvent(ResponseCode::DiskCreated, StringPrintf("%d", mFlags));
                            VolumeManager::Instance()->getBroadcaster()->sendBroadcast(event,
                                CommandListener
                                SocketListener::sendBroadcast
                                    for (i = mClients->begin(); i != mClients->end();
                                        c->sendMsg(code, msg, addErrno, false)
                        readMetadata();
                        readPartitions();
                            ForkExecvp(cmd, output);
                            createPublicVolume(partDevice);
                                new PublicVolume(device)
                                mVolumes.push_back(vol);
                                vol->setDiskId(getId());
                                vol->create();
                                    PublicVolume::doCreate(
                                        CreateDeviceNode(mDevPath, mDevice);
                                            mknod(cpath, mode, dev)
                    mDisks.push_back(std::shared_ptr<android::vold::Disk>(disk));

FrameworkListener::onDataAvailable
    dispatchCommand(c, buffer + offset);
        c->runCommand(cli, argc, argv)
        CommandListener::VolumeCmd::runCommand

main
    cl = new CommandListener();
             FrameworkListener("vold", true)
                    SocketListener(socketName, true, false)
                init(socketName, false);

        registerCmd(new DumpCmd());
        registerCmd(new VolumeCmd());
        registerCmd(new AsecCmd());
        registerCmd(new ObbCmd());
        registerCmd(new StorageCmd());
        registerCmd(new CryptfsCmd());
        registerCmd(new FstrimCmd());
    vm->setBroadcaster((SocketListener *) cl);
    nm->setBroadcaster((SocketListener *) cl);
    vm->start()
         unmountAll();
         new android::vold::EmulatedVolume("/data/media")
         mInternalEmulated->create();
    process_config(vm)
    nm->start()
        mSock = socket(PF_NETLINK, SOCK_DGRAM | SOCK_CLOEXEC,
            NETLINK_KOBJECT_UEVENT))
        bind(mSock, (struct sockaddr *) &nladdr, sizeof(nladdr)
        mHandler = new NetlinkHandler(mSock);
            NetlinkListener(listenerSocket)
                 SocketListener(socket, false)
        mHandler->start()
            this->startListener();
                mClients->push_back(new SocketClient(mSock, false, mUseCmdNum));
                SocketListener::threadStart
                    SocketListener::runListener
                        select(max + 1, &read_fds, NULL, NULL, NULL)
                    onDataAvailable
                        NetlinkListener::onDataAvailable
                            NetlinkEvent *evt = new NetlinkEvent();
                            evt->decode(mBuffer, count, mFormat)
                            onEvent(evt);
                                evt->getSubsystem();
                                if (!strcmp(subsys, "block")) {
                                    vm->handleBlockEvent(evt);
        fd = openat(dfd, "uevent", O_WRONLY);
        write(fd, "add\n", 4);
    cl->startListener()//dev/socket/vold
        SocketListener::startListener
        mSock = android_get_control_socket(mSocketName)
        listen(mSock, backlog)
        pthread_create(&mThread, NULL, SocketListener::threadStart
            SocketListener::runListener
            accept4(mSock, addrp, &alen, SOCK_CLOEXEC);
            mClients->push_back(new SocketClient(c, true, mUseCmdNum));
            onDataAvailable
                FrameworkListener::onDataAvailable
                    dispatchCommand(c, buffer + offset);
                        c->runCommand(cli, argc, argv)
                        CommandListener::VolumeCmd::runCommand
    coldboot("/sys/block");
    usbmond_main();
*** Surface
SurfaceView
        Surface::Surface
        init
                setWillNotDraw(true);

signalLayerUpdate

Surface::dequeueBuffer
        //ATRACE_CALL();
        mGraphicBufferProducer->dequeueBuffer(&buf, &fence, swapIntervalZero,
                BufferQueueProducer::dequeueBuffer

        *fenceFd = fence->dup();

sw_sync_pt_create
    sync_pt_create
        sync_timeline_add_pt(parent, pt);
            list_add_tail(&pt->child_list, &obj->child_list_head);
    pt->value = value;


static struct sync_timeline_ops sw_sync_timeline_ops = {
    .driver_name = "sw_sync",
    .dup = sw_sync_pt_dup,
    .has_signaled = sw_sync_pt_has_signaled,
    .compare = sw_sync_pt_compare,
    .fill_driver_data = sw_sync_fill_driver_data,
    .timeline_value_str = sw_sync_timeline_value_str,
    .pt_value_str = sw_sync_pt_value_str,
};
sw_sync_timeline_create
    sync_timeline_create

static const struct file_operations sync_fence_fops = {
    .release = sync_fence_release,
    .poll = sync_fence_poll,
    .unlocked_ioctl = sync_fence_ioctl,
    .compat_ioctl = sync_fence_ioctl,
};

pvr_sync_fops
    pvr_sync_ioctl_create_fence
        fd = get_unused_fd();
        pvr_sync_alloc_fence_fdget(data.iAllocFenceFd)
        sync_pt = (struct sync_pt *)
            pvr_sync_create_sync(timeline, sync_data);
                sync_pt_create
                    sync_timeline_add_pt(parent, pt);
                        list_add_tail(&pt->child_list, &obj->child_list_head);
                pvr_pt->sync_data = sync_data;
        fence = sync_fence_create(data.szName, sync_pt);
            fence = sync_fence_alloc(name);
                fence->file = anon_inode_getfile("sync_fence", &sync_fence_fops
                list_add_tail(&fence->sync_fence_list, &sync_fence_list_head);
            list_add(&pt->pt_list, &fence->pt_list_head);
            sync_pt_activate(pt);
                _sync_pt_has_signaled
                    pt->parent->ops->has_signaled(pt);
                list_add_tail(&pt->active_list, &obj->active_list_head);
            sync_fence_signal_pt(pt);
                status = sync_fence_get_status(fence);
                    list_for_each(pos, &fence->pt_list_head) {
                list_for_each_safe(pos, n, &signaled_waiters)
                    waiter->callback(fence, waiter);
                wake_up(&fence->wq);
        data.iFenceFd = fd;
        sync_fence_install(fence, fd);
            fd_install(fd, fence->file);

static struct sync_timeline_ops pvr_sync_timeline_ops = {
    .driver_name        = PVRSYNC_MODNAME,
    .dup                = pvr_sync_dup,
    .has_signaled       = pvr_sync_has_signaled,
    .compare            = pvr_sync_compare,
    .free_pt            = pvr_sync_free_sync,
    .release_obj        = pvr_sync_release_timeline,
    .print_obj          = pvr_sync_print_obj,
    .print_pt           = pvr_sync_print_pt,
};

pvr_sync_open
    sync_timeline_create

doGLFenceWaitLocked

syncForReleaseLocked

syncForReleaseLocked(mEglDisplay);
    sync = eglCreateSyncKHR(dpy, EGL_SYNC_NATIVE_FENCE_ANDROID, NULL);
        IMGeglCreateSyncKHR
            psDpy = GetKEGLDisplay(psTls, eglDpy);
            psSysContext = &psDpy->sSysContext;
            psSync = EGLCalloc(sizeof(KEGL_SYNC));
            InsertEglSyncFenceToGC(psSysContext, psSync->psContext, psTls, psSync, &psSync->iNativeFd)
                psGlobalData->spfnOGLES3.pfnGLESInsertFenceSyncGC(ctx->hClientContext,
                //sGLES3FunctionTable
                GLES3InsertFenceSyncGC
                    GLES3FlushBuffersGC(gc, NULL, IMG_TRUE, IMG_FALSE, IMG_FALSE, NULL
                    SyncCreateCommand(&gc->psSysContext->sSyncInterface, SYNC_EGL_FENCESYNC, NULL);
                    SyncInsertFence(&gc->psSysContext->sSyncInterface, SYNC_UPDATE_TQ,
                    SyncInsertFence(&gc->psSysContext->sSyncInterface, SYNC_UPDATE_RENDER,
                    SyncPrepareCommitCommand(&gc->psSysContext->sSyncInterface, psCommand,
                    RGXKickSync(gc->psDevConnection,
                    SyncCommitCommand(&gc->psSysContext->sSyncInterface, psCommand, NU
    glFlush();
    fenceFd = eglDupNativeFenceFDANDROID(dpy, sync);
        IMGeglDupNativeFenceFDANDROID
            dup(psSync->iNativeFd);


    eglDestroySyncKHR(dpy, sync);
    sp<Fence> fence(new Fence(fenceFd));
    addReleaseFenceLocked(mCurrentTexture,mCurrentTextureImage->graphicBuffer(), fence);
        mSlots[slot].mFence = fence;


SurfaceControl()
        mNativeObject = nativeCreate(session, name, w, h, format, flags)//jni
        client(android_view_SurfaceSession_getClient(env, sessionObj));
        client->createSurface

DisplayEventReceiver::DisplayEventReceiver
        mEventConnection = sf->createDisplayEventConnection()
                SurfaceFlinger::createDisplayEventConnection
                                mEventThread->createEventConnection();
                                        new Connection(const_cast<EventThread*>(this));
                                                mEventThread(eventThread), mChannel(new BitTube()
                                        EventThread::Connection::onFirstRef
                                                mEventThread->registerDisplayEventConnection(this)
                                                mDisplayEventConnections.add(connection);
                        mDataChannel = mEventConnection->getDataChannel();


SurfaceComposerClient::createSurface
        Client::createSurface
                flinger->createLayer
                        createNormalLayer
                                *outLayer = new Layer(this, client, name, w, h, flags);
                                        mFlinger->getRenderEngine().genTextures(1, &mTextureName);
                                                return mRenderEngine
                                                glGenTextures(count, names);
                                mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);
                                        mTextureName = textureName;
                                        mTextureTarget = textureTarget;
                        flinger->getHwComposer().getRefreshPeriod(HWC_DISPLAY_PRIMARY);
                                mFrameTracker.setDisplayRefreshPeriod(displayPeriod);
                                Layer::onFirstRef
                                        BufferQueue::createBufferQueue(&producer, &consumer);
                                            mProducer = new MonitoredProducer(producer, mFlinger);
                                            mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName);
                                            mSurfaceFlingerConsumer->setConsumerUsageBits(getEffectiveUsage(0));
                                            mSurfaceFlingerConsumer->setContentsChangedListener(this);
                                            mSurfaceFlingerConsumer->setName(mName);
                                            mSurfaceFlingerConsumer->setDefaultMaxBufferCount(3);
                                            hw(mFlinger->getDefaultDisplayDevice());
                                            updateTransformHint(hw);
                                (*outLayer)->setBuffers(w, h, format, flags);
                                        maxSurfaceDims = min(
                                mFlinger->getMaxTextureSize(), mFlinger->getMaxViewportDims());
                                        mSurfaceFlingerConsumer->setDefaultBufferSize(w, h);
                                mSurfaceFlingerConsumer->setDefaultBufferFormat(format);
                                mSurfaceFlingerConsumer->setConsumerUsageBits(getEffectiveUsage(0));
                                *handle = (*outLayer)->getHandle();
                                        new Handle(mFlinger, this);
                                                mOwner(layer)
                        *gbp = (*outLayer)->getProducer();
                                return mProducer
                addClientLayer(client, *handle, *gbp, layer);
                        mCurrentState.layersSortedByZ.add(lbc);
                        mGraphicBufferProducerList.add(IInterface::asBinder(gbc));
                        client->attachLayer(handle, lbc);
                                mLayers.add(handle, layer);
        new SurfaceControl(this, handle, gbp);

public Surface(SurfaceTexture surfaceTexture)
        setNativeObjectLocked(nativeCreateFromSurfaceTexture(surfaceTexture));
        nativeCreateFromSurfaceTexture
                producer(SurfaceTexture_getProducer(env, surfaceTextureObj));
                        env->GetLongField(thiz, fields.producer)
                surface(new Surface(producer, true));
                        mGraphicBufferProducer(bufferProducer),
                        ANativeWindow::setSwapInterval  = hook_setSwapInterval;
                    ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;
                    ANativeWindow::cancelBuffer     = hook_cancelBuffer;
                    ANativeWindow::queueBuffer      = hook_queueBuffer;
                    ANativeWindow::query            = hook_query;
                    ANativeWindow::perform          = hook_perform;
                    ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;
                    ANativeWindow::cancelBuffer_DEPRECATED  = hook_cancelBuffer_DEPRECATED;
                    ANativeWindow::lockBuffer_DEPRECATED    = hook_lockBuffer_DEPRECATED;
                    ANativeWindow::queueBuffer_DEPRECATED   = hook_queueBuffer_DEPRECATED;


onMessageReceived
    case MessageQueue::INVALIDATE
        SurfaceFlinger::handleMessageInvalidate
            SurfaceFlinger::handlePageFlip
                layer->hasQueuedFrame()
                layer->shouldPresentNow(mPrimaryDispSync)
                    mSurfaceFlingerConsumer->computeExpectedPresent(dispSync);
                        nextRefresh = dispSync.computeNextRefresh(hwcLatency);
                        extraPadding = 1000000;        // 1ms (6% of 60Hz)
                        return nextRefresh + extraPadding;
                layersWithQueuedFrames.push_back(layer.get());
                layer->latchBuffer(visibleRegions)
                    mSurfaceFlingerConsumer->updateTexImage(&r,
                                    mFlinger->mPrimaryDispSync, maxFrameNumber);
                        acquireBufferLocked(&item, computeExpectedPresent(dispSync),
                            GLConsumer::acquireBufferLocked(item, presentWhen,
                                ConsumerBase::acquireBufferLocked(item, presentWhen,
                                mEglSlots[slot].mEglImage = new EglImage(item->mGraphicBuffer);
                        updateAndReleaseLocked(item);
                            checkAndUpdateEglStateLocked();
                            mEglSlots[buf].mEglImage->createIfNeeded(mEglDisplay, item.mCrop);
                                mEglImage = createImage(mEglDisplay, mGraphicBuffer, mCropRect);
                            syncForReleaseLocked(mEglDisplay);
                                sync = eglCreateSyncKHR(dpy, EGL_SYNC_NATIVE_FENCE_ANDROID, NULL);
                                glFlush();
                                fenceFd = eglDupNativeFenceFDANDROID(dpy, sync);
                                eglDestroySyncKHR(dpy, sync);
                                sp<Fence> fence(new Fence(fenceFd));
                                addReleaseFenceLocked(mCurrentTexture,mCurrentTextureImage->graphicBuffer(), fence);
                                    mSlots[slot].mFence = fence;
                            releaseBufferLocked(
                                            mCurrentTexture, mCurrentTextureImage->graphicBuffer(),
                                            mEglDisplay, mEglSlots[mCurrentTexture].mEglFence);
                                 ConsumerBase::releaseBufferLocked(
                                    mConsumer->releaseBuffer(
                            mCurrentTexture = buf;
                            mCurrentTextureImage = mEglSlots[buf].mEglImage;
                            mCurrentCrop = item.mCrop;
                            mCurrentTransform = item.mTransform;
                            mCurrentScalingMode = item.mScalingMode;
                            mCurrentTimestamp = item.mTimestamp;
                            mCurrentFence = item.mFence;
                            mCurrentFrameNumber = item.mFrameNumber;
                         bindTextureImageLocked();
                    mActiveBuffer = mSurfaceFlingerConsumer->getCurrentBuffer();
                layer->useSurfaceDamage();
                signalLayerUpdate();
        signalRefresh();
            mEventQueue.refresh();
                mHandler->dispatchRefresh();



SurfaceFlinger::onMessageReceived
        handleMessageRefresh();
                preComposition();
                        layers[i]->onPreComposition()
        rebuildLayerStacks();
                LayerVector& layers(mDrawingState.layersSortedByZ)
                DisplayDevice hw(mDisplays[dpy]
                Transform& tr(hw->getTransform())
                Rect bounds(hw->getBounds())
                SurfaceFlinger::computeVisibleRegions(layers,
                        hw->getLayerStack(), dirtyRegion, opaqueRegion)
                hw->setVisibleLayersSortedByZ(layersSortedByZ);
            hw->undefinedRegion.set(bounds);
            hw->undefinedRegion.subtractSelf(tr.transform(opaqueRegion));
            hw->dirtyRegion.orSelf(dirtyRegion);
        setUpHWComposer();
                mDisplays[dpy]->beginFrame(mustRecompose);
                id = hw->getHwcDisplayId()
                currentLayers(hw->getVisibleLayersSortedByZ())
                hwc.createWorkList(id, count)
                HWComposer::LayerListIterator cur = hwc.begin(id)
                for (size_t i=0 ; cur!=end &
                        layer(currentLayers[i]);
                        layer->setGeometry(hw, *cur)
                        layer->setPerFrameData(hw, *cur);
                hwc.prepare();
                hw->prepareFrame(hwc);
                        mDisplaySurface->prepareFrame(compositionType);
        doDebugFlashRegions();
        doComposition();
                doDisplayComposition(hw, dirtyRegion);
                        doComposeSurfaces(hw, dirtyRegion)
                                hwc.hasGlesComposition(id)
                                hw->makeCurrent(mEGLDisplay, mEGLContext)
                                hasHwcComposition = hwc.hasHwcComposition(id);
                                if (hasHwcComposition) {
                                        engine.clearWithColor(0, 0, 0, 0);
                                else
                                        Region bounds(hw->getBounds());
                                        letterbox(bounds.subtract(hw->getScissor()));
                                        region(hw->undefinedRegion.merge(letterbox));
                                        region.andSelf(dirty);
                                layers(hw->getVisibleLayersSortedByZ());
                                tr = hw->getTransform()
                                for (size_t i=0 ; i<count && cur!=end
                                        switch (cur->getCompositionType())
                                                case HWC_OVERLAY
                                                case HWC_FRAMEBUFFER: {
                                layer->draw(hw, clip);
                                        onDraw
                                                ATRACE_CALL();
                                                mSurfaceFlingerConsumer->bindTextureImage();
                                                        bindTextureImageLocked
                                                                glBindTexture(mTexTarget, mTexName);
                                                                mCurrentTextureImage->bindToTextureTarget(mTexTarget)
                                                                        glEGLImageTargetTexture2DOES(texTarget,
                                                                                        static_cast<GLeglImageOES>(mEglImage));
                                                                doGLFenceWaitLocked
                                                fenceFd = mCurrentFence->dup();
                                                EGLSyncKHR sync = eglCreateSyncKHR(dpy,
                                                fenceFd = mCurrentFence->dup();
                                                eglWaitSyncKHR(dpy, sync, 0);
                                                eglDestroySyncKHR(dpy, sync);
                                                drawWithOpenGL(hw, clip, useIdentityTransform);
                                                        computeGeometry(hw, mMesh, useIdentityTransform);
                                                        Mesh::VertexArray<vec2> texCoords(mMesh.getTexCoordArray<vec2>());
                                                                            texCoords[0] = vec2(left, 1.0f - top);
                                                                            texCoords[1] = vec2(left, 1.0f - bottom);
                                                                            texCoords[2] = vec2(right, 1.0f - bottom);
                                                                            texCoords[3] = vec2(right, 1.0f - top);
                                                                            engine.setupLayerBlending(mPremultipliedAlpha, isOpaque(s), s.alpha);
                                                                            engine.drawMesh(mMesh);
                                                                            engine.disableBlending();
                                                                engine.disableTexturing();
                        layer->setAcquireFence(hw, *cur);
                            fence = mSurfaceFlingerConsumer->getCurrentFence()
                            fenceFd = fence->dup();
                            layer.setAcquireFenceFd(fenceFd);
                                getLayer()->acquireFenceFd = fenceFd;
                        hw->swapRegion.orSelf(dirtyRegion);
                        hw->swapBuffers(getHwComposer());
                    eglSwapBuffers(mDisplay, mSurface);
                        FramebufferSurface::onFrameAvailable
                            nextBuffer(buf, acquireFence);
                                acquireBufferLocked(&item, 0)
                                mCurrentBufferSlot = item.mBuf;
                                mCurrentBuffer = mSlots[mCurrentBufferSlot].mGraphicBuffer;
                                outFence = item.mFence;
                                outBuffer = mCurrentBuffer;
                            mHwc.fbPost(mDisplayType, acquireFence, buf);
                                setFramebufferTarget(id, acquireFence, buffer);

                                mDisplaySurface->advanceFrame()

            hw->flip(hw->swapRegion);

                hw->compositionComplete();
                        mDisplaySurface->compositionComplete();
                                mHwc.fbCompositionComplete();
                postFramebuffer();
                        hwc.commit();
                    mHwc->set(mHwc, mNumDisplays, mLists);
                        hw->onSwapBuffersCompleted(hwc);
                    mDisplaySurface->onFrameCommitted
                        fence = mHwc.getAndResetReleaseFence(mDisplayType);
                            disp.framebufferTarget->releaseFenceFd;
                        addReleaseFence(mCurrentBufferSlot,
                        currentLayers[i]->onLayerDisplayed(hw, &*cur)
                    layer->onDisplayed();
                        getLayer()->acquireFenceFd = -1;
                    mSurfaceFlingerConsumer->setReleaseFence(layer->getAndResetReleaseFence());
                        addReleaseFence(mCurrentTexture,
                                    mCurrentTextureImage->graphicBuffer(), fence)
        postComposition();
                layers[i]->onPostComposition();
                hwc = getHwComposer();
                presentFence = hwc.getDisplayFence(HWC_DISPLAY_PRIMARY)
                mPrimaryDispSync.addPresentFence(presentFence)
                enableHardwareVsync();

SurfaceTexture_init
        BufferQueue::createBufferQueue(&producer, &consumer);
                core(new BufferQueueCore(allocator)
                        sp<ISurfaceComposer> composer(ComposerService::getComposerService());
                        mAllocator = composer->createGraphicBufferAlloc();

                producer(new BufferQueueProducer(core)
                consumer(new BufferQueueConsumer(core)
                *outProducer = producer;
            *outConsumer = consumer;
        surfaceTexture = new GLConsumer(consumer, texName,GL_TEXTURE_EXTERNAL_OES
        surfaceTexture->setName(String8::format("SurfaceTexture-%d-%d-%d",
        SurfaceTexture_setSurfaceTexture(env, thiz, surfaceTexture);
        SurfaceTexture_setProducer(env, thiz, producer);
        ctx(new JNISurfaceTextureContext(env, weakThiz,
        surfaceTexture->setFrameAvailableListener(ctx);
        SurfaceTexture_setFrameAvailableListener(env, thiz, ctx);
*** surfaceFlinger
main
        flinger = new SurfaceFlinger()
                DispSync::DispSync
                        mThread(new DispSyncThread())
                        mThread->run("DispSync", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);
                        reset();
                beginResync();
                onFirstRef
                        mEventQueue.init(this);
                                mFlinger = flinger;
                                mLooper = new Looper(true);
                                mHandler = new Handler(*this);
        flinger->init();

SurfaceFlinger::init
        mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
                egl_init_drivers
                        egl_init_drivers_locked
                                Loader& loader(Loader::getInstance());
                                cnx = &gEGLImpl
                                cnx->hooks[egl_connection_t::GLESv1_INDEX] =
                        &gHooks[egl_connection_t::GLESv1_INDEX];
                        cnx->hooks[egl_connection_t::GLESv2_INDEX] =
                        &gHooks[egl_connection_t::GLESv2_INDEX];
                        cnx->dso = loader.open(cnx);
                                dso = load_driver("GLES", cnx, EGL | GLESv1_CM | GLESv2)
                                // /system/lib/egl/
                                        init_api(dso, gl_names,
                                cnx->libEgl   = load_wrapper("/system/lib/libEGL.so");
                                cnx->libGles2 = load_wrapper("/system/lib/libGLESv2.so");
                                cnx->libGles1 = load_wrapper("/system/lib/libGLESv1_CM.so")
                egl_display_t::getFromNativeDisplay
                        sDisplay[uintptr_t(disp)].getDisplay(disp)
    eglInitialize(mEGLDisplay, NULL, NULL);
        egl_display_t::initialize
                cnx->egl.eglInitialize(
        sp<VSyncSource> vsyncSrc = new DispSyncSource(&mPrimaryDispSync,
            vsyncPhaseOffsetNs, true, "app");
    mEventThread = new EventThread(vsyncSrc);
        mVSyncSource(src),
        se.sigev_notify = SIGEV_THREAD;
        se.sigev_value.sival_ptr = this;
        se.sigev_notify_function = vsyncOffCallback;
        se.sigev_notify_attributes = NULL;
        timer_create(CLOCK_MONOTONIC, &se, &mTimerId);
        onFirstRef
                run("EventThread", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);
                        EventThread::threadLoop
    sp<VSyncSource> sfVsyncSrc = new DispSyncSource(&mPrimaryDispSync,
            sfVsyncPhaseOffsetNs, true, "sf");
    mSFEventThread = new EventThread(sfVsyncSrc);
    mEventQueue.setEventThread(mSFEventThread);
        mEventThread = eventThread;
            mEvents = eventThread->createEventConnection();
                new Connection(const_cast<EventThread*>(this))
                        mEventThread(eventThread), mChannel(new BitTube()
                        EventThread::Connection::onFirstRef
                                mEventThread->registerDisplayEventConnection(this)
                                        mDisplayEventConnections.add(connection);
            mEventTube = mEvents->getDataChannel();
            mLooper->addFd(mEventTube->getFd(), 0, Looper::EVENT_INPUT,
                    MessageQueue::cb_eventReceiver, this);
                                queue->eventReceiver(fd, events);
                                        DisplayEventReceiver::getEvents(mEventTube, buffer, 8)
                                        mHandler->dispatchInvalidate();
                                                mQueue.mLooper-se>sendMessage(this, Message(MessageQueue::INVALIDATE));
                                                        MessageQueue::Handler::handleMessage
                                                                mQueue.mFlinger->onMessageReceived(message.what);
    mHwc = new HWComposer(this,
            *static_cast<HWComposer::EventHandler *>(this));
        property_get("debug.sf.no_hw_vsync", value, "0");
        int fberr = loadFbHalModule();
                hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module);
                framebuffer_open(module, &mFbDev);
                        module->methods->open(module, GRALLOC_HARDWARE_FB0,
        loadHwcModule();
                hw_get_module(HWC_HARDWARE_MODULE_ID, &module)
                hwc_open_1(module, &mHwc);
        mCBContext->hwc = this;
        mCBContext->procs.invalidate = &hook_invalidate;
        mCBContext->procs.vsync = &hook_vsync;
        mHwc->registerProcs(mHwc, &mCBContext->procs)
        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0);
        queryDisplayProperties(i);
                mHwc->getDisplayConfigs(mHwc, disp, configs, &numConfigs)
                mHwc->getDisplayAttributes(mHwc, disp, configs[c],
                mDisplayData[disp].configs.push_back(config);

    mRenderEngine = RenderEngine::create(mEGLDisplay, mHwc->getVisualID());
        config = chooseEglConfig(display, hwcFormat);
        contextClientVersion = 2;
        EGLint contextAttributes[] = {
            EGL_CONTEXT_CLIENT_VERSION, contextClientVersion,      // MUST be first
        EGLContext ctxt = eglCreateContext(display, config, NULL, contextAttributes);
        EGLSurface dummy = eglCreatePbufferSurface(display, dummyConfig, attribs);
        eglMakeCurrent(display, dummy, dummy, ctxt);
        engine = new GLES20RenderEngine();
        eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\
        engine->setEGLHandles(config, ctxt);
    mEGLContext = mRenderEngine->getEGLContext();
    createBuiltinDisplayLocked(type);
        mBuiltinDisplays[type] = new BBinder();
    wp<IBinder> token = mBuiltinDisplays[i];
    BufferQueue::createBufferQueue(&producer, &consumer, new GraphicBufferAlloc());
    fbs = new FramebufferSurface(*mHwc, i, consumer);
        ConsumerBase(consumer),
        mDisplayType(disp),
    hwcId = allocateHwcDisplayId(type);
         mHwc->allocateDisplayId()
    hw = new DisplayDevice(this,
                    type, hwcId, mHwc->getFormat(hwcId), isSecure, token,
                    fbs, producer,
                    mRenderEngine->getEGLConfig());
        mNativeWindow = surface = new Surface(producer, false);
        eglSurface = eglCreateWindowSurface(display, config, window, NULL);
        mDisplayName = "Built-in Screen";
        setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
                frame = Rect(w, h);
                viewport = Rect(w, h);
                DisplayDevice::orientationToTransfrom(orientation, w, h, &R)
                mGlobalTransform = R * TP * S * TL;
                mScissor = mGlobalTransform.transform(viewport);
    mDisplays.add(token, hw);
    getDefaultDisplayDevice()->makeCurrent(mEGLDisplay, mEGLContext);
        sur = eglGetCurrentSurface(EGL_DRAW);
        eglMakeCurrent(dpy, mSurface, mSurface, ctx);
        setViewportAndProjection();
                mFlinger->getRenderEngine().setViewportAndProjection(w, h, sourceCrop, h,
                false, Transform::ROT_0);
                glViewport(0, 0, vpw, vph);
                mState.setProjectionMatrix(m);
    mEventControlThread = new EventControlThread(this);
    mEventControlThread->run("EventControl", PRIORITY_URGENT_DISPLAY);
        mFlinger->eventControl(HWC_DISPLAY_PRIMARY,
                    SurfaceFlinger::EVENT_VSYNC, mVsyncEnabled);
    initializeDisplays();
        flinger->onInitializeDisplays();
                setPowerModeInternal(getDisplayDevice(d.token), HWC_POWER_MODE_NORMAL);
                hw->setPowerMode(mode);
                mEventThread->onScreenAcquired();
                        mUseSoftwareVSync = false
                        mCondition.broadcast();
                resyncToHardwareVsync(true);
                        mPrimaryDispSync.beginResync();
                        mEventControlThread->setVsyncEnabled(true);
                                mFlinger->eventControl(HWC_DISPLAY_PRIMARY
                                        ATRACE_CALL();
                                        getHwComposer().eventControl(disp, event, enabled);
                                                mHwc->eventControl(mHwc, disp, event, enabled)
                repaintEverything();
    startBootAnim();

handle_adf_event
        dev->event_cb->vsync(dev->event_cb_data, disp, vsync->timestamp);
                HWComposer::vsync
                         snprintf(tag, sizeof(tag), "HW_VSYNC_%1u", disp);
                         ATRACE_INT(tag, ++mVSyncCounts[disp] & 1);
                         mEventHandler.onVSyncReceived(disp, timestamp);
                                SurfaceFlinger::onVSyncReceived
                                        needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);
                                                DispSync::addResyncSample
                                                        updateModelLocked();
                                                                mPeriod = durationSum / (mNumResyncSamples - 1);
                                                                sampleAvgX /= double(mNumResyncSamples);
                                                        sampleAvgY /= double(mNumResyncSamples);
                                                        mPhase = nsecs_t(atan2(sampleAvgY, sampleAvgX) / scale);
                                                                ATRACE_INT64("DispSync:Period", mPeriod);
                                                        ATRACE_INT64("DispSync:Phase", mPhase);
                                                        mThread->updateModel(mPeriod, mPhase);
                                                                mPeriod = period;
                                                                mPhase = phase;
                                                                mCond.signal();

mThread->run("DispSync", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);
DispSyncThread::threadLoop
        nextEventTime = computeNextEventTimeLocked(now);
                t = computeListenerNextEventTimeLocked
    targetTime = nextEventTime;
    mCond.waitRelative(mMutex, targetTime - now);
    now = systemTime(SYSTEM_TIME_MONOTONIC);
        callbackInvocations = gatherCallbackInvocationsLocked(now);
                 mEventListeners[i].mCallback
        fireCallbackInvocations(callbackInvocations);
                callbacks[i].mCallback->onDispSyncEvent(callbacks[i].mEventTime);
                DispSyncSource::onDispSyncEvent
                        ATRACE_INT(mVsyncEventLabel.string(), mValue);
                        callback->onVSyncEvent(when);
                        EventThread::onVSyncEvent
                                mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;
                            mVSyncEvent[0].header.id = 0;
                            mVSyncEvent[0].header.timestamp = timestamp;
                            mVSyncEvent[0].vsync.count++;
                            mCondition.broadcast();
                            EventThread::threadLoop
                                signalConnections = waitForEvent(&event);
                                sp<Connection>& conn(signalConnections[i]);
                                conn->postEvent(event);
                                        MessageQueue::cb_eventReceiver, this);
                                                queue->eventReceiver(fd, events);
                                                        DisplayEventReceiver::getEvents(mEventTube, buffer, 8)
                                                        mHandler->dispatchInvalidate();
                                                                mQueue.mLooper-se>sendMessage(this, Message(MessageQueue::INVALIDATE));
                                                                        MessageQueue::Handler::handleMessage
                                                                                mQueue.mFlinger->onMessageReceived(message.what);


// count >= 1 : continuous event. count is the vsync rate
// count == 0 : one-shot event that has not fired
// count ==-1 : one-shot event that fired this round / disabled
EventThread::waitForEvent
        size_t count = mDisplayEventConnections.size();
    for (size_t i=0 ; i<count ; i++) {
        connection(mDisplayEventConnections[i].promote());
        if (connection->count >= 0)
                waitForVSync = true;
                if (timestamp) {
                        if (connection->count == 0) {
                                connection->count = -1;
                    signalConnections.add(connection);
    if (timestamp && !waitForVSync) {
                disableVSyncLocked();
    } else if (!timestamp && waitForVSync) {
            enableVSyncLocked();
                        EventThread::enableVSyncLocked();
                                        mVSyncSource->setCallback(static_cast<VSyncSource::Callback*>(this));
                                                mCallback = callback;
                                mVSyncSource->setVSyncEnabled(true);
                                        mDispSync->addEventListener(mPhaseOffset,
                                                static_cast<DispSync::Callback*>(this));
                                                mThread->addEventListener(phase, callback);
                                                        mEventListeners.push(listener);

EventThread::requestNextVsync
        if (connection->count < 0) {
        connection->count = 0;
        mCondition.broadcast();
    }


SurfaceFlinger::postComposition
        DispSync::addPresentFence
                for (size_t i = 0; i < NUM_PRESENT_SAMPLES
                        nsecs_t t = f->getSignalTime();
                        mPresentTimes[i] = t + kPresentTimeOffset;
                updateErrorLocked();
                        nsecs_t sampleErr = (sample - mPhase) % period;
                        mError = sqErrSum / numErrSamples;
*** SensorService
SensorService
        SensorService::onFirstRef
                SensorDevice:: getInstance
                        hw_get_module(SENSORS_HARDWARE_MODULE_ID,
                                mSensorModule->get_sensors_list(mSensorModule, &list);
                                mActivationCount.add(list[i].handle, model);
                mSensorDevice->activate(
        dev.initCheck
        dev.getSensorList(&list);
        registerSensor( new HardwareSensor(list[i]) );
                Sensor sensor(s->getSensor());
                // add to the sensor list (returned to clients)
                mSensorList.add(sensor);
                // add to our handle->SensorInterface mapping
                mSensorMap.add(sensor.getHandle(), s);
        SensorFusion::getInstance());
        registerVirtualSensor( new RotationVectorSensor
        registerVirtualSensor( new N(lis
        registerVirtualSensor( new LinearAccelerationS
                if (virtualSensorsNeeds & (1<<SENSOR_TYPE_ROTATION_VECTOR\|{
                   mUserSensorList.replaceAt(aSensor, orientationIndex);
               }
        registerVirtualSensor( new CorrectedGyroSensor
        mLooper = new Looper(false);

SensorService::threadLoop
        device.poll(mSensorEventBuffer, numEventMax);
        recordLastValue(buffer, count);
        fusion.process(event[i]);
        activeConnections[i]->sendEvents(mSensorEventBuffer,
        //SensorService::SensorEventConnection::sendEvents
                // filter out events not for this connection
                sendPendingFlushEventsLocked();
                findWakeUpSensorEventLocked(scratch, count);
                SensorEventQueue::write(mChannel,
                        BitTube::sendObjects(tube, events, numEvents);

SensorManager::getInstanceForPackage  //android N


ANDROID_SINGLETON_STATIC_INSTANCE(SensorManager)
        SensorManager::SensorManager()
                assertStateLocked();
                        getService("sensorservice", &mSensorServer);
                        mSensors = mSensorServer->getSensorList();

gBaseEventQueueClassInfo.dispatchSensorEvent = GetMethodIDOrDie(env,
            gBaseEventQueueClassInfo.clazz, "dispatchSensorEvent"


class Receiver : public LooperCallback {
        handleEvent
                q = reinterpret_cast<SensorEventQueue *>(data)
                q->read(buffer, 16)
                receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal));
                env->CallVoidMethod(receiverObj.get(),gBaseEventQueueClassInfo.dispatchSensorEvent,
                        SensorEventQueue::dispatchSensorEvent(int handle, float[] values, int inAccuracy,
                                final Sensor sensor = mManager.mHandleToSensor.get(handle);
                                 mListener.onSensorChanged(t);

public boolean registerListener(SensorEventListener listener, Sensor sensor,
        return registerListener(listener, sensor, samplingPeriodUs, null);
                queue = new SensorEventQueue(listener, looper, this);
                        static final class SensorEventQueue extends BaseEventQueue
                                super(looper, manager, OPERATING_MODE_NORMAL, packageName);
                                 nativeInitBaseEventQueue(manager.mNativeInstance,
                                            new WeakReference<>(this), looper.getQueue(), mScratch,
                                            packageName, mode, manager.mContext.getOpPackageName());
                                        JNINativeMethod gBaseEventQueueMethods[] = {
                                            {"nativeInitBaseEventQueue",                                                |
                                                    "(Landroid/hardware/SystemSensorManager$BaseEventQueue;Landroid/os/MessageQueue;[F)J",
                                                        (void*)nativeInitSensorEventQueue },
                                        nativeInitSensorEventQueue
                                                sp<SensorEventQueue> queue(mgr.createEventQueue());
                                                         mSensorServer->createSensorEventConnection();
                                                                 SensorService::createSensorEventConnection
                                                                        new SensorEventConnection(this, uid)
                                                                                mChannel = new BitTube(mService->mSocketBufferSize);
                                                                                        BitTube::init
                                                                                                socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)
                                                                                                mReceiveFd = sockets[0];
                                                                                        mSendFd = sockets[1];
                                                                                SensorService::SensorEventConnection::onFirstRef()
                                                                                        LooperCallback::onFirstRef()
                                                         new SensorEventQueue(connection);
                                                                 mSensorChannel = mSensorEventConnection->getSensorChannel();
                                                                 mRecBuffer = new ASensorEvent[MAX_RECEIVE_BUFFER_EVENT_COUNT];
                                                messageQueue = android_os_MessageQueue_getMessageQueue(e
                                                receiver = new Receiver(queue, messageQueue, eventQ, scratch);
                                                        onFirstRef
                                                                mMessageQueue->getLooper()->addFd(mSensorQueue->getFd(),
                                                                         SensorEventQueue::getFd()
                                                                                mSensorChannel->getFd();
                queue.addSensor(sensor, delayUs, maxBatchReportLatencyUs, reservedFlags)
                         addSensorEvent(sensor);
                                SensorEvent t = new SensorEvent(Se
                                mSensorsEvents.put(sensor.getHandle(), t);
                         enableSensor(sensor, delayUs, maxBatchReportLatencyUs, reservedFlags)
                                nativeEnableSensor(nSensorEventQueue, sensor.getHandle(), rateU
                                        receiver->getSensorEventQueue()->enableSensor(han
                                                // SensorEventQueue::enableSensor
                                                mSensorEventConnection->enableDisable(sensor->getHandle(), true,
                                                        mService->enable(this, handle, samplingPeriodNs
                                                                 rec = new SensorRecord(connection);
                                                                 mActiveSensors.add(handle, rec);
                                                                 connection->addSensor(handle)
                                                                 //SensorService::SensorEventConnection::addSensor
                                                                        verifyCanAccessSensor(mService->getSensorFromHandle(handle)
                                                                                mSensorMap.valueFor(handle)->getSensor();



SensorEventQueue::read
        BitTube::recvObjects(mSensorChannel,
                tube->read(vaddr, count*objSize)
                        ::recv(mReceiveFd, vaddr, size, MSG_DONTWAIT);

         TYPE_ORIENTATION
         TYPE_GAME_ROTATION_VECTOR
         TYPE_GYROSCOPE_UNCALIBRATED

SensorBase::SensorBase(
        data_fd = openInput(data_name);

SurfaceTexture_init //gSurfaceTextureMethods

static const JNINativeMethod displayServiceMethods[] = {
        { "_init", "()Z",(void*) actions_server_DisplayService_init
                //device/actions/common/frameworks/services/jni/com_actions_server_DisplayService.cpp:
                hw_get_module(DM_HARDWARE_MODULE_ID, (const hw_module_t**) &module)
                owldisp_manager_open(&module->common, &mDisplayManager)

        { "_setHdmiEnable", "(Z)V",(void*) actions_server_DisplayService_setHdmiEnable }
                actions_server_DisplayService_setHdmiEnable
                        mDisplayManager->set_hdmi_enable(mDisplayManager,enable)
*** GVR
CardboardViewNativeImpl
TreasureHuntActivity extends GvrActivity implements GvrView.StereoRenderer
        initializeGvrView
                GvrView gvrView = (GvrView) findViewById(R.id.gvr_view);
                        init(context);
                        this.cardboardViewApi = ImplementationSelector.createCardboardViewApi(context);
                                new CardboardViewNativeImpl(context);

                        addView(this.cardboardViewApi.getRootView(), 0);
                        GLSurfaceView glSurfaceView = this.cardboardViewApi.getGLSurfaceView();

                setGvrView(gvrView);
                        gvrView.setOnCardboardTriggerListener(new Runnable() GvrActivity.this.onCardboardTrigger();
                                this.cardboardViewApi.setOnCardboardTriggerListener(listener);
                        NdefMessage tagContents = this.sensorConnection.getNfcSensor().getTagContents();
                        updateGvrViewerParams(GvrViewerParams.createFromNfcContents(tagContents));
                                createFromUri
                                        cardboardV1ViewerParams
                                                deviceParams.distortion = Distortion.cardboardV1Distortion();
                                                        params.coefficients = ((float[])CARDBOARD_V1_COEFFICIENTS.clone());
                        gvrView.setConvertTapIntoTrigger(this.convertTapIntoTriggerEnabled);

GvrView
        setScanlineRacingEnabled (boolean enabled)
        setOnTransitionViewDoneListener
        setNeckModelEnabled
        setElectronicDisplayStabilizationEnabled
                CardboardViewNativeImpl.this.nativeSetElectronicDisplayStabilizationEnabled
        setOnCardboardTriggerListener
        setDistortionCorrectionEnabled
                CardboardViewNativeImpl.this.nativeSetDistortionCorrectionEnabled(CardboardViewNativeImpl.this.nativeCardboardView, enabled);
        getInterpupillaryDistance

GvrViewerParams
        setDefaultValues
                this.vendor = "Google, Inc.";
/* 622 */     this.model = "Default Cardboard";
/* 623 */     this.interLensDistance = 0.064F;
/* 624 */     this.verticalAlignment = CARDBOARD_V2_2_VERTICAL_ALIGNMENT;
/* 625 */     this.verticalDistanceToLensCenter = 0.035F;
/* 626 */     this.screenToLensDistance = 0.039F;
/* 627 */     this.leftEyeMaxFov = new FieldOfView();
/* 628 */     this.hasMagnet = false;
/*     */
/* 630 */     this.distortion = new Distortion();
ScreenParams
Distortion
        private static final float[] CARDBOARD_V2_2_COEFFICIENTS = { 0.34F, 0.55F };
        private static final float[] CARDBOARD_V1_COEFFICIENTS = { 0.441F, 0.156F };

HeadMountedDisplayManager
        this.paramsProvider = VrParamsProviderFactory.create(context);
                new Intent("android.content.action.VR_SETTINGS_PROVIDER");
                providerResolveInfos = pm.queryIntentContentProviders(providerIntent, 0);
                ContentProviderClient client = context.getContentResolver().acquireContentProviderClient(authority);
                new ContentProviderVrParamsProvider(client, authority);
        this.hmd = new HeadMountedDisplay(createScreenParams(), createGvrViewerParams());
                createScreenParams
                        Display display = getDisplay();
                        ScreenParams params = ScreenParams.fromProto(display, this.paramsProvider.readPhoneParams());
                createGvrViewerParams
                        new GvrViewerParams(this.paramsProvider.readDeviceParams());
StereoRenderer
        onDrawEye(Eye eye)
        onFinishFrame(Viewport viewport)
        onNewFrame(HeadTransform headTransform)
        onRendererShutdown()
        onSurfaceChanged(int width, int height)
        onSurfaceCreated(EGLConfig config)
** weave + brillo
curl -k  -d  '{ "authentication": {"anonymousMaxScope": "viewer","mode": "anonymous" }}' -H "Authorization:Privet anonymous"  https://ac-Latitude-E6430.local.:7781/privet/v3/auth

curl -k  -d '{"componet": "led1","name":"onOff.setConfig", "parameters": {"state": "on"}}'   -H "Content-Type: application/json" -H 'Authorization:Privet WCuFRggaHsa3j0IBDkQJQjEAQgpARgUaHsbFn1BCFwW9x4g40hTyRx+42zr6' https://ac-Latitude-E6430.local.:7781/privet/v3/commands/execute

sudo out/Debug/weave_daemon_sample --registration_ticket=93019287-6b26-04a0-22ee-d55ad23a4226
main
        Daemon daemon{opts}
                task_runner_{new weave::examples::EventTaskRunner},
        config_store_{new weave::examples::FileConfigStore(opts.model_id,
        http_client_{new weave::examples::CurlHttpClient(task_runner_.get())},
        network_{new weave::examples::EventNetworkImpl(task_runner_.get())},
                 UpdateNetworkState();
                        connectivity_probe_.reset(bufferevent_socket_new
                                bufferevent_setcb(
                                        [](struct bufferevent* buf, short events, void* ctx) {
                                                if (events & BEV_EVENT_CONNECTED) {
                                                network->UpdateNetworkStateCallback(State::kOnline);
        bluetooth_{new weave::examples::BluetoothImpl} {
                dns_sd_.reset(new weave::examples::AvahiClient);
                // LOG(INFO) << "connecting to avahi-daemon";
                new weave::examples::HttpServerImpl{task_runner_.get()});
                                 SSL_library_init();
                                 httpd_.reset(evhtp_new(task_runner_->GetEventBase(), nullptr));
                                 evhtp_bind_socket(httpd_.get(), "0.0.0.0", GetHttpPort(), -1) //7780


                device_ = weave::Device::Create(config_store_.get(), task_runner_.get(),
                        new DeviceManager{config_store, task_runner, http_client, network, dns_sd,
                                new Config{config_store
                                        CreateDefaultSettings(config_store)
                                                config_store->LoadDefaults(&result)
                                        Transaction change{this};
                                        change.LoadState();
                                                config_->config_store_->LoadSettings(kConfigName);
                                                //Loading settings from /var/lib/weave/weave_settings_AAAAA_config.json
                                                config_->config_store_->LoadSettings();
                                                //Loading settings from /var/lib/weave/weave_settings_AAAAA.json
                                        Config::Transaction::~Transaction()
                                                Commit();
                                                        config_->Save();
                                                                config_store_->SaveSettings(
                                                        //Saving settings to /var/lib/weave/weave_settings_AAAAA_config.json
                                new ComponentManagerImpl{task_runner}
                                new AccessApiHandler{this, access_revocation_manager_.get()}
                    new AccessRevocationManagerImpl{config_store});
                                        Load();
                                                store_->LoadSettings(kConfigFileName)
                                                //Loading settings from /var/lib/weave/weave_settings_AAAAA_black_list.json
                        new privet::AuthManager(config_.get(), access_revocation_manager_.get(),
                                http_server->GetHttpsCertificateFingerprint()));
                        new AccessApiHandler{this, access_revocation_manager_.get()});
                                new DeviceRegistrationInfo(
                                        component_manager_->AddTraitDefChangedCallback(base::Bind(
                                        &DeviceRegistrationInfo::OnTraitDefsChanged, weak_factory_.GetWeakPtr()));
                                        on_trait_changed_.push_back(callback);
                                                //callback.Run();
                                                DeviceRegistrationInfo::OnTraitDefsChanged
                                                        // VLOG(1) << "CommandDefinitionChanged notification received";
                                                        UpdateDeviceResource(base::Bind(&IgnoreCloudError));
                                        component_manager_->AddComponentTreeChangedCallback(
                                        base::Bind(&DeviceRegistrationInfo::OnComponentTreeChanged,
                                                //device_registration_info.cc(1276)] ComponentTreeChanged notification received
                        component_manager_->AddStateChangedCallback(base::Bind(
                                        &DeviceRegistrationInfo::OnStateChanged, weak_factory_.GetWeakPtr()));
                                        //device_registration_info.cc(1267)] StateChanged notification received
                                 device_info_->Start();
                                 //LOG(INFO) << "Starting notification channel";

                                StartPrivet();
                                        new privet::Manager{task_runner_}
                                        privet_->Start(network_
                                                device_ = DeviceDelegate::CreateDefault(
                                                cloud_ = CloudDelegate::CreateDefault(task_runner_, device, component_manager);
                                                        new CloudDelegateImpl{task_runner, device, component_manager}};
                                                                device_->AddGcdStateChangedCallback(base::Bind(
                                                                &CloudDelegateImpl::OnRegistrationChanged, weak_factory_.GetWeakPtr()));
                                                            component_manager_->AddCommandAddedCallback(base::Bind(
                                                                &CloudDelegateImpl::OnCommandAdded, weak_factory_.GetWeakPtr()));
                                                            component_manager_->AddCommandRemovedCallback(base::Bind(
                                                                 &CloudDelegateImpl::OnCommandRemoved, weak_factory_.GetWeakPtr()));
                                            network->AddConnectionChangedCallback(
                                              base::Bind(&Manager::OnConnectivityChanged, base::Unretained(this)));
                                                // VLOG(1) << "Enabling WiFi bootstrapping.";
                                            new WifiBootstrapManager(
                                            wifi_bootstrap_manager_->Init();
                                                 UpdateConnectionState();
                                                 //VLOG(3) << "New network state: " << EnumToString(service_state);
                                                 EventNetworkImpl->AddConnectionChangedCallback(
                                                        base::Bind(&WifiBootstrapManager::OnConnectivityChange,
                                                StartMonitoring(
                                                        base::TimeDelta::FromSeconds(kMonitoringWithSsidTimeoutSeconds))
                                                        ContinueMonitoring(timeout);
                                                        //VLOG(1) << "Monitoring connectivity.";
                                                                UpdateState(State::kMonitoring);
                                                                //Switching state from disabled to monitoring
                                                        //VLOG(2) << "Waiting for connection until: " << monitor_until_;
                                            (new Publisher(device_.get(),
                                                Update();
                                                        ExposeService();
                                                                //VLOG(2) << "DNS-SD update requested";
                                                                // VLOG(1) << "Updating service using DNS-SD, port: " << port
                                                                dns_sd_->PublishService(kPrivetServiceType, port, txt_record);
                                                                AvahiClient::PublishService
                                                                        //LOG(INFO) << "Publishing service";
                                                                        avahi_entry_group_update_service_txt_strlst

                                                privet_handler_.reset(new PrivetHandler(cloud_.get(), device_.get(),
                                                        cloud_->AddOnTraitsChangedCallback(base::Bind(
                                                              &PrivetHandler::OnTraitDefsChanged,
                                                              component_manager_->AddTraitDefChangedCallback(callback);
                                                              ComponentManagerImpl::AddTraitDefChangedCallback
                                                                        on_trait_changed_.push_back(callback);
                                                                                callback.Run();
                                                                                PrivetHandler::OnTraitDefsChanged


                                                        cloud_->AddOnStateChangedCallback(base::Bind(&PrivetHandler::OnStateChanged,
                                                        cloud_->AddOnComponentsChangeCallback(base::Bind(
                                                              &PrivetHandler::OnComponentTreeChanged,
                                                        AddHandler("/privet/info", &PrivetHandler::HandleInfo, AuthScope::kNone);
                                                        AddHandler("/privet/v3/pairing/start", &PrivetHandler::HandlePairingStart,
                                                for (const auto& path : privet_handler_->GetHttpPaths()) {
                                                        http_server->AddHttpRequestHandler(path, base::Bind(&Manager::PrivetRequestHandler,
                                                        handlers_[std::make_pair(path, httpd_.get())] = callback;
                                                                evhtp_set_cb(httpd_.get(), path.c_str(), &ProcessRequestCallback, this);

                                        http_server->AddHttpsRequestHandler(
                                                path, base::Bind(&Manager::PrivetRequestHandler,
                        AddSettingsChangedCallback(base::Bind(&DeviceManager::OnSettingsChanged,



        SampleHandler handler{daemon.GetTaskRunner()};
        handler.Register(daemon.GetDevice());
        daemon.Run();
                device_->Register(registration_data_, base::Bind(&OnRegisterDeviceDone, device_.get()))
                        device_info_->RegisterDevice(registration_data, callback);
                        DeviceRegistrationInfo::RegisterDevice
                                registration_data.oauth_url = GetDefaults().oauth_url;
                            registration_data.client_id = GetDefaults().client_id;
                            registration_data.client_secret = GetDefaults().client_secret;
                            registration_data.api_key = GetDefaults().api_key;
                                VLOG(1) << "RegisterDevice: "
                                  << "ticket_id: " << registration_data.ticket_id
                                  << ", oauth_url: " << registration_data.oauth_url
                                  << ", client_id: " << registration_data.client_id
                                  << ", client_secret: " << registration_data.client_secret
                                  << ", api_key: " << registration_data.api_key
                                  << ", service_url: " << registration_data.service_url
                                  << ", xmpp_endpoint: " << registration_data.xmpp_endpoint;
                            // RegisterDevice: ticket_id: 7b9689b0-65c2-b201-bb4b-29ed8d60eb59,
                            // oauth_url: https://accounts.google.com/o/oauth2/,
                            // client_id: 251090581729-ibu9pvq4f94rc8gkejtsrdd810p159qd.apps.googleusercontent.com,
                            // client_secret: g047ACP5rH0LkCf5345jSnZb,
                            // api_key: AIzaSyD5Ky09Wl9z9H01xd6vEixXNaaTNK_8YxM,
                            // service_url: https://www.googleapis.com/weave/v1/,
                            // xmpp_endpoint: talk.google.com:5223
                            RequestSender sender{HttpClient::Method::kPatch, url, http_client_};
                                sender.SetJsonData(req_json);
                                sender.Send(base::Bind(&DeviceRegistrationInfo::RegisterDeviceOnTicketSent,
                                        //VLOG(1) << "Sending request. id:" << debug_id
                                //<< " method:" << EnumToString(method_) << " url:" << url_;
                                        //VLOG(2) << "Request data: " << data_;
                                        transport_->SendRequest(method_, url_, GetFullHeaders(), data_,
                            base::Bind(on_done, debug_id, callback));
                                                CurlHttpClient::SendRequest
                                                        pending_tasks_.emplace_back(
                                                std::async(std::launch::async, SendRequestBlocking, method, url, headers,
                                                                SendRequestBlocking
                                                        CheckTasks();
                                                        //VLOG(4) << "CurlHttpClient::CheckTasks, size=" << pending_tasks_.size();

                task_runner_->Run();

DeviceRegistrationInfo::RegisterDevice
        DeviceRegistrationInfo::RegisterDeviceOnTicketSent
                RegisterDeviceOnTicketFinalized
                        RegisterDeviceOnAuthCodeSent

DeviceRegistrationInfo::RegisterDeviceOnAuthCodeSent
        change.set_robot_account(robot_account);
        change.set_refresh_token(refresh_token);
        StartNotificationChannel();
                //LOG(INFO) << "Starting notification channel";
                pull_channel_.reset(new PullChannel{pull_interval, task_runner_});
                        pull_channel_->Start(this);
                                delegate_ = delegate;
                                RePost();
                                        delegate_->OnCommandCreated(empty_dict, GetName());
                                        //DeviceRegistrationInfo::OnCommandCreated
                                        //VLOG(1) << "Command notification received: " << command;
                primary_notification_channel_.reset(
                new XmppChannel{GetSettings().robot_account, access_token_,
                        parser_ = XML_ParserCreate(nullptr);

                                XML_SetUserData(parser_, this);
                                XML_SetElementHandler(parser_, &XmppStreamParser::HandleElementStart,
                        &XmppStreamParser::HandleElementEnd);
                                XML_SetCharacterDataHandler(parser_, &XmppStreamParser::HandleCharData);
                                iq_stanza_handler_{new IqStanzaHandler{this, task_runner}}
                        CreateSslSocket();
                                //LOG(INFO) << "Starting XMPP connection to: " << xmpp_endpoint_;
                                //Starting XMPP connection to: talk.google.com:5223
                                network_->OpenSslSocket(host_port.first, port,
                          base::Bind(&XmppChannel::OnSslSocketReady,
                                EventNetworkImpl::OpenSslSocket(
                                        SSLStream::Connect(task_runner_, host, port, callback);
                        OnSslSocketReady
                                RestartXmppStream();
                                        SendMessage(BuildXmppStartStreamCommand());//....
                                                        ScheduleRegularPing();
                                                                SchedulePing(base::TimeDelta::FromSeconds(kRegularPingIntervalSeconds),
                                                                        //VLOG(1) << "Next XMPP ping in " << interval << " with timeout " << timeout;
                                                                        //Next XMPP ping in 60s with timeout 30s
                                                                        task_runner_->PostDelayedTask(FROM_HERE, base::Bind(&
                                                                        XmppChannel::PingServer,
                                                                                //VLOG(1) << "Sending XMPP ping";
                                                                                iq_stanza_handler_->SendRequestWithCustomTimeout(
                                                                                "get", jid_, account_, "<ping xmlns='urn:xmpp:ping'/>", timeout,
                                                                                base::Bind(&XmppChannel::OnPingResponse, task_ptr_factory_.GetWeakPtr(),
        primary_notification_channel_->Start(this)

        SendAuthInfo();
        ScheduleCloudConnection({});

SendMessage(BuildXmppStartStreamCommand());
        //  VLOG(2) << "Sending XMPP message: "
        // <stream:stream to='clouddevices.gserviceaccount.com' xmlns:stream='http://etherx.jabber.org/streams' xml:lang='*' version='1.0' xmlns='jabber:client'>
         stream_->Write(write_socket_data_.data(), write_socket_data_.size(),
                        base::Bind(&XmppChannel::OnMessageSent
                                OnMessageSent
                                 WaitForMessage();
                                        stream_->Read(read_socket_data_.data(), read_socket_data_.size(),
                                                base::Bind(&XmppChannel::OnMessageRead,
                                                OnMessageRead
                                                        //VLOG(2) << "Received XMPP packet: '" << msg << "'";
                                                        //Received XMPP packet: '<stream:stream from="clouddevices.gserviceaccount.com" id="6D74DC06FCA95808" version="1.0" xmlns:stream="http://etherx.jabber.org/streams" xmlns="jabber:client">'
                                                        stream_parser_.ParseData(msg);
                                                        XmppStreamParser::ParseData
                                                                XML_Parse(parser_, data.data(), data.size(), 0);
                                                                        XmppStreamParser::HandleElementStart
                                                                                XmppStreamParser::OnOpenElement
                                                                                //delegate_->OnStreamStart(node_name, std::move(attributes))
                                                                                        XmppChannel::OnStreamStart
                                                                                        //VLOG(2) << "XMPP stream start: " << node_name;
                                                                                        //XMPP stream start: stream:stream
                                                                                        node_stack_.emplace(new XmlNode{node_name, std::move(attributes)});
                                                        WaitForMessage();
                                                                //Received XMPP packet: '<stream:features><mechanisms xmlns="urn:ietf:params:xml:ns:xmpp-sasl"><mechanism>X-OAUTH2</mechanism><mechanism>X-GOOGLE-TOKEN</mechanism><mechanism>PLAIN</mechanism></mechanisms></stream:features>'
                                                                XmppStreamParser::HandleElementEnd
                                                                        XmppStreamParser::OnCloseElement
                                                                                //delegate_->OnStanza(std::move(node));
                                                                                XmppChannel::OnStanza
                                                                                        task_runner_->PostDelayedTask(
                                                                                base::Bind(&XmppChannel::HandleStanza,
                                                                                XmppChannel::HandleStanza
                                                                                        //VLOG(2) << "XMPP stanza received: " << stanza->ToString();
                                                                                        //XMPP stanza received: <stream:features><mechanisms xmlns="urn:ietf:params:xml:ns:xmpp-sasl"><mechanism>X-OAUTH2</mechanism><mechanism>X-GOOGLE-TOKEN</mechanism><mechanism>PLAIN</mechanism></mechanisms></stream:features>

XmppChannel::HandleStanza
        kConnected
        SendMessage(BuildXmppAuthenticateCommand(account_, access_token_));
        //Sending XMPP message: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='X-OAUTH2' auth:service='oauth2' auth:allow-non-google-login='true' auth:client-uses-full-bind-result='true' xmlns:auth='http://www.google.com/talk/protocol/auth'>ADBkMDdiNjcwZDNmMjhiN2EyNWU1ODViMjEwZjU5ZmZiQGNsb3VkZGV2aWNlcy5nc2VydmljZWFjY291bnQuY29tAHlhMjkuLnl3SU5YTXVzU2YxN2lWMl9zR0NjTTFZRVlDaUUtSEZzQXBmTnU0aVNORHBRaTRFdl9pU1dtQVpteEpES0ctOUJLQQ==</auth>
                BuildXmppAuthenticateCommand
                        Base64Encode
        //Received XMPP packet: '<success xmlns="urn:ietf:params:xml:ns:xmpp-sasl"/>'
        kAuthenticationStarted
        //XMPP stanza received: <success xmlns="urn:ietf:params:xml:ns:xmpp-sasl"/>
        RestartXmppStream();
                SendMessage(BuildXmppStartStreamCommand());
                        XmppChannel::OnStreamStart
                        //XMPP stream start: stream:stream

                        //Received XMPP packet: '<stream:features><bind xmlns="urn:ietf:params:xml:ns:xmpp-bind"/><session xmlns="urn:ietf:params:xml:ns:xmpp-session"/></stream:features>'
        kStreamRestartedPostAuthentication
                //XMPP stanza received: <stream:features><bind xmlns="urn:ietf:params:xml:ns:xmpp-bind"/><session xmlns="urn:ietf:params:xml:ns:xmpp-session"/></stream:features>
                stanza->FindFirstChild("bind", false
                IqStanzaHandler
                iq_stanza_handler_->SendRequest(
            "set", "", "", "<bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>",
            base::Bind(&XmppChannel::OnBindCompleted,
                       task_ptr_factory_.GetWeakPtr()),
            base::Bind(&XmppChannel::Restart, task_ptr_factory_.GetWeakPtr()));
                        BuildIqStanza(std::to_string(last_request_id_), type, to, from, body);
                        requests_.insert(std::make_pair(++last_request_id_, response_callback));
                        xmpp_channel_->SendMessage(message);
                        // Sending XMPP message: <iq id='1' type='set'><bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/></iq>
                        XmppChannel::OnBindCompleted,

        kBindSent
                iq_stanza_handler_->HandleIqStanza(std::move(stanza)
                        IqStanzaHandler::HandleIqStanza
                                requests_.find(id)
                                        XmppChannel::OnBindCompleted

XmppChannel::OnBindCompleted
        kSessionStarted
        iq_stanza_handler_->SendRequest(
      "set", "", "", "<session xmlns='urn:ietf:params:xml:ns:xmpp-session'/>",
      base::Bind(&XmppChannel::OnSessionEstablished,
      OnSessionEstablished
        kSubscribeStarted
        std::string body =
        "<subscribe xmlns='google:push'>"
        "<item channel='cloud_devices' from=''/></subscribe>";
        iq_stanza_handler_->SendRequest(
                "set", "", account_, body,
                base::Bind(&XmppChannel::OnSubscribed,
                        XmppChannel::OnSubscribed
                                kSubscribed
                                delegate_->OnConnected(GetName());
                                DeviceRegistrationInfo::OnConnected
                                        base::Bind(&DeviceRegistrationInfo::FetchAndPublishCommands,

                        DeviceRegistrationInfo::SendCloudRequest
                        DeviceRegistrationInfo::OnCloudRequestDone
DeviceRegistrationInfo::RefreshAccessToken

void DeviceRegistrationInfo::OnRefreshAccessTokenDone

//callback control flow
EventNetworkImpl::UpdateNetworkState()
        connectivity_probe_.reset(bufferevent_socket_new
        bufferevent_setcb(
                [](struct bufferevent* buf, short events, void* ctx) {
                        if (events & BEV_EVENT_CONNECTED) {
                        network->UpdateNetworkStateCallback(State::kOnline);

event_base_loop(g_event_base, EVLOOP_ONCE);
        EventNetworkImpl::UpdateNetworkStateCallback(
                Manager::OnConnectivityChanged() {
                        Manager::OnChanged() {
                                //VLOG(1) << "Manager::OnChanged";
                                publisher_->Update();
                                          ExposeService();
                                                //VLOG(2) << "DNS-SD update requested";
                                                //VLOG(1) << "Updating service using DNS-SD, port: " << port;
                                                dns_sd_->PublishService(kPrivetServiceType, port, txt_record);


                task_runner_->PostDelayedTask(
                        FROM_HERE, base::Bind(&EventNetworkImpl::UpdateNetworkState,

//dns sd
new weave::examples::HttpServerImpl{task_runner_.get()});
                                 SSL_library_init();
                                 httpd_.reset(evhtp_new(task_runner_->GetEventBase(), nullptr));
                                 evhtp_bind_socket(httpd_.get(), "0.0.0.0", GetHttpPort(), -1) //7780

StartPrivet();
        new privet::Manager{task_runner_}
        privet_->Start(network_
                for (const auto& path : privet_handler_->GetHttpPaths()) {
                        http_server->AddHttpRequestHandler(path, base::Bind(&Manager::PrivetRequestHandler,
                                handlers_[std::make_pair(path, httpd_.get())] = callback;
                                        evhtp_set_cb(httpd_.get(), path.c_str(), &ProcessRequestCallback, this);


ProcessRequestCallback
        static_cast<HttpServerImpl*>(arg)->ProcessRequest(req);
        HttpServerImpl::ProcessRequest
                new RequestImpl{EventPtr<evhtp_request_t>{req}}
                //it->second.Run(std::move(request));
                Manager::PrivetRequestHandler
                        request->GetData()
                        PrivetRequestHandlerWithData(request, content_type == http::kJson
                                value = base::JSONReader::Read(data)
                                value->GetAsDictionary(&dictionary);
                                PrivetHandler::HandleRequest(request->GetPath(), auth_header, dictionary,
                                base::Bind(&Manager::PrivetResponseHandler,)
                                //(this->*handler->second.handler)(*input, user_info, callback);
                                PrivetHandler::HandleInfo
                                        output.SetString(kInfoVersionKey, kInfoVersionValue);
                                                output.SetString(kInfoIdKey, cloud_->GetDeviceId());
                                                output.SetString(kNameKey, name);
                                                //callback.Run(http::kOk, output);
                                                Manager::PrivetResponseHandler
                                                        base::JSONWriter::WriteWithOptions(output, base::JSONWriter::OPTIONS_PRETTY_PRINT, &data);
                                                        //request->SendReply(status, data, http::kJson);
                                                                HttpServerImpl::SendReply
                                                                evhtp_send_reply_start(req_.get(), status_code);
                                                        evhtp_send_reply_body(req_.get(), buf.get());
                                                        evhtp_send_reply_end(req_.get());

raspberry pi:

make –j5 && make –j5 modules
CONCURRENCY_LEVEL=5 DEB_HOST_ARCH=armhf fakeroot make-kpkg --append-to-version raspberry --revision `date +%Y%m%d%H%M%S` --initrd kernel_image kernel_headers
sudo dpkg -i linux-header*.deb linux-image*.deb
sudo sh –c ‘echo “kernel=vmlinuz-3.18.11-rpi2-v7+” >> config.txt’
** mbed
iperf_run_client
        iperf_connect
                test->ctrl_sck = netdial(test->settings->domain, Ptcp, test->bind_address, 0, test->server_hostname, test->server_port);
                        s = socket(server_res->ai_family, proto, 0);
                        bind(s, (struct sockaddr *) local_res->ai_addr, local_res->ai_addrlen)
                        connect(s, (struct sockaddr *) server_res->ai_addr, server_res->ai_addrlen)
                Nwrite
                        r = write(fd, buf, nleft);
                FD_SET(test->ctrl_sck, &test->read_set);

udpecho_thread
        conn = netconn_new(NETCONN_UDP);
        netconn_bind(conn, NULL, 7);
        while (1)
    {
        err = netconn_recv(conn, &buf);
        netbuf_copy(buf, buffer, buf->p->tot_len)
        err = netconn_send(conn, buf);
        netbuf_delete(buf);
*** lwip
main
        app_low_level_init
        tcpip_init
        netif_add
        netif_set_default
        ping_init
                sys_thread_new("ping_thread", ping_thread, NULL, PING_STACKSIZE, PING_PRIORITY);
                OSA_Start();
                    vTaskStartScheduler();
                while(1){}

ping_thread
        netif_set_up(&fsl_netif0);
        lwip_socket(AF_INET, SOCK_RAW, IP_PROTO_ICMP)
        lwip_setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout))
        while (1)
    {
        ping_send(s, &ping_target)
                iecho = (struct icmp_echo_hdr *)mem_malloc((mem_size_t)ping_size);
                ping_prepare_echo(iecho, (u16_t)ping_size);
                lwip_sendto(s, iecho, ping_size, 0, (struct sockaddr*)&to, sizeof(to));
                        p = pbuf_alloc(PBUF_TRANSPORT, short_size, PBUF_RAM);
                        inet_addr_to_ipaddr_p(remote_addr, &to_in->sin_addr);
                        remote_port = ntohs(to_in->sin_port);
                        LOCK_TCPIP_CORE();
                        err = sock->conn->last_err = raw_sendto(sock->conn->pcb.raw, p, remote_addr);

                        UNLOCK_TCPIP_CORE();
                        pbuf_free(p);

        ping_recv(s);

define LWIP_DEBUG //


lwipv4_socket_recv
        recv_validate(socket, buf, len)
        recv_copy_free(socket, buf, len)

irqTCPRecv


tcp_pcb_purge
        //"tcp_pcb_purge\n"));
        //"tcp_pcb_purge: data left on ->unacked\n"
        tcp_segs_free(pcb->unacked);
                tcp_seg_free(seg);
                        pbuf_free(seg->p);
                        memp_free(MEMP_TCP_SEG, seg);



struct k64f_enetdata {
  struct netif *netif;  /**< Reference back to LWIP parent netif */
  volatile u32_t rx_free_descs; /**< Count of free RX descriptors */
  struct pbuf *rxb[ENET_RX_RING_LEN]; /**< RX pbuf pointer list, zero-copy mode */
  uint8_t *rx_desc_start_addr; /**< RX descriptor start address */
  uint8_t *tx_desc_start_addr; /**< TX descriptor start address */
  uint8_t tx_consume_index, tx_produce_index; /**< TX buffers ring */
  uint8_t rx_fill_index; /**< RX ring fill index */
  struct pbuf *txb[ENET_TX_RING_LEN]; /**< TX pbuf pointer list, zero-copy mode */
  void *txb_aligned[ENET_TX_RING_LEN]; /**< TX aligned buffers (if needed) */
};

EthernetInterface::init
        set_mac_address();//sal-iface-eth
                mbed_mac_address //mbed-hal-frdm-k64f
    init_netif(NULL, NULL, NULL);
        lwip_init();

            memset((void*) &netif, 0, sizeof(netif));
            netif_add(&netif, ipaddr, netmask, gw, NULL, eth_arch_enetif_init, ethernet_input);
                 netif->state = state;
                         netif->num = netifnum++;
                 netif->input = input; //ethernet_input
                 netif_set_addr(netif, ipaddr, netmask, gw);
                 //init(netif) //eth_arch_enetif_init
                        eth_arch_enetif_init
                                k64f_enetdata.netif = netif;
                                SysTick_Init();
                                netif->flags = NETIF_FLAG_BROADCAST
                                                                | NETIF_FLAG_ETHARP
                                                                | NETIF_FLAG_ETHERNET
                                                                | NETIF_FLAG_IGMP;
                                netif->state = &k64f_enetdata;
                                        err = low_level_init(netif);
                                                k64f_init_eth_hardware
                                                enetIfPtr->macCfgPtr = &g_enetMacCfg[BOARD_DEBUG_ENET_INSTANCE];
                                                        enetIfPtr->phyCfgPtr = &g_enetPhyCfg[
                                                enetIfPtr = (enet_dev_if_t *)&enetDevIf[BOARD_DEBUG_ENET_INSTANCE]
                                                enetIfPtr->macApiPtr = &g_enetMacApi;
                                                enetIfPtr->phyApiPtr = (void *)&g_enetPhyApi;
                                                k64f_rx_setup(netif, &rxbdCfg)
                                                        rxBdPtr = (uint8_t *)calloc(1, enet_hal_get_bd_size() * enetIfPtr->macCfgPtr->rxBdNumber + ENET_BD_ALIGNMENT);
                                                        k64f_rx_queue(netif, RX_PBUF_AUTO_INDEX);
                                                                pbuf_alloc(PBUF_RAW, enetIfPtr->macCfgPtr->rxBufferSize + RX_BUF_ALIGNMENT, PBUF_RAM);
                                                k64f_tx_setup(netif, &txbdCfg)
                                                enet_mac_init(enetIfPtr, &rxbdCfg, &txbdCfg)
                                                         enetIfHandle = enetIfPtr;
                                                phy_get_link_speed(enetIfPtr, &phy_speed);
                                                        phy_get_link_duplex(enetIfPtr, &phy_duplex);
                                                        BW_ENET_RCR_RMII_10T(enetIfPtr->deviceNumber, phy_speed == kEnetSpeed10M ? kEnetCfgSpeed10M : kEnetCfgSpeed100M);
                                                        BW_ENET_TCR_FDEN(enetIfPtr->deviceNumber, phy_duplex == kEnetFullDuplex ? kEnetCfgFullDuplex : kEnetCfgHalfDuplex);
                                netif->output = /*k64f_*/etharp_output;
                                        netif->linkoutput = k64f_low_level_output;
            netif_set_default(&netif);
                netif_default = netif;
            netif_set_link_callback  (&netif, netif_link_callback);
                netif->link_callback = link_callback;
                         // link_up = 1;
            netif_set_status_callback(&netif, netif_status_callback);
                netif->status_callback = status_callback;
                        //if_up = 1;
            allow_net_callbacks = 1;


lwip_init
        stats_init();
        mem_init();
        memp_init();
                #define LWIP_MEMPOOL(name,num,size,desc) u8_t memp_memory_ ## name ## _base \
                  [((num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size)))];
                #include "lwip/memp_std.h"

                /** This array holds the base of each memory pool. */
                static u8_t *const memp_bases[] = {
                #define LWIP_MEMPOOL(name,num,size,desc) memp_memory_ ## name ## _base,
                #include "lwip/memp_std.h"
                };
        pbuf_init();
        netif_init()
                netif_add(&loop_netif,
                netif_set_up(&loop_netif);
        //lwip_socket_init();
        //ip_init();
        //etharp_init();
        //raw_init();
        //udp_init();
        //tcp_init();
        //snmp_init();
        //autoip_init();
        igmp_init();
                IP4_ADDR(&allsystems, 224, 0, 0, 1);
                IP4_ADDR(&allrouters, 224, 0, 0, 2);
        dns_init();
                DNS_SERVER_ADDRESS(&dnsserver);
                dns_pcb = udp_new();
                        pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
                udp_bind(dns_pcb, IP_ADDR_ANY, 0);
                        //udp_bind(ipaddr = port = 0)
                        ip_addr_set(&pcb->local_ip, ipaddr);
                        pcb->local_port = port;
                        //udp_bind: bound to 0.0.0.0, port 49152
        udp_recv(dns_pcb, dns_recv, NULL);
                pcb->recv = recv;
                        pcb->recv_arg = recv_arg;
        dns_setserver(0, &dnsserver);
                dns_servers[numdns] = (*dnsserver);
        sys_timeouts_init();
                sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
                        timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
                        timeout->h = handler;
                        timeout->arg = arg;
                        timeout->time = msecs;
                        static struct sys_timeo *next_timeout;
                        for(t = next_timeout; t != NULL; t = t->next) {
                                timeout->next = t->next;
                        t->next = timeout;
                sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
                        etharp_tmr

                sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
                sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
                        dhcp_fine_tmr
                                if (netif->dhcp->request_timeout == 1)
                                        dhcp_timeout(netif);
                                                struct dhcp *dhcp = netif->dhcp;
                                                //dhcp_timeout()
                                                if (dhcp->state == DHCP_CHECKING)
                                                        //dhcp_timeout(): CHECKING, ARP request timed out
                                                        dhcp_bind(netif);
                                                                //dhcp_bind(netif=%p)
                                                                //dhcp_bind(): t1 renewal timer 345600 secs
                                                                dhcp->t1_timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
                                                                //dhcp_bind(): set request timeout 345600000 msecs
                                                                //dhcp_bind(): t2 rebind timer 604800 secs
                                                                dhcp->t2_timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
                                                                //dhcp_bind(): set request timeout 604800000 msecs
                                                                //dhcp_bind(): IP: 0x5204a8c0
                                                                netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
                                                                        //netif_set_ipaddr: netif address being changed
                                                                        //netif: IP address of interface en set to 192.168.4.82
                                                                //"dhcp_bind(): SN: 0x%08"X32_F"
                                                                netif_set_netmask(netif, &sn_mask);
                                                                        //netif: netmask of interface en set to 255.255.254.0
                                                                //dhcp_bind(): GW: 0x0104a8c0
                                                                netif_set_gw(netif, &gw_addr);
                                                                        //netif: GW address of interface en set to 192.168.4.1
                                                                netif_set_up(netif);
                                                                dhcp_set_state(dhcp, DHCP_BOUND);
                //sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);
                sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
                sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);

EthernetInterface::connect
        netif_set_up(struct netif *netif)
                etharp_gratuitous
                        etharp_request((netif), &(netif)->ip_addr)// dst is us, RFC3220
                                //etharp_request: sending ARP request.
                                etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                                        pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
                                        //"etharp_raw: sending raw ARP packet
                                        result = netif->linkoutput(netif, p);
                                        k64f_low_level_output
                                                k64f_tx_ready(netif)
                                                k64f_update_txbds(k64f_enet, idx, q->payload, q->len, 0);
                                                //k64f_low_level_output: pbuf packet(0x20003a28) sent, chain#=0, size = 44 (index=0)
                                                enet_hal_active_txbd(BOARD_DEBUG_ENET_INSTANCE_ADDR);
                                                         HW_ENET_TDAR_SET(instance, BM_ENET_TDAR_TDAR);
                                        pbuf_free(p);
                                        // ("pbuf_free: %p has ref %"U16_F", ending here


etharp_request((netif), &(netif)->ip_addr)// dst is us, RFC3220
        //etharp_request: sending ARP request.
        etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
                //"etharp_raw: sending raw ARP packet
                result = netif->linkoutput(netif, p);
                k64f_low_level_output
                        k64f_tx_ready(netif)
                        k64f_update_txbds(k64f_enet, idx, q->payload, q->len, 0);
                        //k64f_low_level_output: pbuf packet(0x20003a28) sent, chain#=0, size = 44 (index=0)
                        enet_hal_active_txbd(BOARD_DEBUG_ENET_INSTANCE_ADDR);
                                 HW_ENET_TDAR_SET(instance, BM_ENET_TDAR_TDAR);
                pbuf_free(p);
                // ("pbuf_free: %p has ref %"U16_F", ending here


enet_mac_tx_isr(void *enetIfPtr)
        enet_hal_clear_interrupt(((enet_dev_if_t *)enetIfPtr)->deviceNumber, kEnetTxFrameInterrupt);
        k64f_tx_reclaim(k64f_enet);
                pbuf_free(k64f_enet->txb[i]);
                //pbuf_free: deallocating


EthernetInterface::connect
        eth_arch_enable_interrupts
                enet_hal_config_interrupt(BOARD_DEBUG_ENET_INSTANCE_ADDR, (kEnetTxFrameInterrupt | kEnetRxFrameInterrupt), true);
                INT_SYS_EnableIRQ(enet_irq_ids[BOARD_DEBUG_ENET_INSTANCE][enetIntMap[kEnetRxfInt]]);
                INT_SYS_EnableIRQ(enet_irq_ids[BOARD_DEBUG_ENET_INSTANCE][enetIntMap[kEnetTxfInt]]);
         dhcp_start(&netif);
                //dhcp_start(netif=%p)
                if (dhcp == NULL) {
                        //"dhcp_start(): starting new DHCP client
                        dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
                        //dhcp_start(): allocated dhcp
                        dhcp->pcb = udp_new();
                        udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);//68
                        udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);//67
                                ip_addr_set(&pcb->remote_ip, ipaddr);
                                pcb->remote_port = port;
                                //udp_connect: connected to %"U16_F".%"U16_F"
                                pcb->next = udp_pcbs;
                                udp_pcbs = pcb;
                        udp_recv(dhcp->pcb, dhcp_recv, netif);
                                pcb->recv = recv;
                                pcb->recv_arg = recv_arg;
                        result = dhcp_discover(netif);

dhcp_discover(netif);
        //"dhcp_discover()\n")
        ip_addr_set_any(&dhcp->offered_ip_addr);
        dhcp_set_state(dhcp, DHCP_SELECTING);
        result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER)
        //"dhcp_discover: making request
        //"dhcp_discover: realloc()ing\n"
        udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
                udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
                        ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
                                ip_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
                                        netif->output(netif, p, dest);



ENET_Receive_IRQHandler  ; Ethernet MAC Receive Interrupt//startup_mk64f12.s
        enet_hal_get_interrupt_status(((enet_dev_if_t *)enetIfPtr)->deviceNumber
        enet_mac_rx_isr(enetIfHandle);
                struct k64f_enetdata *k64f_enet = &k64f_enetdata;
                enet_bd_struct_t * bdPtr = (enet_bd_struct_t*)k64f_enet->rx_desc_start_addr;
                enet_hal_clear_interrupt
                while ((bdPtr[idx].control & kEnetRxBdEmpty)
                        k64f_enetif_input(k64f_enet->netif, idx);
                                p = k64f_low_level_input(netif, idx);
                                        k64f_rx_queue(netif, idx)
                                                p = pbuf_alloc(PBUF_RAW, enetIfPtr->macCfgPtr->rxBufferSize + RX_BUF_ALIGNMENT, PBUF_RAM);
                                                k64f_rxqueue_pbuf(k64f_enet, p, idx);
                                                        enet_hal_init_rxbds(start + idx, (uint8_t*)p->payload, idx == ENET_RX_RING_LEN - 1);
                                                        enet_hal_active_rxbd(BOARD_DEBUG_ENET_INSTANCE_ADDR);
                                //netif->input(p, netif)
                                ethernet_input
                idx = (idx + 1) % ENET_RX_RING_LEN;

ethernet_input
        //ethernet_input: dest:%"X8_F"
        type = ethhdr->type;
        case PP_HTONS(ETHTYPE_ARP):
                etharp_arp_input (netif, (struct eth_addr*)(netif->hwaddr), p)
                        //update_arp_entry:
                        find_entry(ipaddr, flags);
                                for (i = 0; i < ARP_TABLE_SIZE; ++i) {
                                        //"find_entry: found empty entry
                                        //find_entry: no empty entry found and not allowed to recycle
                        update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
                           for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
                        //etharp_arp_input: incoming ARP reply
                        dhcp_arp_reply(netif, &sipaddr);
                        //"dhcp_arp_reply()\
        case PP_HTONS(ETHTYPE_IP):
                ip_input(p, netif);
                        iphdr_len = ntohs(IPH_LEN(iphdr));
                        pbuf_realloc(p, iphdr_len);
                        //"ip_input: iphdr->dest 0x%"X32_F" netif->ip_addr 0x%"X32_F
                        if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
                                //"ip_input: UDP packet to DHCP client port
                                if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
                                        //"ip_input: DHCP packet accepted
                        //ip_input: \n"
                        ip_debug_print(p);
                        //ip_input: p->len 328 p->tot_len 328
                        switch (IPH_PROTO(iphdr))
                                case IP_PROTO_UDP:
                                udp_input(p, inp);
                                case IP_PROTO_TCP:
                                tcp_input(p, inp);
                                case IP_PROTO_ICMP:
                                icmp_input(p, inp);
                                case IP_PROTO_IGMP:
                                igmp_input(p, inp, &current_iphdr_dest);

udp_input
        //("udp_input: calculating checksum
        mpcb->recv(mpcb->recv_arg, mpcb, q, ip_current_src_addr(), src);
        dhcp_recv
                //"dhcp_recv(pbuf = %p) from DHCP server
                //("searching DHCP_OPTION_MESSAGE_TYPE
                if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING))
                        //"DHCP_OFFER received in DHCP_SELECTING state
                        dhcp_handle_offer(netif);
                                //dhcp_handle_offer(netif
                                ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
                                //dhcp_handle_offer(): server 0x%08"
                                ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
                                //"dhcp_handle_offer(): offer for 0
                                dhcp_select(netif);
                                        dhcp_set_state(dhcp, DHCP_REQUESTING);
                                        result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
                                        dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
                                dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
                                        udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
                if (msg_type == DHCP_ACK)
                        //DHCP_ACK received
                        dhcp_handle_ack(netif);
                                dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
                                dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
                                dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
                                ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
                                ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
                                ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
                                ip4_addr_set_u32(&dns_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
                                dns_setserver(n, &dns_addr);
                        dhcp_check(netif);
                                //dhcp_check(netif=0x1fffaac0) en
                                dhcp_set_state(dhcp, DHCP_CHECKING);
                                etharp_query(netif, &dhcp->offered_ip_addr, NULL);
                                        //etharp_request: sending ARP request.
                                dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;

TCPStream(SOCKET_STACK_LWIP_IPV4) _stream;              /**< The TCP Socket */
        TCPAsynch::TCPAsynch(const socket_stack_t stack)
                Socket(stack)
                        Socket(const socket_stack_t stack);
                                CThunk(this)
                                        init(instance, NULL, NULL);
                                                m_thunk.context = (uint32_t)context;
                                m_thunk.instance = (uint32_t)instance;
                                m_thunk.callback = (uint32_t)&m_callback;
                                m_thunk.trampoline = (uint32_t)&trampoline;
                                _irq.callback(&Socket::_nvEventHandler);
                            _socket.handler = (socket_api_handler_t)_irq.entry();
                                return (((uint32_t)&m_thunk)|CTHUNK_ADDRESS);
                            _socket.impl = NULL;
                            _socket.stack = stack;
                            _socket.api = socket_get_api(stack);
                            //socket_api_ptrs[i]  lwipv4_socket_init() {
                        //	return socket_register_stack(&lwipv4_socket_api);
                _socket.family = SOCKET_STREAM;

_stream.open(SOCKET_AF_INET4);
        socket_error_t err = Socket::open(af, SOCKET_STREAM);
                _socket.api->create(&_socket, af, pf, (socket_api_handler_t)_irq.entry());
                lwipv4_socket_create
                        struct tcp_pcb *tcp = tcp_new();
                                return tcp_alloc(TCP_PRIO_NORMAL);
                                        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);

                        sock->impl = (void *)tcp;
                    sock->stack = SOCKET_STACK_LWIP_IPV4;
                    tcp_arg(tcp, (void*) sock);
                    tcp_err(tcp, tcp_error_handler);
                sock->family = pf;
                sock->handler = (void*)handler;//_nvEventHandler

_nvEventHandler
        minar::Scheduler::postCallback(_onError.bind(this, ev->i.e));
        minar::Scheduler::postCallback(_onReadable.bind(this));
        minar::Scheduler::postCallback(_onSent.bind(this, ev->i.t.sentbytes));
        minar::Scheduler::postCallback(_onDNS.bind(this, ev->i.d.addr, ev->i.d.domain));

Socket::resolve //fix ip
        _socket.api->resolve(&_socket, address);
        lwipv4_socket_resolve
                err_t err = dns_gethostbyname(address, &ia, dnscb, sock);
                        ipaddr = ipaddr_addr(hostname);
                        ip4_addr_set_u32(addr, ipaddr);
                        //dns_enqueue(hostname, found, callback_arg);
                dnscb(address, &ia, sock);
                        socket_api_handler_t handler = (socket_api_handler_t) sock->handler;
                        e.event = SOCKET_EVENT_DNS;
                        socket_addr_set_ipv4_addr(&e.i.d.addr, addr->addr);
                        //handler()
                        _nvEventHandler
                                minar::Scheduler::postCallback(_onDNS.bind(this, ev->i.d.addr, ev->i.d.domain));
                lwipv4_socket_error_remap(err);

 _stream.connect
        _socket.api->connect(&_socket, address.getAddr(), port);
        lwipv4_socket_connect
                tcp_connect((struct tcp_pcb *)sock->impl, (void*)socket_addr_get_ipv4_addrp(address), port, irqConnect);
                        pcb->remote_ip = *ipaddr;
                        pcb->remote_port = port;
                        pcb->local_port = tcp_new_port();
                        pcb->connected = connected;//irqConnect
                        tcp_enqueue_flags(pcb, TCP_SYN);
                                //tcp_enqueue_flags: queuelen:
                                pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)
                                seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)
                                //tcp_enqueue_flags: queueing
                                pcb->unsent = seg;
                                pcb->snd_queuelen += pbuf_clen(seg->p);
                                //tcp_enqueue_flags: 1 (after enqueued)
                        TCP_REG(&tcp_active_pcbs, pcb);
                        tcp_output(pcb);
                                //tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd
                                 tcp_output_segment(seg, pcb);
                                         seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
                                         seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
                                         //tcp_output_segment: %"U32_F":%"U32_F"\
                                         inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
                                         seg->tcphdr->chksum = FOLD_U32T(acc);
                                         //netif->output()
                                         ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
                                         IP_PROTO_TCP);
                                 pcb->unacked = seg;

ip_output
        netif = ip_route(dest)
        ip_output_if(p, src, dest, ttl, tos, proto, netif);
                ip_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
                pbuf_header(p, IP_HLEN)
                //pbuf_header: old 0x20003a4c new 0x20003a38
                IPH_TTL_SET(iphdr, ttl);
        IPH_PROTO_SET(iphdr, proto);
                iphdr = (struct ip_hdr *)p->payload
                ip_addr_copy(iphdr->src, *src);
                ip_addr_copy(dest_addr, iphdr->dest);
                ip_debug_print(struct pbuf *p)
/*
IP header:
+-------------------------------+
| 4 | 5 |  0x00
|        44     | (v, hl, tos, len)
+-------------------------------+
|        0
|000|       0   | (id, flags, offset)
+-------------------------------+
|  255
|    6  |    0x31d7     | (ttl, proto, chksum)
+-------------------------------
+
|  192  |  168  |    4  |   11  | (src)
+-------------------------------+
|  192
|  168  |    4  |  153  | (dest)
+-------------------------------+
*/

netif->output(netif, p, dest);
        etharp_output
                pbuf_header(q, sizeof(struct eth_hdr)
                etharp_query(netif, ipaddr, q);
                        find_entry(ipaddr, ETHARP_FLAG_TRY_HARD)
                                //find_entry: found empty entry 0
                                //find_entry: selecting empty entry 0
                        if (arp_table[i].state == ETHARP_STATE_EMPTY) {
                        arp_table[i].state = ETHARP_STATE_PENDING;
                        }
                        result = etharp_request(netif, ipaddr);
                        etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
                        //etharp_send_ip: sending packet %p
                        netif->linkoutput(netif, p)
                        k64f_low_level_output
                                k64f_tx_ready(netif)
                                k64f_update_txbds(k64f_enet, idx, q->payload, q->len, 0);
                                //k64f_low_level_output: pbuf packet(0x20003a28) sent, chain#=0, size = 44 (index=0)
                                enet_hal_active_txbd(BOARD_DEBUG_ENET_INSTANCE_ADDR);
                                         HW_ENET_TDAR_SET(instance, BM_ENET_TDAR_TDAR);
request_module
        call_usermodehelper
** linux
*** network
static struct inet_protosw inetsw_array[] =
{
        {
                .type =       SOCK_STREAM,
                .protocol =   IPPROTO_TCP,
                .prot =       &tcp_prot,
                .ops =        &inet_stream_ops,
                .no_check =   0,
                .flags =      INET_PROTOSW_PERMANENT |
                              INET_PROTOSW_ICSK,
        },
struct proto tcp_prot = {
        .name			= "TCP",
        .owner			= THIS_MODULE,
        .close			= tcp_close,
        .connect		= tcp_v4_connect,
        .disconnect		= tcp_disconnect,
        .accept			= inet_csk_accept,
        .ioctl			= tcp_ioctl,
        .init			= tcp_v4_init_sock,
        .destroy		= tcp_v4_destroy_sock,
        .shutdown		= tcp_shutdown,
        .setsockopt		= tcp_setsockopt,
        .getsockopt		= tcp_getsockopt,
        .recvmsg		= tcp_recvmsg,
        .sendmsg		= tcp_sendmsg,
        .sendpage		= tcp_sendpage,
        .backlog_rcv		= tcp_v4_do_rcv,
        .release_cb		= tcp_release_cb,
        .mtu_reduced		= tcp_v4_mtu_reduced,
        .hash			= inet_hash,
        .unhash			= inet_unhash,
        .get_port		= inet_csk_get_port,
        .enter_memory_pressure	= tcp_enter_memory_pressure,
        .sockets_allocated	= &tcp_sockets_allocated,
        .orphan_count		= &tcp_orphan_count,
        .memory_allocated	= &tcp_memory_allocated,
        .memory_pressure	= &tcp_memory_pressure,
        .sysctl_wmem		= sysctl_tcp_wmem,
        .sysctl_rmem		= sysctl_tcp_rmem,
        .max_header		= MAX_TCP_HEADER,
        .obj_size		= sizeof(struct tcp_sock),
        .slab_flags		= SLAB_DESTROY_BY_RCU,
        .twsk_prot		= &tcp_timewait_sock_ops,
        .rsk_prot		= &tcp_request_sock_ops,
        .h.hashinfo		= &tcp_hashinfo,
        .no_autobind		= true,
#ifdef CONFIG_COMPAT
        .compat_setsockopt	= compat_tcp_setsockopt,
        .compat_getsockopt	= compat_tcp_getsockopt,
#endif
#ifdef CONFIG_MEMCG_KMEM
        .init_cgroup		= tcp_init_cgroup,
        .destroy_cgroup		= tcp_destroy_cgroup,
        .proto_cgroup		= tcp_proto_cgroup,
#endif
};
const struct proto_ops inet_stream_ops = {
        .family            = PF_INET,
        .owner             = THIS_MODULE,
        .release           = inet_release,
        .bind              = inet_bind,
        .connect           = inet_stream_connect,
        .socketpair        = sock_no_socketpair,
        .accept            = inet_accept,
        .getname           = inet_getname,
        .poll              = tcp_poll,
        .ioctl             = inet_ioctl,
        .listen            = inet_listen,
        .shutdown          = inet_shutdown,
        .setsockopt        = sock_common_setsockopt,
        .getsockopt        = sock_common_getsockopt,
        .sendmsg           = inet_sendmsg,
        .recvmsg           = inet_recvmsg,
        .mmap              = sock_no_mmap,
        .sendpage          = inet_sendpage,
        .splice_read       = tcp_splice_read,
#ifdef CONFIG_COMPAT
        .compat_setsockopt = compat_sock_common_setsockopt,
        .compat_getsockopt = compat_sock_common_getsockopt,
        .compat_ioctl      = inet_compat_ioctl,
#endif
};

SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)
        sock_create
                __sock_create
                        sock = sock_alloc();
                        //pf->create(net, sock, protocol, kern);
                        inet_create
                                 sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot)
                                 //sk->sk_prot->init(sk);
                                        tcp_v4_init_sock
        sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));
                sock_alloc_file(sock, flags, NULL);
                        alloc_file(&path, FMODE_READ | FMODE_WRITE,
                                &socket_file_ops);
                fd_install(fd, newfile);

SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)
        //sock->ops->bind(sock,
        inet_bind
                inet->inet_rcv_saddr = inet->inet_saddr = addr->sin_addr.s_addr;
                inet_csk_get_port
                        head = &hashinfo->bhash[inet_bhashfn(net, rover,
                inet->inet_sport = htons(inet->inet_num);
                inet->inet_daddr = 0;
                inet->inet_dport = 0;

inet_listen
        inet_csk_listen_start(sk, backlog);
                inet_connection_sock *icsk = inet_csk(sk);
                reqsk_queue_alloc(&icsk->icsk_accept_queue, nr_table_entries);
                         nr_table_entries = min_t(u32, nr_table_entries, sysctl_max_syn_backlog);
                //sk->sk_prot->hash(sk);
                inet_hash
                        __inet_hash(sk);
                        ilb = &hashinfo->listening_hash[inet_sk_listen_hashfn(sk)];
                        __sk_nulls_add_node_rcu(sk, &ilb->head);

accept4
        sock = sockfd_lookup_light(fd, &err, &fput_needed);
        newsock = sock_alloc();
        newsock->type = sock->type;
        newsock->ops = sock->ops;
        newfile = sock_alloc_file(newsock, flags, sock->sk->sk_prot_creator->name);
        //sock->ops->accept(sock, newsock, sock->file->f_flags)
        inet_accept
                //sk2 = sk1->sk_prot->accept(sk1, flags, &err)
                inet_csk_accept
                        request_sock_queue *queue = &icsk->icsk_accept_queue;
                        req = reqsk_queue_remove(queue);
                        newsk = req->sk;
                        sk_acceptq_removed(sk);
                sock_graft(sk2, newsock);
                        sk_set_socket(sk, parent);
        newsock->ops->getname(newsock, (struct sockaddr *)&address,
        move_addr_to_user(&address,
        fd_install(newfd, newfile);

SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,
        sockfd_lookup_light(fd, &err, &fput_needed);
        err = move_addr_to_kernel(uservaddr, addrlen, &address);
        //sock->ops->connect(sock, (struct sockaddr *)&address, addrlen,
        inet_stream_connect
                err = __inet_stream_connect(sock, uaddr, addr_len, flags);
                        //err = sk->sk_prot->connect(sk, uaddr, addr_len);
                        tcp_v4_connect

inet_init(void)
        proto_register(&tcp_prot, 1);
        for (q = inetsw_array; q < &inetsw_array[INETSW_ARRAY_LEN]; ++q)
                inet_register_protosw(q);
        inet_add_protocol(&tcp_protocol, IPPROTO_TCP)
        arp_init();
        ip_init();
        tcp_v4_init();
        tcp_init();
        dev_add_pack(&ip_packet_type);
                ptype_head(pt)
                        if (pt->type == htons(ETH_P_ALL))
                                return &ptype_all;
                        else
                                return &ptype_base[ntohs(pt->type) & PTYPE_HASH_MASK];

DEFINE_PER_CPU_ALIGNED(struct softnet_data, softnet_data);
struct napi_struct {

net_dev_init
        for_each_possible_cpu(i) {
                struct softnet_data *sd = &per_cpu(softnet_data, i);
                skb_queue_head_init(&sd->input_pkt_queue);
                skb_queue_head_init(&sd->process_queue);
                sd->backlog.poll = process_backlog;
        open_softirq(NET_TX_SOFTIRQ, net_tx_action);
        open_softirq(NET_RX_SOFTIRQ, net_rx_action);

static struct sdio_drv_priv sdio_drvpriv = {
        .r871xs_drv.probe = rtw_drv_init,
rtw_drv_init
        rtw_sdio_if1_init
                rtw_set_hal_ops
                        rtl8723bs_set_hal_ops
                                rtl8723bs_init_recv_priv
rtl8723bs_recv_tasklet
        rtw_recv_entry
                recv_func
                        recv_func_prehandle
                                mp_recv_frame
                                        recv_indicatepkts_in_order
                                                rtw_recv_indicatepkt
                                                        rtw_os_recv_indicate_pkt
                                                                pkt->protocol = eth_type_trans(pkt, padapter->pnetdev);
                                                                        is_multicast_ether_addr(eth->h_dest)
                                                                        ether_addr_equal_64bits(eth->h_dest, dev->broadcast)
                                                                        skb->pkt_type =
                                                                        if (ntohs(eth->h_proto) >= ETH_P_802_3_MIN)
                                                                                return eth->h_proto;
                                                                rtw_netif_rx
                                                                        _rtw_netif_rx
                                                                                netif_rx

netif_rx
        netpoll_rx(skb)
        //trace_netif_rx(skb);
        enqueue_to_backlog(skb, get_cpu(), &qtail);
                __skb_queue_tail(&sd->input_pkt_queue, skb);
                ____napi_schedule(sd, &sd->backlog);
                        list_add_tail(&napi->poll_list, &sd->poll_list);
                        __raise_softirq_irqoff(NET_RX_SOFTIRQ);

net_rx_action
        while (!list_empty(&sd->poll_list)) {
                work = n->poll(n, weight);
                        process_backlog
                                while ((skb = __skb_dequeue(&sd->process_queue))) {
                                        __netif_receive_skb(skb);
                //trace_napi_poll(n);
                list_move_tail(&n->poll_list, &sd->poll_list);

__netif_receive_skb
        __netif_receive_skb_core(skb, false)
        //trace_netif_receive_skb(skb);
                skb->skb_iif = skb->dev->ifindex;
                deliver_skb(skb, pt_prev, orig_dev);
                        //pt_prev->func(skb, skb->dev, pt_prev, orig_dev);
                        ip_rcv

ip_rcv
        iph = ip_hdr(skb);
        ip_fast_csum((u8 *)iph, iph->ihl)
        len = ntohs(iph->tot_len);
        skb->transport_header = skb->network_header + iph->ihl*4;
        NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, NULL,
                       ip_rcv_finish)
                ip_route_input_noref(skb, iph->daddr, iph->saddr, iph->tos, skb->dev);
                        res = ip_route_input_slow(skb, daddr, saddr, tos, dev);
                                fib_lookup(net, &fl4, &res);
                                fib_validate_source(skb, saddr, daddr, tos,
                                rth->dst.input= ip_local_deliver;
                                skb_dst_set(skb, &rth->dst);
                                ip_rcv_options(skb)
                                dst_input(skb);
                                //skb_dst(skb)->input(skb)
                                        ip_local_deliver
                                                ip_is_fragment(ip_hdr(skb)
                                                        ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER)
                                                NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, skb, skb->dev, NULL,
                                         ip_local_deliver_finish
                                                __skb_pull(skb, skb_network_header_len(skb));
                                                protocol = ip_hdr(skb)->protocol
                                                ipprot = rcu_dereference(inet_protos[protocol]);
                                                //ret = ipprot->handler(skb);
                                                tcp_v4_rcv //tcp_protocol
tcp_v4_rcv
        th = tcp_hdr(skb);
        iph = ip_hdr(skb);
        TCP_SKB_CB(skb)->seq = ntohl(th->seq);
        TCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +
                                    skb->len - th->doff * 4);
        TCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);
        sk = __inet_lookup_skb(&tcp_hashinfo, skb, th->source, th->dest);
                __inet_lookup(dev_net(skb_dst(skb)->dev), hashinfo,
                        __inet_lookup_established(net, hashinfo,
                                hash = inet_ehashfn(net, daddr, hnum, saddr, sport);
                                INET_MATCH(sk, net, acookie,
                                INET_TW_MATCH(sk, net, acookie,
                        __inet_lookup_listener(net, hashinfo, saddr, sport,
                                struct inet_listen_hashbucket *ilb = &hashinfo->listening_hash[hash];
                        if (!tcp_prequeue(sk, skb))
                                        sysctl_tcp_low_latency || !tp->ucopy.task
                                        skb_dst_force(skb);
                                        __skb_queue_tail(&tp->ucopy.prequeue, skb);
                                        tp->ucopy.memory += skb->truesize;
                                ret = tcp_v4_do_rcv(sk, skb);
                                        if (sk->sk_state == TCP_ESTABLISHED) {
                                                tcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len)
                                        if (sk->sk_state == TCP_LISTEN) {// second ack
                                                tcp_v4_hnd_req(sk, skb);
                                                        request_sock *req = inet_csk_search_req(sk, &prev, th->source,
                                                       iph->saddr, iph->daddr);
                                                        tcp_check_req(sk, skb, req, prev, false);
                                                                //inet_csk(sk)->icsk_af_ops->syn_recv_sock(sk, skb, req, NULL);
                                                                        tcp_v4_syn_recv_sock
                                                                                newsk = tcp_create_openreq_child(sk, req, skb);
                                                                                inet_sk_rx_dst_set(newsk, skb);
                                                                                dst = inet_csk_route_child_sock(sk, newsk, req);
                                                                                __inet_inherit_port(sk, newsk)
                                                                                        tb = inet_csk(sk)->icsk_bind_hash;
                                                                                        port = inet_sk(child)->inet_num;
                                                                                        inet_bind_hash(child, tb, port);
                                                                                                sk_add_bind_node(sk, &tb->owners);
                                                                                __inet_hash_nolisten(newsk, NULL);
                                                                                        head = inet_ehash_bucket(hashinfo, sk->sk_hash);
                                                                                        __sk_nulls_add_node_rcu(sk, list);
                                                                inet_csk_reqsk_queue_unlink(sk, req, prev);
                                                                inet_csk_reqsk_queue_removed(sk, req);
                                                                inet_csk_reqsk_queue_add(sk, req, child);
                                                tcp_child_process(sk, nsk, skb)
                                                        tcp_rcv_state_process(child, skb, tcp_hdr(skb),
                                                                case TCP_SYN_RECV:
                                                                tcp_set_state(sk, TCP_ESTABLISHED);
                                                                tp->snd_una = TCP_SKB_CB(skb)->ack_seq;
                                                                tp->snd_wnd = ntohs(th->window)
                                                                tcp_init_wl(tp, TCP_SKB_CB(skb)->seq);
                                                        parent->sk_data_ready(parent, 0);

                                        tcp_rcv_state_process(sk, skb, tcp_hdr(skb), skb->len)
                                                if (th->syn) { //first syn
                                                        //icsk->icsk_af_ops->conn_request(sk, skb)
                                                        tcp_v4_conn_request
                                                                inet_csk_reqsk_queue_is_full
                                                                sk_acceptq_is_full
                                                                inet_reqsk_alloc(&tcp_request_sock_ops);
                                                                        request_sock *req = reqsk_alloc(ops);
                                                                tcp_parse_options(skb, &tmp_opt, 0, want_cookie ? NULL : &foc);
                                                                tcp_openreq_init(req, &tmp_opt, skb);
                                                                ireq = inet_rsk(req);
                                                                ireq->loc_addr = daddr;
                                                                ireq->rmt_addr = saddr;
                                                                isn = tcp_v4_init_sequence(skb);
                                                                __tcp_v4_send_check(skb_synack, ireq->loc_addr, ireq->rmt_addr);
                                                                skb_set_queue_mapping(skb_synack, skb_get_queue_mapping(skb));
                                                                err = ip_build_and_send_pkt(skb_synack, sk, ireq->loc_addr,
                                                                     ireq->rmt_addr, ireq->opt);
                                                                inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);

tcp_rcv_established
        tcp_checksum_complete_user(sk, skb))
        tcp_queue_rcv(sk, skb, tcp_header_len, &fragstolen);
                __skb_pull(skb, hdrlen);
                tcp_sk(sk)->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
                __skb_queue_tail(&sk->sk_receive_queue, skb);
                skb_set_owner_r(skb, sk);
        tcp_event_data_recv(sk, skb);
        tcp_ack(sk, skb, FLAG_DATA);
        tcp_data_snd_check(sk);
        if (!inet_csk_ack_scheduled(sk))
        __tcp_ack_snd_check(sk, 0);


SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,
        sock_recvmsg
                __sock_recvmsg
                        __sock_recvmsg_nosec(iocb, sock, msg, size, flags)
                                //sock->ops->recvmsg(iocb, sock, msg, size, flags);
                                tcp_recvmsg

tcp_recvmsg
        skb_queue_walk(&sk->sk_receive_queue, skb) {
                err = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, used);
                        //trace_skb_copy_datagram_iovec(skb, len);
                *seq += used;
                copied += used;
                len -= used;
                tcp_rcv_space_adjust(sk);
                tcp_cleanup_rbuf(sk, copied);
                if (copied >= target && !sk->sk_backlog.tail)
                        break;

ip_rcv
        ip_route_input_noref(skb, iph->daddr, iph->saddr, iph->tos, skb->dev);
                res = ip_route_input_slow(skb, daddr, saddr, tos, dev);
                        fib_lookup(net, &fl4, &res);
                        err = ip_mkroute_input(skb, &res, &fl4, in_dev, daddr, saddr, tos);
                                __mkroute_input(skb, res, in_dev, daddr, saddr, tos);
                                        out_dev = __in_dev_get_rcu(FIB_RES_DEV(*res));
                                        fib_validate_source(skb, saddr, daddr, tos, FIB_RES_OIF(*res),
                                        rt_dst_alloc(out_dev->dev,
                                        rth->dst.input = ip_forward;
                                        rth->dst.output = ip_output;
                                        skb_dst_set(skb, &rth->dst);
                                        ip_rcv_options(skb)
                                        dst_input(skb);
                                        //skb_dst(skb)->input(skb)
                                        ip_forward
                                                IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb)
                                                skb_forward_csum(skb);
                                                if (ip_hdr(skb)->ttl <= 1)
                                                xfrm4_route_forward(skb)//ipsec
                                                rt = skb_rtable(skb);
                                                opt->is_strictroute && rt->rt_uses_gateway
                                                ip_may_fragment(skb) && ip_exceeds_mtu(skb, dst_mtu(&rt->dst)
                                                skb_cow(skb, LL_RESERVED_SPACE(rt->dst.dev)+rt->dst.header_len)
                                                ip_decrease_ttl(iph);
                                                skb->priority = rt_tos2priority(iph->tos);
                                                NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, skb, skb->dev,
                                                               rt->dst.dev, ip_forward_finish);
                                                        dst_output(skb);
                                                                //skb_dst(skb)->output(skb)
                                                                ip_output

SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,
        sock = sockfd_lookup_light(fd, &err, &fput_needed);
        err = move_addr_to_kernel(addr, addr_len, &address);
        err = sock_sendmsg(sock, &msg, len);
                 __sock_sendmsg(&iocb, sock, msg, size);
                        __sock_sendmsg_nosec(iocb, sock, msg, size);
                                //sock->ops->sendmsg(iocb, sock, msg, size);
                                tcp_sendmsg

tcp_sendmsg
        timeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);
        sk_stream_alloc_skb(sk,
                alloc_skb_fclone(size + sk->sk_prot->max_header, gfp);
                        cache = (flags & SKB_ALLOC_FCLONE)
                        ? skbuff_fclone_cache : skbuff_head_cache;
                        skb = kmem_cache_alloc_node(cache, gfp_mask & ~__GFP_DMA, node);
                        size = SKB_DATA_ALIGN(size);
                        size += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
                        data = kmalloc_reserve(size, gfp_mask, node, &pfmemalloc);
                        shinfo = skb_shinfo(skb);
                                //skb->head + skb->end;
        skb_entail(sk, skb);
        __tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);
                tcp_write_xmit(sk, cur_mss, nonagle, 0,
                        while ((skb = tcp_send_head(sk))) {
                                tso_segs = tcp_init_tso_segs(sk, skb, mss_now);
                                cwnd_quota = tcp_cwnd_test(tp, skb);
                                tcp_snd_wnd_test(tp, skb, mss_now)
                                tcp_nagle_test(tp, skb, mss_now,
                                tcp_transmit_skb(sk, skb, 1, gfp)
                                //icsk->icsk_af_ops->queue_xmit(skb, &inet->cork.fl);
                                        ip_queue_xmit


ip_queue_xmit // struct inet_connection_sock_af_ops ipv4_specific = {
        inet_opt = rcu_dereference(inet->inet_opt);
        fl4 = &fl->u.ip4;
        rt = skb_rtable(skb);
        rt = (struct rtable *)__sk_dst_check(sk, 0);
        ip_route_output_ports(sock_net(sk), fl4, sk,
                flowi4_init_output(fl4, oif, sk ? sk->sk_mark : 0, tos,
                ip_route_output_flow(net, fl4, sk);
                        __ip_route_output_key(net, flp4);
                        xfrm_lookup(net, &rt->dst, flowi4_to_flowi(flp4),
        skb_dst_set_noref(skb, &rt->dst);
                __skb_dst_set_noref(skb, dst, false);
                        skb->_skb_refdst = (unsigned long)dst | SKB_DST_NOREF;
        skb_push(skb, sizeof(struct iphdr) + (inet_opt ? inet_opt->opt.optlen : 0));
        skb_reset_network_header(skb);
        iph = ip_hdr(skb);
        iph->ttl      = ip_select_ttl(inet, &rt->dst);
        iph->protocol = sk->sk_protocol;
        ip_copy_addrs(iph, fl4);
        ip_local_out(skb);
                __ip_lip_finish_output2ocal_out(skb);
                        ip_send_check
                                iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
                        dst_output
                                //skb_dst(skb)->output(skb);
                                ip_output

ip_output
        struct net_device *dev = skb_dst(skb)->dev;
        skb->dev = dev;
        skb->protocol = htons(ETH_P_IP);
        ip_finish_output
                if (skb->len > ip_skb_dst_mtu(skb) && !skb_is_gso(skb))
                        return ip_fragment(skb, ip_finish_output2);
                else
                        return ip_finish_output2(skb);
                                nexthop = (__force u32) rt_nexthop(rt, ip_hdr(skb)->daddr);
                                neigh = __ipv4_neigh_lookup_noref(dev, nexthop);
                                dst_neigh_output(dst, neigh, skb);
                                //n->output(n, skb);
                                        neigh_resolve_output//struct neigh_ops arp_hh_ops = {
                                                __skb_pull(skb, skb_network_offset(skb));
                                        seq = read_seqbegin(&neigh->ha_lock);
                                        err = dev_hard_header(skb, dev, ntohs(skb->protocol),
                                        dev_queue_xmit(skb);
                                                txq = netdev_pick_tx(dev, skb);
                                                q = rcu_dereference_bh(txq->qdisc);
                                                //trace_net_dev_queue(skb);
                                                __dev_xmit_skb(skb, q, dev, txq);
                                                        __qdisc_run(q)

rtw_drv_init
        rtw_sdio_if1_init
                rtw_wdev_alloc(padapter, dvobj_to_dev(dvobj));
                        wiphy = wiphy_new(&rtw_cfg80211_ops, sizeof(_adapter*));
                                cfg80211_rtw_change_iface	//rtw_cfg80211_ops
                                        netdev_open
                                                _netdev_open
                                                        rtw_netif_wake_queue
                                                                netif_tx_wake_all_queues
                rtw_init_netdev
                        pnetdev->features |= NETIF_F_IP_CSUM;
netif_tx_wake_all_queues
        netif_tx_wake_queue(txq);
                netif_tx_wake_queue(netdev_get_tx_queue(dev, 0));
                        __netif_schedule(dev_queue->qdisc);
                                *sd->output_queue_tailp = q;
                                sd->output_queue_tailp = &q->next_sched;
                                raise_softirq_irqoff(NET_TX_SOFTIRQ);

net_tx_action
        head = sd->output_queue;
        while (head) {
                qdisc_run(q);
                        __qdisc_run(q);
                                qdisc_restart(q)
                                        skb = dequeue_skb(q);
                                        dev = qdisc_dev(q);
                                        txq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));
                                        sch_direct_xmit(skb, q, dev, txq, root_lock);
                                                dev_hard_start_xmit(skb, dev, txq);
                                                        //ops->ndo_start_xmit(skb, dev);
                                                        rtw_cfg80211_monitor_if_xmit_entry
                                                dev_requeue_skb//o

cfg80211_rtw_add_virtual_intf //rtw_cfg80211_ops
        rtw_cfg80211_add_monitor_if
                mon_ndev->netdev_ops = &rtw_cfg80211_monitor_if_ops;

netif_start_queue
        netif_tx_start_queue(netdev_get_tx_queue(dev, 0))
                clear_bit(__QUEUE_STATE_DRV_XOFF, &dev_queue->state);
*** fuse
//android/system/core/sdcard/sdcard.c
fd = open("/dev/fuse", O_RDWR);
snprintf(opts, sizeof(opts),            "fd=%i,rootmode=40000,default_permissions,allow_other,user_id=%d,group_id=%d",
res = mount("/dev/fuse", dest_path, "fuse", MS_NOSUID | MS_NODEV, opts);
fuse_init(&fuse, fd, source_path, write_gid, derive, split_perms);
res = ignite_fuse(&fuse, num_threads);
        handlers = malloc(num_threads * sizeof(struct fuse_handler));
        pthread_create(&thread, NULL, start_handler, &handlers[i]);

start_handler
        handle_fuse_requests(handler);
                read(fuse->fd,
                handler->request_buffer, sizeof(handler->request_buffer));
                handle_fuse_request(fuse, handler, hdr, data, data_len);
                        case FUSE_OPEN: { /* open_in -> open_out */
                const struct fuse_open_in *req = data;
                return handle_open(fuse, handler, hdr, req);
                fuse_status(fuse, unique, res);
                         write(fuse->fd, &hdr, sizeof(hdr));
*** lguest
main //tools/lguest/lguest.c
        devices.descpage = get_pages(1);
        setup_block_file
                new_device("block", VIRTIO_ID_BLOCK);
                        dev->desc = new_dev_desc(type);
                add_virtqueue(dev, VIRTQUEUE_NUM, blk_request);
                        vq->config.num = num_descs;
                        vq->config.irq = devices.next_irq++;
                        vq->config.pfn = to_guest_phys(p) / getpagesize();
                set_config(dev, offsetof(struct virtio_blk_config, geometry), &conf);
        boot = from_guest_phys(0);
        tell_kernel(start);
                lguest_fd = open_or_die("/dev/lguest", O_RDWR);
                write(lguest_fd, args, sizeof(args)) < 0) //LHREQ_INITIALIZE
                        write //drivers/lguest/lguest_user.c
                                initialize(file, input);//drivers/lguest/lguest_user.c
                                        lg = kzalloc(sizeof(*lg), GFP_KERNEL);
                                        err = lg_cpu_start(&lg->cpus[0], 0, args[2]);
                                                cpu->regs_page = get_zeroed_page(GFP_KERNEL);
                                                cpu->regs = (void *)cpu->regs_page + PAGE_SIZE - sizeof(*cpu->regs);
                                                lguest_arch_setup_regs(cpu, start_ip);
                                                        regs->ds = regs->es = regs->ss = __KERNEL_DS|GUEST_PL;
                                                        regs->cs = __KERNEL_CS|GUEST_PL;
                                                        setup_guest_gdt(cpu);
                                                                cpu->arch.gdt[GDT_ENTRY_KERNEL_CS] = FULL_EXEC_SEGMENT;
                                                                cpu->arch.gdt[GDT_ENTRY_KERNEL_DS] = FULL_SEGMENT;
                                        err = init_guest_pagetable(lg);
                                                cpu->cpu_pgd = new_pgdir(cpu, 0, &allocated);
                                                        cpu->lg->pgdirs[next].gpgdir = gpgdir;
                                                        flush_user_mappings(cpu->lg, next);
                                                allocate_switcher_mapping
                                                        pte_t *pte = find_spte(cpu, switcher_addr
                                                        get_page(lg_switcher_pages[0]);
                                                        set_pte(pte, mk_pte(lg_switcher_pages[0], PAGE_KERNEL_RX));
        run_guest();
                for (;;) {
                pread(lguest_fd, &notify_addr,sizeof(notify_addr), cpu_id);
                        run_guest(cpu, (unsigned long __user *)user);
                                lguest_arch_run_guest(cpu);
                                        run_guest_once(cpu, lguest_pages(raw_smp_processor_id()));
                                                copy_in_guest_info(cpu, pages);
                                                        map_switcher_in_guest(cpu, pages);
                                                                pages->state.host_cr3 = __pa(current->mm->pgd);
                                                                map_switcher_in_guest(cpu, pages);
                                                                        set_pte(pte, mk_pte(regs_page, __pgprot(__PAGE_KERNEL & ~_PAGE_GLOBAL)));
                                                                        set_pte(pte, mk_pte(percpu_switcher_page,
                                                        copy_traps(cpu, pages->state.guest_idt, default_idt_entries);
                                                        copy_gdt(cpu, pages->state.guest_gdt);
                                                asm volatile("pushf; lcall *lguest_entry"
                                                         "0"(pages), "1"(__pa(cpu->lg->pgdirs[cpu->cpu_pgd].pgdir))
                                                        switch_to_guest //switch_32.S
                        //	lguest_arch_handle_trap(cpu);
                        //		case LGUEST_TRAP_ENTRY:
                        //		cpu->hcall = (struct hcall_args *)cpu->regs;
                handle_output(notify_addr);
                        update_device_status(i);
                                start_device(dev);
                                        create_thread(vq);
                                                vq->eventfd = eventfd(0, 0);
                                                write(lguest_fd, &args, sizeof(args)
                                                        attach_eventfd(lg, input);
                                                vq->thread = clone(do_thread, stack + 32768, CLONE_VM | SIGCHLD, vq);

do_thread // launcher device thread
        vq->service(vq);
        //blk_request
                head = wait_for_vq_desc(vq, iov, &out_num, &in_num);
                        trigger_irq(vq);
                                write(lguest_fd, buf, sizeof(buf)
                                        user_send_irq(cpu, input);
                                                set_interrupt(cpu, irq);
                                                        set_bit(irq, cpu->irqs_pending);
                                                        kick_process(cpu->tsk); //laucher tsk
                                                        //vring_interrupt

                        read(vq->eventfd, &event, sizeof(event)) != sizeof(event)
                lseek64(vblk->fd, off, SEEK_SET)
                readv(vblk->fd, iov + out_num, in_num);
                add_used(vq, head, wlen);
run_guest
        irq = interrupt_pending(cpu, &more);
        if (irq < LGUEST_IRQS)
        try_deliver_interrupt(cpu, irq, more);
                idt = &cpu->arch.idt[FIRST_EXTERNAL_VECTOR+irq];
                set_guest_interrupt(cpu, idt->a, idt->b, false);
                        push_guest_stack(cpu, &gstack, eflags);
                        push_guest_stack(cpu, &gstack, cpu->regs->cs);
                        push_guest_stack(cpu, &gstack, cpu->regs->eip);
                        cpu->regs->ss = ss;
                        cpu->regs->esp = virtstack + (gstack - origstack);
                        cpu->regs->cs = (__KERNEL_CS|GUEST_PL);
                        cpu->regs->eip = idt_address(lo, hi);
        /*	vring_interrupt
                        virtblk_done
                                virtqueue_get_buf(vblk->vq, &len)
                                virtblk_bio_done(vbr); */
init // drivers/lguest/core.c
        map_switcher
                lg_switcher_pages[i] = alloc_page(GFP_KERNEL|__GFP_ZERO);
                switcher_addr = FIXADDR_START - (TOTAL_SWITCHER_PAGES+1)*PAGE_SIZE;
                err = map_vm_area(switcher_vma, PAGE_KERNEL_EXEC, &pagep);
                memcpy(switcher_vma->addr, start_switcher_text, //switcher_32.S
        err = init_interrupts();
        err = lguest_device_init();
                misc_register(&lguest_dev);
        lguest_arch_host_init();
                default_idt_entries[i] += switcher_offset();
                store_idt(&state->host_idt_desc);
                setup_default_gdt_entries(state);
                /* Most IDT entries are the same for all Guests, too.*/
                setup_default_idt_entries(state, default_idt_entries);
                        default_idt_entry(&state->guest_idt[i], i, def[i], NULL);
                lguest_entry.offset = (long)switch_to_guest + switcher_offset();
                lguest_entry.segment = LGUEST_CS;
//guest os
lguest_entry //arch/x86/lguest/i386_head.S
        //jmp lguest_init+__PAGE_OFFSET
        lguest_init
                pv_cpu_ops.load_gdt = lguest_load_gdt;
                pv_cpu_ops.cpuid = lguest_cpuid;
                switch_to_new_gdt(0);
                i386_start_kernel();
                                start_kernel
                                        setup_arch
                                                paravirt_arch_setup_early();
                                                paravirt_patch_apply();


postcore_initcall(lguest_devices_init) //drivers/lguest/lguest_device.c
        lguest_root = root_device_register("lguest");
        lguest_devices = lguest_map(max_pfn<<PAGE_SHIFT, 1);
        scan_devices();
                add_lguest_device(d, i);
                        ldev->vdev.config = &lguest_config_ops;
                        register_virtio_device(&ldev->vdev) != 0)



init //drivers/block/virtio_blk.c
        virtblk_wq = alloc_workqueue("virtio-blk", 0, 0);
        major = register_blkdev(0, "virtblk");
        error = register_virtio_driver(&virtio_blk);

virtblk_probe
        vdev->priv = vblk = kmalloc(sizeof(*vblk) +
                                    sizeof(vblk->sg[0]) * sg_elems, GFP_KERNEL);
        err = init_vq(vblk);
                vblk->vq = virtio_find_single_vq(vblk->vdev, virtblk_done, "requests");
                        vdev->config->find_vqs(vdev, 1, &vq, callbacks, names);
                        //	.find_vqs = lg_find_vqs,
                                lg_find_vqs
                                        lg_find_vq(vdev, i, callbacks[i], names[i]);
                                                lvq->pages = lguest_map((unsigned long)lvq->config.pfn << PAGE_SHIFT,
                                                vq = vring_new_virtqueue(index, lvq->config.num, LGUEST_VRING_ALIGN, vdev,
                                                                         true, lvq->pages, lg_notify, callback, name);
                                                err = lguest_setup_irq(lvq->config.irq);
                                                err = request_irq(lvq->config.irq, vring_interrupt, IRQF_SHARED,
                                                                  dev_name(&vdev->dev), vq);
        vblk->disk = alloc_disk(1 << PART_BITS);
        q = vblk->disk->queue = blk_init_queue(virtblk_request, NULL);
        blk_queue_make_request(q, virtblk_make_request);
        add_disk(vblk->disk);

virtblk_make_request
        vbr = virtblk_alloc_req(vblk, GFP_NOIO);
        virtblk_bio_send_data(vbr);
                virtblk_add_req(vbr, have_data);
                         __virtblk_add_req(vblk->vq, vbr, vbr->sg,
                                                 have_data)) < 0)
                                virtqueue_add_sgs(vq, sgs, num_out, num_in, vbr, GFP_ATOMIC);
                                        virtqueue_add(_vq, sgs, sg_next_chained,
                             total_out, total_in, out_sgs, in_sgs, data, gfp);
                virtqueue_kick(vblk->vq);

virtblk_request
        blk_peek_request
        do_req(q, vblk, req)
                __virtblk_add_req(vblk->vq, vbr, vblk->sg, num) < 0)
        blk_start_request
        virtqueue_kick(vblk->vq);
                virtqueue_kick_prepare(vq)
                virtqueue_notify(vq);
                        vq->notify(_vq);
                        //lg_notify(struct virtqueue *vq)
                        hcall(LHCALL_NOTIFY, lvq->config.pfn << PAGE_SHIFT, 0, 0, 0);
                                asm volatile("int $" __stringify(LGUEST_TRAP_ENTRY)
                                deliver_to_host // switcher_32.S
                                //do_hypercalls(cpu);
                                        do_hcall(cpu, cpu->hcall);
                                                cpu->pending_notify = args->arg1;
                                                send_notify_to_eventfd(cpu)
                                                        rcu_dereference(cpu->lg->eventfds);
                                                        if (map->map[i].addr == cpu->pending_notify) {
                                                        eventfd_signal(map->map[i].event, 1);
                                                        //launcher do_thread



SYSCALL_DEFINE1(unlink, const char __user *, pathname)
        do_unlinkat(AT_FDCWD, pathname);
                name = user_path_parent(dfd, pathname, &nd, lookup_flags);
                dentry = lookup_hash(&nd);
                //security_path_unlink(&nd.path, dentry)
                error = vfs_unlink(nd.path.dentry->d_inode, dentry);
                        ext4_unlink
                                bh = ext4_find_entry(dir, &dentry->d_name, &de, NULL);
                                retval = ext4_delete_entry(handle, dir, de, bh);
                                ext4_orphan_add(handle, inode);

iput
        iput_final(inode);
                op->drop_inode(inode);
                        ext4_drop_inode
                                generic_drop_inode(inode);
        evict(inode);
                op->evict_inode(inode);
                        ext4_evict_inode
                                ext4_truncate(inode);
                                ext4_orphan_del(NULL, inode);

ext4_mount
        ext4_fill_super
                ext4_orphan_cleanup(sb, es);
                        while (es->s_last_orphan) {
                                inode = ext4_orphan_get(sb, le32_to_cpu(es->s_last_orphan));
                                ext4_truncate(inode);
                                iput(inode);  /* The delete magic happens here! */
*** devicemapper
//dmsetup
dev_create
        alloc_dev
                md->queue = blk_alloc_queue(GFP_KERNEL);
                dm_init_md_queue(md);
                        md->queue->queuedata = md;
                        md->queue->backing_dev_info.congested_fn = dm_any_congested;
                        md->queue->backing_dev_info.congested_data = md;
                        blk_queue_make_request(md->queue, dm_request);
                md->disk = alloc_disk(1);
                md->disk->major = _major;
                md->disk->first_minor = minor;
                md->disk->fops = &dm_blk_dops;
                md->disk->queue = md->queue;
                md->disk->private_data = md;
                sprintf(md->disk->disk_name, "dm-%d", minor);
                add_disk(md->disk);
        dm_hash_insert(param->name, *param->uuid ? param->uuid : NULL, md);
        __dev_status(md, param);

table_load
        md = find_device(param);
        dm_table_create(&t, get_mode(param), param->target_count, md)
                alloc_targets(t, num_targets))
        populate_table(t, param, param_size);
                dm_table_add_target(table, spec->target_type,
                                        (sector_t) spec->sector_start,
                                        (sector_t) spec->length,
                                        target_params);
                        dm_get_target_type(type)
                        tgt->type->ctr(tgt, argc, argv);
                        //.ctr = cache_ctr,
        dm_setup_md_queue(md);
                dm_init_request_based_queue(md)
                        blk_init_allocated_queue(md->queue, dm_request_fn, NULL);
                        md->queue = q;
                        dm_init_md_queue(md);
                        blk_queue_softirq_done(md->queue, dm_softirq_done);
                        blk_queue_prep_rq(md->queue, dm_prep_fn);
        __dev_status(md, param);

dm_request
        _dm_request(q, bio);
                __split_and_process_bio(md, bio);
                        ci.map = dm_get_live_table(md);
                        ci.md = md;
                        ci.io = alloc_io(md);
                        ci.io->bio = bio;
                        ci.io->md = md;
                        ci.sector = bio->bi_sector;
                        __split_and_process_non_flush(&ci);
                                dm_table_find_target(ci->map, ci->sector);
                                __clone_and_map_data_bio(ci, ti, ci->sector, bio->bi_max_vecs,
                                        tio = alloc_tio(ci, ti, nr_iovecs, target_bio_nr);
                                        clone_bio(tio, bio, sector, idx, bv_count, len);
                                        __map_bio(tio);
                                                clone->bi_end_io = clone_endio;
                                                //dm_endio_fn endio = tio->ti->type->end_io;
                                                        //cache_end_io
                                                ti->type->map(ti, clone);
                                                //cache_map
                                                generic_make_request(clone);

md_init
        register_blkdev(MD_MAJOR, "md"))
        register_blkdev(0, "mdp"))
        blk_register_region(MKDEV(MD_MAJOR, 0), 1UL<<MINORBITS, THIS_MODULE,
                            md_probe, NULL, NULL);
        blk_register_region(MKDEV(mdp_major, 0), 1UL<<MINORBITS, THIS_MODULE,
                            md_probe, NULL, NULL);
        md_geninit();

md_probe
        md_alloc
                blk_alloc_queue(GFP_KERNEL);
                blk_queue_make_request(mddev->queue, md_make_request);
                disk = alloc_disk(1 << shift);
                disk->fops = &md_fops;
                add_disk(disk);

md_ioctl
        set_array_info
                mddev->major_version = info->major_version;
                mddev->minor_version = info->minor_version;
                mddev->patch_version = info->patch_version;
                mddev->persistent = !info->not_persistent;

        add_new_disk
                rdev = md_import_device(dev, -1, 0);
                        alloc_disk_sb(rdev);
                        super_types[super_format].load_super(rdev, NULL, super_minor);

                rdev->raid_disk = info->raid_disk;
                rdev->sb_start = calc_dev_sboffset(rdev);
                rdev->sectors = rdev->sb_start;
                bind_rdev_to_array(rdev, mddev);

        do_md_run
                md_run
                        //mddev->pers->run(mddev)
                        raid0_run
                                blk_queue_max_write_same_sectors(mddev->queue, mddev->chunk_sectors);
                                create_strip_zones(mddev, &conf);
                                                conf->devlist = kzalloc(sizeof(struct md_rdev*)*
                                                                conf->nr_strip_zones*mddev->raid_disks,	GFP_KERNEL);
                                mddev->private = conf;
                                blk_queue_merge_bvec(mddev->queue, raid0_mergeable_bvec);
                bitmap_load


md_make_request
        //mddev->pers->make_request(mddev, bio);
        raid0_make_request
                zone = find_zone(mddev->private, &sector_offset);
                tmp_dev = map_sector(mddev, zone, bio->bi_sector, &sector_offset);
                bio->bi_bdev = tmp_dev->bdev;
                bio->bi_sector = sector_offset + zone->dev_start +	tmp_dev->data_offset;


raid0_init
        register_md_personality

*** crashkernel
setup_arch
        reserve_crashkernel
                parse_crashkernel(boot_command_line, total_mem,
                reserve_bootmem(crash_base, crash_size, BOOTMEM_EXCLUSIVE)
                crashk_res.start = crash_base;
                crashk_res.end = crash_base + crash_size - 1

parse_crashkernel
        __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,
                                        "crashkernel=", NULL);
crash_save_vmcoreinfo_init

vmcore_init
        proc_create("vmcore", S_IRUSR, NULL, &proc_vmcore_operations);

kexec -p <dump-capture-kernel-vmlinux-image> \
   --initrd=<initrd-for-dump-capture-kernel> --args-linux \
   --append="root=<root-dev> <arch-specific-options>"

kexec_load
        dest_image = &kexec_crash_image;
        result = kimage_crash_alloc(&image, entry,
                                                     nr_segments, segments);
                do_kimage_alloc(&image, entry, nr_segments, segments);
        kimage_alloc_crash_control_pages
        machine_kexec_prepare(image);
        kimage_load_segment(image, &image->segment[i]);
                kimage_load_crash_segment(image, segment);
                        copy_from_user(ptr, buf, uchunk);
panic
        crash_kexec  //Documentation/kdump
                crash_save_vmcoreinfo();
                machine_kexec(kexec_crash_image);

*** sound
snd_soc_init
        platform_driver_register(&soc_driver);
        /*static struct platform_driver soc_driver = {
                .driver		= {
                        .name		= "soc-audio",
                        .owner		= THIS_MODULE,
                        .pm		= &snd_soc_pm_ops,
                },
                .probe		= soc_probe,
                .remove		= soc_remove,
        };
        atm7059_link_init
                atm7059_link_snd_device = platform_device_alloc("soc-audio", -1);
                ret = platform_device_add(atm7059_link_snd_device); */
                soc_probe
                        snd_soc_register_card(card);
                                ret = snd_soc_instantiate_card(card);
                                        soc_bind_dai_link(card, i);
                                        snd_soc_init_codec_cache(codec, compress_type)
                                        snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1, card->owner, 0, &card->snd_card);
                                                snd_ctl_create(card);
                                                        snd_device_new(card, SNDRV_DEV_CONTROL, card, &ops);
                                                snd_info_card_create(card);
*** memory
paging_init
        early_alloc(PAGE_SIZE);
                early_alloc_aligned
                        memblock_alloc
        bootmem_init
                arm64_memory_present
                        memory_present
                                sparse_index_alloc
                                        alloc_bootmemmem_node(NODE_DATA(nid), array_size)
        sparse_init
                sparse_early_usemaps_alloc_node



early_init_dt_alloc_memory_arch
        memblock_alloc
        sparse_init
                alloc_bootmem
                        __alloc_memory_core_early
/*
 * vmalloc=size forces the vmalloc area to be exactly 'size'
 * bytes. This can be used to increase (or decrease) the vmalloc
 * area - the default is 240m.
 */
static int __init early_vmalloc(char *arg)
{
        unsigned long vmalloc_reserve = memparse(arg, NULL);

        if (vmalloc_reserve < SZ_16M) {
                vmalloc_reserve = SZ_16M;
                printk(KERN_WARNING
                        "vmalloc area too small, limiting to %luMB\n",
                        vmalloc_reserve >> 20);
        }

        if (vmalloc_reserve > VMALLOC_END - (PAGE_OFFSET + SZ_32M)) {
                vmalloc_reserve = VMALLOC_END - (PAGE_OFFSET + SZ_32M);
                printk(KERN_WARNING
                        "vmalloc area is too big, limiting to %luMB\n",
                        vmalloc_reserve >> 20);
        }

        vmalloc_min = (void *)(VMALLOC_END - vmalloc_reserve);
        return 0;
}
early_param("vmalloc", early_vmalloc);
*** loadbalance
load_balance(cpu, rq, sd, idle, &balance)
        find_busiest_group(&env, balance);
                update_sd_lb_stats(env, balance, &sds);
                        load_idx = get_sd_load_idx(env->sd, env->idle)
                                load_idx = sd->idle_idx
                        update_sg_lb_stats
                                load = target_load(i, load_idx)
                                        weighted_cpuload(cpu)
                                                cpu_rq(cpu)->load.weight
                                        max(rq->cpu_load[type-1], total);
                                sgs->group_load += load;
                                sgs->sum_nr_running += nr_running;
                                sgs->sum_weighted_load += weighted_cpuload(i);
                                update_group_power(env->sd, env->dst_cpu)
                                        update_cpu_power(sd, cpu);
                                                power *= arch_scale_freq_power(sd, cpu)
                                                         default_scale_freq_power(sd, cpu)
                                                                return SCHED_POWER_SCALE
                                                power *= scale_rt_power(cpu)
                                                        div_u64(available, total)
                                                cpu_rq(cpu)->cpu_power = power;
                                                sdg->sgp->power = power
                                sgs->avg_load = (sgs->group_load*SCHED_POWER_SCALE) / group->sgp->power;
                        sds->total_load += sgs.group_load;
                        sds->total_pwr += sg->sgp->power;
        update_h_load(env.src_cpu);
                walk_tg_tree(tg_load_down, tg_nop, (void *)cpu)
                        tg_load_down
                                load = tg->parent->cfs_rq[cpu]->h_load;
                                load *= tg->se[cpu]->load.weight;
                                load /= tg->parent->cfs_rq[cpu]->load.weight + 1;
        busiest = find_busiest_queue(&env, group);
        cur_ld_moved = move_tasks(&env)

loadavg_proc_show
*** scheduler
scheduler_tick
        trigger_load_balance
                run_rebalance_domains
                        rebalance_domains(this_cpu, idle);
                                load_balance(cpu, rq, sd, idle, &balance)


__schedule
        idle_balance
                load_balance(this_cpu, this_rq,sd, CPU_NEWLY_IDLE, &balance)


const struct sched_class fair_sched_class = {
        .next			= &idle_sched_class,
        .enqueue_task		= enqueue_task_fair,
        .dequeue_task		= dequeue_task_fair,
        .yield_task		= yield_task_fair,
        .yield_to_task		= yield_to_task_fair,

        .check_preempt_curr	= check_preempt_wakeup,

        .pick_next_task		= pick_next_task_fair,
        .put_prev_task		= put_prev_task_fair,

#ifdef CONFIG_SMP
        .select_task_rq		= select_task_rq_fair,
#ifdef CONFIG_FAIR_GROUP_SCHED
        .migrate_task_rq	= migrate_task_rq_fair,
#endif
        .rq_online		= rq_online_fair,
        .rq_offline		= rq_offline_fair,

        .task_waking		= task_waking_fair,
#endif

        .set_curr_task          = set_curr_task_fair,
        .task_tick		= task_tick_fair,
        .task_fork		= task_fork_fair,

        .prio_changed		= prio_changed_fair,
        .switched_from		= switched_from_fair,
        .switched_to		= switched_to_fair,

        .get_rr_interval	= get_rr_interval_fair,

#ifdef CONFIG_FAIR_GROUP_SCHED
        .task_move_group	= task_move_group_fair,
#endif
};


update_cfs_rq_blocked_load(cfs_rq, 1);
        u64 now = cfs_rq_clock_task(cfs_rq) >> 20;
        decays = now - cfs_rq->last_decay;
        atomic64_read(&cfs_rq->removed_load))	// removed_load from migrate task
                subtract_blocked_load_contrib(cfs_rq, removed_load);
                        cfs_rq->blocked_load_avg -= load_contrib
        cfs_rq->blocked_load_avg = decay_load(cfs_rq->blocked_load_avg,  decays);
        __update_cfs_rq_tg_load_contrib(cfs_rq, force_update);
                tg_contrib = cfs_rq->runnable_load_avg + cfs_rq->blocked_load_avg;
                tg_contrib -= cfs_rq->tg_load_contrib;
                atomic64_add(tg_contrib, &tg->load_avg);
                cfs_rq->tg_load_contrib += tg_contrib;

start_kernel
        cgroup_init
                struct cgroup_subsys *ss = subsys[i]
                        #define SUBSYS(_x) [_x ## _subsys_id] = &_x ## _subsys,
                        static struct cgroup_subsys *subsys[CGROUP_SUBSYS_COUNT] = {
                                #include <linux/cgroup_subsys.h>
                        };
                                #if IS_SUBSYS_ENABLED(CONFIG_CGROUP_SCHED)
                                        SUBSYS(cpu_cgroup)// cpu_cgroup_subsys
                                #endif
                cgroup_init_subsys(ss)
                        cgroup_init_cftsets(ss);
                        //css = ss->css_alloc(dummytop)
                        cpu_cgroup_css_alloc
                                sched_create_group(parent)
                                        alloc_fair_sched_group(tg, parent)
                        init_cgroup_css(css, ss, dummytop);

        cpuset_init
                register_filesystem(&cpuset_fs_type)

cgroup_tg

cpu_shares_write_u64
        sched_group_set_shares(cgroup_tg(cgrp), scale_load(shareval))
                for_each_sched_entity(se)
                        update_cfs_shares(group_cfs_rq(se));


update_cfs_shares
        tg = cfs_rq->tg;
        se = tg->se[cpu_of(rq_of(cfs_rq))];	// on this cpu

        if (likely(se->load.weight == tg->shares))

        shares = calc_cfs_shares(cfs_rq, tg);
                tg_weight = calc_tg_weight(tg, cfs_rq);
                        tg_weight = atomic64_read(&tg->load_avg);
                        tg_weight -= cfs_rq->tg_load_contrib;
                        tg_weight += cfs_rq->load.weight
                load = cfs_rq->load.weight;
                shares = (tg->shares * load);
                shares /= tg_weight;
        reweight_entity(cfs_rq_of(se), se, shares);
                account_entity_dequeue(cfs_rq, se);
                        update_load_sub(&cfs_rq->load, se->load.weight)
                                lw->weight -= dec;
                update_load_set(&se->load, weight);// se.load.weight = shares
                        lw->weight = w;
                account_entity_enqueue(cfs_rq, se);
                        update_load_add(&cfs_rq->load, se->load.weight)
                                lw->weight += inc;

update_entity_load_avg(se, 1);
        __update_entity_runnable_avg(now, &se->avg, se->on_rq, cfs_rq->curr == se, cpu)
                delta = now - sa->last_runnable_update
                delta >>= 10
                periods = delta / 1024
                sa->runnable_avg_sum = decay_load(sa->runnable_avg_sum, periods + 1);
                sa->runnable_avg_period = decay_load(sa->runnable_avg_period, periods + 1);
                sa->usage_avg_sum = decay_load(sa->usage_avg_sum, periods + 1);
                /* add the contribution from this period */
                /* Efficiently calculate \sum (1..n_period) 1024*y^i */
                runnable_contrib = __compute_runnable_contrib(periods);
                        contrib = decay_load(contrib, n);
                        return contrib + runnable_avg_yN_sum[n];
                // load_avg = u_0` + y*(u_0 + u_1*y + u_2*y^2 + ... )
                sa->runnable_avg_sum += delta;
                sa->runnable_avg_period += delta;
                return decayed;// 1ms
        if (!__update_entity_runnable_avg(now, &se->avg, se->on_rq,	cfs_rq->curr == se, cpu))
                return;

        contrib_delta = __update_entity_load_avg_contrib(se, &ratio_delta);
                if (entity_is_task(se)) {
                        __update_task_entity_contrib(se);
                                contrib = se->avg.runnable_avg_sum * scale_load_down(se->load.weight);
                                contrib /= (se->avg.runnable_avg_period + 1);
                                se->avg.load_avg_contrib = scale_load(contrib);
                                //trace_sched_task_load_contrib(task_of(se), se->avg.load_avg_contrib);
                                contrib = se->avg.runnable_avg_sum * scale_load_down(NICE_0_LOAD);
                                contrib /= (se->avg.runnable_avg_period + 1);
                                se->avg.load_avg_ratio = scale_load(contrib);
                                //trace_sched_task_runnable_ratio(task_of(se), se->avg.load_avg_ratio);
                } else {
                        __update_tg_runnable_avg(&se->avg, group_cfs_rq(se));
                                group_cfs_rq
                                        return grp->my_q; // task group
                                tg = cfs_rq->tg
                                atomic_add(contrib, &tg->runnable_avg);
                                cfs_rq->tg_runnable_contrib += contrib;
                        __update_group_entity_contrib(se);
                                contrib = cfs_rq->tg_load_contrib * tg->shares;
                                se->avg.load_avg_contrib = div64_u64(contrib, atomic64_read(&tg->load_avg) + 1);
                                runnable_avg = atomic_read(&tg->runnable_avg);
                                se->avg.load_avg_contrib *= runnable_avg;
                                se->avg.load_avg_contrib >>= NICE_0_SHIFT;
                return se->avg.load_avg_contrib - old_contrib;
        cfs_rq->runnable_load_avg += contrib_delta;
        rq_of(cfs_rq)->avg.load_avg_ratio += ratio_delta;

__schedule
        deactivate_task(rq, prev, DEQUEUE_SLEEP)
                dequeue_task(rq, p, flags);
                        update_rq_clock(rq);
                        sched_info_dequeued(p);
                        //p->sched_class->dequeue_task(rq, p, flags);
                        dequeue_task_fair

dequeue_task_fair
        cfs_rq = cfs_rq_of(se);
        for_each_sched_entity(se)
                dequeue_entity(cfs_rq, se, flags);
                        update_curr(cfs_rq);
                        dequeue_entity_load_avg(cfs_rq, se, flags & DEQUEUE_SLEEP);
                                update_entity_load_avg(se, 1);
                                /* we force update consideration on load-balancer moves */
                                update_cfs_rq_blocked_load(cfs_rq, !sleep);
                                cfs_rq->runnable_load_avg -= se->avg.load_avg_contrib;
                                rq_of(cfs_rq)->avg.load_avg_ratio -= se->avg.load_avg_ratio;
                                cfs_rq->blocked_load_avg += se->avg.load_avg_contrib;
                                se->avg.decay_count = atomic64_read(&cfs_rq->decay_counter);
                        update_stats_dequeue(cfs_rq, se);
                                if (se != cfs_rq->curr)
                                        update_stats_wait_end
                                        //trace_sched_stat_wait(task_of(se), rq_of(cfs_rq)->clock - se->statistics.wait_start);
                                        schedstat_set(se->statistics.wait_start, 0);
                        if (tsk->state & TASK_INTERRUPTIBLE)
                                se->statistics.sleep_start = rq_of(cfs_rq)->clock;
                        if (tsk->state & TASK_UNINTERRUPTIBLE)
                                se->statistics.block_start = rq_of(cfs_rq)->clock;
                        __dequeue_entity(cfs_rq, se);
                        se->on_rq = 0;
                        account_entity_dequeue(cfs_rq, se);
                                update_load_sub(&rq_of(cfs_rq)->load, se->load.weight);
                                cfs_rq->nr_running--;
                        return_cfs_rq_runtime(cfs_rq);
                                __return_cfs_rq_runtime(cfs_rq);
                        update_min_vruntime(cfs_rq);
                        update_cfs_shares(cfs_rq);
        for_each_sched_entity
                update_cfs_shares(cfs_rq);
                update_entity_load_avg(se, 1);
        dec_nr_running(rq);
        update_rq_runnable_avg(rq, 1);
        hrtick_update(rq)

pre_schedule_idle
        idle_exit_fair(rq);
                update_rq_runnable_avg(this_rq, 0);
        rq_last_tick_reset(rq);

enqueue_task_fair
        enqueue_entity(cfs_rq, se, flags)
                se->vruntime += cfs_rq->min_vruntime
                update_curr(cfs_rq)
                enqueue_entity_load_avg(cfs_rq, se, flags & ENQUEUE_WAKEUP);
                        if (wakeup) {
                                subtract_blocked_load_contrib(cfs_rq, se->avg.load_avg_contrib);
                                        cfs_rq->blocked_load_avg -= load_contrib;
                                update_entity_load_avg(se, 0);
                        cfs_rq->runnable_load_avg += se->avg.load_avg_contrib;
                        rq_of(cfs_rq)->avg.load_avg_ratio += se->avg.load_avg_ratio;
                account_entity_enqueue(cfs_rq, se);
                        update_load_add(&cfs_rq->load, se->load.weight)
                update_cfs_shares(cfs_rq);
                if (flags & ENQUEUE_WAKEUP) {
                        place_entity(cfs_rq, se, 0);
                        enqueue_sleeper(cfs_rq, se);//try to wakeup
                                delta = rq_of(cfs_rq)->clock - se->statistics.sleep_start
                                //trace_sched_stat_sleep(tsk, delta);
                                if (tsk) {
                                        if (tsk->in_iowait) {
                                                //trace_sched_stat_iowait(tsk, delta);
                                //trace_sched_stat_blocked(tsk, delta);
                update_stats_enqueue(cfs_rq, se);
                        if (se != cfs_rq->curr)
                                update_stats_wait_start(cfs_rq, se);
                                        schedstat_set(se->statistics.wait_start, rq_of(cfs_rq)->clock);
                check_spread(cfs_rq, se)
                __enqueue_entity(cfs_rq, se);// insert to rb tree
                se->on_rq = 1
        for_each_sched_entity
                update_cfs_shares(cfs_rq);
                update_entity_load_avg(se, 1);
        update_rq_runnable_avg(rq, rq->nr_running);
        inc_nr_running(rq);
        hrtick_update(rq)
                hrtick_start_fair(rq, curr)
                        sched_slice(cfs_rq, se)
                                 __sched_period(cfs_rq->nr_running + !se->on_rq)
                                        // p = (nr <= nl) ? l : l*nr/nl
                                slice = calc_delta_mine(slice, se->load.weight, load)
                                        //delta *= weight / lw
                                ran = se->sum_exec_runtime - se->prev_sum_exec_runtime
                                delta = slice - ran
                        hrtick_start(rq, delta);
                                hrtimer_set_expires(timer, time)
                                hrtimer_restart(timer)

try_to_wake_up_local // workqueue
wake_up_process
        try_to_wake_up(p, TASK_NORMAL, 0
                cpu = select_task_rq(p, SD_BALANCE_WAKE, wake_flags);
                        int cpu = p->sched_class->select_task_rq(p, sd_flags, wake_flags);
                        select_task_rq_fair
                                cpu = smp_processor_id()
                                prev_cpu = task_cpu(p)
                                new_cpu = select_idle_sibling(p, prev_cpu)
                set_task_cpu
                        //trace_sched_migrate_task(p, new_cpu);
                        //p->sched_class->migrate_task_rq(p, new_cpu);
                        migrate_task_rq_fair
                                update_cfs_rq_blocked_load(cfs_rq, 0);
                                se->avg.decay_count = -__synchronize_entity_decay(se);
                                atomic64_add(se->avg.load_avg_contrib, &cfs_rq->removed_load)
                                __set_task_cpu(p, new_cpu);
                                        set_task_rq(p, cpu);
                                                p->se.cfs_rq = tg->cfs_rq[cpu];
                                                p->se.parent = tg->se[cpu];
                ttwu_queue(p, cpu)
                        ttwu_do_activate(rq, p, 0);
                                ttwu_queue_remote(p, cpu); // we can use scheduler IPI
                                ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING)
                                        activate_task(rq, p, en_flags);
                                                enqueue_task(rq, p, flags);
                                                        //p->sched_class->enqueue_task(rq, p, flags)
                                                        enqueue_task_fair
                                        p->on_rq = 1;
                                ttwu_do_wakeup
                                        check_preempt_curr(rq, p, wake_flags);
                                                //rq->curr->sched_class->check_preempt_curr(rq, p, flags)
                                                check_preempt_wakeup
                                        //trace_sched_wakeup(p, true);
                                        if (rq->idle_stamp) {
                                                u64 delta = rq->clock - rq->idle_stamp;
                                                u64 max = 2*sysctl_sched_migration_cost;
                                                if (delta > max)
                                                        rq->avg_idle = max;
                                                else
                                                        update_avg(&rq->avg_idle, delta);
update_curr(cfs_rq);
        delta_exec = (unsigned long)(now - curr->exec_start）
        __update_curr(cfs_rq, curr, delta_exec);
                curr->sum_exec_runtime += delta_exec
                schedstat_add(cfs_rq, exec_clock, delta_exec)
                delta_exec_weighted = calc_delta_fair(delta_exec, curr)
                        calc_delta_mine(delta, NICE_0_LOAD, &se->load)
                                delta *= weight / lw
                curr->vruntime += delta_exec_weighted;
                update_min_vruntime(cfs_rq)
                        vruntime = cfs_rq->curr->vruntime
                        se = rb_entry(cfs_rq->rb_leftmost
                        vruntime = min_vruntime(vruntime, se->vruntime)
                        cfs_rq->min_vruntime = max_vruntime(cfs_rq->min_vruntime, vruntime)
        curr->exec_start = now;
        //trace_sched_stat_runtime
        cpuacct_charge(curtask, delta_exec)//cgroup 统计
                ca = task_ca(tsk)
                cpuusage = per_cpu_ptr(ca->cpuusage, cpu);
                *cpuusage += cputime
        account_group_exec_runtime(curtask, delta_exec)
                cputimer = &tsk->signal->cputimer
                cputimer->cputime.sum_exec_runtime += ns
        account_cfs_rq_runtime(cfs_rq, delta_exec)
                __account_cfs_rq_runtime(cfs_rq, delta_exec)
                        cfs_rq->runtime_remaining -= delta_exec
                        expire_cfs_rq_runtime(cfs_rq)
                                rq->clock - cfs_rq->runtime_expires
task_fork_fair
        update_rq_clock(rq);
                rq->clock += delta;
                update_rq_clock_task(rq, delta)
                        rq->clock_task += delta
        update_curr(cfs_rq);
        se->vruntime = curr->vruntime;
        place_entity(cfs_rq, se, 1);
                vruntime = cfs_rq->min_vruntime
                vruntime += sched_vslice(cfs_rq, se);
                se->vruntime = max_vruntime(se->vruntime, vruntime)
        se->vruntime -= cfs_rq->min_vruntime;// normized to relative vtime

do_fork
        copy_process
                sched_fork(p);
                        __sched_fork(p);
                        p->sched_class = &fair_sched_class
                        p->sched_class->task_fork(p)
                        task_fork_fair
                set_load_weight(p);
                        load->weight = scale_load(prio_to_weight[prio]);
                        load->inv_weight = prio_to_wmult[prio];
        //trace_sched_process_fork
        wake_up_new_task
                rq = __task_rq_lock(p);
                activate_task(rq, p, 0);
                        enqueue_task
                                update_rq_clock(rq);
                                        sched_clock_cpu
                                                sched_clock
                                                        //sched_clock_func
                                                        sched_clock_32
                                                                //read_sched_clock
                                                                owl_read_sched_clock
                                                                        act_readl(T0_VAL)
                                        update_rq_clock_task(rq, delta)
                                                rq->clock_task += delta
                                sched_info_queued(p);
                                        t->sched_info.last_queued = task_rq(t)->clock
                                //p->sched_class->enqueue_task(rq, p, flags)
                                enqueue_task_fair
                p->on_rq = 1;
                trace_sched_wakeup_new(p, true);
                check_preempt_curr(rq, p, WF_FORK)
                        //rq->curr->sched_class->check_preempt_curr(rq, p, flags)

__schedule();//idle case
        pre_schedule(rq, prev);
                //prev->sched_class->pre_schedule(rq, prev);
                pre_schedule_idle
                        idle_exit_fair(rq);
                                update_rq_runnable_avg(this_rq, 0);
                        rq_last_tick_reset(rq);
        next = pick_next_task(rq);
                // class->pick_next_task(rq)
                pick_next_task_fair
                        pick_next_entity(cfs_rq);
                                se = __pick_first_entity(cfs_rq)

                        set_next_entity(cfs_rq, se)
                                update_stats_wait_end(cfs_rq, se);
                                        if (entity_is_task(se)) {
                                                //trace_sched_stat_wait(task_of(se), rq_of(cfs_rq)->clock - se->statistics.wait_start);
                                cfs_rq->curr = se
        context_switch(rq, prev, next); /* unlocks the rq */
                prepare_task_switch(rq, prev, next);
                        //trace_sched_switch(prev, next);
schedule
        sched_submit_work(tsk);
                 blk_schedule_flush_plug
        __schedule();
                hrtick_clear(rq)
                deactivate_task(rq, prev, DEQUEUE_SLEEP);
                        dequeue_task(rq, p, flags);
                                update_rq_clock(rq);
                                //p->sched_class->dequeue_task(rq, p, flags);
                                dequeue_task_fair
                pre_schedule(rq, prev);
                        //prev->sched_class->pre_schedule(rq, prev);
                put_prev_task(rq, prev);
                        //prev->sched_class->put_prev_task(rq, prev);
                        put_prev_task_fair
                                put_prev_entity
                                        update_stats_wait_start(cfs_rq, prev);
                                                schedstat_set(se->statistics.wait_start, rq_of(cfs_rq)->clock);
                                        __enqueue_entity(cfs_rq, prev);
                                        update_entity_load_avg(prev, 1);
                                        cfs_rq->curr = NULL;
                next = pick_next_task(rq);
                        // class->pick_next_task(rq)
                        pick_next_task_fair
                                pick_next_entity(cfs_rq);
                                        se = __pick_first_entity(cfs_rq)
                                        wakeup_preempt_entity(cfs_rq->last, left)
                                                wakeup_gran(curr, se)
                                                        sysctl_sched_wakeup_granularity;
                                                        calc_delta_fair(gran, se)
                                        clear_buddies
                                set_next_entity(cfs_rq, se)
                                        update_stats_wait_end(cfs_rq, se);
                                                if (entity_is_task(se)) {
                                                        //trace_sched_stat_wait(task_of(se), rq_of(cfs_rq)->clock - se->statistics.wait_start);
                                        __dequeue_entity(cfs_rq, se);//rbtree remove
                                        update_entity_load_avg(se, 1);
                                        update_stats_curr_start(cfs_rq, se);
                                                se->exec_start = rq_of(cfs_rq)->clock_task;
                                        cfs_rq->curr = se
                                        se->prev_sum_exec_runtime = se->sum_exec_runtime;
                                hrtick_start_fair(rq, p)
                        pick_next_task_idle
                context_switch(rq, prev, next); /* unlocks the rq */
                        prepare_task_switch(rq, prev, next);
                                //trace_sched_switch(prev, next);
                                sched_info_switch(prev, next);
                                        sched_info_depart(prev);
                                        sched_info_arrive(next);
                        arch_start_context_switch
                        switch_mm
                        context_tracking_task_switch
                        switch_to
                        finish_task_switch
                post_schedule(rq);
                        //rq->curr->sched_class->post_schedule(rq)
wake_up_process
        try_to_wake_up(p, TASK_NORMAL, 0)

task_tick_fair
        entity_tick(cfs_rq, se, queued);
                update_curr(cfs_rq);
                update_entity_load_avg(curr, 1);
                update_cfs_rq_blocked_load(cfs_rq, 1);
                update_cfs_shares(cfs_rq);
                resched_task(rq_of(cfs_rq)->curr)
                check_preempt_tick(cfs_rq, curr)
                        ideal_runtime = sched_slice(cfs_rq, curr);
                        delta_exec = curr->sum_exec_runtime - curr->prev_sum_exec_runtime;
                        if (delta > ideal_runtime)
                                resched_task(rq_of(cfs_rq)->curr);
        update_rq_runnable_avg(rq, 1);
                __update_entity_runnable_avg(rq->clock_task, &rq->avg, runnable,
                                     runnable, cpu);
                __update_tg_runnable_avg(&rq->avg, &rq->cfs);
                //trace_sched_rq_runnable_ratio(cpu_of(rq), rq->avg.load_avg_ratio);
                //trace_sched_rq_runnable_load(cpu_of(rq), rq->cfs.runnable_load_avg);
                //trace_sched_rq_nr_running(cpu_of(rq), rq->nr_running, rq->nr_iowait.counter);
hrtick
        update_rq_clock(rq);
        //rq->curr->sched_class->task_tick(rq, rq->curr, 1);
        task_tick_fair

wake_up_process //wakeup on local cpu
try_to_wake_up(p, TASK_NORMAL, 0
        cpu = select_task_rq(p, SD_BALANCE_WAKE, wake_flags);
                int cpu = p->sched_class->select_task_rq(p, sd_flags, wake_flags);
                select_task_rq_fair
                        cpu = smp_processor_id()
                        prev_cpu = task_cpu(p)
                        new_cpu = select_idle_sibling(p, prev_cpu)
        ttwu_queue(p, cpu)
                ttwu_do_activate(rq, p, 0);
                        ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING)
                                activate_task(rq, p, en_flags);
                                        enqueue_task(rq, p, flags);
                                                enqueue_task_fair
                                                        enqueue_entity(cfs_rq, se, flags)
                                                                se->vruntime += cfs_rq->min_vruntime
        1							update_curr(cfs_rq)   // 1
                                                                enqueue_entity_load_avg(cfs_rq, se, flags & ENQUEUE_WAKEUP);
                                                                if (wakeup) {
                                                                        subtract_blocked_load_contrib(cfs_rq, se->avg.load_avg_contrib);
                                                                                cfs_rq->blocked_load_avg -= load_contrib;
        2 3								update_entity_load_avg(se, 0);// 2 3
                                                                if (flags & ENQUEUE_WAKEUP) {
                                                                        place_entity(cfs_rq, se, 0);
                                                                        enqueue_sleeper(cfs_rq, se);//try to wakeup
        4									delta = rq_of(cfs_rq)->clock - se->statistics.sleep_start
                                                                                //trace_sched_stat_sleep(tsk, delta);  //4
                                                        update_rq_runnable_avg(rq, rq->nr_running);
                                                                __update_entity_runnable_avg(rq->clock_task, &rq->avg, runnable, runnable, cpu);
                                                                __update_tg_runnable_avg(&rq->avg, &rq->cfs);
        5							//trace_sched_rq_runnable_ratio(cpu_of(rq), rq->avg.load_avg_ratio);
        6							//trace_sched_rq_runnable_load(cpu_of(rq), rq->cfs.runnable_load_avg);
        7							//trace_sched_rq_nr_running
                                ttwu_do_wakeup
                                        check_preempt_curr(rq, p, wake_flags);
        8				//trace_sched_wakeup(p, true);

 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052720: sched_stat_runtime: comm=Chrome_ChildIOT pid=5402 runtime=210750 [ns] vruntime=7375806629872 [ns]\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052730: sched_task_load_contrib: comm=Chrome_IOThread pid=5362 load_contrib=1689\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052732: sched_task_runnable_ratio: comm=Chrome_IOThread pid=5362 ratio=442\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052736: sched_stat_sleep: comm=Chrome_IOThread pid=5362 delay=438250 [ns]\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052740: sched_rq_runnable_ratio: cpu=3 ratio=623\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052742: sched_rq_runnable_load: cpu=3 load=2380\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052744: sched_rq_nr_running: cpu=3 nr_running=1 nr_iowait=0\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..5 120167.052750: sched_wakeup: comm=Chrome_IOThread pid=5362 prio=114 success=1 target_cpu=003\n\

 schedule  //task sleep
        sched_submit_work(tsk);
                 blk_schedule_flush_plug
        __schedule();
                hrtick_clear(rq)
                deactivate_task(rq, prev, DEQUEUE_SLEEP);
                        dequeue_task(rq, p, flags);
                                update_rq_clock(rq);
                                //p->sched_class->dequeue_task(rq, p, flags);
                                dequeue_task_fair
                                        cfs_rq = cfs_rq_of(se);
                                        for_each_sched_entity(se)
                                                dequeue_entity(cfs_rq, se, flags);
        1						update_curr(cfs_rq);
                                        dec_nr_running(rq);
        2 3 4			update_rq_runnable_avg(rq, 1);
                next = pick_next_task(rq);
                        pick_next_task_fair
                                set_next_entity(cfs_rq, se)
                                        update_stats_wait_end(cfs_rq, se);
                                                if (entity_is_task(se)) {
        5						//trace_sched_stat_wait
                context_switch(rq, prev, next); /* unlocks the rq */
                        prepare_task_switch(rq, prev, next);
        6			//trace_sched_switch(prev, next);
 Chrome_ChildIOT-5402  ( 5331) [003] d..3 120167.052807: sched_stat_runtime: comm=Chrome_ChildIOT pid=5402 runtime=89750 [ns] vruntime=7375806653401 [ns]\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..3 120167.052816: sched_rq_runnable_ratio: cpu=3 ratio=442\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..3 120167.052818: sched_rq_runnable_load: cpu=3 load=1689\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..3 120167.052819: sched_rq_nr_running: cpu=3 nr_running=1 nr_iowait=0\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..3 120167.052823: sched_stat_wait: comm=Chrome_IOThread pid=5362 delay=89750 [ns]\n\
 Chrome_ChildIOT-5402  ( 5331) [003] d..3 120167.052828: sched_switch: prev_comm=Chrome_ChildIOT prev_pid=5402 prev_prio=114 prev_state=S ==> next_comm=Chrome_IOThread next_pid=5362 next_prio=114\n\


wake_up_process
        try_to_wake_up(p, TASK_NORMAL, 0
                cpu = select_task_rq(p, SD_BALANCE_WAKE, wake_flags);
                set_task_cpu
1			//trace_sched_migrate_task(p, new_cpu);
                ttwu_queue(p, cpu)
                        ttwu_do_activate(rq, p, 0);
                                ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING)
                                        activate_task(rq, p, en_flags);
                                                enqueue_task(rq, p, flags);
                                                        enqueue_task_fair
                                                                enqueue_entity(cfs_rq, se, flags)
                                                                        se->vruntime += cfs_rq->min_vruntime
                                                                        update_curr(cfs_rq)
                                                                        enqueue_entity_load_avg(cfs_rq, se, flags & ENQUEUE_WAKEUP);
                                                                        if (wakeup) {
                                                                                subtract_blocked_load_contrib(cfs_rq, se->avg.load_avg_contrib);
                                                                                        cfs_rq->blocked_load_avg -= load_contrib;
                                                                                update_entity_load_avg(se, 0);
                                                                        if (flags & ENQUEUE_WAKEUP) {
                                                                                place_entity(cfs_rq, se, 0);
                                                                                enqueue_sleeper(cfs_rq, se);//try to wakeup
                                                                                        delta = rq_of(cfs_rq)->clock - se->statistics.sleep_start
2											//trace_sched_stat_sleep(tsk, delta);  //4
                                                                update_rq_runnable_avg(rq, rq->nr_running);
                                                                        __update_entity_runnable_avg(rq->clock_task, &rq->avg, runnable,
                                                                                             runnable, cpu);
                                                                        __update_tg_runnable_avg(&rq->avg, &rq->cfs);
3									//trace_sched_rq_runnable_ratio(cpu_of(rq), rq->avg.load_avg_ratio);
4									//trace_sched_rq_runnable_load(cpu_of(rq), rq->cfs.runnable_load_avg);
5									//trace_sched_rq_nr_running
                                        ttwu_do_wakeup
                                                check_preempt_curr(rq, p, wake_flags);
6						//trace_sched_wakeup(p, true);

 Chrome_IOThread-5362  ( 5062) [003] d..4 120167.053800: sched_migrate_task: comm=Chrome_ChildIOT pid=5402 prio=114 orig_cpu=3 dest_cpu=2\n\
 Chrome_IOThread-5362  ( 5062) [003] d..5 120167.053822: sched_stat_sleep: comm=Chrome_ChildIOT pid=5402 delay=1010500 [ns]\n\
 Chrome_IOThread-5362  ( 5062) [003] d..5 120167.053830: sched_rq_runnable_ratio: cpu=2 ratio=181\n\
 Chrome_IOThread-5362  ( 5062) [003] d..5 120167.053831: sched_rq_runnable_load: cpu=2 load=691\n\
 Chrome_IOThread-5362  ( 5062) [003] d..5 120167.053834: sched_rq_nr_running: cpu=2 nr_running=0 nr_iowait=0\n\
 Chrome_IOThread-5362  ( 5062) [003] d..5 120167.053846: sched_wakeup: comm=Chrome_ChildIOT pid=5402 prio=114 success=1 target_cpu=002\n\

cpu_idle_loop
        schedule_preempt_disabled();
                schedule();
                        __schedule();//idle case
                                pre_schedule(rq, prev);
                                        //prev->sched_class->pre_schedule(rq, prev);
                                        pre_schedule_idle
                                                idle_exit_fair(rq);
1 2 3						update_rq_runnable_avg(this_rq, 0);
                                                rq_last_tick_reset(rq);
                                next = pick_next_task(rq);
                                        // class->pick_next_task(rq)
                                        pick_next_task_fair
                                                pick_next_entity(cfs_rq);
                                                        se = __pick_first_entity(cfs_rq)
                                                set_next_entity(cfs_rq, se)
                                                        update_stats_wait_end(cfs_rq, se);
                                                                if (entity_is_task(se)) {
4									//trace_sched_stat_wait(task_of(se), rq_of(cfs_rq)->clock - se->statistics.wait_start);
                                                        cfs_rq->curr = se
                                context_switch(rq, prev, next); /* unlocks the rq */
                                        prepare_task_switch(rq, prev, next);
5						//trace_sched_switch(prev, next);

          <idle>-0     (-----) [002] dN.3 120167.053865: sched_rq_runnable_ratio: cpu=2 ratio=181\n\
          <idle>-0     (-----) [002] dN.3 120167.053870: sched_rq_runnable_load: cpu=2 load=691\n\
          <idle>-0     (-----) [002] dN.3 120167.053871: sched_rq_nr_running: cpu=2 nr_running=1 nr_iowait=0\n\
          <idle>-0     (-----) [002] dN.3 120167.053876: sched_stat_wait: comm=Chrome_ChildIOT pid=5402 delay=0 [ns]\n\
          <idle>-0     (-----) [002] d..3 120167.053882: sched_switch: prev_comm=swapper/2 prev_pid=0 prev_prio=120 prev_state=R ==> next_comm=Chrome_ChildIOT next_pid=5402 next_prio=114\n\



sched_init
        init_sched_domains(cpu_active_mask);
        init_rq_hrtick
                hrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
                        __hrtimer_init(timer, clock_id, mode);
                rq->hrtick_timer.function = hrtick;
                init_idle(current, smp_processor_id());
                        rq->curr = rq->idle = idle;
                        idle->sched_class = &idle_sched_class;

=> update_process_times

 => tick_sched_timer

 => __run_hrtimer

 => hrtimer_interrupt

 => twd_handler

 => handle_percpu_devid_irq

 => generic_handle_irq

 => handle_IRQ

 => gic_handle_irq

 => __irq_svc

 => _raw_spin_unlock_irq

 => finish_task_switch

 => __schedule

 => schedule_preempt_disabled

 => cpu_startup_entry

 => start_kernel
*** timer
update_process_times(user_mode(get_irq_regs()));
        run_local_timers
                hrtimer_run_queues();
                        timerqueue_getnext
                        cpu_base = &__get_cpu_var(hrtimer_bases)
                        __run_hrtimer(timer, &base->softirq_time)
                raise_softirq(TIMER_SOFTIRQ);
                        run_timer_softirq
                                hrtimer_run_pending();
                                        tick_check_oneshot_change
                                        hrtimer_switch_to_hres()
                                                tick_nohz_switch_to_nohz();
                                                        tick_switch_to_oneshot(tick_nohz_handler)
                                __run_timers(base)
                                        call_timer_fn(timer, fn, data);
        rcu_check_callbacks
        scheduler_tick
                sched_clock_tick
                update_rq_clock
                update_cpu_load_active
                        __update_cpu_load(this_rq, this_rq->load.weight, 1);
                                this_rq->cpu_load[0] = this_load;
                                this_rq->cpu_load[i] = (old_load * (scale - 1) + new_load) >> i
                                sched_avg_update(this_rq)
                                        rq->rt_avg /= 2
                        calc_load_account_active(this_rq)
                //curr->sched_class->task_tick(rq, curr, 0);
                task_tick_fair
                trigger_load_balance

hrtimer_switch_to_hres
        tick_init_highres
                tick_switch_to_oneshot(hrtimer_interrupt)
                                //hrtimer_interrupt
                                __run_hrtimer(timer, &basenow);
                                tick_program_event(expires_next, 1);
                        td = &__get_cpu_var(tick_cpu_device)
                        dev->event_handler = handler;
                        clockevents_set_mode(dev, CLOCK_EVT_MODE_ONESHOT);
                        tick_broadcast_switch_to_oneshot();
        tick_setup_sched_timer();
                ts = &__get_cpu_var(tick_cpu_sched);
                hrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
                ts->sched_timer.function = tick_sched_timer;// only forward timer no reprogram tick device
                        tick_sched_do_timer(now);
                                tick_do_update_jiffies64(now);
                        tick_sched_handle(ts, regs);
                                update_process_times(user_mode(regs));
                                touch_softlockup_watchdog();
                        hrtimer_forward(timer, now, tick_period); //
tick_handle_periodic
        tick_periodic(cpu);
                do_timer(1);
                        jiffies_64 += ticks;
                        update_wall_time();
                                //clock->read(clock)
                                owl_read_timer
                                        act_readl(T0_VAL)
                                timekeeping_adjust(tk, offset)
                        calc_global_load(ticks);
/*  Once every LOAD_FREQ:
 *
 *   nr_active = 0;
 *   for_each_possible_cpu(cpu)
 *      nr_active += cpu_of(cpu)->nr_running + cpu_of(cpu)->nr_uninterruptible;
 *
 *   avenrun[n] = avenrun[0] * exp_n + nr_active * (1 - exp_n) */
                update_process_times(user_mode(get_irq_regs()));
        ktime_add(dev->next_event, tick_period);
        clockevents_program_event(dev, next, false)


CLOCKSOURCE_OF_DECLARE(arm_twd_a9, "arm,cortex-a9-twd-timer", twd_local_timer_of_register);
twd_local_timer_of_register

time_init
        //machine_desc->init_time()
        owl_timer_init
                owl_gp_timer_init
                        setup_sched_clock(owl_read_sched_clock, 32, rate);
                        clocksource_register_hz(&owl_clksrc, rate);
                                sched_clock_timer.data = msecs_to_jiffies(w - (w / 10));
                                update_sched_clock();
                        setup_irq(OWL_IRQ_TIMER1, &owl_timer_irq);
                        owl_clkevt.cpumask = cpumask_of(0);
                        clockevents_config_and_register(&owl_clkevt, rate,0xf, 0xffffffff);
                                clockevents_register_device
                                        tick_check_new_device
                                                td = &per_cpu(tick_cpu_device, cpu);
                                                tick_setup_device(td, newdev, cpu, cpumask_of(cpu))
                                                        td->evtdev = newdev
                                                        tick_setup_periodic(newdev, 0)
                                                                tick_set_periodic_handler(dev, broadcast)
                                                                        dev->event_handler = tick_handle_periodic
                                                                clockevents_set_mode(dev, CLOCK_EVT_MODE_ONESHOT);
                                                                        clockevents_program_event
                                                                                //dev->set_next_event((unsigned long) clc, dev);
                                                                                owl_clkevt_next
                owl_twd_init
                        twd_local_timer_register(&twd_local_timer)
                                twd_base = ioremap(tlt->res[0].start, resource_size(&tlt->res[0]));
                                twd_local_timer_common_register(NULL);
                                        request_percpu_irq(twd_ppi, twd_handler, "twd", twd_evt);
                                        local_timer_register(&twd_lt_ops);
                                                //struct local_timer_ops *lt_ops = twd_lt_ops ;
                                                //static struct local_timer_ops twd_lt_ops __cpuinitdata = {
                                                //	.setup	= twd_timer_setup,
                                                        twd_timer_setup
                                                                clk->name = "local_timer";
                                                                clk->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |
                                                                                CLOCK_EVT_FEAT_C3STOP;
                                                                clk->rating = 350;
                                                                clk->set_mode = twd_set_mode;
                                                                clk->set_next_event = twd_set_next_event;
                                                                clk->irq = twd_ppi;
                                                                this_cpu_clk = __this_cpu_ptr(twd_evt);
                                                                *this_cpu_clk = clk;
                                                                clockevents_config_and_register(clk, twd_timer_rate,
                                                                                                0xf, 0xffffffff);
                                                                enable_percpu_irq(clk->irq, 0);
                                        twd_get_clock(np);
                                                of_clk_get(np, 0);
                                                clk_get_sys("smp_twd", NULL);
                                                clk_prepare_enable(twd_clk);

        sched_clock_postinit
                sched_clock_poll(sched_clock_timer.data);//
                        mod_timer(&sched_clock_timer, round_jiffies(jiffies + wrap_ticks));
                        update_sched_clock();
start_kernel
        init_timers();
                open_softirq(TIMER_SOFTIRQ, run_timer_softirq)
                        run_timer_softirq
                                hrtimer_run_pending
        hrtimers_init();
                open_softirq(HRTIMER_SOFTIRQ, run_hrtimer_softirq);
        time_init();
        rest_init
                init_idle_bootup_task(current);
                cpu_startup_entry(CPUHP_ONLINE);
                        cpu_idle_loop();
}
*** cpu hotplug
cpu_down
        _cpu_down
                __cpu_notify(CPU_DOWN_PREPARE | mod, hcpu, -1, &nr_calls)
                __stop_machine
                __cpu_die
                        platform_cpu_kill(cpu)
                                //smp_ops.cpu_kill
                                owl_cpu_kill
                cpu_notify_nofail(CPU_DEAD | mod, hcpu)

scheduler_ipi
        tick_nohz_full_check();
                tick_nohz_full_cpu(smp_processor_id())
                tick_nohz_restart_sched_tick(ts, ktime_get());
                        tick_nohz_restart(ts, now);
        sched_ttwu_pending();
                ttwu_do_activate(rq, p, 0);

cpu_idle_loop
        tick_nohz_idle_enter();
                ts = &__get_cpu_var(tick_cpu_sched);
                ts->inidle = 1;
                __tick_nohz_idle_enter(ts);
                        tick_nohz_start_idle(cpu, ts)
                                ts->idle_entrytime = now;
                                ts->idle_active = 1;
                                sched_clock_idle_sleep_event();
                        can_stop_idle_tick(cpu, ts)
                        expires = tick_nohz_stop_sched_tick(ts, now, cpu);
                                rcu_needs_cpu
                                get_next_timer_interrupt
                                nohz_balance_enter_idle(cpu);
                                        set_bit(NOHZ_TICK_STOPPED, nohz_flags(cpu));
                                calc_load_enter_idle();
                                        calc_load_fold_active(this_rq);
                                ts->last_tick = hrtimer_get_expires(&ts->sched_timer);
                                ts->tick_stopped = 1;
                                raise_softirq_irqoff(TIMER_SOFTIRQ);
                                //trace_tick_stop(1, " ");
        if (cpu_is_offline(smp_processor_id()))
                arch_cpu_idle_dead();
                        cpu_die
                                //smp_ops.cpu_die(cpu)
                                owl_cpu_die
                                        platform_do_lowpower
                                                cpu_enter_lowpower
                                                        scu_power_mode(scu_base, 0x3);//WFI
        arch_cpu_idle_enter();
                ledtrig_cpu(CPU_LED_IDLE_START);
        arch_cpu_idle();
                if (cpuidle_idle_call())
                        default_idle();
                                if (arm_pm_idle)
                                        arm_pm_idle();
                                else
                                        cpu_do_idle();
                                                //__glue(CPU_NAME,_do_idle) //name##fn
                                                cpu_v7_do_idle //arch/arm/mm/proc-v7.S
        arch_cpu_idle_exit();
        tick_nohz_idle_exit();
        schedule_preempt_disabled();
                schedule();

hotplug_timer
        cpu_down
        cpu_up

owl_pm_hotplug_init
        INIT_DELAYED_WORK(&hotplug_work, hotplug_timer);
        INIT_DELAYED_WORK(&(freq_trans_works.work), adjust_hot_plug_with_freq);
        INIT_DELAYED_WORK(&detecting_freq_work, set_cpu_frequence);

secondary_start_kernel
        //smp_ops.smp_secondary_init(cpu);
        owl_secondary_init
                gic_secondary_init(NULL, CPU_STARTING, (void*)0)
        notify_cpu_starting(cpu)
        cpu_startup_entry
                cpu_idle_loop();

start_kernel
        setup_arch
                smp_init_cpus()
                        //smp_ops.smp_init_cpus()
                        owl_smp_init_cpus
        rest_init
                kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);
                        kernel_init_freeable
                                smp_prepare_cpus(setup_max_cpus)
                                        percpu_timer_setup();
                                                struct clock_event_device *evt = &per_cpu(percpu_clockevent, cpu);
                                                //lt_ops->setup(evt)
                                                twd_timer_setup
                                                        clk->name = "local_timer";
                                                        clk->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |
                                                                        CLOCK_EVT_FEAT_C3STOP;
                                                        clk->rating = 350;
                                                        clk->set_mode = twd_set_mode;
                                                        clk->set_next_event = twd_set_next_event;
                                                        clk->irq = twd_ppi;
                                                        this_cpu_clk = __this_cpu_ptr(twd_evt);
                                                        *this_cpu_clk = clk;
                                                        clockevents_config_and_register(clk, twd_timer_rate,
                                                                                        0xf, 0xffffffff);
                                                        enable_percpu_irq(clk->irq, 0);

                                        //smp_ops.smp_prepare_cpus(max_cpus)
                                        owl_smp_prepare_cpus
                                smp_init
                                        idle_threads_init
                                                idle_init
                                                        fork_idle
                                                                copy_process
                                                                init_idle_pids(task->pids);
                                                                init_idle(task, cpu);
                                                                        idle->sched_class = &idle_sched_class;
                                        cpu_up(cpu);//
                                                _cpu_up
                                                        cpu_hotplug_begin
                                                        __cpu_notify(CPU_UP_PREPARE | mod, hcpu, -1, &nr_calls);
                                                        __cpu_up(cpu, idle);
                                                                idle = idle_thread_get(cpu);
                                                                        per_cpu(idle_threads, cpu)
                                                                boot_secondary(cpu, idle)
                                                                        //smp_ops.smp_boot_secondary(cpu, idle)
                                                                        owl_boot_secondary
                                                                                wakeup_secondary
                                                                                        owl_powergate_power_on
                                                                                        act_writel(virt_to_phys(owl_secondary_startup)
                                                                                                secondary_startup//HEAD.S
                                                                                                        secondary_start_kernel
                                                        cpu_notify(CPU_ONLINE | mod, hcpu)
                                                        cpu_hotplug_done()
                                        smp_cpus_done//bogomips

static struct smp_operations owl_smp_ops =
{
#ifdef CONFIG_SMP
    .smp_init_cpus = owl_smp_init_cpus,
    .smp_prepare_cpus = owl_smp_prepare_cpus,
    .smp_secondary_init = owl_secondary_init,
    .smp_boot_secondary = owl_boot_secondary,
#ifdef CONFIG_HOTPLUG_CPU
        .cpu_kill = owl_cpu_kill,
        .cpu_die = owl_cpu_die,
        .cpu_disable = owl_cpu_disable,
#endif
#endif
};

owl_smp_init
        smp_set_ops(&owl_smp_ops);
*** irq
static struct irq_chip gic_chip = {
        .name			= "GIC",
        .irq_mask		= gic_mask_irq,
        .irq_unmask		= gic_unmask_irq,
        .irq_eoi		= gic_eoi_irq,
        .irq_set_type		= gic_set_type,
        .irq_retrigger		= gic_retrigger,
#ifdef CONFIG_SMP
        .irq_set_affinity	= gic_set_affinity,
#endif
        .irq_set_wake		= gic_set_wake,
};

const struct irq_domain_ops gic_irq_domain_ops = {
        .map = gic_irq_domain_map,
        .xlate = gic_irq_domain_xlate,
};

request_irq
        request_threaded_irq
                irq_to_desc
                __setup_irq(irq, desc, action)

owl_init_irq
        gic_init
                gic_init_bases
                        irq_alloc_descs
                        irq_domain_add_legacy //gic_irq_domain_ops
                                irq_domain_alloc
                                //ops->map(domain, irq, hwirq)
                                gic_irq_domain_map
                                        irq_set_chip_and_handler(irq, &gic_chip,handle_percpu_devid_irq);
                                irq_domain_add
                         set_smp_cross_call(gic_raise_softirq);
*** pinctrl
p = pinctrl_get(dev);
                create_pinctrl
                        pinctrl_dt_to_map
                                kasprintf(GFP_KERNEL, "pinctrl-%d", state)
                                of_find_property
                                dt_to_map_one_config(p, statename, np_config)
                                        pctldev = get_pinctrl_dev_from_of_node(np_pctldev)
                                        ops = pctldev->desc->pctlops
                                        ops->dt_node_to_map(pctldev, np_config, &map, &num_maps)
                                        //owl_pinctrl_dt_node_to_map
                                        dt_remember_or_free_map(p, statename, pctldev, map, num_maps)
                                                pinctrl_register_map(map, num_maps, false, true)
                                                        pinmux_validate_map(&maps[i], i)
                                                        list_add_tail(&maps_node->node, &pinctrl_maps)
s = pinctrl_lookup_state(p, "8bit");
ret = pinctrl_select_state(p, s);
static struct pinctrl_ops owl_pctlops_ops = {
        .get_groups_count = owl_pctlops_get_groups_count,
        .get_group_name = owl_pctlops_get_group_name,
        .get_group_pins = owl_pctlops_get_group_pins,
        .pin_dbg_show = owl_pctlops_pin_dbg_show,
        .dt_node_to_map = owl_pinctrl_dt_node_to_map,
        .dt_free_map = owl_pinctrl_dt_free_map,

};


static struct pinmux_ops owl_pmxops_ops = {
        .get_functions_count = owl_pmxops_get_funcs_count,
        .get_function_name = owl_pmxops_get_func_name,
        .get_function_groups = owl_pmxops_get_groups,
        .enable = owl_pmxops_enable,
        .disable = owl_pmxops_disable,
        .request = owl_pmxops_request,
        .gpio_request_enable = owl_pmxops_gpio_request_enable,
        .gpio_disable_free = owl_pmxops_gpio_disable_free,

};

static struct pinctrl_desc owl_pinctrl_desc = {
        .name = NULL,
        .pins = NULL,
        .npins = 0,
        .pctlops = &owl_pctlops_ops,
        .pmxops = &owl_pmxops_ops,
        .confops = &owl_confops_ops,
        .owner = THIS_MODULE,
};

owl_pinctrl_common_probe
        pinctrl_register(&owl_pinctrl_desc, &pdev->dev, apctl)

cpu0_set_target
        cpufreq_frequency_table_target
        opp_find_freq_ceil
        opp_get_voltage
        cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE)
        clk_set_rate
        regulator_set_voltage_tol
        cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE)

static struct cpufreq_driver cpu0_cpufreq_driver = {
        .flags = CPUFREQ_STICKY,
        .verify = cpu0_verify_speed,
        .target = cpu0_set_target,
        .get = cpu0_get_speed,
        .init = cpu0_cpufreq_init,
        .exit = cpu0_cpufreq_exit,
        .name = "generic_cpu0",
        .attr = cpu0_cpufreq_attr,
};
*** cpufreq
late_initcall(cpu0_cpufreq_driver_init);
        owl_cpu0_cpufreq_driver_init
                get_cpu_device(0)
                owl_cpu0_clk_init
                devm_regulator_get
                init_cpu0_opp_info
                find_cpu0_opp_info_max_min_freq
                CF0AOT_all //opp_add
                cpufreq_register_driver
cpufreq_interactive_speedchange_task
        __cpufreq_driver_target
                cpufreq_driver->target(policy, target_freq, relation)

cpufreq_interactive_timer
        update_load(data);
        choose_freq(pcpu, loadadjfreq);
                cpufreq_frequency_table_target
        cpufreq_frequency_table_target(pcpu->policy, pcpu->freq_table,new_freq, CPUFREQ_RELATION_L,&index)
        wake_up_process(speedchange_task)

cpufreq_governor_interactive
        CPUFREQ_GOV_POLICY_INIT:
        policy->governor_data = tunables
        CPUFREQ_GOV_START:
        freq_table = cpufreq_frequency_get_table(policy->cpu)
        cpufreq_interactive_timer_start
                add_timer_on(&pcpu->cpu_timer, cpu)
                //pcpu->cpu_timer.function = cpufreq_interactive_timer;
                cpufreq_interactive_timer
struct cpufreq_governor cpufreq_gov_interactive = {
        .name = "interactive",
        .governor = cpufreq_governor_interactive,
        .max_transition_latency = 10000000,
        .owner = THIS_MODULE,
};
cpufreq_add_dev
        cpufreq_add_dev_interface(cpu, policy, dev)
                __cpufreq_set_policy(policy, &new_policy)
                        __cpufreq_governor(data, CPUFREQ_GOV_POLICY_INIT))
                                //policy->governor->governor(policy, event)
                                cpufreq_governor_interactive
                        __cpufreq_governor(data, CPUFREQ_GOV_START)

static struct subsys_interface cpufreq_interface = {
        .name		= "cpufreq",
        .subsys		= &cpu_subsys,
        .add_dev	= cpufreq_add_dev,
        .remove_dev	= cpufreq_remove_dev,
};

cpufreq_register_driver
        subsys_interface_register(&cpufreq_interface)

of_find_compatible_node

/*
cpu0_cpufreq_probe
        of_init_opp_table
                of_find_property(dev->of_node, "operating-points", NULL)
                opp_add(dev, freq, volt)
        opp_init_cpufreq_table
                find_device_opp
                freq_table[i].frequency = opp->rate / 1000
        cpufreq_register_driver
*/
*** regulator
regulator_get
        _regulator_get
                regulator_dev_lookup
                        of_get_regulator
                        list_for_each_entry(r, &regulator_list, list)
                                if (r->dev.parent && node == r->dev.of_node)
                create_regulator
                        regulator->rdev = rdev;
                        list_add(&regulator->list, &rdev->consumer_list);
regulator_enable
        _regulator_enable
                _regulator_do_enable
                        _regulator_get_enable_time(rdev)
                        trace_regulator_enable(rdev_get_name(rdev));
                        rdev->desc->ops->enable(rdev)
devm_regulator_get
        devres_alloc
                alloc_dr
__device_release_driver
        devres_release_all
                release_nodes
                        dr->node.release(dev, dr->data);
*** zram
shrink_page_list
        add_to_swap
                entry = get_swap_page();
                         swp_entry(type, offset);
        add_to_swap_cache(page, entry,
                __add_to_swap_cache
                        swap_address_space(entry); //&swapper_spaces[swp_type(entry)
        pageout
                // mapping->a_ops->writepage
                swap_writepage // swap_aops
                        try_to_free_swap
                                delete_from_swap_cache(page);
                        frontswap_store
                        __swap_writepage(page, wbc, end_swap_bio_write)//else
                                page_swap_info(page)
                                get_swap_bio(GFP_NOIO, page, end_write_func);
                                submit_bio(rw, bio);
handle_pte_fault
        do_swap_page
                lookup_swap_cache
                        swapin_readahead
                                read_swap_cache_async
                                        swap_readpage
                                                get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);
                                                submit_bio(READ, bio);
                swap_free
                        swap_entry_free(p, entry, 1);
                                //disk->fops->swap_slot_free_notify
                                zram_slot_free_notify	//zram_devops
__remove_mapping
        swapcache_free
                swap_entry_free

(zram_slot_free_notify+0x1c/0x40) from [<c010f0d0>] (swap_entry_free+0x12c/0x168)
(swap_entry_free+0x12c/0x168) from [<c010f2c8>] (swap_free+0x20/0x2c)
(swap_free+0x20/0x2c) from [<c010006c>] (handle_pte_fault+0x3e0/0x85c)
(handle_pte_fault+0x3e0/0x85c) from [<c01005bc>] (handle_mm_fault+0xd4/0x11c)
(handle_mm_fault+0xd4/0x11c) from [<c001b118>] (do_page_fault+0x250/0x3a4)
(do_page_fault+0x250/0x3a4) from [<c00084d4>] (do_DataAbort+0x38/0x98)
(do_DataAbort+0x38/0x98) from [<c000f074>] (__dabt_usr+0x34/0x40)

SYSCALL_DEFINE2(swapon
        alloc_swap_info
                swap_info_struct p = swap_info[type]
        p->swap_file = file_open_name(name,
        claim_swapfile(p, inode);
                p->bdev = bdgrab(I_BDEV(inode))
                blkdev_open //bdev->bd_inode->i_mapping
                set_blocksize(p->bdev, PAGE_SIZE);
        read_mapping_page(mapping, 0, swap_file);
        setup_swap_map_and_extents
        enable_swap_info
                frontswap_init
                        __frontswap_init(type, map)
                                frontswap_ops->init(type); //zcache_frontswap_ops
                                        zcache_frontswap_init
                _enable_swap_info(p, prio, swap_map);


zram_init
        register_blkdev(0, "zram");
                 create_device(&zram_devices[dev_id], dev_id);
                        blk_queue_make_request(zram->queue, zram_make_request);
                        zram->disk->fops = &zram_devops;
zram_make_request
        __zram_make_request(zram, bio, bio_data_dir(bio));
                zram_bvec_rw(zram, &bv, index+1, 0, bio, rw) < 0)
                                zram_bvec_write
                                        zs_malloc(meta->mem_pool, clen);
                        bio_endio(bio, 0);
zcache_init
        zcache_frontswap_register_ops
                frontswap_register_ops(&zcache_frontswap_ops);

warn_slowpath_common+0x4c/0x68) from [<c00309f8>] (warn_slowpath_null+0x1c/0x24)
warn_slowpath_null+0x1c/0x24) from [<c02783c8>] (fuse_lookup+0x120/0x130)
fuse_lookup+0x120/0x130) from [<c0124bf0>] (lookup_real+0x20/0x50)
lookup_real+0x20/0x50) from [<c01254e8>] (__lookup_hash+0x34/0x44)
__lookup_hash+0x34/0x44) from [<c0125530>] (lookup_slow+0x38/0x9c)
lookup_slow+0x38/0x9c) from [<c01275b4>] (path_lookupat+0x22c/0x7c8)
path_lookupat+0x22c/0x7c8) from [<c0127b70>] (filename_lookup+0x20/0xbc)
filename_lookup+0x20/0xbc) from [<c0129f6c>] (user_path_at_empty+0x50/0x7c)
user_path_at_empty+0x50/0x7c) from [<c0129fac>] (user_path_at+0x14/0x1c)
user_path_at+0x14/0x1c) from [<c01205f8>] (vfs_fstatat+0x4c/0x90)
vfs_fstatat+0x4c/0x90) from [<c01208fc>] (SyS_fstatat64+0x14/0x30)
SyS_fstatat64+0x14/0x30) from [<c000f0c0>] (ret_fast_syscall+0x0/0x30)

[ 8495.987327] [<c0015ea0>] (unwind_backtrace+0x0/0x134) from [<c00132d8>] (show_stack+0x10/0x14)
[ 8495.996053] [<c00132d8>] (show_stack+0x10/0x14) from [<c072a80c>] (dump_header.isra.12+0x74/0x1a0)
[ 8496.005108] [<c072a80c>] (dump_header.isra.12+0x74/0x1a0) from [<c00d84fc>] (oom_kill_process+0x268/0x3b8)
[ 8496.014817] [<c00d84fc>] (oom_kill_process+0x268/0x3b8) from [<c00d8ac0>] (out_of_memory+0x2ac/0x2dc)
[ 8496.024075] [<c00d8ac0>] (out_of_memory+0x2ac/0x2dc) from [<c00dd2f0>] (__alloc_pages_nodemask+0x84c/0x8f4)
[ 8496.033843] [<c00dd2f0>] (__alloc_pages_nodemask+0x84c/0x8f4) from [<c00d74d0>] (filemap_fault+0x1cc/0x44c)
[ 8496.043600] [<c00d74d0>] (filemap_fault+0x1cc/0x44c) from [<c00f60f0>] (__do_fault+0x6c/0x4d8)
[ 8496.052243] [<c00f60f0>] (__do_fault+0x6c/0x4d8) from [<c00f9480>] (handle_pte_fault+0x70/0x898)
[ 8496.061045] [<c00f9480>] (handle_pte_fault+0x70/0x898) from [<c00f9d7c>] (handle_mm_fault+0xd4/0x11c)
[ 8496.070404] [<c00f9d7c>] (handle_mm_fault+0xd4/0x11c) from [<c001b29c>] (do_page_fault+0x250/0x3a4)
[ 8496.079739] [<c001b29c>] (do_page_fault+0x250/0x3a4) from [<c0008568>] (do_PrefetchAbort+0x34/0x98)
[ 8496.088816] [<c0008568>] (do_PrefetchAbort+0x34/0x98) from [<c000f294>] (ret_from_exception+0x0/0x10)
*** memleak
kmalloc
        kmalloc_index
        __kmalloc
                __do_kmalloc
                        kmalloc_slab
                        slab_alloc
                                __do_cache_alloc
                                        kmemleak_alloc_recursive
                                                kmemleak_alloc
                                                        create_object

                                        kmemcheck_slab_alloc
                        //trace_kmalloc


kmemleak_scan_thread
        kmemleak_scan
                scan_block

proc_stat_init
        proc_create("stat", 0, NULL, &proc_stat_operations);
        stat_open
                single_open(file, show_stat, NULL)
                        show_stat
                                get_iowait_time
                                        get_cpu_iowait_time_us


setup_vmstat
        proc_create("buddyinfo", S_IRUGO, NULL, &fragmentation_file_operations);
        proc_create("pagetypeinfo", S_IRUGO, NULL, &pagetypeinfo_file_ops);
        proc_create("vmstat", S_IRUGO, NULL, &proc_vmstat_file_operations);
        proc_create("zoneinfo", S_IRUGO, NULL, &proc_zoneinfo_file_operations);
vmstat_op
*** ion
liger_reserve
        asoc_pdev_ion_data.heaps[0].base = asoc_ion0_start;
        asoc_pdev_ion_data.heaps[0].size = asoc_ion0_size;
        asoc_pdev_ion_data.heaps[1].base = asoc_ion1_start;
        asoc_pdev_ion_data.heaps[1].size = asoc_ion1_size;
struct dma_map_ops arm_dma_ops = {
        .alloc			= arm_dma_alloc,
        .free			= arm_dma_free,
        .mmap			= arm_dma_mmap,
        .get_sgtable		= arm_dma_get_sgtable,
        .map_page		= arm_dma_map_page,
        .unmap_page		= arm_dma_unmap_page,
        .map_sg			= arm_dma_map_sg,
        .unmap_sg		= arm_dma_unmap_sg,
        .sync_single_for_cpu	= arm_dma_sync_single_for_cpu,
        .sync_single_for_device	= arm_dma_sync_single_for_device,
        .sync_sg_for_cpu	= arm_dma_sync_sg_for_cpu,
        .sync_sg_for_device	= arm_dma_sync_sg_for_device,
        .set_dma_mask		= arm_dma_set_mask,
};
static struct ion_heap_ops ion_cma_ops = {
        .allocate = ion_cma_allocate,
        .free = ion_cma_free,
        .map_dma = ion_cma_heap_map_dma,
        .unmap_dma = ion_cma_heap_unmap_dma,
        .phys = ion_cma_phys,
        .map_user = ion_cma_mmap,
        .map_kernel = ion_cma_map_kernel,
        .unmap_kernel = ion_cma_unmap_kernel,
};

ion_ioctl
        ion_alloc
                ion_buffer_create
                        ion_cma_allocate //heap->ops->allocate
                                dma_alloc_coherent
                        buffer->sg_table = table;
                        buffer->pages[k++] = page++;
                        ion_buffer_add
                ion_handle_create
                ion_handle_add

static struct dma_buf_ops dma_buf_ops = {
        .map_dma_buf = ion_map_dma_buf,
        .unmap_dma_buf = ion_unmap_dma_buf,
        .mmap = ion_mmap,
        .release = ion_dma_buf_release,
        .begin_cpu_access = ion_dma_buf_begin_cpu_access,
        .end_cpu_access = ion_dma_buf_end_cpu_access,
        .kmap_atomic = ion_dma_buf_kmap,
        .kunmap_atomic = ion_dma_buf_kunmap,
        .kmap = ion_dma_buf_kmap,
        .kunmap = ion_dma_buf_kunmap,
};

ion_ioctl
        ion_share_dma_buf_fd//ION_IOC_SHARE
                ion_share_dma_buf
                        ion_buffer_get
                        dma_buf_export(buffer, &dma_buf_ops, buffer->size, O_RDWR)
                                dma_buf_export_named
                                        anon_inode_getfile("dmabuf", &dma_buf_fops, dmabuf, flags)
                                                path.dentry = d_alloc_pseudo(anon_inode_mnt->mnt_sb, &this)//anon_inode_mnt = kern_mount(&anon_inode_fs_type);
                                                alloc_file(&path, OPEN_FMODE(flags), dma_buf_fops);
                                                //.mmap		= dma_buf_mmap_internal,
                                        dmabuf->file = file;
                dma_buf_fd
                        get_unused_fd_flags(flags);
                        fd_install(fd, dmabuf->file);

ion_ioctl
        ion_import_dma_buf//ION_IOC_IMPORT
                dmabuf = dma_buf_get(fd)
                        file->private_data
                buffer = dmabuf->priv;
                handle = ion_handle_create(client, buffer);
                ion_handle_add(client, handle);

dma_buf_mmap_internal //dma_buf_fops
        ion_mmap//dmabuf->ops->mmap   dma_buf_ops
                ion_cma_mmap // buffer->heap->ops->map_user ion_cma_ops
                        dma_mmap_coherent
                                dma_mmap_attrs
                                        arm_dma_mmap //arm_dma_ops
                                                vma->vm_page_prot = __get_dma_pgprot(attrs, vma->vm_page_prot)
                                                remap_pfn_range
asoc_ion_driver
        asoc_ion_probe
                ion_device_create(asoc_ion_ioctl);
                        idev->dev.fops = &ion_fops;
                        misc_register
                        idev->custom_ioctl = asoc_ion_ioctl;
                ion_heap_create
                        ion_carveout_heap_create
                                ion_pages_sync_for_device
                                        dma_sync_sg_for_device //arm_dma_ops
                                                arm_dma_sync_sg_for_device
                                                        arm_dma_sync_single_for_device
                                gen_pool_create
                                        pool->algo = gen_pool_first_fit;
                                gen_pool_add(carveout_heap->pool, carveout_heap->base, heap_data->size,
                                carveout_heap->heap.ops = &carveout_heap_ops;
                                        //ion_carveout_heap_allocate
                                                //ion_carveout_allocate
                                                        //gen_pool_alloc
                                                                //gen_pool_first_fit
                                carveout_heap->pool = gen_pool_create(12, -1);
                        ion_system_contig_heap_create
                        ion_system_heap_create
                        ion_cma_heap_create
                                cma_heap->heap.ops = &ion_cma_ops;
                                        //ion_cma_allocate
                                                //dma_alloc_coherent
                ion_device_add_heap
                        plist_add(&heap->node, &dev->heaps);

dma_alloc_noncoherent
dma_alloc_coherent
        dma_alloc_attrs
                arm_dma_alloc
                        __dma_alloc
                                __alloc_from_contiguous
                                        dma_alloc_from_contiguous
                                                alloc_contig_range(pfn, pfn + count, MIGRATE_CMA);
                                                        start_isolate_page_range
                                                                set_migratetype_isolate
                                                                        set_pageblock_migratetype(page, MIGRATE_ISOLATE);
                                                                        nr_pages = move_freepages_block(zone, page, MIGRATE_ISOLATE);
                                                                        __mod_zone_freepage_state(zone, -nr_pages, migratetype);
                                                        __alloc_contig_migrate_range
                                                                isolate_migratepages_range
                                                                        __isolate_lru_page
                                                                        del_page_from_lru_list(page, lruvec, page_lru(page));
                                                                        list_add(&page->lru, migratelist);
                                                                        //trace_mm_compaction_isolate_migratepages
                                                                reclaim_clean_pages_from_list
                                                                        shrink_page_list(&clean_pages,
                                                                migrate_pages(&cc->migratepages, alloc_migrate_target,0, MIGRATE_SYNC, MR_CMA);
                                                                        unmap_and_move(get_new_page, private,page, pass > 2, mode);
                                                                                alloc_migrate_target
                                                                                __unmap_and_move
                                                                        //trace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);
                                __dma_clear_buffer
                                __dma_remap(page, size, prot);
                                        apply_to_page_range(&init_mm, start, size, __dma_update_fpte, &prot);
                                page_address(page);


dma_contiguous_set_global_reserve_size

core_initcall(cma_init_reserved_areas);
cma_init_reserved_areas
        cma_create_area
                cma->base_pfn = base_pfn;
                cma->count = count;
                cma->bitmap = kzalloc(bitmap_size, GFP_KERNEL);
                cma_activate_area
                        init_cma_reserved_pageblock
                                __ClearPageReserved(p);
                                set_page_refcounted(page);
                                set_pageblock_migratetype(page, MIGRATE_CMA);
                                __free_pages(page, pageblock_order);
        dev_set_cma_area
                dma_contiguous_default_area = cma;
/*
  static int __init foo_set_up_cma_areas(void)
    {
        struct cma *cma;

        cma = dev_get_cma_area(device1);
        dev_set_cma_area(device2, cma);
        return 0;
    }
    postcore_initcall(foo_set_up_cma_areas);
*/

start_kernel
        setup_arch
                arm_memblock_init
                        dma_contiguous_reserve //CONFIG_CMA_SIZE_MBYTES
                                dma_declare_contiguous
                                        __memblock_alloc_base
                                                memblock_reserve




__page_set_anon_rmap
        page->mapping = (struct address_space *) anon_vma;
        page->index = linear_page_index(vma, address);



sys_remap_file_pages // VM_NONLINEAR
        find_vma
        vma->vm_flags |= VM_NONLINEAR;
        vma_interval_tree_remove(vma, &mapping->i_mmap);
        vma_nonlinear_insert(vma, &mapping->i_mmap_nonlinear);
        mmu_notifier_invalidate_range_start(mm, start, start + size);
        err = vma->vm_ops->remap_pages(vma, start, size, pgoff);
        mmu_notifier_invalidate_range_end(mm, start, start + size);
*** alloc_pages
buffered_rmqueue
        list = &pcp->lists[migratetype]; // order == 0
        page = list_entry(list->prev, struct page, lru);
        __rmqueue
                __rmqueue_smallest
                        &area->free_list[migratetype]
                        rmv_page_order
                                __ClearPageBuddy
                                set_page_private(page, 0);
                        expand
                                set_page_order
                                        set_page_private(page, order);
                                        __SetPageBuddy(page);
                __rmqueue_fallback
                        migratetype = fallbacks[start_migratetype][i]
                        move_freepages_block
                        set_pageblock_migratetype
                        expand
                migratetype = MIGRATE_RESERVE;
                        goto retry_reserve;
                        //trace_mm_page_alloc_extfrag
        //trace_mm_page_alloc_zone_locked
        prep_new_page
                check_new_page
                set_page_private(page, 0);
                set_page_refcounted(page);

alloc_pages
        __alloc_pages_nodemask
                gfp_zone
                allocflags_to_migratetype
                first_zones_zonelist
                alloc_flags |= ALLOC_CMA;
                get_page_from_freelist
                        zone_watermark_ok
                                __zone_watermark_ok// min_free_order_shift
                                buffered_rmqueue
                                        //trace_mm_page_alloc_zone_locked
                __alloc_pages_slowpath
                        wake_all_kswapd
                                wakeup_kswapd
                                        //trace_mm_vmscan_wakeup_kswapd
                        gfp_to_alloc_flags
                        get_page_from_freelist //~ALLOC_NO_WATERMARKS last chance
                        __alloc_pages_high_priority
                                get_page_from_freelist //ALLOC_NO_WATERMARKS
                                wait_iff_congested //__GFP_NOFAIL
                                //trace_writeback_wait_iff_congested
                        __alloc_pages_direct_compact
                        __alloc_pages_direct_reclaim
                                get_page_from_freelist
                                drain_all_pages
                                        drain_local_pages
                        __alloc_pages_may_oom
                                get_page_from_freelist //ALLOC_WMARK_HIGH|ALLOC_CPUSET
                                        out_of_memory(zonelist, gfp_mask, order, nodemask, false);

                        if (should_alloc_retry(gfp_mask, order, did_some_progress,pages_reclaimed)) {
                                        wait_iff_congested(preferred_zone, BLK_RW_ASYNC, HZ/50);
                                        //trace_writeback_wait_iff_congested
                                        goto rebalance;
                //trace_mm_page_alloc(page, order, gfp_mask, migratetype);
*** meminit
free_area_init_nodes
        find_zone_movable_pfns_for_nodes
                find_usable_zone_for_movable
                        movable_zone = zone_index;
                zone_movable_pfn[nid] = end_pfn;
        free_area_init_node

init_per_zone_wmark_min // module_init(init_per_zone_wmark_min)
        setup_per_zone_wmarks
                __setup_per_zone_wmarks
                        setup_zone_migrate_reserve
                                set_pageblock_migratetype(page,	MIGRATE_RESERVE);
                                move_freepages_block(zone, page,MIGRATE_RESERVE);

min_free_kbytes_sysctl_handler
        setup_per_zone_wmarks

free_area_init_core
        zone->present_pages = realsize;
        zone_pcp_init
                zone->pageset = &boot_pageset;
        lruvec_init(&zone->lruvec);
        set_pageblock_order();
        setup_usemap(pgdat, zone, zone_start_pfn, size);
                usemap_size
                zone->pageblock_flags = alloc_bootmem_node_nopanic
        init_currently_empty_zone(zone, zone_start_pfn,size, MEMMAP_EARLY);
                zone_wait_table_init
                zone->zone_start_pfn = zone_start_pfn
                zone_init_free_lists
                        zone->free_area[order].nr_free = 0;
        memmap_init
                memmap_init_zone // all page reserved & MIGRATE_MOVABLE
                        SetPageReserved(page);
                        set_pageblock_migratetype(page, MIGRATE_MOVABLE); //

start_kernel
        setup_arch
                setup_machine_fdt
                        for_each_machine_desc
                        of_scan_flat_dt(early_init_dt_scan_memory, NULL);
                                early_init_dt_add_memory_arch
                                        arm_add_memory
                arm_memblock_init(&meminfo, mdesc);
                        memblock_add(mi->bank[i].start, mi->bank[i].size);
                                memblock_add_region(&memblock.memory, base, size, MAX_NUMNODES);
                        memblock_reserve(__pa(_stext), _end - _stext);
                        arm_mm_memblock_reserve();
                        arm_dt_memblock_reserve();	//4M
                        if (mdesc->reserve)
                                mdesc->reserve();
                sanity_check_meminfo
                        high_memory = __va(arm_lowmem_limit - 1) + 1;
                paging_init
                        early_alloc
                                memblock_alloc
                        prepare_page_table
                        map_lowmem
                                for_each_memblock(memory, reg)
                                        create_mapping
                                                alloc_init_pud(pgd, addr, next, phys, type, force_pages);
                        dma_contiguous_remap
                        devicemaps_init
                        bootmem_init
                                find_limits
                                arm_bootmem_init
                                        bitmap = memblock_alloc_base
                                                memblock_reserve
                                        init_bootmem_node
                                                init_bootmem_core
                                                        bdata->node_bootmem_map = phys_to_virt(PFN_PHYS(mapstart));//bitmap
                                                        memset(bdata->node_bootmem_map, 0xff, mapsize);
                                        free_bootmem
                                                mark_bootmem
                                                        mark_bootmem_node
                                                                __free
                                                                        test_and_clear_bit(idx, bdata->node_bootmem_map)
                                        reserve_bootmem
                                arm_bootmem_free
                                        zone_size[0] = max_low - min;
                                        free_area_init_node
                                                alloc_node_mem_map(pgdat);
                                                        pgdat->node_mem_map = map + (pgdat->node_start_pfn - start);
                                                free_area_init_core
                unflatten_device_tree();
                arm_dt_init_cpu_maps();

        setup_per_cpu_areas

        build_all_zonelists
                __build_all_zonelists
                        build_zonelists(pgdat);
                                build_zonelists_node
                                        zoneref_set_zone
                                                zoneref->zone_idx = zone_idx(zone);
                        build_zonelist_cache(pgdat);
                        for_each_possible_cpu(cpu) {
                                setup_pageset(&per_cpu(boot_pageset, cpu), 0);

        mm_init
                page_cgroup_init_flatmem();
                mem_init();
                        free_all_bootmem();
                                free_all_bootmem_core
                                        reset_node_lowmem_managed_pages(pgdat)
                                                //z->managed_pages = 0;
                                        __free_pages_bootmem
                                                page_zone(page)->managed_pages += 1 << order;
                                                __ClearPageReserved(p);
                                                __free_pages
                                                        free_hot_cold_page
                kmem_cache_init();
                percpu_init_late();
                pgtable_cache_init();
                vmalloc_init();

        setup_per_cpu_pageset
                setup_zone_pageset
                        setup_pageset(pcp, zone_batchsize(zone));

        rest_init
                kernel_init
                        free_initmem
                                poison_init_mem
                                free_initmem_default
                                        __free_page
                                                __free_pages_ok(page, order);
                                                        set_freepage_migratetype(page, migratetype);
                                                        free_one_page(page_zone(page), page, order, migratetype);
                                                                __free_one_page
                                                                        __mod_zone_freepage_state
                                                                                __mod_zone_page_state(zone, NR_FREE_PAGES,
                                                                                __mod_zone_page_state(zone, NR_FREE_CMA_PAGES
                                                                        list_add(&page->lru, &zone->free_area[order].free_list[migratetype]);

                        do_basic_setup();
                                cpuset_init_smp();
                                usermodehelper_init();
                                shmem_init();
                                driver_init();
                                init_irq_proc();
                                do_ctors();
                                usermodehelper_enable();
                                do_initcalls();
                                        do_initcall_level(level);
                                /*
                                        static char *initcall_level_names[] __initdata = {
                                                        "early",
                                                        "core",
                                                        "postcore",
                                                        "arch",
                                                        "subsys",
                                                        "fs",
                                                        "device",
                                                        "late",
                                                };
                                */
                                random_int_secret_init();
*** shrink
mpage_da_submit_io
        pagevec_release
                __pagevec_release
                        lru_add_drain
                        release_pages

lru_add_drain
        lru_add_drain_cpu
                pagevec_lru_move_fn(pvec, lru_deactivate_fn, NULL);
                        lru_deactivate_fn
                                ClearPageActive
                                ClearPageReferenced
                        release_pages
                                __ClearPageLRU
                                put_page_testzero
                                del_page_from_lru_list
                                list_add(&page->lru, &pages_to_free)
                                free_hot_cold_page_list
                                        //trace_mm_page_free_batched
                                        free_hot_cold_page

free_hot_cold_page
        free_pages_prepare
                //trace_mm_page_free
        get_pageblock_migratetype(page);
        list_add_tail(&page->lru, &pcp->lists[migratetype]);
        if (pcp->count >= pcp->high) {
                free_pcppages_bulk(zone, pcp->batch, pcp);
                        __free_one_page //buddy system
                        //trace_mm_page_pcpu_drain(page, 0, mt);
end_page_writeback
        TestClearPageReclaim
                rotate_reclaimable_page
                        pvec = &__get_cpu_var(lru_rotate_pvecs);
                        pagevec_add(pvec, page)

page_referenced
mark_page_accessed

alloc_pages_vma
        __alloc_pages_nodemask
                __alloc_pages_slowpath
                        __alloc_pages_direct_reclaim
                                __perform_reclaim
                                        try_to_free_pages


filemap_fault //ext4_file_vm_ops = {
        do_sync_mmap_readahead(vma, ra, file, offset);
                ra_submit(ra, mapping, file);
                        __do_page_cache_readahead
                                page_cache_alloc_readahead(mapping);
                                        __page_cache_alloc
                                                alloc_pages
                                read_pages(mapping, filp, &page_pool, ret);
                                        mapping->a_ops->readpages(filp, mapping, pages, nr_pages);
                                                ext4_readpages //ext4_da_aops
                                                        mpage_readpages(mapping, pages, nr_pages, ext4_get_block);
                                                                add_to_page_cache_lru
                                                                //trace_mm_filemap_add_to_page_cache(page);
                                                                mpage_bio_submit(READ, bio);
                                                                        bio->bi_end_io = mpage_end_io;
                                                                        submit_bio(rw, bio);
        page_cache_read
                add_to_page_cache_lru
                        add_to_page_cache
                                add_to_page_cache_locked
                                        //trace_mm_filemap_add_to_page_cache
                mapping->a_ops->readpage(file, page); //ext4_da_aops
                        ext4_readpage
                                //trace_ext4_readpage
                                mpage_readpage
                                        do_mpage_readpage
                                        mpage_bio_submit(READ, bio);
                                                submit_bio(rw, bio);


do_page_fault
        __do_page_fault
                handle_mm_fault
                        //count_vm_event(PGFAULT);
                        handle_pte_fault
                                do_linear_fault
                                        __do_fault
                                                alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);
                                                        __alloc_pages_nodemask
                                                        //count_vm_event(PGMAJFAULT);
                                                ret = vma->vm_ops->fault(vma, &vmf);
                                                        filemap_fault //ext4_file_vm_ops

                                                        //count_vm_event(PGMAJFAULT);
                                do_anonymous_page
                                        alloc_zeroed_user_highpage_movable(vma, address);
                                                __alloc_zeroed_user_highpage(__GFP_MOVABLE, vma, vaddr);
                                                        alloc_page_vma(GFP_HIGHUSER | movableflags,	vma, vaddr);
                                                                __alloc_pages_nodemask
                                                                        //trace_mm_page_alloc(page, order, gfp_mask, migratetype);
                                do_nonlinear_fault
                                do_swap_page
                                        //count_vm_event(PGMAJFAULT);

pageout

do_wp_page
        page_add_new_anon_rmap
                __page_set_anon_rmap
                        page->mapping = (struct address_space *) anon_vma;
                        page->index = linear_page_index(vma, address);

page_check_references
        page_referenced
                page_rmapping
                page_referenced_ksm
                page_referenced_anon
                        page_lock_anon_vma_read
                        vma_address
                        page_referenced_one
        pin	page_referenced_file
        TestClearPageReferenced

free_hot_cold_page
        get_pageblock_migratetype
                get_pageblock_flags_group
                        zone->pageblock_flags;
        set_freepage_migratetype
                page->index = migratetype;
                if (cold)
                        list_add_tail(&page->lru, &pcp->lists[migratetype]);
                else
                        list_add(&page->lru, &pcp->lists[migratetype]);
                if (pcp->count >= pcp->high) {
                        free_pcppages_bulk(zone, pcp->batch, pcp);
                                mt = get_freepage_migratetype(page);
                                __free_one_page(page, zone, 0, mt);
                                        list_add(&page->lru, &zone->free_area[order].free_list[migratetype]);
                                //trace_mm_page_pcpu_drain(page, 0, mt);
                        pcp->count -= pcp->batch;
                }


shrink_inactive_list(nr_to_scan, lruvec, sc, lru)
        while (unlikely(too_many_isolated(zone, file, sc))) {
                        congestion_wait(BLK_RW_ASYNC, HZ/10);
                                //trace_writeback_congestion_wait
        lru_add_drain
        nr_taken = isolate_lru_pages(nr_to_scan, lruvec, &page_list, &nr_scanned, sc, isolate_mode, lru);
                __isolate_lru_page
                        get_page_unless_zero
                        ClearPageLRU(page);
                //trace_mm_vmscan_lru_isolate(sc->order, nr_to_scan, scan,nr_taken, mode, is_file_lru(lru));
        shrink_page_list(&page_list, zone, sc, TTU_UNMAP, &nr_dirty, &nr_writeback, false);
                SetPageReclaim //o PageWriteback
                wait_on_page_writeback

                page_check_references
                        page_referenced
                                TestClearPageReferenced
                                SetPageReferenced//o referenced_ptes

                try_to_unmap //page_mapped

                SetPageReclaim//PageDirty
                pageout(page, mapping, sc)
                        is_page_cache_freeable
                        clear_page_dirty_for_io
                        SetPageReclaim
                        mapping->a_ops->writepage(page, &wbc); //ext4_da_aops
                                ext4_writepage
                                        //trace_ext4_writepage(page);
                        //trace_mm_vmscan_writepage(page, trace_reclaim_flags(page));
                __remove_mapping(mapping, page)
                        __delete_from_page_cache
                                //trace_mm_filemap_delete_from_page_cache
                __clear_page_locked
                list_add(&page->lru, &free_pages);
                free_hot_cold_page_list(&free_pages, 1);
                        //trace_mm_page_free_batched
                        free_hot_cold_page
                wait_iff_congested
                        //trace_writeback_wait_iff_congested
        //trace_mm_vmscan_lru_shrink_inactive

shrink_lruvec
        get_scan_count
                size = get_lru_size(lruvec, lru);
                scan = size >> sc->priority; // nr_inactive_file
        nr_reclaimed += shrink_list(lru, nr_to_scan,lruvec, sc)
                shrink_active_list
                shrink_inactive_list(nr_to_scan, lruvec, sc, lru)
        throttle_vm_writeout(sc->gfp_mask);
                global_dirty_limits
                        //trace_global_dirty_state(background, dirty);
                if (global_page_state(NR_WRITEBACK) <= dirty_thresh)
                break;
                congestion_wait(BLK_RW_ASYNC, HZ/10);
                        //trace_writeback_congestion_wait


alloc_pages
        __alloc_pages_nodemask
                get_page_from_freelist
                        zone_watermark_ok
                                __zone_watermark_ok// min_free_order_shift
                __alloc_pages_slowpath
                        wake_all_kswapd
                                wakeup_kswapd
                                        //trace_mm_vmscan_wakeup_kswapd

try_to_free_pages
        //trace_mm_vmscan_direct_reclaim_begin
        do_try_to_free_pages
                shrink_zones
                        shrink_zone
                wait_iff_congested
                        //trace_writeback_wait_iff_congested
        //trace_mm_vmscan_direct_reclaim_end


kswapd
        kswapd_try_to_sleep
                prepare_kswapd_sleep
                        pgdat_balanced
                                zone_balanced
                                        zone_watermark_ok_safe
                                                __zone_watermark_ok
                //trace_mm_vmscan_kswapd_sleep
        //trace_mm_vmscan_kswapd_wake
        balance_pgdat(pg_data_t * pgdat, int order, int * classzone_idx)
                age_active_anon(zone, &sc);
                zone_balanced(zone, order, 0, 0)
                        zone_watermark_ok_safe(zone, order, high_wmark_pages(zone) + 0
                                zone_page_state_snapshot
                                __zone_watermark_ok
                lru_pages += zone_reclaimable_pages(zone);
                        zone_page_state(zone, NR_ACTIVE_FILE) + zone_page_state(zone, NR_INACTIVE_FILE);
                nr_soft_reclaimed = mem_cgroup_soft_limit_reclaim
                balance_gap = min(low_wmark_pages(zone),zone->managed_pages /KSWAPD_ZONE_BALANCE_GAP_RATIO
                zone_balanced(zone, testorder,balance_gap, end_zone)
                        zone_watermark_ok_safe(zone, order, high_wmark_pages(zone) + balance_gap,
                shrink_zone(zone, &sc);
                        mem_cgroup_zone_lruvec
                        shrink_lruvec
                nr_slab = shrink_slab(&shrink, sc.nr_scanned, lru_pages);
                        //trace_mm_shrink_slab_start
                        do_shrinker_shrink
                                sc->nr_to_scan = nr_to_scan;
                                return (*shrinker->shrink)(shrinker, sc);
                                        lowmem_shrink
                        //trace_mm_shrink_slab_end
                pgdat_balanced(pgdat, order, *classzone_idx)
                        zone_balanced(zone, order, 0, i)
                } while (--sc.priority >= 0);
*** dts
setup_arch
        setup_machine_fdt
                for_each_machine_desc
                of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
                of_scan_flat_dt(early_init_dt_scan_memory, NULL);
                early_init_dt_add_memory_arch
        unflatten_device_tree
        mdesc->init_early()
        arm_dt_init_cpu_maps

IRQCHIP_DECLARE(cortex_a9_gic, "arm,cortex-a9-gic", gic_of_init);
init_IRQ
        irqchip_init
                of_irq_init(__irqchip_begin)
                        gic_of_init
                                of_iomap
                                of_property_read_u32

customize_machine
        of_platform_populate
                of_platform_bus_create

customize_machine
        .init_machine	= tegra_dt_init,
                of_platform_populate
*** pinctrl
devm_pinctrl_get_select

devm_pinctrl_get
        pinctrl_get
                create_pinctrl
pinctrl_lookup_state
pinctrl_select_state

pinctrl_register_mappings

pinctrl_register
        pinctrl_register_pins

of_gpiochip_add_pin_range
        gpiochip_add_pin_range
                pinctrl_find_and_add_gpio_range
                        pinctrl_add_gpio_range

pinctrl_gpio_range
pinctrl_add_gpio_range
pin_config_set


filemap_fdatawait_range(struct address_space * mapping, loff_t start_byte, loff_t end_byte)(struct address_space * mapping, loff_t start_byte, loff_t end_byte)

ext4_da_write_begin
writeback_dirty_page
generic_write_end
__ext4_journal_get_write_access

journal_start
journal_stop


ext2_super_block
EXT2_VALID_FS

ext2_get_block
ext2_get_blocks
*** blk cgroup
CONFIG_BLK_DEV_INTEGRITY
#define BLK_MAX_REQUEST_COUNT 16//4

CONFIG_BLK_CGROUP=y
CONFIG_DEBUG_BLK_CGROUP=y
CONFIG_CFQ_GROUP_IOSCHED=y
CONFIG_BLK_DEV_THROTTLING=y
CONFIG_BLK_DEV_IO_TRACE=y

CONFIG_PM_RUNTIME
CONFIG_BLK_CGROUP
CONFIG_CFQ_GROUP_IOSCHED
CONFIG_BLK_DEV_THROTTLING
CONFIG_BLK_DEV_IO_TRACE

cfq_group_served
        cfq_log_cfqq(cfqq->cfqd, cfqq,"sl_used=%u disp=%u charge=%u iops=%u sect=%lu",
cfq_set_prio_slice
        cfq_log_cfqq(cfqd, cfqq, "set_slice=%lu", cfqq->slice_end - jiffies);
cfq_add_cfqq_rr
        cfq_log_cfqq(cfqd, cfqq, "add_to_rr");
cfq_del_cfqq_rr
        cfq_log_cfqq(cfqd, cfqq, "del_from_rr");
cfq_activate_request
        cfq_log_cfqq(cfqd, RQ_CFQQ(rq), "activate rq, drv=%d",
                                                cfqd->rq_in_driver);
cfq_deactivate_request
        cfq_log_cfqq(cfqd, RQ_CFQQ(rq), "deactivate rq, drv=%d",
                                                cfqd->rq_in_driver);
__cfq_set_active_queue
        cfq_log_cfqq(cfqd, cfqq, "set_active wl_class:%d wl_type:%d",
                                cfqd->serving_wl_class, cfqd->serving_wl_type);
__cfq_slice_expired
        cfq_log_cfqq(cfqd, cfqq, "slice expired t=%d", timed_out);
        cfq_log_cfqq(cfqd, cfqq, "resid=%ld", cfqq->slice_resid);
cfq_should_idle
        cfq_log_cfqq(cfqd, cfqq, "Not idling. st->count:%d", st->count);
cfq_arm_slice_timer
        cfq_log_cfqq(cfqd, cfqq, "Not idling. think_time:%lu",
                             cic->ttime.ttime_mean);
        cfq_log_cfqq(cfqd, cfqq, "arm_idle: %lu group_idle: %d", sl,
                        group_idle ? 1 : 0);
cfq_dispatch_insert
        cfq_log_cfqq(cfqd, cfqq, "dispatch_insert");
cfq_check_fifo
        cfq_log_cfqq(cfqq->cfqd, cfqq, "fifo=%p", rq);
cfq_dispatch_requests
        cfq_log_cfqq(cfqd, cfqq, "dispatched a request");
cfq_put_queue
        cfq_log_cfqq(cfqd, cfqq, "put_queue");
check_blkcg_changed
        cfq_log_cfqq(cfqd, sync_cfqq, "changed cgroup");
cfq_find_alloc_queue
        cfq_log_cfqq(cfqd, cfqq, "alloced");
cfq_update_idle_window
        cfq_log_cfqq(cfqd, cfqq, "idle=%d", enable_idle);
cfq_preempt_queue
        cfq_log_cfqq(cfqd, cfqq, "preempt");
cfq_insert_request
        cfq_log_cfqq(cfqd, cfqq, "insert_request");
cfq_completed_request
        cfq_log_cfqq(cfqd, cfqq, "complete rqnoidle %d",
                     !!(rq->cmd_flags & REQ_NOIDLE));
cfq_completed_request
        cfq_log_cfqq(cfqd, cfqq, "complete rqnoidle %d",
                     !!(rq->cmd_flags & REQ_NOIDLE));
        cfq_log_cfqq(cfqd, cfqq, "will busy wait");
cfq_merge_cfqqs
        cfq_log_cfqq(cfqd, cfqq, "merging with queue %p", cfqq->new_cfqq);
cfq_set_request
        cfq_log_cfqq(cfqd, cfqq, "breaking apart cfqq");
choose_wl_class_and_type
        cfq_log(cfqd, "workload slice:%d", slice);

blk_register_tracepoints
        register_trace_block_getrq(blk_add_trace_getrq, NULL);

static struct tracer blk_tracer __read_mostly = {
        .name		= "blk",
        .init		= blk_tracer_init,
        .reset		= blk_tracer_reset,
        .start		= blk_tracer_start,
        .stop		= blk_tracer_stop,
        .print_header	= blk_tracer_print_header,
        .print_line	= blk_tracer_print_line,
        .flags		= &blk_tracer_flags,
        .set_flag	= blk_tracer_set_flag,
};
blk_tracer_print_line
        print_one_line
                blk_log_action

cfq_log_cfqq
        blk_add_trace_msg
                __trace_note_message
                        trace_note

} what2act[] = {
        [__BLK_TA_QUEUE]	= {{  "Q", "queue" },      blk_log_generic },
        [__BLK_TA_BACKMERGE]	= {{  "M", "backmerge" },  blk_log_generic },
        [__BLK_TA_FRONTMERGE]	= {{  "F", "frontmerge" }, blk_log_generic },
        [__BLK_TA_GETRQ]	= {{  "G", "getrq" },      blk_log_generic },
        [__BLK_TA_SLEEPRQ]	= {{  "S", "sleeprq" },    blk_log_generic },
        [__BLK_TA_REQUEUE]	= {{  "R", "requeue" },    blk_log_with_error },
        [__BLK_TA_ISSUE]	= {{  "D", "issue" },      blk_log_generic },
        [__BLK_TA_COMPLETE]	= {{  "C", "complete" },   blk_log_with_error },
        [__BLK_TA_PLUG]		= {{  "P", "plug" },       blk_log_plug },
        [__BLK_TA_UNPLUG_IO]	= {{  "U", "unplug_io" },  blk_log_unplug },
        [__BLK_TA_UNPLUG_TIMER]	= {{ "UT", "unplug_timer" }, blk_log_unplug },
        [__BLK_TA_INSERT]	= {{  "I", "insert" },     blk_log_generic },
        [__BLK_TA_SPLIT]	= {{  "X", "split" },      blk_log_split },
        [__BLK_TA_BOUNCE]	= {{  "B", "bounce" },     blk_log_generic },
        [__BLK_TA_REMAP]	= {{  "A", "remap" },      blk_log_remap },
};

struct cfq_group {
        /* must be the first member */
        struct blkg_policy_data pd;  // embed in cfg_group
        //blkcg_gq  ref  blkg_policy_data
        //blkcg_gq  link  request_queue and blkcg
struct blkcg {
        struct cgroup_subsys_state	css;// kernel cgroup

struct bio {

#ifdef CONFIG_BLK_CGROUP
        struct io_context	*bi_ioc; // ionice
        struct cgroup_subsys_state *bi_css //cgroup

struct cfq_io_cq {
        struct io_cq		icq;		/* must be the first member */
        struct cfq_queue	*cfqq[2];
struct io_cq {
        struct request_queue	*q;
        struct io_context	*ioc;
struct request {
        union {
                struct {
                        struct io_cq		*icq;
                        void			*priv[2];
                } elv;

struct throtl_data
{
        /* service tree for active throtl groups */
        struct throtl_rb_root tg_service_tree;
        /* Total Number of queued bios on READ and WRITE lists */
        unsigned int nr_queued[2];

struct throtl_grp {
        /* must be the first member */
        struct blkg_policy_data pd;
        /* active throtl group service_tree member */
        struct rb_node rb_node;

generic_make_request_checks
        blk_throtl_bio
                throtl_lookup_tg
                        blkg_lookup
                        blkg_to_tg
                throtl_lookup_create_tg
                tg_may_dispatch
                throtl_add_bio_tg
                        throtl_enqueue_tg
                                __throtl_enqueue_tg
                                        tg_service_tree_add
                throtl_schedule_next_dispatch
                        throtl_schedule_delayed_work //blk_throtl_work

blk_throtl_work
        throtl_dispatch
                throtl_select_dispatch
                        blk_start_plug
                                generic_make_request
                        blk_finish_plug
*** blk cfq
get_request
        __get_request
                //trace_block_getrq
                        blk_add_trace_getrq
                                __blk_add_trace

get_request
        blk_get_rl
                bio_blkcg
                        task_blkcg(current);
                                 container_of(task_subsys_state(tsk, blkio_subsys_id),
                                        task_subsys_state_check
                blkg_lookup_create
                        __blkg_lookup
                        blkcg_parent
                                 //blkcg->css.cgroup->parent;
                        blkg_create
                                blkg_alloc // create blkcg_gq
                                // pd_init_fn
                                cfq_pd_init // create cfq_group
                //return &blkg->rl;
        __get_request
                queue_congestion_on_threshold// q->nr_congestion_on = q->nr_requests - (q->nr_requests / 8) + 1;
                blk_rl_full                              // nr_requests =128 , then  q->nr_congestion_on=113
                ioc_set_batching
                blk_set_rl_full
                blk_rq_should_init_elevator
                ioc_lookup_icq//
                mempool_alloc
                blk_rq_init
                blk_rq_set_rl
                        ioc_create_icq//o
                                kmem_cache_alloc_node(et->icq_cache
                                radix_tree_insert(&ioc->icq_tree
                                //et->ops.elevator_init_icq_fn
                                cfq_init_icq
                                        //cic->ttime.last_end_request = jiffies;
                //rq->elv.icq = icq;
                elv_set_request
                        //e->type->ops.elevator_set_req_fn
                        cfq_set_request
                                check_ioprio_changed
                                        //cfq_mark_cfqq_prio_changed
                                check_blkcg_changed
                                cic_to_cfqq(cic, is_sync);
                                        return cic->cfqq[is_sync]; // sync �� async�ǲ�ͬ����
                                cfq_get_queue//o
                                        cfq_async_queue_prio//async
                                                return &cfqd->async_cfqq[0][ioprio]; //IOPRIO_CLASS_RT
                                                return &cfqd->async_cfqq[1][ioprio]; //IOPRIO_CLASS_BE
                                                return &cfqd->async_idle_cfqq; //IOPRIO_CLASS_IDLE
                                        cfq_find_alloc_queue // syncÿ�����һ�����У� cgroup����async
                                                bio_blkcg
                                                cfq_lookup_create_cfqg
                                                kmem_cache_alloc_node(cfq_pool,
                                                cfq_init_cfqq(cfqd, cfqq, current->pid, is_sync);
                                                cfq_init_prio_data(cfqq, cic);
                                                cfq_link_cfqq_cfqg(cfqq, cfqg);
                                                //cfq_log_cfqq(cfqd, cfqq, "alloced");
                                cic_set_cfqq//o
                                rq->elv.priv[0] = cfqq;
                                rq->elv.priv[1] = cfqq->cfqg;
                //trace_block_getrq(q, bio, rw_flags & 1);
        prepare_to_wait_exclusive
        //trace_block_sleeprq
        io_schedule
        ioc_set_batching


//q->elevator->type->ops.elevator_add_req_fn(q, rq);
cfq_insert_request

add_acct_request
        drive_stat_acct//account
                part_round_stats
                part_inc_in_flight
        __elv_add_request
                //trace_block_rq_insert
                elv_rqhash_add //ELEVATOR_INSERT_SORT
                //q->elevator->type->ops.elevator_add_req_fn(q, rq);
                cfq_insert_request
                        cfq_init_prio_data
                        rq_set_fifo_time
                        cfq_log_cfqq
                        list_add_tail(&rq->queuelist
                        cfq_add_rq_rb(rq);
                                elv_rb_add(&cfqq->sort_list, rq);
                                cfq_add_cfqq_rr
                                        cfq_resort_rr_list
                                                cfq_service_tree_add // add cfg_queue to cfg_group 's service tree
                                                    //rb_key = cfq_slice_offset(cfqd, cfqq) + jiffies
                                                    //higer prio cfqueue get small rb_key in cfq_group's service tree
                                                        //&cfqg->service_trees[class][type]; st_for(cfqq->cfqg, cfqq_class(cfqq), cfqq_type(cfqq));
                                                        cfqq->service_tree = st;
                                                        cfq_group_notify_queue_add
                                                                //st = &cfqd->grp_service_tree
                                                                cfq_group_service_tree_add // add cfg_group to cfgd's grp_service_tree
                                                                        cfq_update_group_weight(cfqg);
                                                                        __cfq_group_service_tree_add
                                                                                cfqg_key //cfqg->vdisktime - st->min_vdisktime;
                                                                        //vfr = vfr * pos->leaf_weight / pos->children_weight;
                                                cfq_prio_tree_add  // add cfg_queue to cfgd 's prio tree
                                                        //cfqq->p_root = &cfqd->prio_trees[cfqq->org_ioprio];
                                cfq_choose_req // choose the request that is closest to the head right now
                                cfq_prio_tree_add //o  cfqq->p_root = &cfqd->prio_trees[cfqq->org_ioprio];
                        cfqg_stats_update_io_add(RQ_CFQG(rq), cfqd->serving_group,
                                                 rq->cmd_flags);
                        cfq_rq_enqueued(cfqd, cfqq, rq);
                                        cfq_update_io_thinktime(cfqd, cfqq, cic);
                                        cfq_update_io_seektime(cfqd, cfqq, rq);
                                        cfq_update_idle_window(cfqd, cfqq, cic);
                                                // cfqd->cfq_slice_idle ==0  then cfq_cfqq_idle_window =0
                                        cfq_should_preempt
                                                cfq_preempt_queue

// ioc_batching  when request_list is congested, and bio had io_context ,
// then can use batching to get more  q->nr_batching  request

cfq_slice_expired
        __cfq_slice_expired
                cfq_group_served
                        // vdisktime determine cgroup position in grp_service_tree
                        vfr = cfqg->vfraction;
                        cfq_group_service_tree_del(st, cfqg);
                        cfqg->vdisktime += cfqg_scale_charge(charge, vfr);
                        cfq_group_service_tree_add(st, cfqg);
                cfq_resort_rr_list


    __rq_for_each_bio(
bio_for_each_segment
blk_queue_bio(struct request_queue * q, struct bio * bio)

blk_peek_request
        __elv_next_request
                q->prep_rq_fn//null
                //q->elevator->type->ops.elevator_dispatch_fn ��������û��reqʱ
                cfq_dispatch_requests
                        cfq_select_queue
                                cfq_close_cooperator
                                        cfqq_close
                                                root = &cfqd->prio_trees[cur_cfqq->org_ioprio];
                                                __cfqq = cfq_prio_tree_lookup(cfqd, root, sector, &parent, NULL);
                                cfq_slice_expired
                                        __cfq_slice_expired

                                cfq_choose_cfqg
                                        cfq_get_next_cfqg(cfqd);
                                                cfq_rb_first_group(cfqd->grp_service_tree)
                                        choose_wl_class_and_type
                                        //cfq_log(cfqd, "workload slice:%d", slice);
                                                cfq_choose_wl_type
                                                cfq_group_slice //cfqd->cfq_target_latency * cfqg->vfraction >> CFQ_SERVICE_SHIFT;
                                                                //async workload slice is scaled down according to the sync/async slice ratio.
                                cfq_set_active_queue
                                        __cfq_set_active_queue //cfq_mark_cfqq_slice_new(cfqq);
                                        //cfq_log_cfqq(cfqd, cfqq, "set_active wl_class:%d wl_type:%d",

                        cfq_dispatch_request
                                cfq_dispatch_insert
                                        cfq_find_next_rq
                                                cfq_choose_req
                                        cfq_remove_request
                                        elv_dispatch_sort
                                                //list_add(&rq->queuelist, entry);
                        cfq_slice_expired //expire an async queue immediately if it has used up its slice. idle queue always expire after 1 dispatch round.
                                __cfq_slice_expired

cfq_schedule_dispatch

__blk_end_request

blk_finish_request
        blk_delete_timer
        blk_account_io_done
        __blk_put_request
                elv_completed_request
                        //e->type->ops.elevator_completed_req_fn
                        cfq_completed_request
                                cfqg_stats_update_completion
                                RQ_CIC(rq)->ttime.last_end_request = now;
                                cfq_set_prio_slice //cfq_cfqq_slice_new
                                        //cfq_log_cfqq(cfqd, cfqq, "set_slice=%lu", cfqq->slice_end - jiffies);
                                        cfq_scaled_cfqq_slice // when low_latency ==0, slice determined by prio
                                                cfq_prio_to_slice
                                                cfq_group_slice //cfqd->cfq_target_latency * cfqg->vfraction >> CFQ_SERVICE_SHIFT
                                                //slice = max(slice * group_slice / expect_latency,  low_slice);
                                        cfqq->slice_start = jiffies;
                                        cfqq->slice_end = jiffies + slice;
                                        cfqq->allocated_slice = slice;
                                cfq_should_wait_busy //extend_sl = cfqd->cfq_group_idle;
                                cfq_arm_slice_timer //	cfq_idle_slice_timer
                                        cfq_idle_slice_timer
                                                cfq_slice_expired //cfq_slice_used
                                                        __cfq_slice_expired
                                cfq_schedule_dispatch
                blk_rq_rl
                blk_free_request(rl, req);
                freed_request(rl, flags);
                blk_put_rl(rl);
*** blk cgroup
cfq_blkcg_files
        cfq_set_weight
                __cfq_set_weight
                        //blkcg->cfq_weight

cgroup_subsys

struct cgroup_subsys blkio_subsys = {
        .name = "blkio",
        .css_alloc = blkcg_css_alloc,
        .css_offline = blkcg_css_offline,
        .css_free = blkcg_css_free,
        .can_attach = blkcg_can_attach,
        .subsys_id = blkio_subsys_id,
        .base_cftypes = blkcg_files,
        .module = THIS_MODULE,

        /*
         * blkio subsystem is utterly broken in terms of hierarchy support.
         * It treats all cgroups equally regardless of where they're
         * located in the hierarchy - all cgroups are treated as if they're
         * right below the root.  Fix it and remove the following.
         */
        .broken_hierarchy = true,
};

struct blkcg blkcg_root = { .cfq_weight = 2 * CFQ_WEIGHT_DEFAULT,
                            .cfq_leaf_weight = 2 * CFQ_WEIGHT_DEFAULT, };


static struct blkcg_policy blkcg_policy_throtl = {
        .pd_size		= sizeof(struct throtl_grp),
        .cftypes		= throtl_files,

        .pd_init_fn		= throtl_pd_init,
        .pd_exit_fn		= throtl_pd_exit,
        .pd_reset_stats_fn	= throtl_pd_reset_stats,
};
static struct blkcg_policy blkcg_policy_cfq = {
        .pd_size		= sizeof(struct cfq_group),
        .cftypes		= cfq_blkcg_files,

        .pd_init_fn		= cfq_pd_init,
        .pd_offline_fn		= cfq_pd_offline,
        .pd_reset_stats_fn	= cfq_pd_reset_stats,
};


cfq_init
        cfq_slice_idle
        blkcg_policy_register // blkcg_policy_cfq
                cgroup_add_cftypes
        elv_register

elevator_init
        //.elevator_init_fn =		cfq_init_queue,
        cfq_init_queue
                //	cfqd->grp_service_tree = CFQ_RB_ROOT;
                blkcg_activate_policy //blkcg_policy_cfq
                        blkg_alloc
                        blk_queue_bypass_start
                        blkg_create
                        // pd_init_fn
                        cfq_pd_init
                //cfqd->root_group = blkg_to_cfqg(q->root_blkg);




blk_alloc_queue_node
        blkcg_init_queue
                blk_throtl_init
                        blkcg_activate_policy // blkcg_policy_throtl  blk_throtl_work

set_task_ioprio

cfq_io_context

/* max queue in one round of service */
static const int cfq_quantum = 8;
static const int cfq_fifo_expire[2] = { HZ / 4, HZ / 8 };
/* maximum backwards seek, in KiB */
static const int cfq_back_max = 16 * 1024;
/* penalty of a backwards seek */
static const int cfq_back_penalty = 2;
static const int cfq_slice_sync = HZ / 10;
static int cfq_slice_async = HZ / 25;
static const int cfq_slice_async_rq = 2;
static int cfq_slice_idle = HZ / 125;
static int cfq_group_idle = HZ / 125;
static const int cfq_target_latency = HZ * 3/10; /* 300 ms */
static const int cfq_hist_divisor = 4;


blk_queue_init_tags
blk_queue_start_tag
blk_queue_end_tag

blk_init_queue

touch_buffer //trace_block_touch_buffer
mark_buffer_dirty //trace_block_dirty_buffer

blk_account_io_merge //attempt_merge
drive_stat_acct //add_acct_request bio_attempt_back_merge blk_queue_bio
blk_account_io_done //blk_finish_request




blk_queue_make_request
        //q->nr_batching = BLK_BATCH_REQ;
blk_rq_map_sg

elv_merge(struct request_queue * q, struct request * * req, struct bio * bio)

elv_add_request
        blk_do_rq

CONFIG_BLK_DEV_IO_TRACE
*** submit_bio
blk_flush_plug_list //
        queue_unplugged
                __blk_run_queue
                 //cfqd->unplug_work, cfq_kick_queue);
                        cfq_kick_queue
                                __blk_run_queue
                                //q->request_fn
                                        DDL_DiskRequestArrivedCB

submit_bio
        generic_make_request
                generic_make_request_checks
                        blk_partition_remap
                                //trace_block_bio_remap
                        blk_throtl_bio

                //trace_block_bio_queue
                //q->make_request_fn
                blk_queue_bio
                        attempt_plug_merge
                                bio_attempt_back_merge
                                        ll_back_merge_fn
                                                queue_max_sectors
                                                ll_new_hw_segment
                                        //trace_block_bio_backmerge
                                bio_attempt_front_merge
                                        ll_front_merge_fn
                                        //trace_block_bio_frontmerge(q, bio)

                        elv_merge // �ж�merge���ͣ� �Լ��ҵ���Ӧ��req
                                blk_try_merge // q->last_merge
                                elv_rqhash_find
                                elv_rq_merge_ok
                                        elv_iosched_allow_merge
                                                //e->type->ops.elevator_allow_merge_fn
                                                cfq_allow_merge
                                //e->type->ops.elevator_merge_fn
                                cfq_merge
                        bio_attempt_back_merge  // ��bio���뵽req�У��ϲ����ȼ�IOPRIO_CLASS_BE
                        elv_bio_merged
                                //e->type->ops.elevator_bio_merged_fn(
                                cfq_bio_merged
                        attempt_back_merge
                                elv_latter_request
                                        // e->type->ops.elevator_latter_req_fn
                                        elv_rb_latter_request
                                attempt_merge
                                        ll_merge_requests_fn
                                        blk_account_io_merge //account
                                        elv_merge_requests
                                                //e->type->ops.elevator_merge_req_fn(q, rq, next);
                                                cfq_merged_requests
                                        __blk_put_request
                                                elv_completed_request
                                                        //e->type->ops.elevator_completed_req_fn
                                                        cfq_completed_request
                        elv_merged_request// ǰ��ʧ�ܺ�
                                //e->type->ops.elevator_merged_fn
                                cfq_merged_request
                        get_request(q, rw_flags, bio, GFP_NOIO)
                        init_request_from_bio
                        list_add_tail(&req->queuelist, &plug->list);//��ǰ��plug
                        //trace_block_plug(q);
                        add_acct_request // ��ǰû��plugʱ
                                drive_stat_acct//account
                                        part_round_stats
                                        part_inc_in_flight
                                __elv_add_request
                                        //trace_block_rq_insert
                                        elv_rqhash_add //ELEVATOR_INSERT_SORT
                                        //q->elevator->type->ops.elevator_add_req_fn(q, rq);
                                        cfq_insert_request
                        __blk_run_queue

blk_peek_request
        __elv_next_request
                q->prep_rq_fn//null
                //q->elevator->type->ops.elevator_dispatch_fn ��������û��reqʱ
                cfq_dispatch_requests
        elv_activate_rq
                 //CONFIG_CFQ_GROUP_IOSCHED
                        cfq_activate_request//CONFIG_BLK_DEV_THROTTLING
                                cfq_log_cfqq //CONFIG_BLK_DEV_IO_TRACE ��Ҫ��blk tracer


=> ftrace_ops_no_ops\n\
 => ftrace_graph_call\n\
 => filemap_write_and_wait_range\n\
 => ext4_sync_file\n\
 => generic_write_sync\n\
 => generic_file_aio_write\n\
 => ext4_file_write\n\
 => do_sync_write\n\
 => vfs_write\n\
 => SyS_write\n\
 => ret_fast_syscall\n\
 => elv_rqhash_find\n\
 => elv_merge\n\
 => blk_queue_bio\n\
 => generic_make_request\n\
 => submit_bio\n\
 => ext4_io_submit\n\
 => mpage_da_submit_io\n\  //ext4_bio_write_page io_submit_add_bh   io_submit_init
                                                        //ext4_end_io_work   ext4_end_bio
 => mpage_da_map_and_submit\n\
 => ext4_da_writepages\n\  //tag_pages_for_writeback blk_start_plug
 => do_writepages\n\
 => __filemap_fdatawrite_range\n\
 => filemap_write_and_wait_range\n\
 => ext4_sync_file\n\
 => vfs_fsync\n\
 => do_fsync\n\

bio_endio(struct bio * bio, int error)
        ext4_end_bio(struct bio * bio, int error)
                ext4_free_io_end
                        put_io_page
                                end_page_writeback
                                        test_clear_page_writeback
                                        wake_up_page(page, PG_writeback);
                                put_page
LDL_ThreadLoop
LDL_DeviceRequestInsertPage
        LDL_ThreadInsertOneRequest
                wake_up(&LDL_ThreadPool.thread[unitNo].go);
*** VFS
__mark_inode_dirty
        bdi_wakeup_thread_delayed //5S
                bdi_forker_thread
                        wb_do_writeback
                                bdi_writeback_thread

wb_update_bandwidth
        __bdi_update_bandwidth
                bdi_update_dirty_ratelimit
                        //trace_bdi_dirty_ratelimit


bdi_start_background_writeback
        //trace_writeback_wake_background
        bdi_wakeup_flusher

default_bdi_init
        alloc_workqueue("writeback"
        bdi_init
                bdi_wb_init
                        INIT_DELAYED_WORK(&wb->dwork, bdi_writeback_workfn);
        bdi_register
                device_create_vargs

__blk_run_queue\n\
 => queue_unplugged\n\
 => blk_flush_plug_list\n\
 => blk_queue_bio\n\
 => generic_make_request\n\
 => submit_bio\n\
 => ext4_io_submit\n\
 => ext4_bio_write_page\n\
 => mpage_da_submit_io\n\
 => mpage_da_map_and_submit\n\
 => write_cache_pages_da\n\
 => ext4_da_writepages\n\
 => do_writepages\n\
 => __writeback_single_inode\n\
 => writeback_sb_inodes\n\
 => __writeback_inodes_wb\n\
 => wb_writeback\n\
 => wb_do_writeback\n\
 => bdi_writeback_workfn\n\
 => process_one_work\n\
 => worker_thread\n\
 => kthread\n\
ext4_da_writepages  //trace_ext4_da_writepages
        tag_pages_for_writeback //PAGECACHE_TAG_TOWRITE
        blk_start_plug
        ext4_da_writepages_trans_blocks
        ext4_journal_start
        write_cache_pages_da //trace_ext4_da_write_pages
                pagevec_lookup_tag
                lock_page
                mpage_da_map_and_submit
                        ext4_journal_current_handle
                        ext4_map_blocks
                                ext4_es_lookup_extent
                                //trace_ext4_es_lookup_extent_enter(inode, lblk);
                                //trace_ext4_es_lookup_extent_exit(inode, es, found);
                                ext4_ext_map_blocks(handle, inode, map, flags & EXT4_GET_BLOCKS_KEEP_SIZE);
                                ext4_mark_inode_dirty
                                        //trace_ext4_mark_inode_dirty(inode, _RET_IP_);
                        mpage_da_submit_io
                                pagevec_lookup
                                clear_page_dirty_for_io
                                ext4_bio_write_page
                                        set_page_writeback
                                        io_submit_add_bh
                                                io_submit_init
                                                        bio_get_nr_vecs
                                                                queue_max_segments
                                                        ext4_init_io_end //ext4_end_io_work
                                                //bio->bi_private = io->io_end = io_end;
                                                //bio->bi_end_io = ext4_end_bio;
                                                bio_add_page
                                                        __bio_add_page
                                                //ext4_io_submit
                                        unlock_page
                                ext4_io_submit
                                        submit_bio
        ext4_journal_stop
        blk_finish_plug

bdi_writeback_workfn //
        wb_do_writeback //trace_writeback_pages_written
                get_next_work_item
                //trace_writeback_exec
                wb_writeback
                        list_empty(&wb->bdi->work_list)
                        over_bground_thresh
                                global_dirty_limits //trace_global_dirty_state
                        //trace_writeback_start(wb->bdi, work);
                        __writeback_inodes_wb//trace_writeback_written
                                writeback_sb_inodes
                                        writeback_chunk_size  //MIN_WRITEBACK_PAGES ����4M ���ٶȵ�һ��
                                        inode->i_state |= I_SYNC;
                                        writeback_single_inode
                                                __writeback_single_inode
                                                //trace_writeback_single_inode_start
                                                do_writepages
                                                        ext4_da_writepages
                                                filemap_fdatawait //wbc->sync_mode == WB_SYNC_ALL
                                                mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)
                                                inode->i_state &= ~I_DIRTY_PAGES;/* Clear I_DIRTY_PAGES if we've written out all dirty pages */
                                                //trace_writeback_single_inode
                                                inode_sync_complete
                                        requeue_inode
                                        inode_sync_complete
                                        time_is_before_jiffies // ����100ms�˳�
                        //trace_writeback_written
                        wb_update_bandwidth
                                __bdi_update_bandwidth
                                        bdi_update_write_bandwidth
                        inode_wait_for_writeback //trace_writeback_wait
                complete
                wb_check_old_data_flush
                wb_check_background_flush
        //trace_writeback_pages_written
        mod_delayed_work
        bdi_wakeup_thread_delayed


ext4_file_write
        generic_file_aio_write
                __generic_file_aio_write
                        generic_file_buffered_write
                                generic_perform_write
                                        ext4_write_begin
                                        iov_iter_copy_from_user_atomic//memcpy
                                        balance_dirty_pages_ratelimited
                                        ext4_write_end

mark_buffer_dirty
        __set_page_dirty_buffers
                __set_page_dirty_nobuffers
                        account_page_dirtied
                        __inc_zone_page_state(page, NR_FILE_DIRTY);
                        __inc_zone_page_state(page, NR_DIRTIED);
                        __inc_bdi_stat(mapping->backing_dev_info, BDI_RECLAIMABLE);
                        __inc_bdi_stat(mapping->backing_dev_info, BDI_DIRTIED);
                        current->nr_dirtied++;
                        this_cpu_inc(bdp_ratelimits);

end_page_writeback
        TestClearPageReclaim
                rotate_reclaimable_page
                        pvec = &__get_cpu_var(lru_rotate_pvecs);
                        pagevec_add(pvec, page)
        test_clear_page_writeback
                __bdi_writeout_inc
                        __inc_bdi_stat(bdi, BDI_WRITTEN);
                        __fprop_inc_percpu_max(&writeout_completions, &bdi->completions,
                               bdi->max_prop_frac);


global_dirty_state: dirty=24396 writeback=10230 unstable=0 bg_thresh=3917 thresh=31343 limit=35562 dirtied=106877 written=72240\n\
bdi_dirty_ratelimit: bdi 93:32: write_bw=12848 awrite_bw=18572 dirty_rate=10512 dirty_ratelimit=39616 task_ratelimit=9160 balanced_dirty_ratelimit=16176\n\

trace_printk("%s--%d nr_reclaimable %d nr_dirty %d ",__FILE__, __LINE__, nr_reclaimable,nr_dirty);
balance_dirty_pages_ratelimited
        ratelimit = current->nr_dirtied_pause;
        if (bdi->dirty_exceeded)
                ratelimit = min(ratelimit, 32 >> (PAGE_SHIFT - 10));
        p =  &__get_cpu_var(bdp_ratelimits); // account_page_dirtied ��ext4_write_begin��ʱ�����
        // bdp_ratelimits OR nr_dirtied > nr_dirtied_pause then
        balance_dirty_pages
                nr_dirty = nr_reclaimable + global_page_state(NR_WRITEBACK);
                global_dirty_limits(&background_thresh, &dirty_thresh);
                freerun = dirty_freerun_ceiling//(dirty_thresh + background_thresh) / 2;
                current->nr_dirtied_pause = dirty_poll_interval(nr_dirty, dirty_thresh);
                //nr_dirtied_pause =  (ilog2(dirty_thresh - nr_dirty)
                bdi_start_background_writeback
                bdi_thresh = bdi_dirty_limit(bdi, dirty_thresh);
                //bounded by the bdi->min_ratio and/or bdi->max_ratio parameters,
                // default max=100 min=0, if only one bdi, bdi_thresh will equal dirty_thresh
                bdi_dirty = bdi_stat(bdi, BDI_RECLAIMABLE)+bdi_stat(bdi, BDI_WRITEBACK);
                dirty_exceeded = (bdi_dirty > bdi_thresh) && (nr_dirty > dirty_thresh);
                        bdi->dirty_exceeded = 1;
                bdi_update_bandwidth(bdi, dirty_thresh, background_thresh,nr_dirty, bdi_thresh, bdi_dirty,start_time);
                        if (time_is_after_eq_jiffies(bdi->bw_time_stamp + BANDWIDTH_INTERVAL)
                        // wb_update_bandwidth in flusher thread will update write_banwidth, but did not update dirty_rate
                        //wb_writeback
                        //	wb_update_bandwidth
                        //__		bdi_update_bandwidth
                        //				bdi_update_write_bandwidth
                        __bdi_update_bandwidth
                                global_update_bandwidth
                                bdi_update_dirty_ratelimit
                                        dirty_rate = (dirtied - bdi->dirtied_stamp) * HZ / elapsed;
                                        // (now dirtied pages - last snapshot)  / now - last snapshot
                                        bdi_position_ratio
                                        if (unlikely(balanced_dirty_ratelimit > write_bw))
                                                balanced_dirty_ratelimit = write_bw;
                                        bdi->dirty_ratelimit = balanced_dirty_ratelimit;
                                        //step = 0;
                                        //if (dirty < setpoint) {
                                        //	x = min(bdi->balanced_dirty_ratelimit,
                                        //               min(balanced_dirty_ratelimit, task_ratelimit));
                                        //	if (dirty_ratelimit < x)
                                        //		step = x - dirty_ratelimit;
                                        //}  �˴�����bug�� ��ʱdirty_ratelimit ���� x ʱ��stepһֱΪ0�� ����
                                        // dirty_ratelimit һֱ���ڶ��г�ʼ���ĳ�ʼֵ100M

                                        //trace_bdi_dirty_ratelimit
                                bdi_update_write_bandwidth
                max_pause = bdi_max_pause(bdi, bdi_dirty);
                min_pause = bdi_min_pause(bdi, max_pause,
                period = HZ * pages_dirtied / task_ratelimit;
                pause = period;
                //trace_balance_dirty_pages
                trace_balance_dirty_pages(bdi,
                __set_current_state(TASK_KILLABLE);
                io_schedule_timeout(pause);

generic_writepages
        write_cache_pages
                //trace_wbc_writepage


ext4_write_begin
        //trace_ext4_write_begin
        ext4_writepage_trans_blocks
        grab_cache_page_write_begin
                find_lock_page
                        find_get_page
                                radix_tree_lookup_slot
                        lock_page
                __page_cache_alloc//o
                add_to_page_cache_lru//o
                        add_to_page_cache
                                __set_page_locked
                                add_to_page_cache_locked
                        lru_cache_add_file
                wait_for_stable_page//
                        bdi_cap_stable_pages_required
                        wait_on_page_writeback
        unlock_page
        ext4_journal_start
        lock_page
        wait_on_page_writeback
        __block_write_begin(page, pos, len, ext4_get_block);
                ext4_get_block
                        _ext4_get_block
                                ext4_map_blocks
                                        ext4_ext_map_blocks


ext4_write_end
        //trace_ext4_write_end
        generic_write_end


ext4_ext_map_blocks(handle, inode, map, flags & EXT4_GET_BLOCKS_KEEP_SIZE);
        //trace_ext4_ext_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);
        //trace_ext4_ext_show_extent(inode, ee_block, ee_start, ee_len);
        ext4_mb_new_blocks(handle, &ar, &err);
                //trace_ext4_request_blocks(ar);
                ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);
                        ext4_journal_get_write_access
                ext4_mb_release_context(ac);
                        //trace_ext4_mballoc_prealloc(ac);
                //trace_ext4_allocate_blocks(ar, (unsigned long long)block);
        get_reserved_cluster_alloc(inode,map->m_lblk, allocated);
                //trace_ext4_get_reserved_cluster_alloc(inode, lblk_start, num_blks);
        ext4_da_update_reserve_space(inode,	reserved_clusters, 0);
                //trace_ext4_da_update_reserve_space(inode, used, quota_claim);
                dquot_claim_block
                        mark_inode_dirty_sync
                                __mark_inode_dirty
        //trace_ext4_ext_map_blocks_exit(inode, map, err ? err : allocated);
        ext4_es_insert_extent
                //trace_ext4_es_insert_extent(inode, &newes);
        ext4_ext_show_leaf

ext4_writepage
ext4_da_write_begin
        //trace_ext4_da_write_begin
        grab_cache_page_write_begin
        unlock_page
        handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, 1);
        lock_page
        wait_on_page_writeback
         __block_write_begin(page, pos, len, ext4_da_get_block_prep)
                ext4_da_get_block_prep
                        ext4_da_map_blocks
                                ext4_es_lookup_extent
                                //trace_ext4_es_lookup_extent_enter(inode, lblk);
                                //trace_ext4_es_lookup_extent_exit(inode, es, found);
                                ext4_ext_map_blocks
ext4_da_write_end
        //trace_ext4_da_write_end
        generic_write_end
                block_write_end
                        __block_commit_write
                                mark_buffer_dirty
                                //trace_block_dirty_buffer(bh);
                                        __set_page_dirty
                                                account_page_dirtied
                                                //trace_writeback_dirty_page(page, mapping);
                if (i_size_changed)
                        mark_inode_dirty(inode);
                                __mark_inode_dirty
                                        //trace_writeback_dirty_inode_start
                                        ext4_dirty_inode
                                                ext4_journal_start
                                                ext4_mark_inode_dirty
                                                        ext4_reserve_inode_write
                                                                ext4_get_inode_loc
                                                                        submit_bh(READ | REQ_META | REQ_PRIO, bh);
                                                                        wait_on_buffer(bh);
                                                                ext4_journal_get_write_access
                                                        ext4_mark_iloc_dirty
                                                                __ext4_get_inode_loc
                                                //trace_ext4_mark_inode_dirty
                                                ext4_journal_stop
                                                        jbd2_journal_stop
                                                        //trace_jbd2_handle_stats
                                        //trace_writeback_dirty_inode
*** jbd2
do_sync_write
        ext4_file_write
                generic_file_aio_write
                        __generic_file_aio_write
                                generic_file_buffered_write
                                        generic_perform_write
                                                ext4_da_write_begin
                                                iov_iter_copy_from_user_atomic
                                                        __copy_from_user_inatomic
                                                ext4_da_write_end
                                                cond_resched
                                                balance_dirty_pages_ratelimited
                                                        __bdi_update_bandwidth
                generic_write_sync
                        vfs_fsync_range
                                ext4_sync_file

ext4_sync_file
        filemap_write_and_wait_range
                __filemap_fdatawrite_range
                        do_writepages
                                        ext4_da_writepages  //trace_ext4_da_writepages
                filemap_fdatawait_range
                        pagevec_lookup_tag//PAGECACHE_TAG_WRITEBACK
                        wait_on_page_writeback
        jbd2_complete_transaction
                jbd2_log_wait_commit
                        wait_event(journal->j_wait_done_commit,
        blkdev_issue_flush


jbd2_get_transaction
jbd2_journal_flush


ext4_journal_start
        __ext4_journal_start
                __ext4_journal_start_sb
                //trace_ext4_journal_start
                        jbd2__journal_start
                        //trace_jbd2_handle_start
                                new_handle
                                current->journal_info = handle;
                                start_this_handle
                                        if (transaction->t_state == T_LOCKED) {
                                                prepare_to_wait(&journal->j_wait_transaction_locked,&wait, TASK_UNINTERRUPTIBLE);
                                        atomic_inc(&transaction->t_updates);
ext4_journal_stop
        __ext4_journal_stop
                jbd2_journal_stop
                //trace_jbd2_handle_stats

                        if (handle->h_sync ||
                                jbd2_log_start_commit(journal, transaction->t_tid);
                        wake_up(&journal->j_wait_updates

                        if (wait_for_commit)
                                err = jbd2_log_wait_commit(journal, tid);

ext4_bread
        ext4_getblk
                ext4_map_blocks
                bh = sb_getblk(inode->i_sb, map.m_pblk);
                ext4_handle_dirty_metadata
        ll_rw_block
        wait_on_buffer

ext4_handle_dirty_dirent_node
ext4_group_add_blocks
ext4_free_blocks
ext4_mb_mark_diskspace_used
ext4_delete_entry
ext4_init_new_dir
        ext4_handle_dirty_metadata

ext4_handle_dirty_metadata
        __ext4_handle_dirty_metadata
                jbd2_journal_dirty_metadata
                        __jbd2_journal_file_buffer
                                list = &transaction->t_buffers;

ext4_journal_get_write_access
        __ext4_journal_get_write_access
                jbd2_journal_get_write_access
                        jbd2_journal_add_journal_head
                        do_get_write_access
                                if (jh->b_jlist == BJ_Shadow) {
                                                trace_printk("on shadow: sleep \n");
                                __jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);
                                        list = &transaction->t_reserved_list;
                                jbd2_journal_cancel_revoke(handle, jh);
                        jbd2_journal_put_journal_head

ext4_da_writepages
jbd2_complete_transaction
        jbd2_log_start_commit
                __jbd2_log_start_commit
                        journal->j_commit_request = target;
                        wake_up(&journal->j_wait_commit);
        jbd2_log_wait_commit
                wait_event(journal->j_wait_done_commit,!tid_gt(tid, journal->j_commit_sequence));

kjournald2
        jbd2_journal_commit_transaction
                //trace_jbd_start_commit(journal, commit_transaction);
                //trace_jbd_commit_locking(journal, commit_transaction);
                prepare_to_wait(&journal->j_wait_updates
                __jbd2_journal_clean_checkpoint_list(journal);
                jbd2_clear_buffer_revoked_flags(journal);
                jbd2_journal_switch_revoke_table(journal);
                //trace_jbd2_commit_flushing
                journal_submit_data_buffers
                        list_for_each_entry(jinode, &commit_transaction->t_inode_list,
                        //trace_jbd2_submit_inode_data(jinode->i_vfs_inode);
                        journal_submit_inode_data_buffers
                                generic_writepages
                                        ret = write_cache_pages(mapping, wbc, __writepage, mapping);
                jbd2_journal_write_revoke_records
                //trace_jbd2_commit_logging
                jbd2_journal_get_descriptor_buffer
                        jbd2_journal_next_log_block
                                jbd2_journal_bmap
                        __getblk
                        jbd2_journal_add_journal_head
                jbd2_journal_next_log_block
                jbd2_journal_write_metadata_buffer
                        jbd2_alloc
                                __get_free_pages
                        memcpy(tmp, mapped_data + new_offset, jh2bh(jh_in)->b_size);
                        __jbd2_journal_file_buffer(jh_in, transaction, BJ_Shadow);
                        jbd2_journal_file_buffer(new_jh, transaction, BJ_IO);
                write_tag_block
                bh->b_end_io = journal_end_buffer_io_sync;
                                submit_bh(WRITE_SYNC, bh);

                journal_finish_inode_data_buffers

                journal_submit_commit_record
                        if (journal->j_flags & JBD2_BARRIER &&
                            !JBD2_HAS_INCOMPAT_FEATURE(journal,
                                                       JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT))
                                ret = submit_bh(WRITE_SYNC | WRITE_FLUSH_FUA, bh);
                        else
                                ret = submit_bh(WRITE_SYNC, bh);

                wait_on_buffer
                clear_buffer_jwrite(bh);
                jbd2_journal_unfile_buffer(journal, jh);
                        __jbd2_journal_unfile_buffer
                                __jbd2_journal_temp_unlink_buffer
                                        mark_buffer_dirty
                //trace_jbd2_run_stats(journal->j_fs_dev->bd_dev,  commit_transaction->t_tid, &stats.run);
                journal->j_commit_callback(journal, commit_transaction);
                //trace_jbd2_end_commit(journal, commit_transaction);
                __jbd2_journal_drop_transaction
                jbd2_journal_free_transaction
                wake_up(&journal->j_wait_done_commit);


end_buffer_async_write
        end_page_writeback
                test_clear_page_writeback
                        TestClearPageWriteback
                        __dec_bdi_stat(bdi, BDI_WRITEBACK)
                        __bdi_writeout_inc(bdi);
                        dec_zone_page_state(page, NR_WRITEBACK);
                        inc_zone_page_state(page, NR_WRITTEN);
                wake_up_page(page, PG_writeback);
*** blk
blk_init_queue
        blk_init_queue_node
                blk_alloc_queue_node
                        bdi_init
                                bdi_wb_init
                        blk_throtl_init
                        setup_timer(&q->timeout, blk_rq_timed_out_timer, (unsigned long) q)
                        kobject_init(&q->kobj, &blk_queue_ktype);
                blk_init_allocated_queue
                        blk_queue_make_request(q, blk_queue_bio);
                        elevator_init
                                elevator_init_queue
                                        cfq_init_queue nand_elv_init_queue//eq->type->ops.elevator_init_fn


add_disk
        bdi_register_dev
                bdi_register
                        device_create_vargs
        blk_register_queue
                elv_register_queue
                        __elv_register_queue

blk_peek_request
        __elv_next_request

" /sys/kernel/debug/tracing/events/block/block_rq_issue/enable"
" /sys/kernel/debug/tracing/events/block/block_rq_complete/enable"
*** ext4
const struct file_operations ext4_file_operations = {
        .llseek		= ext4_llseek,
        .read		= do_sync_read,
        .write		= do_sync_write,
        .aio_read	= generic_file_aio_read,
        .aio_write	= ext4_file_write,
        .unlocked_ioctl = ext4_ioctl,
#ifdef CONFIG_COMPAT
        .compat_ioctl	= ext4_compat_ioctl,
#endif
        .mmap		= ext4_file_mmap,
        .open		= ext4_file_open,
        .release	= ext4_release_file,
        .fsync		= ext4_sync_file,
        .splice_read	= generic_file_splice_read,
        .splice_write	= generic_file_splice_write,
        .fallocate	= ext4_fallocate,
};

schedule
        sched_submit_work
                blk_schedule_flush_plug
                        blk_flush_plug_list
                                __elv_add_request  //trace_block_rq_insert
                                        elv_drain_elevator  //.elevator_dispatch_fn =
                                                nand_elv_dispatch_requests,
                                                        deadline_dispatch_requests
                                                        cfq_dispatch_requests
                                                                cfq_dispatch_request
                                                                        cfq_dispatch_insert
                                        __blk_run_queue
                                queue_unplugged  //trace_block_unplug
                                        blk_run_queue_async
                                                queue_delayed_work //kblockd
                                                        blk_delay_work
                                                                __blk_run_queue
                                                                        //q->request_fn
                                                                        DDL_DiskRequestArrivedCB

do_sync_write
        ext4_file_write
                generic_file_aio_write
                        blk_start_plug
                        __generic_file_aio_write
                                generic_file_buffered_write
                        blk_finish_plug


madvise
        madvise_vma
                madvise_willneed
                        force_page_cache_readahead
                                __do_page_cache_readahead
                                        page_cache_alloc_readahead
                                        read_pages
                                                blk_start_plug
                                                        blkdev_readpage//a_ops->readpages



do_sync_read
        generic_file_aio_read //>f_op->aio_rea
                do_generic_file_read
                        page_cache_alloc_cold
                        add_to_page_cache_lru
                                add_to_page_cache
                                        __set_page_locked
                                        add_to_page_cache_locked
                                                //trace_mm_filemap_add_to_page_cache(page);
                        blkdev_readpage//a_ops->readpage
                                block_read_full_page
                                        create_empty_buffers
                                                alloc_page_buffers
                                                        attach_page_buffers
                                                        set_bh_page
                                        blkdev_get_block//get_block
                                                set_buffer_mapped
                                        lock_buffer
                                        mark_buffer_async_read //bh->b_end_io = end_buffer_async_read;
                                        submit_bh //bio->bi_end_io = end_bio_bh_io_sync;
                                                submit_bio
                                                        generic_make_request
                                                                //q->make_request_fn(
                                                                        blk_queue_bio
                        lock_page_killable
                                __lock_page_killable   //PG_locked  end_buffer_async_read
                                        __wait_on_bit_lock  //  wait loop  TASK_KILLABLE
                                                sleep_on_page_killable
                                                        sleep_on_page
                                                                io_schedule
                                                                        atomic_inc(&rq->nr_iowait);//����iowait
                                                                        blk_flush_plug
                                                                                schedule
                        unlock_page
                        page_cache_release
                                put_page
                        file_read_actor
                                __copy_to_user
        wait_on_retry_sync_kiocb  // while loop
                schedule


blk_peek_request
        __elv_next_request
                q->prep_rq_fn//null
                //q->elevator->type->ops.elevator_dispatch_fn ��������û��reqʱ
                cfq_dispatch_requests
        elv_activate_rq
                 //CONFIG_CFQ_GROUP_IOSCHED
                        cfq_activate_request//CONFIG_BLK_DEV_THROTTLING
                                cfq_log_cfqq //CONFIG_BLK_DEV_IO_TRACE ��Ҫ��blk tracer

_dealDiskRequest  // device driver ==> user
        __blk_end_request
                __blk_end_bidi_request
                        blk_update_bidi_request
                                blk_update_request
                                        req_bio_endio
                                                bio_endio
                                                        end_bio_bh_io_sync //bio->bi_end_io
                                                                end_buffer_async_read
                                                                        set_buffer_uptodate
                                                                        SetPageUptodate
                                                                        unlock_page //PG_locked
                                                                                clear_bit_unlock(PG_locked
                                                                                wake_up_page
                blk_finish_request
                        blk_delete_timer
                        blk_account_io_done
                        req->end_io(req, error); //flush_end_io
                        __blk_put_request
                                elv_completed_request
                                        //e->type->ops.elevator_completed_req_fn
                                        cfq_completed_request
                                                cfqg_stats_update_completion
                                                RQ_CIC(rq)->ttime.last_end_request = now;
                                blk_rq_rl
                                blk_free_request(rl, req);
                                freed_request(rl, flags);
                                blk_put_rl(rl);

flush_end_io
        elv_completed_request
        blk_flush_complete_seq
                __blk_end_request_all(rq, error);

__elv_add_request
        blk_insert_flush
        rq->end_io = flush_data_end_io;
        blk_flush_complete_seq

flush_data_end_io
        blk_flush_complete_seq(rq, REQ_FSEQ_DATA, error)

blk_flush_complete_seq
        blk_kick_flush
                //q->flush_rq.end_io = flush_end_io;

trace_ext4_sync_file_enter
ext4_sync_file
        filemap_write_and_wait_range
                __filemap_fdatawrite_range
                        do_writepages
                                ext4_da_writepages
                                        blk_finish_plug
                                                blk_flush_plug_list
                                                        __elv_add_request
                                                                nand_elv_add_request
                                                                        __blk_run_queue
                                                queue_unplugged
                                                        __blk_run_queue

static const struct address_space_operations def_blk_aops = {
        .readpage	= blkdev_readpage,
        .writepage	= blkdev_writepage,
        .write_begin	= blkdev_write_begin,
        .write_end	= blkdev_write_end,
        .writepages	= generic_writepages,
        .releasepage	= blkdev_releasepage,
        .direct_IO	= blkdev_direct_IO,
};


ext4_bread
        ll_rw_block
                block_read_full_page
                        submit_bh
                                submit_bio
                                        generic_make_request
                                                //q->make_request_fn(
                                                        blk_queue_bio


_DiskPartitionCreate
 queue = blk_init_queue(DDL_DiskRequestArrivedCB
         blk_init_queue_node
                 blk_init_allocated_queue
                        blk_queue_make_request
                                // q->make_request_fn = blk_queue_bio

 nand_elv_init
        iosched_nand_elv
*** panic
panic(param...)
__die
        unwind_backtrace
                dump_backtrace_entry   // (%pS)
                                printk
                                        vsnprintf
                                                pointer
                                                        symbol_string
                                                                kallsyms_lookup


kmsg_dump_register(struct kmsg_dumper * dumper)(struct kmsg_dumper * dumper)
*** ftrace
tracing_sched_register
        register_trace_sched_wakeup
                probe_sched_wakeup
                        ftrace_trace_userstack //entry->tgid = current->tgid;

tracing_mark_write
        trace_buffer_lock_reserve  //ftrace.h Ҳ�����event = trace_current_buffer_lock_reserve
                tracing_generic_entry_update  /*        entry->preempt_count		= pc & 0xff;
                                                                                        entry->pid			= (tsk) ? tsk->pid : 0;
                                                                                        entry->padding			= 0;
                                                                                        entry->flags = */
        ring_buffer_unlock_commit
                rb_commit
                        rb_update_write_stamp


trace_create_file("trace_options", 0644, d_tracer,
                        NULL, &tracing_iter_fops);
                        tracing_trace_options_write
                                        set_tracer_flags



trace_create_file("trace_pipe", 0444, d_cpu,
                        (void *) cpu, &tracing_pipe_fops);
                tracing_open
                        __tracing_open
                                seq_open(file, &tracer_seq_ops);//s_show
s_show
        print_trace_line
                print_trace_fmt
                        trace_print_context     //TRACE_ITER_CONTEXT_INFO
                                trace_find_cmdline   //
                                trace_print_lat_fmt //TRACE_ITER_IRQ_INFO
                        ftrace_find_event
                                event->funcs->trace
                                        ftrace_raw_output_##call

event_trace_init
        __trace_add_event_call
                ftrace_event_reg
                        trace_event_raw_init
                                register_ftrace_event //event->type = trace_search_list
                                        ftrace_event_reg
                                                tracepoint_probe_register


tracer_init_debugfs
ftrace_init
ftrace_module_notify
ftrace_global_list_func

ftrace_graph_caller
ftrace_dyn_arch_init
ftrace_caller
ftrace_make_call

// trace.c
tracer_init_debugfs //fs_initcall(tracer_init_debugfs);
        trace_create_file("current_tracer", 0644, d_tracer,
                                &global_trace, &set_tracer_fops);
        init_tracer_debugfs
                tracing_init_debugfs_percpu
                        tracing_dentry_percpu
                                debugfs_create_dir("per_cpu", d_tracer);
                        trace_create_cpu_file("trace", 0644, d_cpu,
                                tr, cpu, &tracing_fops);

tracing_set_trace_write
        tracing_set_tracer
                tracer_init
                        t->init
                        //trace_irqsoff.c
                        irqsoff_tracer_init
                                start_irqsoff_tracer
                                        register_ftrace_function //irqsoff_tracer_call
                                                ftrace_startup
                                                        ftrace_run_update_code // ftrace_trace_function = ftrace_ops_list_func
                                        register_ftrace_graph // irqsoff_graph_return irqsoff_graph_entry

trace_hardirqs_off
trace_create_file("tracing_enabled", 0644, d_tracer,
                        &global_trace, &tracing_ctrl_fops);
tracing_ctrl_write
        current_trace->start
                        //trace_irqsoff.c
                        irqsoff_tracer_start
http://lwn.net/Articles/379903/
register_ftrace_event

ftrace_event_id_fops
ftrace_enable_fops
ftrace_event_filter_fops
ftrace_event_format_fops

trace_module_nb

blk_register_queue
        blk_trace_init_sysfs
                sysfs_create_group(&dev->kobj, &blk_trace_attr_group);
                        //sysfs_blk_trace_attr_show
                        //sysfs_blk_trace_attr_store
//blktrace.c
sysfs_blk_trace_attr_store
        blk_trace_setup_queue
                blk_register_tracepoints //blk_add_trace_rq_insert

//elavtor.c
trace_block_rq_insert
        blk_add_trace_rq_insert
                __blk_add_trace
                        trace_buffer_unlock_commit
//samples/tracepoint

//trace_irqsoff.c
init_irqsoff_tracer
irqsoff_tracer

*** console
Kernel
printk
       vprintk
              local_irq_save
              console_unlock
                     call_console_drivers
                            _call_console_drivers
                                   __call_console_drivers
con->write // asoc_console_write
    con->write
platform_driver_probe
       asoc_serial_probe
              uart_add_one_port
                     uart_configure_port
                            register_console // asoc_console

android �е�klogd
��android
          init
              klog_init
                  android/system/core/libcutils/klog.c

mknod(name, S_IFCHR | 0600, (1 << 8) | 11) ʹ/dev/__kmsg__
        kernel/drivers/char/mem.c
       [11] = { "kmsg", 0, &kmsg_fops, NULL },
����klog_write�����յ���kmsg_fops��kmsg_writev ��д��printk���ڲ�buffer�С�

Logcat�еĴ�ӡ�᲻���ӡ��printkʹ�õ�buffer�����Ǵ�ӡ����drivers/staging/android/logger.c���ж���ļ���buffer�С�

Sh��ʹ�õĴ�ӡ������� (/dev/console)
service_start
       open_console (/dev/console)
service console /system/bin/sh
    class core
    console
disabled

/dev/console
console_fops->open
tty_open
       tty_lookup_driver
              console_device
                     c->device
                            uart_console_device
                                   p->tty_driver
        tty->ops->open(tty, filp)
                     uart_open
                            uart_startup
                                   uart_port_startup
                                          uport->ops->startup // asoc_uart_pops
                                                 asoc_startup
p->tty_driver//arch/arm/mach_leopard/asoc_serial.c
asoc_serial_init
uart_register_driver
       tty_register_driver


shell
console_fops->write
redirected_tty_write
    tty_write
        do_tty_write
            ld->ops->write  //  tty_ldisc_N_TTY
            n_tty_write
                tty->ops->write // uart_ops
                uart_write
                    uart_start
                        spin_lock_irqsave(&port->lock, flags);
                        __uart_start(tty);
                            port->ops->start_tx // asoc_uart_pops
                            asoc_start_tx
                            spin_unlock_irqrestore(&port->lock, flags);`

* 研发会议
** tmp
 + mcu 相关特性
   + APIs and drivers to access on board peripherals like SPI, UART,
     ADC, PWM, Keyscan and IR HW blocks.
   + MCU sample application running on host OS for controlling embedded
     BT applications over WICED HCI protocol.
   + Sample apps for hardware interfaces including ADC, PUART,
     GPIO, PWM.
   + Support for Over-The-Air (OTA) upgrade.
   + Bluetooth stack included the ROM.
   + BT stack and profile level APIs for embedded BT application development.
 + bluetooth标准协议
   + Bluetooth protocols include GAP, GATT, SMP, RFCOMM, SDP,
     AVDTP, AVTCP and OBEX.
   + Bluetooth profiles include A2DP source and sink, AVRCP controller
     and target, HF and AG, HID device and host, HOGP, PBAP, SPP.
   + BR/EDR embedded sample apps for BT profiles.
   + Routing audio data over I2S/PCM interface for HFP(SCO) and A2DP Source and Sink.
   + BLE embedded sample apps for BLE client and server, beacon, AMS, ANCS,
     HID over GATT, Serial port profile over GATT.
 附加协议
** 0728 代码质量会议
附件中有一个ppt中的一句话说得很到位：代码质量不能完全依靠人来保证，但最终还是依靠人来保证。
所以， 从不能完全依靠人来保证这个角度来说，是需要使用工具来帮忙的。

质量目标也要定得合理一些，做确实能够帮到我们的那些活动，优先做投入产出要合算的部分。

结合以前在做USDK的时候的经验教训， 先说下我的看法：
+ 静态检查工具QAC
  以前公司使用的代码静态检查工具QAC，使用的主要是汽车工业的MISRA标准,  这个QAC工具中检查规很多，报出来的warning非常多，很多都是无关紧要的warning，可修改也可以不修改的那种，有一些也不好修改，带来来很多的工作量，但从实际的效果来看，收益很小， 并没有通过QAC查出来有效的问题。

  Zephyr目前用的是Synopsis提供的Coverity Scan来静态检查代码
  https://scan.coverity.com/
  Coverity Scan是在线检查使用，针对开源代码使用免费。
  https://en.wikipedia.org/wiki/Coverity
  | Coverity Code Advisor           | is a static code analysis tool for C, C++, C#, Java, and JavaScript. It is derived from the Stanford Checker, a research tool for finding bugs through static analysis.      |
  | Coverity Code Advisor on Demand | was a cloud hosted version of Coverity Code Advisor.                                                                                                                         |
  | Coverity Scan                   | is a gratis static-analysis cloud-based service for the open source community. The tool analyzes over 3900 open-source projects and is integrated with GitHub and Travis CI. |
  | Coverity Test Advisor           | is a series of products aimed at identifying weaknesses in a project software testing.                                                                                       |

  如果继续使用原来的QAC，建议大幅简化QAC的规则， 只保留确实必要的几条。
  zephyr的项目的话，建议使用Coverity Scan，这个看怎么部署起来可以用。
+ 动态检查工具QAM
  公司在做usdk的时候， 使用的是klockwork这个工具。 这个工具在usdk开发的时候，确实使用这个工具查到了一些动态内存泄露的问题。 相对来说，投入产出比还是合算的。
  后来做linux和android项目的时候， 我们拿linux的内核代码去查（里面包含了内存泄露的bug），但实际并未查出来，还不如linux自带的内存泄露工具有效， 主要的原因是linux中非常广泛的使用了函数指针，这个对klocwork整个工具不够友好。 由于要花钱，所以在linux项目中就没有使用。
  在zephyr项目中，我们在sdk架构设计的时候， 就考虑来动态来检测内存泄露（但这个需要占用内存），能够解决部分问题。 但对很不常见的分支，可能不能查出来。
  如果可以继续使用Klocwork的话，应该可以帮忙一些忙，投入产出应该合算，主要看工具是否合算。
+ 代码走差
  代码质量不能完全依靠人来保证，但最终还是依靠人来保证的。 代码走查就是用人来保证代码的质量，代码走查除了能有效的保证每次代码提交的时候不犯明显的低级错误外， 还可以有效的保证设计的质量， 而后者是靠工具永远没法达到的。
  目前andorid项目和zephyr项目都使用了代码走查工具gerrit。
+ 代码规范
  代码规范的话， 如果是衍生的代码，建议采用原始项目的代码风格， 比如android项目的java代码，那么就采用google的java代码风格， Linux kernel的驱动代码就采用linux自己的风格。 不需针对这些代码应用公司的规范。
  如果是公司完全自研的代码，统一到统一的公司规范上。
  通过类似linux的checkpatch等工具，来检查是否符合规范， 在代码提交review的时候自动进行。
  总的来说，代码规范的执行如果可以做到工具自动化，工作量相对还好。
+ 自动化测试和持续集成
  3503的第二阶段中开始做public api的代码测试和自动化测试。
  主要还是针对平台提供的api来测试，暂时不做模块内部的api的单元测试，
  主要考虑：
  + 如果基于平台的视角来看，public的api是必须测试的。不然没法保证平台的质量，平台的质量可以使用标案，或者demo来测试，但仍不够直接，在没有标案的时候，测试用例是最直接的手段。
  + 单元测试的投入很大，从以前的历史看，投入产出比不好
  + 但由于是模块内部的api，会比较容易变化，一旦变化后，对应的测试用例也需要变化，也不容易积累有效的测试用例，
  + 稳定的测试用例可以用作回归测试，频繁变化的测试用例是不能有这个好处的。
  + 测试需要做到自动化，需要做到代码提交的时候，自动集成，烧写和测试。



** 0725 5120 review
杨哲：
下周请持续组织讨论关于以上两颗IC的策略调整。我要求主管能邀请关键人员参与。
1．5119已经进行了又一轮市场调研，仍然在进行中，我自己也在调研。基于杨哲和冯国荣的报告，以及龚建等的评测状况再一次详细讨论下一步计划。
在成本不挑格子的前提下，我个人还是强烈建议大家重点看功耗和品质。 原因如下。
1）在耳际这个行业功耗是一举三得的重中之众，它既是区别于对手的重要指标，也是成本（可以用更小的电池），又是品质。
2）炬芯/炬力在音频市场多年的积累创造的是音质和品质的美誉度，不能随便把自己的根据地扔掉，即便做地段，也要切实做到这一点。而不是反其道而行之。
3）老刘也反复在提醒大家，不要为进攻超低端过热。我们必须有持续的低端策略，但绝对不主动重兵进攻超低端，这个公司早有结论，目前并没有改变，我也不认为会改变。5119不能定位超低端纯粹杀价格。
4）富翰虽然由于自己的品质问题出局了，但是他的策略并不错，以低功耗加足够低的价格出手会收到市场热捧，试想，如果他没有自己的质量问题，他当时的定位杀伤力是不是很大？所以这个策略是没有问题的，但是必须真的能执行。有品质来支撑这个立题。

2 5120/5116C是时候从新定位了，尤其是针对以下几个点进行从新思考。
1）Paul反复在问的全兼容和替换策略的必要性，如果不必要允许放宽多少？换来的好处是啥？
2）5116C属于情急之下的匆忙之做，光CPU/DSP就三个，高端加着急加兼容迫使成本几乎不在考虑范围。
3）由于RF的限制，再加着急，只能放弃对耳机和运动耳机的支持。
除了26日我不能参加以外，其他时间我都OK
我再次提醒，我不喜欢主管们只是带着笔记和笔近来听，你们必须准备资料，包括收集的资料，和你们的想法，这些想法预先要整理好。
洪波和杨哲这方面一直做得比较好，其它主管要学习。
** 0717 5118开发平台后续策略
*** cypress wiced BT sdk
**** CYW20706
| Technology            | Bluetooth (BR + EDR + BLE)                        |
| Bluetooth Spec.       | Bluetooth 4.2                                     |
| RX Sensitivity        | -93.5 dBm                                         |
| Max. TX Power         | 12 dBm (Programmable TX Power)                    |
| Power-Class           | Class 1, Class 2                                  |
| CPU Core              | ARM Cortex M3                                     |
| Flash/EEPROM          | Ext. Flash/EEPROM support                         |
| Internal              | 848 KB ROM                                        |
| SRAM                  | 352 KB                                            |
| Coexistence Interface | GCI SECI (2-wire)                                 |
| Serial Interfaces     | 2 UART, 2 SPI, I2C, PCM, I2S                      |
| ADC                   | 10-bit @ 100 KHz (Static) 13-bit @ 16 KHz (Audio) |
| GPIOs                 | Up to 24                                          |

The Cypress CYW20706 is a monolithic, single-chip, Bluetooth 4.2 + HS compliant SOC, comprising a baseband processor, an ARM Cortex-M3 processor, and an integrated transceiver. It is designed for use in embedded applications, with on-chip support for an embedded stack. Manufactured using the industry's most advanced 40 nm CMOS low-power process, the CYW20706 employs the highest level of integration, eliminating all critical external components, and thereby minimizing the device’s footprint and costs associated with the implementation of Bluetooth solutions.

The CYW20706 is the optimal solution for voice, data, home automation, accessories and other applications that require a Bluetooth SIG standards-compliant interface. The CYW20706 supports a host command interface (HCI) through USB or UART and also supports PCM audio.

BCM920706V2_EVAL

The CYW20706 transceiver’s enhanced radio performance meets the most stringent industrial temperature application requirements for compact integration into mobile handset and portable devices. The CYW20706 provides full radio compatibility, enabling it to operate simultaneously with GPS and cellular radios.

The CYW20706 microprocessor unit runs software from the Link Control (LC) layer up to the stack and Application layer. In the HCI mode of operation the stack will be run on the external host. The microprocessor is based on the Cortex-M3 32-bit RISC processor with embedded ICE-RT debug and JTAG interface units. The microprocessor also includes 848 KB of ROM memory for program storage and boot ROM, 352 KB of RAM for data scratch-pad, and patch RAM code.

**** 特性
 1. Bluetooth application
    + RFCOMM/SPP
    + A2DP source and sink
    + AVRCP controller and target
    + Hands-free AG and HF
    + BR-EDR and BLE HID Device
    + BR-EDR HID Host
    + BLE Client and Server
    + BLE beacon
    + Apple ANCS, AMS
    + Apple HomeKit and iAP2 support (requires add-in package, contact Cypress support for details)
    + OBEX library and PBAP client profile.
    + Serial over GATT profile.
 2. Peripheral interfaces
    + GPIO
    + Timer (Software)
    + PWM
    + UART (two instances - one for application download and another for application use).
    + SPI (two instances - one for serial flash and another for  application use).
    + I2C (master only).
    + RTC (Real Time Clock)
    + Keyscan
    + ADC (12 bit)
 3. Generic profile level abstraction API
 4. API to access NV storage areas.
 5. WICED Bluetooth Designer to create BR-EDR/BLE sample applications
   (See WICED Studio menu -> File -> New -> WICED Bluetooth Designer)
    + Creating Single mode BR-EDR or BLE and Dual Mode applications
    + Built-in GATT database and BLE profiles (Heart rate monitor, blood pressure, cycling speed, etc.)
    + Built-in SDP records generation for BR-EDR profiles
    + Hardware peripherals and interfaces (UART, LED, timers, Battery,  etc.)
 6. WICED BT Application Framework
    + OTA firmware upgrade
    + Overlay support to load code from NV storage on demand (NV storage dependent latency and power).
 7. 可以做为模组使用
    作为模组使用的话， 也有两种模式：
    + hci controller模式
      在这个模式下hci之上的stack都跑在主控上，CYW207xx只跑hci命令
    + application模式
      应用和蓝牙的整个协议栈都跑在CYW207xx上，主控和应用通过uart 或 spi采用定制的hci协议交互
 8. tools
    + BTSpy application for viewing embedded BT application and
      HCI protocol traces.
    + Manufacturing tools to verify RF performance (mbt and wmbt).
    + WICED Bluetooth Designer wizard for quickly creating Bluetooth
      applications.
      (See Eclipse IDE menu -> File -> New -> WICED Bluetooth Designer)
    + Segger J-Link debugger using J-Link GDB server and GCC GDB client.
    + Test tool for automated testing.
    + low_power_sensor application on 20735B0 platform
**** 目录结构
| apps      | Example & Test Applications                                                                               |
| doc       | API & Reference Documentation, Eval Board & Module Schematics                                             |
| drivers   | Drivers for the USB serial converter                                                                      |
| include   | WICED API, constants, and defaults                                                                        |
| libraries | Bluetooth profile and protocol libraries                                                                  |
| platforms | Configuration files and information for supported  hardware platforms                                     |
| test      | Tools provided for automation testing tools, wiced_tools : Build tools, compilers, programming tools etc. |
| WICED     | Core WICED components                                                                                     |

其中：
apps中都是应用逻辑代码， 和蓝牙协议关系不大。
libraries中是蓝牙协议栈的一些上层的profile的实现代码，主要有：a2dp_sink_profile avrc_target hidh_lib ams_lib fw_upgrade_lib obex_lib ancs_lib gatt_utils_lib pbap_lib avrc_controller handsfree_profile spp_lib
WICED中就是bt的核心的协议栈和整个平台的实现，主要是一个rom或ram的镜像，以及平台提供的api的符号定义。
**** WICED BT的可配置方式
需要注意的是在WICED的cofig目录中有一个配置文件: Wiced-BT/config/A_20703A2.inc
可以明显的看出是采用的Kconfig的格式， 该文件定义的变量会在makefile的编译选项中作为预定义的宏来使用。 从这里也可以间接看出，他们的内部开发是使用Kconfig系统的，ram和rom的镜像只是特定的一个配置组合的编译输出。
**** A2DP sink例子的分析
***** 简述
A2DP的例子实现了一个demo，通过蓝牙建立一个a2dp的链接，实际接收到的数据只做了打印信息输出，并没有真正实现播放器的功能。
仅仅是演示如何使用a2dp的协议。
***** 相关各层接口
+----------+--------------------------------------+
| apps     | a2dp_sink_management_callback        |
|          | a2dp_sink_control_cback              |
|          | a2dp_sink_data_cback                 |
+----------+--------------------------------------+
| librarys | wiced_bt_a2dp_sink_init              |
+----------+--------------------------------------+
| ROM      | wiced_bt_avdt_register               |
|          | wiced_bt_avdt_create_stream          |
|          | wiced_bt_avdt_connect_req            |
|          | wiced_audioe_sink_config_init        |
|          | wiced_audio_sink_register_data_cback |
+----------+--------------------------------------+

***** 工作过程
1. wiced_bt_stack_init
   参数1是bt的各种设置，设备名字，查询扫描参数，连接间隔，BLE的广播参数等
   另外一个参数就是a2dp_sink_management_callback回调函数
   该回调函数会在bt初始化完成后调用
2. a2dp_sink_management_callback
   bt协议栈的各种LMP等核心处理函数，主要配对，链路管理，加密等核心bt时间的处理函数
   bt底层协议栈初始化完成后，回调此函数，在BTM_ENABLED_EVT事件中来做ad2p的初始化
3. wiced_bt_a2dp_sink_init
   参数1是a2dp sink的各个参数，比如codec的参数
   参数2是一个回调函数 a2dp_sink_control_cback

   应用通过调用该函数来初始化a2dp的协议， a2dp协议的大部分代码都实现在libraries/a2dp_sink_profile/目录下，a2dp依赖的核心协议AVDTP（audio video distribution profile）是实现在ROM中的。比如：wiced_bt_avdt_register wiced_bt_avdt_create_stream wiced_bt_avdt_connect_req wiced_audioe_sink_config_init 等接口

   a2dp协议初始化后，会处理各种AVDTP的事件，把部分需要应用层处理的时间通过调用注册的回调a2dp_sink_control_cback传递给应用，主要包括：
   + WICED_BT_A2DP_SINK_CODEC_CONFIG_EVT
   + WICED_BT_A2DP_SINK_CONNECT_EVT
   + WICED_BT_A2DP_SINK_DISCONNECT_EVT
   + WICED_BT_A2DP_SINK_START_IND_EVT
   + WICED_BT_A2DP_SINK_START_CFM_EVT
   + WICED_BT_A2DP_SINK_SUSPEND_EVT
4. wiced_audio_sink_register_data_cback
   应用通过该函数注册a2dp的数据接收的回调， 当有音频数据来的时候就会回调该函数
***** 主要涉及的文件大小统计：
| file name                                                           | code size | data size | rodata size |
| ../../Apps/a2dp_sink/a2dp_sink.c                                    |       488 |        24 |           0 |
| ../../Apps/a2dp_sink/a2dp_sink_main.c                               |       744 |         4 |          37 |
| ../../Apps/a2dp_sink/wiced_bt_cfg.c                                 |         0 |        64 |         221 |
| ../../libraries/a2dp_sink_profile/wiced_bt_a2dp_sbc.c               |       122 |         0 |           0 |
| ../../libraries/a2dp_sink_profile/wiced_bt_a2dp_sink_act.c          |     1,950 |         0 |          44 |
| ../../libraries/a2dp_sink_profile/wiced_bt_a2dp_sink_api.c          |       192 |         0 |           0 |
| ../../libraries/a2dp_sink_profile/wiced_bt_a2dp_sink_cfg.c          |       282 |         0 |           0 |
| ../../libraries/a2dp_sink_profile/wiced_bt_a2dp_sink_main.c         |       920 |       508 |          16 |
| ../../libraries/a2dp_sink_profile/wiced_bt_a2dp_sink_route_config.c |       360 |        56 |           0 |
| ../../libraries/a2dp_sink_profile/wiced_bt_a2dp_sink_ssm.c          |       140 |         0 |         416 |
***** 总结
+ 应用开发是相对简单的， 并且都遵循一定的模式，
  主要就是完成配置参数，然后注册一些回调来处理感兴趣的事件就可以了，不需要关心蓝牙具体是如何实现的。
  蓝牙参数的配置，一是可以抄例子的，含义也是相对比较直观的
  配置确定后，事件的处理就完全是应用层自己的逻辑。
+ 在a2dp的协议实现中，处理了大部分的avdtp的事件，只传递必要的事件给应用层
  这部分也保持了开源，在遇到兼容性问题的时候，开发者还是可以通过修改这里的代码来解决的。
+ AVDTP， L2CAP ， SDP保持闭源
  核心的蓝牙协议栈，不大有兼容性问题的部分，保持了闭源，同时也封装了比较好的接口。
**** 各个例子的大小
除了A2DP的例子外，还提供很多其他的例子，其中有hci字样的都是作为蓝牙模组配合其他主控使用的。另外还提供了一些使用mcu的其他非蓝牙功能的例子。
具体如下：
+------------------------------------+-----------+-----------+-------------+
| module name                        | code size | data size | rodata size |
+------------------------------------+-----------+-----------+-------------+
| spp Apps                           |      1358 |      1102 |         354 |
| spp libraries                      |       368 |        66 |           0 |
+------------------------------------+-----------+-----------+-------------+
| a2dp_sink Apps                     |      1558 |        92 |         298 |
| a2dp_sink libraries                |      3966 |       564 |         476 |
+------------------------------------+-----------+-----------+-------------+
| handsfree Apps                     |      3786 |       244 |         495 |
| handsfree libraries                |     12278 |      3746 |         908 |
+------------------------------------+-----------+-----------+-------------+
| hal_adc_app Apps                   |       474 |        48 |          40 |
+------------------------------------+-----------+-----------+-------------+
| hal_gpio_app Apps                  |       438 |        52 |          40 |
+------------------------------------+-----------+-----------+-------------+
| hal_puart_app  Apps                |       478 |         0 |          40 |
+------------------------------------+-----------+-----------+-------------+
| hal_pwm_app   Apps                 |       366 |        48 |          41 |
+------------------------------------+-----------+-----------+-------------+
| hello_client Apps                  |      1940 |       121 |         494 |
+------------------------------------+-----------+-----------+-------------+
| hello_sensor Apps                  |      2028 |       144 |         459 |
+------------------------------------+-----------+-----------+-------------+
| hci_audio_gateway Apps             |     11294 |      1990 |         918 |
+------------------------------------+-----------+-----------+-------------+
| hci_audio_remote_control Apps      |      4864 |       194 |         442 |
| hci_audio_remote_control libraries |      7538 |      3098 |         139 |
+------------------------------------+-----------+-----------+-------------+
| hci_ble_hid_dev Apps               |      2398 |       401 |         497 |
+------------------------------------+-----------+-----------+-------------+
| hci_handsfree Apps                 |      4408 |        41 |         302 |
| hci_handsfree libraries            |      5710 |       890 |         305 |
+------------------------------------+-----------+-----------+-------------+
| hci_hid_device Apps                |      4932 |      1393 |         678 |
+------------------------------------+-----------+-----------+-------------+
| hci_hid_host Apps                  |      2782 |         9 |         283 |
| hci_hid_host libraries             |      4354 |       228 |           0 |
+------------------------------------+-----------+-----------+-------------+
| hci_pbap_client Apps               |      7864 |      9009 |         483 |
| hci_pbap_client libraries          |     26410 |      2109 |        2275 |
+------------------------------------+-----------+-----------+-------------+
| hci_raw_spp Apps                   |      1742 |        96 |         302 |
+------------------------------------+-----------+-----------+-------------+
| hci_serial_gatt_service Apps       |      6468 |       829 |         524 |
+------------------------------------+-----------+-----------+-------------+
| hci_uart_spi_bridge Apps           |      1960 |      4159 |         168 |
+------------------------------------+-----------+-----------+-------------+
| mybeacon Apps                      |       434 |         0 |         221 |
+------------------------------------+-----------+-----------+-------------+
| ota_firmware_upgrade Apps          |      1256 |        50 |         376 |
| ota_firmware_upgrade libraries     |      1648 |       282 |           0 |
+------------------------------------+-----------+-----------+-------------+
| watch Apps                         |     19666 |      2677 |         941 |
| watch libraries                    |      7682 |      3098 |         139 |
+------------------------------------+-----------+-----------+-------------+
**** 文档
博通的wiced bt sdk提供的相关文档如下
+ api 文档
  使用了一个整体的html索引文档， 来管理各个模块的文档，具体模块的api函数是直接通过头文件中的注释使用工具doxgen来生成的html的文档。
  除了api函数接口文档外， sdk还提供其他文档。
+ 硬件部分
    BCM920735WCDEVAL_REV03.pdf
    CYW92070xV3_EVAL-Hardware-User-Guide.pdf
    CYW920735WCDEVAL-Hardware-User-Manual.pdf
    CYW9207x9WCDEVAL-Schematic.pdf
+ 快速入门
    WICED-20719-BT-Quick-Start-Guide.pdf
    Debugging-Support-Using-J-Link.pdf
    Manufacturing-Bluetooth-Test-Tool.pdf
+ 组件部分：
    | WICED-AMS-Library.pdf                                     | 访问苹果手机的Apple Media Service                           |
    | WICED-ANCS-Library.pdf                                    | 访问苹果手机的Apple Notification Center Service             |
    | WICED-Application-Buffer-Pools.pdf 蓝牙协议栈的buffer管理 |                                                             |
    | WICED-Application-Filesystem.pdf                          | 应用如何通过文件系统操作卡等                                |
    | WICED-BT-Designer-User-Manual.pdf                         | 用来快速开发蓝牙应用的ide工具，可以自动生成代码             |
    | WICED-Firmware-Upgrade-Library.pdf                        | 固件升级                                                    |
    | WICED-HCI-Control-Protocol.pdf                            | 不做主控作为hci controller的协议, 可以通过hci下载开发的应用 |
    | WICED-HCI-Test-System.pdf                                 | 通过hci的测试工具                                           |
    | WICED-HID-Device-Library.pdf                              | BLE HID的实现                                               |
    | WICED-SPI-Implementation.pdf                              | 通过spi做hci controller                                     |
    | WICED-Secure-Over-the-Air-Firmware-Upgrade.pdf            | OTA固件升级                                                 |

*** zephyr + IVT
**** A2DP sink例子的分析
***** 简述
A2DP的例子实现了一个demo，通过蓝牙建立一个a2dp的链接, 播放完整的sbc或aac解码
***** 相关各层接口
主要分为三层：
bt app：用来处理应用逻辑， 播放音乐，处理方案规格关心的bt事件
btmgr：适配ivt协议栈的bt管理层，结合ivt库实现profile的功能。
IVT库：提供各种bt核心协议的解析。

| bt app    |        |                               |
|           | LOCAL  | btmgr_ready_cb                |
|           |LOCAL        | btplay_stream_opened          |
|           | LOCAL       | btplay_stream_closed          |
|           |     LOCAL   | btplay_pcm_indicated          |
| btmgr     | GLOBAL | btmgr_start                   |
|           | LOCAL  | gap_indicate_cb               |
|           | LOCAL  | gap_set_local_name_cfm        |
|           |   LOCAL     |a2dp_indicate_cb                               |
| IVT GAP   |        |                               |
|           | GLOBAL | GAP_SetLocalNameA             |
|           | GLOBAL | GAP_ResetHardwareA            |
|           | GLOBAL | GAP_RegisterIndCbk            |
| IVT A2DP  |        |                               |
|           | GLOBAL | A2DP_StreamReconfigure        |
|           | GLOBAL | A2DP_StreamSuspend            |
|           | GLOBAL | A2DP_StreamStart              |
|           | GLOBAL | A2DP_GetConfiguration         |
|           | GLOBAL | A2DP_Connect                  |
|           | GLOBAL | A2DP_Register_SEP             |
|           | GLOBAL | A2DP_RegCbk                   |
|           | GLOBAL | A2DP_RegisterService          |

***** 工作流程
****** 初始化
+ 应用调用btmgr_start来初始化bt协议栈
  使用btmgr_ready_cb作为回调
+ btmgr_start
    在btmgr中会通过调用GAP的一系列函数完成btstack的初始化，初始化完成后，回调btmgr_ready_cb。
    从这里也可以看出IVT协议栈的典型特点，是通过一些列的回调穿起来的， 比如如下序列：
  + IVT使用者调用GAP_RegisterTransportLayerA设置回调gap_register_tl_cfm
  + GAP_RegisterTransportLayerA回调gap_register_tl_cfm
  + gap_register_tl_cfm调用GAP_ResetHardwareA并设置回调gap_reset_hardware_cfm
  + GAP_ResetHardwareA回调gap_reset_hardware_cfm
  + gap_reset_hardware_cfm调用GAP_SetLocalNameA并设置回调gap_set_local_name_cfm
  + gap_set_local_name_cfm 最后会调用btmgr_ready_cb
    | GAP_RegisterIndCbk          | 设置gap_indicate_cb为GAP的indication的处理函数  |
    | GAP_RegisterTransportLayerA | 设置协议栈使用的传输方式以及gap_register_tl_cfm |
    | GAP_ResetHardwareA          | 复位并设置 gap_reset_hardware_cfm               |
    | GAP_SetLocalNameA           | 设置bt设备名字，并设置回调gap_set_local_name_cfm          |
+ btmgr_ready_cb
  调用A2DP_RegisterService注册A2DP服务，设置a2dp_indicate_cb为A2DP事件的回调，同时记录应用层注册的回调
  调用A2DP_Register_SEP注册服务端点（sbc acc）
  最后调用GAP_SetVisualModeA设置GAP角色，让蓝牙变得可以被发现和连接。这样在有GAP相关的连接请求时就会会调用GAP_RegisterIndCbk设置的gap_indicate_cb回调函数
****** A2DP连接建立
+ gap_indicate_cb
  bt协议的基本处理都是通过GAP的事件回调开始的，在 gap_indicate_cb中处理GAP_IND_CONNECTION_EVENT事件来处理bt设备连接
+ a2dp_indicate_cb
  bt连接建立后， 会通过a2dp_indicate_cb来处理各种a2dp的时间，如A2DP_EV_STREAMOPEN，在该事件的处理中会通过回调应用层注册的处理函数btplay_stream_opened
+ btplay_stream_opened
  应用层的具体处理逻辑，比如播放提示音什么的。

***** 各模块大小

|---------------+------------------+-----------+-----------+-------------|
|               | module name      | code size | data size | rodata size |
|---------------+------------------+-----------+-----------+-------------|
| bt app        | btplay           |      1532 |         4 |          60 |
|---------------+------------------+-----------+-----------+-------------|
| bt mgr        |                  |     17144 |      4200 |         739 |
|               | actions/btdrv/   |     15676 |        69 |         712 |
|               | actions/btmgr/   |     12820 |      4127 |          27 |
|               | actions/btstack/ |      2348 |         4 |           0 |
|---------------+------------------+-----------+-----------+-------------|
| baseband      |                  |    285960 |      7118 |        5458 |
|               | core/lc/         |     65840 |      3112 |          16 |
|               | core/hc/         |     15104 |        28 |         680 |
|               | core/hw_rf/      |     30652 |       514 |        2144 |
|               | core/hw/         |      1212 |         0 |           0 |
|               | core/le/         |     44368 |       683 |          13 |
|               | core/lmp/        |     99688 |      1783 |        1585 |
|               | core/sys/        |      2716 |       902 |        1020 |
|               | core/bt          |      4232 |        30 |           0 |
|               | core/tc/         |     10182 |         0 |           0 |
|               | core/hcit/       |      2734 |         9 |           0 |
|               | core/transport/  |      9232 |        57 |           0 |
|---------------+------------------+-----------+-----------+-------------|
| core profiles |                  |     67416 |       159 |        1507 |
|               | hci_             |     19370 |        16 |        1003 |
|               | gap_             |     11136 |        44 |         144 |
|               | l2cap_           |     21176 |         5 |         224 |
|               | sdap_            |      6016 |        75 |           0 |
|               | sdp              |      9718 |        19 |         136 |
|---------------+------------------+-----------+-----------+-------------|
| profiles      |                  |     37446 |       628 |             |
|               | a2dp_            |      1692 |         8 |           0 |
|               | avctp_           |      3266 |         4 |           0 |
|               | avdtp_           |      9672 |         5 |           0 |
|               | avrcp_           |     10846 |         4 |           0 |
|---------------+------------------+-----------+-----------+-------------|
| others        |                  |           |           |             |
|               | others           |     11970 |       607 |           0 |
|---------------+------------------+-----------+-----------+-------------|

***** 总结
+ 应用开发是相对简单的，只需要注册关心的事件的回调就可以了。
+ btmgr层中，需要按照IVT的接口，提供各个核心协议要求的回调，相对比较复杂一些，每一个profile的开发都需要严格按照协议处理各个层次的bt协议的内容，相对来说胶水代码比较多。
+ IVT协议相对独立，规范性好，协议的完备性也都有。凡是需要用户处理的部分都通过回调的方式开放出来了。
*** zephyr bluetooth

*** 5118B
**** 平台主要优势
5118平台相对现在常见的mcu开发平台，主要的优势在于:
+ 蓝牙支持
+ 多格式解码支持
+ 音效，魔音，vad，录音等语音处理算法
目前的mcu开发平台大部分都不会提供这些组件，特别是蓝牙的协议栈，几乎没有看到开源的。
音频部分有一些开源的实现， 但开源的实现相对占用资源都比较大， 并且支持的格式也不多。
像wifi支持这些都不能算做优势，只是从侧面说明了我们平台的cpu和ram能够支持相对复杂的应用的例子。
**** 主要架构考虑
+ 基于开发板进行开发
  开发板需要满足主要
+ 使用统一的内存模型
  sdk不开源的部分， 比如蓝牙的hci之下的部分，音视频解码库都使用静态库的方式提供。
  整个应用，kernel，平台其他组件，采用统一链接的方式，生成一个可执行的文件。
  在链接文件中，用户可以统一的规划内存空间的使用， 可以把某些代码放在ram空间执行。
  sdk不会强制要求特别的地址空间，这样可以有利于客户程序的内存使用和规划。
+ 灵活的可配置选择
  对绝大部分的模块都采用可配置的方式，不需要的功能可以完全通过config的方式去掉代码和功能，去掉的内存不再占用空间。
+ 蓝牙协议栈选择
  倾向于选择zephyr的协议栈，主要有几点考虑：
  + zephyr的协议栈是开源的
    HCI层之上的所有协议用户都可以看到， 也就是说只要我们提供的hci层之下的baseband 和 链路管理层不出现问题，所有的兼容性问题，客户应该都有机会可以搞定。
    从目前了解的兼容性问题来看，比较大的部分不是协议本身的问题，更多是手机不规范需要再应用中workaround的问题。
    协议栈开源的话，用户想开发一些自有的蓝牙协议也是有机会的。
  + 使用zephyr协议栈可以更多利用社区的力量
    zephyr的协议栈，特别是BLE的部分，发展是比较快的。
  + zephyr相对于IVT体积更小，架构复杂性更低
    zephyr协议栈相对于IVT协议栈来说，封装较好，架构也更简洁一些，比容容易写上层应用， 不需要特别了解蓝牙协议栈的开发者都可以开发蓝牙应用。 深度定制的话，可能需要动到协议栈的代码。
    IVT协议栈提供了特别多的可能性，把几乎所有的协议中可以变化的部分都暴露出来给了上层，要写一个完整的蓝牙应用，一方面需要对蓝牙协议理解较深，另一方面还是要写比较多的代码才可以， 开发相对复杂。代码量也会比较大。就算是深度定制，也基本不需要改IVT协议栈本身的代码。
  + 避免重复做IVT的工作
    IVT协议栈以及上层的bt engine的工作蓝牙音箱重构完成后，可以直接porting过来。
    避免两边做重复的工作
  + 蓝牙兼容性的问题
    开发平台的话，思路主要是提供完善的底层平台支持，然后基于平台提供一些sample的应用，比如a2dp，hfp， avrcp， gatt等各种使用蓝牙协议的sample应用。
    提供sample应用的主要目的是为了演示如何使用蓝牙协议栈，针对这些sample做一下我们内部的兼容性是不是就够了。
    完整的兼容性是在最终的产品上来做的。
+ 应用开发和测试
  按照平台的思路来开发的话， 应用就是一些sample应用，整个平台可能有几十个sample的应用，比如：
  蓝牙：a2dp， avrcp，hfp，音频广播， beacon， hid等
  播放器:  播放mp3等格式， 播放pcm， pcm录制， amr录制
  系统相关：读写文件，读写card， led， gpio， usb 传输等
  如果有wifi：iperf，http client， http server， mqtt，ping等
  以及zephyr提供的其他的sample

  这部分sample的应用除了给客户展示如何基于平台开发应用外，也可以测试部的测试应用，测试部门可以基于这些应用来编写系统测试用例，兼容性测试也可以使用这些应用来测试。
+ 平台测试
  平台按照模块的测试采用自动化测试的方式进行， 这部分主要针对应用编程接口测试，类似android的cts测试。主要针对的是应用开发可见的编程接口。
  不测试模块内部自身的逻辑。
+ 文档
  文档整合的目标可以分阶段进行：
  + 基本开发文档
    开发板相关的硬件文档，IC的data sheet
    快速入门开发环境建立， api编程手册，工具使用文档
  + 各个模块的设计文档
    这部分根据实际的情况，逐步完成。
** WICED BT代码结构
*** a2dp sink
**** apps
***** APPLICATION_START()
+ wiced_bt_stack_init( a2dp_sink_management_callback , &a2dp_sink_cfg_settings, a2dp_sink_cfg_buf_pools);
***** a2dp_sink_management_callback
+ a2dp_sink_management_callback
  switch( event )
  + case BTM_ENABLED_EVT:
    + a2dp_sink_write_eir( );
      + pBuf = (uint8_t*)wiced_bt_get_buffer( WICED_HS_EIR_BUF_MAX_SIZE );
      + wiced_bt_dev_write_eir( pBuf, (uint16_t)(p - pBuf) );
    /* create SDP records */
    + wiced_bt_sdp_db_init( ( uint8_t * )a2dp_sink_sdp_db, sizeof( a2dp_sink_sdp_db ) );
    /* start the a2dp application */
    + av_app_init();
      + result = wiced_bt_a2dp_sink_init( &bt_audio_config,  a2dp_sink_control_cback );
        + wiced_bt_a2dp_sink_init_state_machine
          + static const wiced_bt_a2dp_sink_sst_tbl_entry_t wiced_bt_a2dp_sst_tbl[] =
        + wiced_bt_a2dp_sink_cb.p_config_data = p_config_data
        + wiced_bt_a2dp_sink_register()
          + wiced_bt_a2dp_sink_init_ccb();
            + wiced_bt_a2dp_sink_cb.ccb[idx].p_dt_cback = wiced_bt_a2dp_sink_ctrl_cback;
          + wiced_bt_avdt_register(&reg, wiced_bt_a2dp_sink_conn_cback);//rom
          + wiced_bt_a2dp_sink_reg_a2dp(&cs, p_scb);
        + wiced_audio_sink_config_init(&p_config_data->p_param)
      + wiced_bt_a2dp_sink_register_data_cback( a2dp_sink_data_cback );
    /* Making the sink device discoverable and connectable */
    wiced_bt_dev_set_discoverability( BTM_GENERAL_DISCOVERABLE, BTM_DEFAULT_DISC_WINDOW, BTM_DEFAULT_DISC_INTERVAL );
    wiced_bt_dev_set_connectability(  WICED_TRUE, BTM_DEFAULT_CONN_WINDOW, BTM_DEFAULT_CONN_INTERVAL );
  + case  BTM_PIN_REQUEST_EVT:
    wiced_bt_dev_pin_code_reply(*p_event_data->pin_request.bd_addr,result/*WICED_BT_SUCCESS*/,4, &pincode[0]);
  + case BTM_USER_CONFIRMATION_REQUEST_EVT:
    wiced_bt_dev_confirm_req_reply( WICED_BT_SUCCESS, p_event_data->user_confirmation_request.bd_addr );
  + case BTM_PASSKEY_NOTIFICATION_EVT:
  + case BTM_PAIRING_IO_CAPABILITIES_BR_EDR_REQUEST_EVT:
    p_event_data->pairing_io_capabilities_br_edr_request.local_io_cap = BTM_IO_CAPABILITIES_NONE;
    p_event_data->pairing_io_capabilities_br_edr_request.auth_req = BTM_AUTH_SINGLE_PROFILE_GENERAL_BONDING_NO;
  + case BTM_PAIRING_COMPLETE_EVT:
    p_pairing_cmpl = &p_event_data->pairing_complete;
    if( p_pairing_cmpl->transport == BT_TRANSPORT_BR_EDR )      {
     pairing_result = p_pairing_cmpl->pairing_complete_info.br_edr.status;      }
  + case BTM_ENCRYPTION_STATUS_EVT:
    p_encryption_status = &p_event_data->encryption_status;
  + case BTM_PAIRED_DEVICE_LINK_KEYS_UPDATE_EVT:
    a2dp_sink_write_nvram( A2DP_SINK_NVRAM_ID, sizeof( wiced_bt_device_link_keys_t ), &p_event_data->paired_device_link_keys_update );
  + case  BTM_PAIRED_DEVICE_LINK_KEYS_REQUEST_EVT:
    if ( a2dp_sink_read_nvram( A2DP_SINK_NVRAM_ID, &p_event_data->paired_device_link_keys_request, sizeof(wiced_bt_device_link_keys_t)) != 0 )      {
    result = WICED_BT_SUCCESS;
  + case BTM_POWER_MANAGEMENT_STATUS_EVT:
    p_power_mgmt_notification = &p_event_data->power_mgmt_notification;
    p_power_mgmt_notification->status, p_power_mgmt_notification->hci_status);
+ wiced_audio_buffer_initialize (a2dp_sink_audio_buf_config);

***** av_app_init
 + av_app_init();
   + result = wiced_bt_a2dp_sink_init( &bt_audio_config,  a2dp_sink_control_cback );
     + wiced_bt_a2dp_sink_init_state_machine
       + static const wiced_bt_a2dp_sink_sst_tbl_entry_t wiced_bt_a2dp_sst_tbl[] =
     + wiced_bt_a2dp_sink_cb.p_config_data = p_config_data
     + wiced_bt_a2dp_sink_register()
       + wiced_bt_a2dp_sink_init_ccb();
         + wiced_bt_a2dp_sink_cb.ccb[idx].p_dt_cback = wiced_bt_a2dp_sink_ctrl_cback;
       + wiced_bt_avdt_register(&reg, wiced_bt_a2dp_sink_conn_cback);//rom
       + wiced_bt_a2dp_sink_reg_a2dp(&cs, p_scb);
     + wiced_audio_sink_config_init(&p_config_data->p_param)
   + wiced_bt_a2dp_sink_register_data_cback( a2dp_sink_data_cback );
     + wiced_audio_sink_register_data_cback( p_cback );
***** a2dp_sink_control_cback
+ {WICED_BT_A2DP_SINK_API_START_EVT            , WICED_BT_A2DP_SINK_OPEN_SST       , wiced_bt_a2dp_sink_do_start},
  + wiced_bt_a2dp_sink_do_start
    + wiced_bt_a2dp_sink_start_ok
      + (*wiced_bt_a2dp_sink_cb.control_cb)(WICED_BT_A2DP_SINK_START_CFM_EVT, (wiced_bt_a2dp_sink_event_data_t *) &start);
      + a2dp_sink_control_cback
        + case WICED_BT_A2DP_SINK_CODEC_CONFIG_EVT:
        + case WICED_BT_A2DP_SINK_CONNECT_EVT
        + case WICED_BT_A2DP_SINK_START_IND_EVT
          + wiced_bt_a2dp_sink_send_start_response( p_data->start_ind.handle, p_data->start_ind.label, A2D_SUCCESS )
        + case WICED_BT_A2DP_SINK_START_CFM_EVT
        + av_app_cb.state = AV_STATE_STARTED
***** a2dp_sink_data_cback
+ WICED_BT_TRACE( "A2DP data %x, %d\n",p_a2dp_data, a2dp_data_len );
**** librarys
***** wiced_bt_a2dp_sink_init
   + result = wiced_bt_a2dp_sink_init( &bt_audio_config,  a2dp_sink_control_cback );
     + wiced_bt_a2dp_sink_init_state_machine
       + static const wiced_bt_a2dp_sink_sst_tbl_entry_t wiced_bt_a2dp_sst_tbl[] =
     + wiced_bt_a2dp_sink_cb.p_config_data = p_config_data
     + wiced_bt_a2dp_sink_cb.control_cb = control_cb;
     + wiced_bt_a2dp_sink_register()
       + p_scb = wiced_bt_a2dp_sink_cb.p_scb
       + wiced_bt_a2dp_sink_init_ccb();
         + wiced_bt_a2dp_sink_cb.ccb[idx].p_dt_cback = wiced_bt_a2dp_sink_ctrl_cback;
       + reg.ctrl_mtu = WICED_BT_A2DP_SINK_AVDT_SIG_CH_MTU;
         reg.ret_tout = WICED_BT_A2DP_SINK_RET_TOUT;
         reg.sig_tout = WICED_BT_A2DP_SINK_SIG_TOUT;
         reg.idle_tout= WICED_BT_A2DP_SINK_IDLE_TOUT;
       + wiced_bt_avdt_register(&reg, wiced_bt_a2dp_sink_conn_cback);//rom
       + wiced_bt_a2dp_sink_reg_a2dp(&cs, p_scb);
         + p_cs->cfg.psc_mask  = AVDT_PSC_TRANS;
           p_cs->media_type    = AVDT_MEDIA_AUDIO;
         + p_cs->p_ctrl_cback  = wiced_bt_a2dp_sink_ctrl_cback;
         + memcpy(&(p_scb[index].cfg), &p_cs->cfg, sizeof(wiced_bt_avdt_cfg_t));
         + ret = wiced_bt_a2dp_sink_cfg_init(&wiced_bt_a2dp_sink_cb.p_config_data->codec_capabilities.info[c_index],
           p_cs->cfg.codec_info,
           &p_cs->cfg.num_protect,
           p_cs->cfg.protect_info)
         + wiced_bt_avdt_create_stream(&(wiced_bt_a2dp_sink_cb.seps[sep_index].av_handle), p_cs)
         + wiced_bt_a2dp_sink_cb.seps[sep_index].codec_type =
           wiced_bt_a2dp_sink_cb.p_config_data->codec_capabilities.info[c_index].codec_id;
     + wiced_audioe_sink_config_init(&p_config_data->p_param)
******* wiced_bt_a2dp_sink_ctrl_cback
  + wiced_bt_a2dp_sink_ctrl_cback
    + wiced_bt_a2dp_sink_proc_stream_evt(handle, bd_addr, event, p_data);
      + memcpy(&p_msg->msg, p_data, sizeof (wiced_bt_avdt_ctrl_t));
      + case AVDT_CONFIG_IND_EVT:
      + memcpy(&p_msg->cfg, p_data->config_ind.p_cfg, sizeof(wiced_bt_avdt_cfg_t));
      + p_msg->hdr.event = wiced_bt_a2dp_sink_stream_evt_ok[event];
      + wiced_bt_a2dp_sink_hdl_event((BT_HDR*)p_msg);
        + p_ccb = wiced_bt_a2dp_sink_get_ccb(event, p_data)
          + p_ccb = wiced_bt_a2dp_sink_get_ccb_by_bd_addr(p_data->str_msg.bd_addr);
            + p_ccb = &wiced_bt_a2dp_sink_cb.ccb[idx];

***** wiced_bt_a2dp_sink_conn_cback
+ if (event == AVDT_CONNECT_IND_EVT || event == AVDT_DISCONNECT_IND_EVT)
  evt = WICED_BT_A2DP_SINK_SIG_CHG_EVT;
+ wiced_bt_a2dp_sink_hdl_event((BT_HDR*)&str_msg)
  + wiced_bt_a2dp_sink_get_ccb
    + case WICED_BT_A2DP_SINK_A一些PI_CONNECT_EVT:
    + p_ccb = wiced_bt_a2dp_sink_alloc_ccb(p_data);
      + wiced_bt_a2dp_sink_cb.ccb[idx].in_use     = WICED_TRUE;
      + wiced_bt_a2dp_sink_cb.ccb[idx].ccb_handle = idx;
      + wiced_bt_a2dp_sink_cb.ccb[idx].p_scb      = &(wiced_bt_a2dp_sink_cb.p_scb[idx]);
      + wiced_bt_a2dp_sink_cb.ccb[idx].p_dt_cback = wiced_bt_a2dp_sink_ctrl_cback;
    + case WICED_BT_A2DP_SINK_AVDT_CONNECT_EVT:
    + p_ccb = wiced_bt_a2dp_sink_get_ccb_by_bd_addr(p_data->str_msg.bd_addr);
    + case WICED_BT_A2DP_SINK_API_START_EVT:
    + p_ccb = wiced_bt_a2dp_sink_get_ccb_by_handle(p_data->api_data.handle);
  + wiced_bt_a2dp_sink_ssm_execute(p_ccb, p_data, p_msg->event);
    + state_table_entry = wiced_bt_a2dp_sst_tbl[p_ccb->state];
    + found = wiced_bt_a2dp_sink_search_event(state_table_entry, event, &next_state, &pfhandler);
    + p_ccb->state  = next_state;
    + pfhandler(p_ccb, p_data);
****** wiced_bt_a2dp_sink_connect_req
{WICED_BT_A2DP_SINK_SDP_DISC_OK_EVT          ,WICED_BT_A2DP_SINK_SIG_OPENING_SST,wiced_bt_a2dp_sink_connect_req},
+ wiced_bt_avdt_connect_req(p_ccb->peer_addr, 0/*Not Used*/, p_ccb->p_dt_cback);

**** ROM
wiced_bt_stack_init
wiced_bt_avdt_register
wiced_bt_avdt_create_stream
wiced_bt_avdt_connect_req(p_ccb->peer_addr, 0/*Not Used*/, p_ccb->p_dt_cback);
wiced_audioe_sink_config_init(&p_config_data->p_param)
wiced_audio_sink_register_data_cback( void* p_cback );

*** zephyr
  + btmgr_start(btmgr_ready_cb);
    + err = ivtmgr_rdm_init();
      + p_rdm = NEW(sizeof(struct ivtmgr_rdm_priv));
      + k_delayed_work_init(&p_rdm->auto_conn_work,
        _auto_connection_work_handler);
      + _paired_info_restore();
        + nvram_config_get(BTMGR_PAIRED_INFO_NVRAM_NAME,
      + _autoconn_info_restore();
        + nvram_config_get(BTMGR_AUTOCONN_INFO_NVRAM_NAME,
    + err = ivtmgr_drv_init(ivtmgr_drv_rx_cb);
      + init_con_env();
        + init_btrom_bss ();
        + load_func_tab();
        + load_btrom_data();
      + g_rx_cb = rx_cb;
      + btc_cfg.rf_txpower_adjust = 7;
        btc_cfg.uart_transport_en = 0;
        btc_cfg.feature_pkg=0;
        btc_cfg.low_freq_available = 1;
        btc_cfg.gpio_debug_mask = 0;
        btc_cfg.log_mask = CON_LOG_MASK_OUTPUT | CON_LOG_VIA_UART;
        btc_cfg.is_fpga = 0;
      + con_init(&btc_cfg);
      + con_general_register_cbk(hci_host_buf_req_cb,
        hci_host_buf_commit_cb,
      + k_thread_spawn(g_schedule_loop_stack, schedule_loop_thread,
      + k_thread_spawn(g_schedule_loop_low_stack,
        schedule_loop_low_thread,
    + g_ready_cb = cb;
    + err = btstack_init();
      + BtInit();
      + k_thread_spawn((void *)ScheduleLoop, NULL, NULL,
      + GAP_RegisterIndCbk(NULL, GAP_IND_ALL, gap_indicate_cb);
      + GAP_RegisterTransportLayerA((HANDLE)&g_tl_hdl,
        (TransportLayerStru *)&g_uart_tl_func,
        gap_register_tl_cfm);

  static const TransportLayerStru g_uart_tl_func = {
          uart_tl_get_type,
          uart_tl_startup,
          uart_tl_shutdown,
  + uart_tl_send,
    + ivtmgr_drv_send(data, len);
      + pbuf = con_buf_req(ptype, NULL, data_size);
      + memcpy(pbuf, data + (len - data_size), data_size);
      + con_buf_commit(ptype, pbuf, data_size);
          uart_tl_start_sco,
          uart_tl_stop_sco,
  };

  static const struct btmgr_a2dp_callbacks a2dp_cbs = {
          .stream_opened = btplay_stream_opened,
          .stream_closed = btplay_stream_closed,
          .pcm_indicated = btplay_pcm_indicated,
  };

  + btmgr_ready_cb
    + btmgr_a2dp_start(&a2dp_cbs);
      + p_a2dp = NEW(sizeof(struct ivtmgr_a2dp_priv));
      + p_a2dp->cbs = cbs;
      + in = NEW(sizeof(struct A2DP_RegCbkStru));
      + in->cbk = a2dp_indicate_cb;
      + A2DP_RegCbk(in);
      + p_a2dp->snk_svc_hdl = A2DP_RegisterService(A2DP_TSEP_SNK,
        A2DP_SPEAKER);
      + a2dp_snk_sep_register();
        + sep = List_NodeNew(sizeof(struct A2DP_SEPStru) + len);
        + sep->mask = AVDTP_SEPMASK_ISSNKSVC;
          sep->media_type = (A2DP_MEDIATYPE_AUDIO << 4) | (A2DP_TSEP_SNK
          << 3);
                  p = sep->sc.service_capability;
                  p[1] = A2DP_SC_MEDIA_TRANSPORT;
                  p[2] = 0;
                  p[3] = A2DP_SC_MEDIA_CODEC;
                  p[4] = 6;
                  p[5] = A2DP_MEDIATYPE_AUDIO << 4;
                  p[6] = A2DP_CODEC_SBC;
                  p[7] = A2DP_SBC_SF_ALL | A2DP_SBC_CHMODE_ALL; /* some
                  phone(XT319) need support all SF. */
                  p[8] = A2DP_SBC_BLOCK_ALL | A2DP_SBC_SUBBAND_ALL |
                  A2DP_SBC_ALLOCATION_ALL;
                  p[9] = 2;
                  p[10] = CONFIG_BTMGR_A2DP_BITPOOL;
        + A2DP_Register_SEP(sep);
      + audioout_hdl = audio_out_device_create();
    + btmgr_avrcp_start(NULL);
    + btmgr_br_set_discoverable(true);
      + GAP_SetVisualModeA((HANDLE)&g_tl_hdl, NULL, g_visual_mode,
        NULL);
    + btmgr_br_set_connnectable(true);
      + GAP_SetVisualModeA((HANDLE)&g_tl_hdl, NULL, g_visual_mode,
        NULL);

  + a2dp_indicate_cb
    + case A2DP_EV_REGSEP:
    + a2dp_sep_registerd(param);
    + case A2DP_EV_STREAMCREATE:
    + a2dp_stream_created(param);
    + case A2DP_EV_SETCONFIGURATION:
    + a2dp_stream_setconfig(param);
    + case A2DP_EV_OPENCODECINFO:
    + a2dp_stream_opencodecinfo(param);
    + case A2DP_EV_STREAMOPEN:
    + a2dp_stream_open(param);
    + case A2DP_EV_STREAMSTART:
    + a2dp_stream_start(param);
    + case A2DP_EV_DATAIND:
    + a2dp_data_ind(param);
      + sbc_info.input = BUFDATA(in->data);
        sbc_info.input_len = DATASIZE(in->data);
        sbc_info.output = NEW(512); /* TODO */
      + audio_decoder_ops_sbc(p_a2dp->decsbc_handle,
        SBC_CMD_FRAME_DECODE,
        (unsigned int)&sbc_info);
      + __pcm_data_out((uint16_t *)sbc_info.output, sbc_info.output_len
        / 2);
    + case A2DP_EV_STREAMSUSPEND:
    + FREE(param);
    + case A2DP_EV_STREAMDONE:
    + a2dp_stream_done(param);

  + gap_register_tl_cfm(HANDLE tl_hdl, UINT16 result, struct
    GAP_RegisterTLCfmStru *cfm_par)
    + GAP_ResetHardwareA(tl_hdl, NULL, gap_reset_hardware_cfm);
      + gap_reset_hardware_cfm
      + gap_start();
        + UINT8 class_of_device[4] = {0x04, 0x04, 0x24}; /* TODO */
        + UINT8 device_name[] = "zephyr-ivt"; /* TODO */
        + GAP_SetLocalDeviceClassA((HANDLE)&g_tl_hdl, NULL,
          class_of_device, NULL);
        + GAP_SetIOCapability((UINT8)HCI_IO_CAPABILITY_NOINPUTNOOUTPUT);
        + GAP_SetLocalNameA((HANDLE)&g_tl_hdl, NULL, device_name,
          sizeof(device_name), gap_set_local_name_cfm);
          + ivtmgr_rdm_auto_connection_start(true);
            + k_delayed_work_submit(&p_rdm->auto_conn_work,
              BTMGR_AUTOCONN_INTERVAL);
            + _auto_connection_work_handler
              + btmgr_a2dp_connect(false, p_rdm->auto_conn.addr);
              + btmgr_avrcp_connect(p_rdm->auto_conn.addr);
              +

  + gap_indicate_cb
      +switch (ind_type) {
    + case GAP_IND_INQUIRY_COMPLETE:
    + case GAP_IND_INQUIRY_RESULT:
    + case GAP_IND_CONNECTION_REQUEST:
    + case GAP_IND_CONNECTION_EVENT:
    + rmt_dev_connection_handle(param);
      + struct GAP_ConnectionEventStru *in = param;
      + ivtmgr_rdm_connected(in->addr.bd);
        + dev = _find_connected_dev(addr);
        + dev = NEW(sizeof(struct rdm_device));
        + memcpy(dev->bt_addr, addr, IVTMGR_BD_ADDR_LEN);
        + sys_slist_append(&p_rdm->dev_list, &dev->node);
    + case GAP_IND_PIN_CODE_REQ:
    + return rmt_dev_pincode_reply(param);
      + strcpy(reply.pin_code, CONFIG_BTMGR_DEV_FIX_PINCODE);
      + GAP_ExecuteCommandA((HANDLE)&g_tl_hdl, NULL,
    + case GAP_IND_LINK_KEY_NOTIFICATION:
    + rmt_dev_link_key_created(param);
      + ivtmgr_rdm_paired(in->remote_bd, in->link_key, in->key_type)
      + dev = _find_connected_dev(addr);
      + entry = _find_paired_entry_by_addr(addr);
      + memcpy(entry->remote_addr, addr, IVTMGR_BD_ADDR_LEN);
      + memcpy(entry->link_key, link_key, IVTMGR_LINKKEY_SIZE);
      + _paired_info_save();
        + nvram_config_set(BTMGR_PAIRED_INFO_NVRAM_NAME,
          (const void *)p_rdm->paired_list,
    + case GAP_IND_LINK_KEY_REQUEST:
    + return rmt_dev_link_key_reply(param);
      + struct HCI_Security_Link_Key_Request_ReplyStru cmd;
      + ivtmgr_rdm_get_link_key(in->remote_bd, cmd.link_key,
        &cmd.key_type)
      + GAP_LinkKeyReply((HANDLE)&g_tl_hdl, &cmd);
    + case GAP_IND_AUTHENTICATION_FAILURE:
    + case GAP_IND_REMOTE_DEVICE_NAME_UPDATED:
    + case GAP_IND_USER_CONFIRMATION_REQUEST:
    + case GAP_IND_USER_PASSKEY_REQUEST:
    + case GAP_IND_SIMPLE_PAIRING_COMPLETE:
    + case GAP_IND_USER_PASSKEY_NOTIFICATION:
    + case GAP_IND_AUTHORIZATION_REQUEST:
    + case GAP_IND_AUTHORIZATION_ABORT:


  + hci_host_buf_req_cb
    + mem_malloc(len);

  + hci_host_buf_commit_cb
    + g_rx_cb(buf, len, qType);
    + ivtmgr_drv_rx_cb
    + k_thread_spawn(btstack_schedule_loop_stack, (void *)ScheduleLoop,
    + GAP_RegisterIndCbk(NULL, GAP_IND_ALL, gap_indicate_cb);
    + GAP_RegisterTransportLayerA((HANDLE)&g_tl_hdl,
      (TransportLayerStru *)&g_uart_tl_func,
      gap_register_tl_cfm);


  + schedule_loop_thread
    + con_schedule_high_loop(255);

  + schedule_loop_low_thread
    + con_schedule_low_loop(255);

  + btmgr_ready_cb
    + btmgr_a2dp_start(&a2dp_cbs);
      + p_a2dp = NEW(sizeof(struct ivtmgr_a2dp_priv));
      + in = NEW(sizeof(struct A2DP_RegCbkStru));
      + in->media_type = A2DP_MEDIATYPE_AUDIO;
      + in->cbk = a2dp_indicate_cb;
      + A2DP_RegCbk(in);
      + p_a2dp->snk_svc_hdl = A2DP_RegisterService(A2DP_TSEP_SNK,
        A2DP_SPEAKER);
      + a2dp_snk_sep_register();
    + btmgr_avrcp_start(NULL)
    + btmgr_br_set_discoverable(true);
    + btmgr_br_set_connnectable(true);

  + a2dp_indicate_cb
  +

** 20170601：平台方向后续规划
#+TITLE:  20170601：平台方向后续规划
*** IC情况
平台的规划主要考虑如下ic平台
+ AP类IC  5202  5211 5209
+ 5116C  5118B  3503 带cache架构的蓝牙IC
+ 5601 BLE IC
+ 耳朵IC  cortex M3 + DSP
+ camera + WIFI小系统
+ cortex A5 + DSP的眼睛IC
*** 平台状况
**** RTOS MIPS平台
***** 主要适配IC
+ 3503，后续考虑 5118B，  5116C， 以及将来camera + wifi IC
***** IC特点
+ nor base
+ cache 架构，可以XIP来执行代码
+ soc内部有限SRAM
***** 主要SDK诉求
+ 方便应用开发和debug
+ Nor 和RAM空间占用要小
+ 功能方便裁剪以节省NOR和内存
***** 主要设计决策
+ kernel使用Zephyr OS，zephyr OS具有以下特点：
  + 有的代码编译成一个二进制
     系统中不存在重复代码，可以节省nor的空间
     没有动态加载的二进制，可以更好防网络攻击
  + 提供了完整的IOT相关协议栈
    蓝牙BLE支持
    WIFI以及网络协议栈支持
    支持zigbee和路由
    支持TLS等安全加密库
  + 提供和很精细的功能可配置
    可以去除不需要的功能，来减少ram和nor代码占用
  + 提供驱动模型
    可以比较好的隔离应用和驱动
  + 有较好的社区支持，社区开发比较活跃
+ 全新设计的应用框架
  + 设计了服务模型，对常见的系统功能（播放，录音，mqtt服务）做成独立的服务，服务独立于应用，可以被多种不同的应用使用
  + 产品整个功能按照场景进行进行合理划分多个应用，故事机划分成多个功能独立的子模块，由应用管理器来管理，主要应用模块有：播放音乐，后台下载 网络配对  百科问答  微信留言 播放tts  PCBA
  + 应用，服务，系统之间使用消息传递的通信方式来实现松耦合
  + 使用steam来封装网络流，文件等数据源，简化应用开发。
+ 系统级的设计优化
  + 设计zero copy技术在驱动，网络协议栈，解码，播放共享同一份数据，极大的减少了内存开销。
  + 设计了避免内存碎片的内存管理方法，从机制上解决碎片问题
  + 设计overlay机制来让不同的解码格式共享同一块内存
  + 应用都是互斥运行的，不同的应用实现复用内存。
  + 精心处理网络策略来在保证网络稳定性的情况下，减少内存占用
    1. tcp 延迟回复ACK来避免重发
    2. 发送数据包使用small buffer避免占用更大buffer
+ 性能和调试的便利性
  + 支持最新的GCC工具链
  + 支持标准JTAG工具
    可以使用业界通用的JTAG调试工具，以及常见的JTAG调试软件，比如gdb， eclipse
  + 提供功能丰富的串口命令行工具
    可以通过串口来做系统系能优化，现场debug等，可以查看系统
    + 设置系统的运行参数
    + 查看cpu负载
    + 统计cache miss情况
    + 查看各个任务的线程栈
    + 查看内存分配情况，任务栈的使用情况
    + 网络相关的各个内存buffer情况。
    + 其他常用的功能
  + 增加了运行期监控
    + 检查堆栈溢出
    + 检查应用的内存泄露
    + 检查系统的最大关中断时间
    + 系统panci时，提供调用栈的完整backtrace，并提供符号支持
***** 不足之处
+ 由于是mips架构， 目前只能支持GCC编译工具链。
  不太容易支持Keil，IAR等集成开发，调试的IDE环境
+ JTAG目前只支持5PIN的，不支持2PIN的SWD
+ MIPS相对ARM对栈的消耗更多一些，内存需求好高一些
+ 社区和生态，相对于arm会差比较大，比如不能支持arm mbed OS以及CMSIS DAP等现在更主流的调试方式。
***** 后续计划
+ 持续跟踪zephyr的版本跟新和动态
+ 目前平台已经整合了wifi， BLE 后续需要整合传统l蓝牙功能
+ 目前应用框架和协议栈都还有一些优化工作需要继续完成
**** RTOS ARM 平台
***** 主要适配IC
+ 5601 耳朵ic， 这里暂时只考虑5601
***** IC特点
+ ROM中固化了协议栈，应用框架以及典型的beacon，数传应用
+ 外挂EEPROM作为规模较小的个性化开发
+ 外挂Nor来支持更复杂的协议栈和应用场景
+ 目前TestChip使用了bank架构，后续正式版建议改成cache架构。
+ Bank架构和cache架构在可开发性上有如下缺点
  + RODATA 不能够放在nor上，需要占用ram空间
  + 程序中一些small literals不能放在nor上，需要占用ram空间
  + 在使用调试器的时候，会看到bank切换这个动作，不能做到完全透明。
***** 主要SDK诉求
+ 方便应用开发和debug
+ EEPROM方案程序需要尽可能的小
+ Nor方案需要尽可能方便开发
***** 主要设计决策
****** EEPROM方案
+ 尽可能的固化更多代码，固化代码包括：各种驱动，蓝牙协议栈，应用框架。
+ ROM中固化了了cordio的代码，以降低风险
+ EEPROM开发只需要编写应用本身逻辑代码，其他部分通过调用ROM中的函数实现。
****** 外挂NOR 方案
+ 在优先考虑开放式开发的时候， 可以不使用ROM中固化的代码
+ 程序代码较大的时候使用bank机制
+ 可以支持更多的OS平台，比如zephyr，mbed OS
****** 开发便利性
+ 支持gcc编译，和标准的jtag调试
+ 支持KEIL等业界常见的IDE环境，可以支持标准的烧写flash，单步调试等操作
+ 支持arm的CMSIS DAP调试规范，可以通过一个usb接口同时支持串口，U盘，以及jtag
+ 使用统一编译的方式，
  整个程序，包括ROM中的patch代码，蓝牙controller的patch代码都在一个工程内可以编译出来，实现所见即所得的开发模式
+ 提供了EEPROM和nor上应用开发的样板工程，简化客户应用程序开发
+ 提供类似业界的主流开发板，以及相应的调试接口
+ 可以使用keil工具增加我们开发的插件，即可完善支持KEIL IDE
***** 不足之处
+ 由于bank架构，所以在程序代码较大的时候， 需要使用bank的时候， 在调试器中能够看到bank切换的过程，从而和真正的EFLASH的调试方式有一些不同
***** 后续计划
+ 完善sdk文档
+ 完善开发板支持
+ nor方案支持zephyr OS
+ nor方案支持mbed OS
**** Linux 音频平台
***** 主要适配IC
+ ATS3605 (GL5202E)
***** IC特点
+ 4核A5， 55nm， 256M DDR
+ SLC NAND 或 Nor base
***** 主要SDK诉求
+ 可以给算法类公司提供一个比较好的开发平台，比较容易的验证算法
+ 可以提供给方案公司，可以开发基于音频播放，录音，以及支持网络的类似WIFI音箱的产品
+ 可以对接比较常见的智能云平台，比如amazon的AVS服务
***** 主要设计决策
+ 需要支持标准的linux工具链，以利于算法公司整合第三方开源库
+ 整合一个标准的比较适合音频的Linux发行版，openWRT
+ 支持alsa lib等linux比较常用的音频相关库
+ 支持一个常用的Linux的音频播放框架
+ 开发一个示例的音频播放程序
+ 对接上amazon的avs云，以及其他元
+ 支持WIFI BT等无线功能
+ BSP尽量规范化，考虑和S700 S900整合到同一个BSP中以方便维护
***** 后续计划
标案立项，分两步走：
1. 基于现有BSP（3703 BSP），整合openWRT，以及支持alsa lib，可以提供给算法公司使用
2. BSP整合到S700，同时完善需要的其他功能，然后发布
**** Linux 视频平台
***** 主要适配IC
+ ATS3703 (GL5202E)
***** IC特点
+ 4核A5， 55nm， 256M DDR
+ SLC NAND 或 Nor base
***** 主要SDK诉求
+ 由于客户熟悉uc平台的开发方式，所以需要api和应用框架都兼容uc
+ 需要支持SWF格式播放
+ 支持视频聊天和图像识别
***** 主要设计决策
+ 保持和7051同一个BSP
  不采用LS360X原来的音视频框架和显示框架，原来框架对bsp改动太多，增加了很多非标准的ioctl
+ 裁剪Android 只剩下NDK中必要的部分，没有java部分。 这样可以复用android平台已经稳定和兼容性没有问题的底层。
+ 使用andriod NDK的开发方式，适配uc平台原有的应用框架
+ UI图层叠加仍然只能使用GPU
+ 移植Android平台的浏览器的FLASH插件，在NDK环境跑起来支持SWF播放
***** 不足之处
+ 需要熟悉android NDK的开发或者熟悉我们uc平台的开发方式
+ 由于使用了android的工具链，不太容易整合标准的Linux的第三方应用程序
  整合第三方应用库的时候， 需要做一些调整才行。虽然大部分的调整并不大，但也是一个障碍
***** 后续计划
+ 会基于这个平台做一些差异化，比如音频+camera类的应用
+ 后续会转给小姚部分做差异化开发
**** Linux桌面版
***** 主要适配IC
+ 5211 5209
***** IC特点
+ 4核A53， 28nm， >512M DDR
+ emmc或nand base
***** 主要SDK诉求
+ 支持Ubuntu或debian等主流系统
+ 支持音视频的硬解码
+ 支持GPU硬件加速
+ LInux版本需要及时更新
***** 主要设计决策
+ 使用S700，S900的android版本同一个bsp来支持多个linux发行版
+ 使用uboot和dts配置
+ kernel 版本支持3.10.57
+ boot中使用arm trust firmware保证及时有频率映射，也能够保证kernel开源
+ Kernel有关SOC的部分采用标准的子系统框架，比如pin ctrl，dma engine，clk framework，以利于将来的upstream的操作
***** 不足之处
+ kernel版本已经偏低
+ 尚未支持视频硬解码加速
+ 尚未支持GPU硬加速
***** 后续计划
+ 升级内核版本到一个比较主流的版本
+ 支持视频硬件加速
**** Android平台
***** 主要适配IC
 + 5211 5209
***** IC特点
+ 4核A53， 28nm， >512M DDR
+ emmc或nand base
***** 主要SDK诉求
+ 支持512M DDR
+ android新版本支持
***** 主要设计决策
+ 和LInux 桌面版使用同一个BSP
***** 后续计划
+ 支持更新的Android版本
*** 人员情况
**** 人员在平台项目间分配情况
|--------+------------+-----------------+--------+------------------------|
| 人员   | 职称       | 平台            |   项目 | 负责模块               |
|--------+------------+-----------------+--------+------------------------|
| 刘炜   | 高级工程师 | RTOS            |   3503 | SDK TL                 |
| 汪辉   | 高级工程师 | RTOS            |   3503 | CASE TL                |
| 李鹏   | 资深工程师 | RTOS            |   3503 | 蓝牙                   |
| 李钊军 | 工程师     | RTOS            |   3503 | 网络 wifi              |
| 蒋斌   | 工程师     | RTOS            |   3503 | 应用开发               |
| 吕锦昂 | 工程师     | RTOS            | 3503 | USB 文件系统               |
|--------+------------+-----------------+--------+------------------------|
| 魏华铭 | 高级工程师 | RTOS            |   5601 | SDK TL                 |
| 刘世军 | 资深工程师 | RTOS            |   5601 | CASE TL                |
|--------+------------+-----------------+--------+------------------------|
| 宋智宁 | 高级工程师 | Android &Linux  |   3605 | CASE TL                |
| 廖田养 | 资深工程师 | Android &Linux  |   3605 | SDK TL                 |
| 孙成志 | 资深工程师 | Android &Linux  |   3605 | 音视频框架，播放器           |
| 荣幸   | 工程师     | Android & Linux |   3605 | 音频，alexa AVS        |
| 刘燚光 | 工程师     | Android & Linux |   3605 | camera&boot&nand flash |
| 刘新旭 | 工程师     | Android & LInux |   3605 | WIFI/BT                |
|--------+------------+-----------------+--------+------------------------|
| 黄俊敏 | 资深工程师 | Android &Linux  |   S700 | GPU，显示， 双系统     |
| 黄海宇 | 工程师     | Andriod & Linux |   S700 | 显示，LCD，HDMI          |
|--------+------------+-----------------+--------+------------------------|
| 蒲进   | 高级工程师 | All             | 无特定 | 项目管理，3503 ota     |
| 张东风 | 经理       | All             | 无特定 | 架构决策，内存管理     |
|--------+------------+-----------------+--------+------------------------|
**** 目前人员状况的一些考虑
+ android/Linux平台
  没有新IC和新的大的标案，人员基本上都需要兼顾原来负责的模块
  同时也需要学习和掌握更多新的模块
+ 在RTOS这边需要更多人员的时候，会从Andoid LInux这边继续抽调
+ 从android/LInux抽调过来的人员在原来维护模块没人接手时，需要继续维护
+ 根据项目需求，需要动态在不同项目间协调人力，
  比如5601项目，目前两个人，实际上后续还是需要做比较多的事情的，现在主要是由于优先级不高，同时市场要求的time to market不特别看重，所以才持续维持在两个人力
+ 资深人员发展问题
  目前部门人员数目小于20人，同时也有经常需要在不同项目间去调整人力，所以目前不适合把不同工作性质的人员划分到不同的团队中去。
  而是通过设立SDK TL 或 CASE TL，以及具体的技术小组来让资深人员发挥更多的影响力。
  资深人员的发展希望继续沿着 资深->高级->主任 工程师的方向发展，我觉得，目前比较可能的人选是 刘炜 和 魏华铭。可以找合适的时机来授予相应的技术职称。
*** 平台部门和方案部门的合作
**** 平台要求
+ 目前以及后续规划的平台，除了需要支持本部门的使用外， 还需要支持 方案开发一部，方案开发二部，合肥 深圳炬才开发部以及有可能的上海的公司
+ 支持外部客户有效率的进行二次开发
+ 平台的是否好用取决于内部客户和外部客户的评价，以及可以基于平台长出多少差异化的方案
**** 其他方案部门合作
在平台开发过程中，需要紧密的和其他部门进行合作开发， 主要有如下几点考量：
+ 平台重构，本身不是一个新的产品方向，而更多是原有技术的积累和重构，此时积累的经验对项目成败很关键
  比如5118B，如果后续需要基于zephyr来进行一次平台开发，那么CASE TL是建议由5118项目组的核心研发人员来担任的，除非实在是抽不出对应的人手，才由部分出这个人，但同时也需要5118核心人员承担顾问的角色。
  SDK TL的角色可以由我们部门承担，也可以借用5118原来比较合格的核心研发人员。
+ 新的平台开发，是新的产品品类，比如3503的wifi
  这个原则上 SDK TL和CASE TL都可以由我们部门承担，如果能比较确定后续那个团队会继续使用该平台做更多的方案，也可以由对应的方案团队出合适的人员来承担CASE TL
+ 在项目开发的过程中，我希望抽调过来的承担TL角色的人员，不再负责原有方案的任务，而专心做平台的案子，在开发的过程中，对我负责。
  之所以这样考虑的原因，主要是由于在决定一些技术问题的，特别是当两个不同的解决不能简单的说那个好，那个不好的情况下，是需要有人能够做一个技术决策的。
+ 项目开发完成后，抽调的人员继续回原来的部门。
**** 平台案的质量保证
关于如何保证平台案的质量，而尽量避免出现临时的修改，导致SDK的架构不好，难于二次开发，目前是如下考虑的：
+ Android Linux 平台相对比较容易下判断，有原生框架的使用原生框架，存在多个框架的时候，选择主流的框架，修改原生框架需要慎重考虑
+ RTOS平台，天然应用，驱动，和内核本身没有非常强的分隔，容易出现划分不清晰的问题
+ BSP开发，应用框架的开发和应用开发由不同的人员承担，尽量避免从上到下都是一个人
+ 开始开发前，会对主要的架构设计做初步的讨论，有初步结论后才会开展
+ 代码提交的时候，使用了gerrit来做代码review，review过的代码才可以集成进来，由CASE TL和SDK TL做初步把关。
+ 项目到一定阶段后，会安排整体的代码review。
+ RTOS系统的代码，由于代码量不算太大，单个人花一些时间也可以看完，我也会看一遍，架构上的不合理和优化点还是比较容易发现的。
+ 目前测试方面，主要还是依赖于研发人员自测，以及系统集成测试这两部分测试。
  对嵌入式系统，还没找到行之有效的单元测试方法。
  在做视频PMP的时代，有尝试过单元测试的方法，投入巨大，但收效很小。
  后续，android和Linux项目中的经验表明，代码review相对来说投入和收益是合适的。

**** 回复
***** 以Zepha为主要决策点主要风险是第三方驱动支持,我不反对这个决策,认为这个决策是有勇气的,但是我们是否需要一个退路? 例如也提供一个FreeROTS的开发平台?

第三方驱动支持这里是不是指的WIFI驱动这部分， WIFI驱动的话， 我这两天又去读了一下broadcom的Wiced WIFI的SDK（现在属于cypress了）
****** 主要情况如下：
+ SDK已经更新到5.0， 支持了更多的组件
+ 支持 FreeRTOS Nuttx ThreadX，抽象了一个wicedrtos的抽象层
+ 支持蓝牙（蓝牙部分未开源）
+ WIFI支持部分，除了wifi模组内部的firmware是一个二进制外，sdio驱动， wifi driver，soft ap， wifi p2p，WDS， wpa suplicant等都是开源的， 对RTOS os的依赖，没有直接依赖，主要依赖RTOS抽象层的 mutex， 信号量，延时以及timer等接口， 使用zephyr也比较容易实现， 所以后续可以我们自己来porting wifi的支持到zephyr上。
  相对于南方硅谷的WIFI，我们可以学到更多东西。
+ 支持音频解码，
+ 支持多个网络协议栈 lwip Netx(未开源) Nuttxns
+ 支持比较丰富的上层协议，mqtt， coap，http2等

但就WIFI而言，我们后续可以安排移植， 只要移植能够通过， 应该就可以排除这个风险。

FreeRTOS平台如果确实有比较强烈的需求，是可以再整理一份的， 主要的点：
+ 由于zephyr的整个系统中，从上到下都是一个比较严密的整体（驱动，协议栈）， 要插入FreeRTOS的支持，会改动比较大一些， 工作量会大一些， 也同时会破坏原生结构，不建议这种方式
+ FreeRTOS 可以做为WIFI平台的一个候选整合FreeRTOS， 驱动， 以及LWIP协议栈
+ 蓝牙平台目前没有看到有好的开源实现， 所以保持zephyr应该不太影响。

****** FreeRTOS与zephyr平台相比的特点：
+ FreeRTOS只是一个单纯的OS的core， 提供基本的操作系统原语，比如，调度，信号量，锁，线程等
+ 使用FreeRTOS的话， 我们还需要整合一些其他组件进来
+ zephyr除了是一个OS的core外， 还提供了IOT需要的协议栈的支持，尤其是蓝牙部分，基本没有找到其他开源的实现
+ zephyr大部分的协议栈是重新开发的，所以是比较为zephyr优化的， 但可能会有不成熟的情况。就目前的使用看，zephyr的核心稳定性还好，网络部分确实有一些不够完善的地方

***** 根据你的分析,是否未来在可以承担的范围内,我们应该尽可能用ARM的M0和M3而不要再用MIPS的M4K了.
从可开发性，和生态上看， 我认为是这样的

***** 3605D Linux音频和3703Linux 视频，是否需要维持两个平台? 是否可以是一个平台。
这个主要还是由两个不同平台的诉求决定的。
****** 3703LInux平台：
+ 支持 SWF播放以及支持讯飞的离线TTS，这个在sayhello规格中需要这两个规格的实现都是从android版本的apk中抠出so来使用的, 因此不能脱离andrid的基本NDK的环境
+ PM需要3703的应用开发的api等用户可见的部分， 需要和3603 uc的保持一致，这个主要是为了客户切换方便，但这个同时也就决定了这个平台不是一个通用的Linux开发平台
+ 在Linux平台， 就没有一个相对比较好的播放器和UI配合的框架，相对于Android平台不管性能还是兼容性都会差不少， 这个是Linux架构的原因， Android本身是做了很多整合的工作的。
+ 由于要支持的规格相对于音频复杂太多， 所以需要的nor 和 Ram的空间都比音频平台大比较多，3703是128M的Nand + 128M的DDR
+ 在3703项目中，在开发中，都一直坚持一个原则， 保持和平板7051使用同一个BSP，差异和适配都是在上层完成的， 所以从维护角度上来说， 不会增加太多的工作量。

****** 3605LInux音频平台：
+ 以标准的LInux开发为主要诉求， 方便客户整合第三方资源，这个确定了不能使用andrioid的环境
+ 音频平台的话，需要把nor和ddr的使用裁剪到最小，nor应该在16M~32M就够了，DDR应该是32M~64M， 规格简单的话应该16M Nor + 32M DDR就够了。这个和视频就没不会完全兼容。
+ 3605D 为了标准化和长期维护的考虑，会采用S700/s900同一个BSP底层
+ 3605音频平台，会考虑扩展支持视频和LCD， 这个是分阶段做的事情，加上视频后可以认为变成了视频平台了，加的方式会是可裁剪和可配置的。

所以长远看， 3605D会支持视频和屏， 但不会支持uc的那一套框架， 那一套只保
留在3703上。

***** 管理上，我立即为啥还是以项目驱动的动因，但我希望决策由几个人做出，所以我建议还是成立一个三到五人的SDK架构部门，任命你为总架构师，其他人为架构师，关键点由这个组产生，项目团队执行。你看看是否合理。

成立一个架构部门我觉得是好的，这样可以集中公司的优势资源，为各个项目服务，做出的决定相互的一致性也会好。

我现在想不清楚的还是架构的决策如何能够被项目开发中真正执行下去，如果项目主要在我这边的这个团队，问题不大，因为我是他们的直接主管。如果项目不在我这边的话，做出的架构决策，我觉得执行起来不会那么顺利，有的时候自己的决定在执行的时候都会反复问自己， 执行其他部门或项目团队外的人的决定相信会更加困难一些。

这部分还是要两位老大多给指导才行

团队的话，主要应该还是RTOS的架构，我们这边考虑如下人员：
刘炜 优势在 zephyr+mips+wifi
魏华铭 优势在 arm+ mbeded + BLE
在加上其他方案部分的一些资深人员就好了，不需要多。
** 20170706 周总关于产品规划和研发过程中的几大问题
各位管理团队成员：
在炬芯今年上半年的工作中发生了一些重大事情，也挖出来一些事情，觉得在我们管理团队的思维中有一些根深蒂固的问题和行为方式，如果不解决，炬芯不是可以用“危险”两个简单的字来解释的。

先流水账式的列举我们上半年看到的一些问题：
１．我们老人机市占大幅下滑，下滑后有很多的解释，但下滑前我们非常专门的为这个市场开了一颗ＩＣ　５００９Ｇ。
２．我们对５１１８销量的高度乐观情绪被现实浇了一桶冰水，这以前我们发疯一样的备库存，这以后的总结居然是我们的业务主管没有投入，我们的体系没有积极推广，或者靠我们体系推广根本不行，我们的产品竞争力不够，或者ＩＣ的接口不够，所以要立刻花上百万美元再开一颗加接口的５１１８Ｂ。　
３．今年我们要ＴＯ四颗ＩＣ，两颗在７月１日ＴＯ了Ｔｅｓｔｃｈｉｐ，　但是这四颗ＩＣ在ＳＰＩ这样的接口不要说啥像国际大厂看齐，我们的四颗ＩＣ用的都不是同样的ＩＰ。研发主管顾左右而言他，啥一个是从某某项目继承的，另一个是从另一个项目继承的，云云。
４．５００９Ｇ中间一个Ｆｅａｔｕｒｅ被莫名的砍了，环顾左右，无人应答是乍砍的，是谁决定的，哪一个研发主管和ＰＭ批准的？　回答为不知道，只能用历史故事来回答，说我们定义芯片经常是问一句，这个Ｆｅａｔｕｒｅ有人用不？无人回答，就砍了，不需要任何人负责，也没有研发主管承担责任。
５．昨天我进入５１１９增强版会议晚了一点，发现研发主管正热烈的在讨论一个全ＲＯＭ版的耳机芯片，也就是说一个所有配置都固定，未来配置的ＭＩＣ，扬声器，模具，按键，灯，ＰＥＱ设置，手机兼容性等等的超级大公模芯片，当然在市场面的强烈反对下，昙花一现，转为使用ＯＴＰ的讨论。但是这样的议题在内部居然有一定的市场。
６．我们梦想进入耳机成为大玩家，但我们没有持续分析对手，连样机都是现在才开始收集。
７．	。。。。。。

分析和解剖几个麻雀。　
一．５００９Ｇ的经验教训
　　２０１５年在我们对老人机最得意的时间点，市场部拍板两个结论１。老人机会持续现有趋势三年或者以上，２。我们如果成本做到和对手一样有信心以平均一年４－５Ｍ的出货量坚持三年。
所以，为老人机专门开一颗ＩＣ是值得的。　于是５００９Ｇ明确定位专门服务老人机同时耕耘广告机，不打故事机及需要解Ｆｌａｓｈ和带摄像头的方案。于是研发进行了大幅度的砍规格，包括砍掉ＶＣＥ，Ｇ２Ｄ和ＣＭＯＳ　Ｓｅｎｓｏｒ接口，还有很多其他。同时后来也发生了以上４里面的情景，在不知不觉中随性的砍掉了一个调节音量的小Ｆｅａｔｕｒｅ。

　　最近我去拜访王国奇时，老王要我明确炬芯到底是不是会坚决地耕耘老人机，我想一个刚刚为老人机开了一颗５５ｎｍ专用ＩＣ的公司，为啥他唯一的客户却在问你是否要坚持打老人机呢？这是啥情况。但事实上是，我们的业务市场部在连自己的新ＩＣ成本都搞错（我不知道这个的影响程度）的前提下操盘，就是给了客户我们有时想坚持，有时不想坚持的印象，前几个月我们的市场占有率下滑到２０％甚至以下。　２０１７年初的这个状况，和２０１５年的拍板距离实在太悬殊了。

有幸另一个创新发生了，老赵部门的贡献，这个明确定位了不打故事机的ＩＣ可以打故事机了，于是市场定位乾坤大挪移，５００９Ｇ定位故事机了，一系列的紧急项目做故事机。

同时我们的市场部对砍掉了ＣＭＯＳ　ｓｅｎｓｏｒ接口有切肤之痛。可惜原因是不知道砍掉不那么影响成本。这个除了可惜，可能还可以有很多教训要吸收，很多词语去形容。

实际上２０１６年老人机市场就开始大幅下滑了，我们是否好好总结过，一年前的市场定位是否草率了。　
我们有没有思考过，如果老赵部门没有这个贡献，我们仅仅在执行５００９Ｇ的原始使命，这颗ＩＣ的投入会变成怎样的窘境？

以限制市场区隔，限制使用场景的Ｃｏｓｔｄｏｗｎ和砍规格很可能是“伪创新”　这个思维模式，这个产品规划思路和研发习惯很可能在根本上伤害了我们的市场机会。

而针对那个莫名其妙被砍掉的Ｆｅａｔｕｒｅ则同样一体两面的，一方面老人机的确不用这个Ｆｅａｔｕｒｅ，所以基于原来的市场定位，这个Ｆｅａｔｕｒｅ被砍貌似不为过。
但是这个Ｆｅａｔｕｒｅ被砍却没有文档，没有人知道，不需要经过严谨的评审，这个是极其危险的。说到底，我们的研发管理，我们的研发流程，我们的研发主管是干啥吃的？

二．５１１８的经验教训
　５１１８定位最低目标培育我们自己RF和通信的整合开发，制造和测试能力，最高目标在标准低端蓝牙音箱（主要是公模市场）咬下一个角。于是研发认真扣了每一个角落的成本，砍掉每一点冗余的Feature和接口，公平的说这是研发最深度的扣成本的一颗ＩＣ，但是不幸的是我们也砍了比我们成本更低的低端对手都支持的接口。砍过头了么？以原有的市场定位并没有砍过头阿。

结果：5118总体结果实际比预期好，但是这种比预期在杰里BK缺货的虚假繁荣促进下走向另一个极端。 冷静之后发现其实现在的结果和我们的真实面实际是非常一致和合理的。我们的初衷就没有想过要耕耘很多差异化案子，甚至在我们的理解里模糊的觉得我们的对手就是只能做标准案，很阳春，没有啥弹性的。是现实重重的打了我们一巴掌，我们才意识到现实不是我们所想象的。

这个过程中反映出来的三个问题非常值得深思。
１．我们是否尊重对手？，我们有没有认真地分析对手的产品？ 作为一个后进者，有没有一个谦虚地态度，谦逊的去做竞争者分析，有根据的制定自己的应对，耕耘每一个细节。
２．我们有没有认真地思考和对待砍掉得那几个接口，现在我们又仓促的要花一百万美元加回这几个接口，这里的经验教训有多深刻？是不是市场定位其实一开始就错了？既不符合市场状况也不符合自己的情况？
３．当我们开始立5118B以后，立项中已经明确了是要针对拓展性市场的，可以说市场定位的确发生了乾坤大挪移，但是我们的研发主管们思维有没有依据这样的市场定位去调整，从5118定位狭窄的最底端标准蓝牙音箱中间拔出来，真正的把思维和可以进行拓展性市场的定位一致？从我抓的ROM代码与OS深度耦合的问题，到接口问题，我们是不是依然深陷在基于固定的使用场景砍规格的固有思维里？

三．５１１９目前的定位和其危险。
我们都对５１１９抱以厚望，但是我们的工作方式已经让５１１９存有巨大的风险。
１．我们根本还不十分了解耳机市场，但是我们没有花大力气去学习和分析耳机对手。　我们有没有收集齐对手的ｄａｔａｓｈｅｅｔ，样机，ＳＤＫ，　配置和量产工具，全面分析其Ｐｒｏ　ａｎｄ　Ｃｏｎ，然后来制定自己的策略。
２．当我们发现对手的配置项非常多的时候，我们是否脚踏实地的去分析过如何应对？还是完全闭门造车的拍脑袋？
３．昨天关于纯ROM版（完全不做任何配置）的讨论，是否是我们基于通过限制应用场景来砍规格以求成本勉强能没有劣势的思维发展到了极端的一种表现？　对于一个我们还不完全了解的市场是否可以走这条路，也许，但必须是要在花极大大力气学习对手的做法，和市场客户的行为之后才能做的事情，我认为这个不是ＰＭ的事情，这是研发主导的事情。我们坐在家里想象未来耳机会完全标准化，未来只有一种磨具，一种按键和灯的配置，仅仅配同一类外围器件，手机兼容性一劳永逸，ＰＥＱ不需要配置，这样的耳机芯片是市场最大量的，　做这样的想象是标准的闭门造车，静态思维和“伪创新”，　危害极大。认真评估是否可以用ＯＴＰ来替代ＥＥＰＲＯＭ和合理的，但必须全面认真的做大量调查分析工作，拍脑袋的做纯ＲＯＭ版是不可取的。

总结一下：
１．既然都为某个市场开了专用ＩＣ了就要锲而不舍，坚持到底。
２．我们必须认清自己手上没有水晶球这个事实，承认初始市场定位发生乾坤大挪移是高概率事件。产品定位和研发必须给自己留有合理的弹性。
３．艺高才能人胆大，不了解和无知不能作为竞争力和砍规格的根据，砍规格应该是一个非常谨慎的行为，是基于高把握度反复琢磨以后的行为，需要有严谨的纪录和签核，不是任何两个工程师就可以决定的大事。研发主管必须看紧，砍是必要的，但必须是谨慎的，有人明确承担功过的。砍规格不能太随意随性。
４．必须非常尊重对手，强化竞争对手分析，我们的市场和研发主管ＧＰＬ必须做到都读过对手的资料，评测过对手的样机，对对手的规格和优劣滚瓜烂熟。不分析对手就做得决策是脱离实际的。不能接受的。要砍掉对手有的接口和Ｆｅａｔｕｒｅ，同样需要艺高人胆大，必须花大力气让自己非常了解市场和客户需求的前提下进行。
５．知己知彼，首先要知己，我们必须要化时间真正了解自己的产品，了解增减某些ＦＥａｔｕｒｅ带来的后果，才能做出合理的决策。

一切皆在细节中，这是ＩＣ设计业不变的真理。　不能重视细节就不可能在这个行业生存。

目前的任务：
  请收集齐全主要耳机对手的各种资料和样机，越全越好，我们需要既安排，也亲自学习和评估，然后组织系列报告和讨论来分析对手制订策略，落实每一个细节，只有这样我们才有赢得可能。

** 20170704研发三部SRD例会报告
#+TITLE:20170704研发三部SRD例会报告
#+LATEX_HEADER: \usepackage{xeCJK}
#+LATEX_HEADER: \setCJKmainfont{STKaiti}
#+OPTIONS: \n:t todo:nil
*** 标案项目相关
**** 3703
***** 支持android APK
****** 需求
PM明确需要在放开资源限制的要求下支持android apk
****** 技术路线
+ 使用先启动到linux下，再后台加载andoird的方式，来保证快速启动的体验， apk加载慢在一定程度上可以缓解
+ 使用双系统相互沟通的方式来进入和退出android的apk
+ 解决双系统并存的资源共享和互斥问题，主要是wifi，以及media server， surface flinger等
****** 工作量
预估 2个人 1.5个月的时间，
**** 3605
***** 标案规格
+ 技术路线选择使用openWRT
+ 音视频框架，采用裁剪3703使用的stage fright方式，
  + 可以充分利用积累的和稳定的codec
  + 从目前裁剪看，原始数据4M， 压缩后2M， 基本可以满足要求， 后续需要继续压缩
***** 火百灵客户案
客户案的支持工作比预期的要多不少，后续可能会和标案抢资源
**** 3503
***** 支持wifi蓝牙combo功能
****** ROM版本情况
  + BR/EDR版本的patch需要26k的的ram
  + BLE功能的patch需要20k左右的ram
  + 固定使用的ram 需要 7k + 3k
****** 蓝牙针对3503功能RAM需求裁剪
+ 只做蓝牙音箱功能，只需要支持a2dp avrcp两个profile
+ 不支持双链路，sniffer等功能的话， BR/EDR的patch应该可以减少到17K
+ BLE 和 BR/EDR 不同时使用
+ 总的RAM需求，控制在17K + 7K + 3K  30K左右。
****** 目前情况
+ 移植了IVT协议栈， 可以通过A2DP播放音乐
+ 利用ROM的版本，老麦初步跑起来了。
****** 需要决策的
上层蓝牙profile的选择，需要讨论和确定
******* IVT库
+ 有比较多的分层和抽象，代码逻辑比较复杂，需要写很多的上层代码适配后，才能实现一个profile功能
+ 有测试过完整的兼容性， IVT库本身问题不多
+ IVT库代码加上上层service会有比较多的代码， 代码size是不太好的
******* zephyr的蓝牙协议栈
+ BLE 支持比较完备，3503 测试Airsync兼容性也没发现问题
+ BR/EDR 缺少一些profile支持，对3503而言， 主要缺少AVRCP  和 SDP
+ 代码精简紧凑，除了实现了IVT部分的功能外， 很大一部分上层适配需要的功能都有框架，不需要像IVT库一样，开发那么多代码
+ 代码大小，相对于使用IVT库，应该会有显著的减少。
+ 缺点是没有测试过相关兼容性，可能有兼容性问题要解决。
******* 总结
从长期来看， 倾向采用补全zephyr的proflie的方式，逐渐完善需要的profile。
****** 需要其他部门配合
需要SD和无线部门，评估下硬件支持蓝牙wifi combo是否可以。
****** 总结
目前初步看，支持蓝牙wifi combo是可行的

***** 支持ASR的其他格式
目前和我们配合的语音识别的提供上，认为我们使用的amr 8k的是不太适合的格式， 最好支持speex-ogg格式，需要算法部分尽快评估
**** Android 版本升级
***** 以往版本相对于原生版本改动
相对于android原生版本的改动，主要集中在以下方面（工作量由高到低）：
1. CTS 和CTS verify失败项解决
   + 音视频
   + camera
   + 512M内存
2. GMS apk兼容性解决
3. 系统测试apk兼容性解决
4. 音视频支持硬解码
5. 音视频兼容性问题解决
6. selinux相关的策略修改和支持
7. 支持HDMI以及多显示设备相关功能
8. modify工具支持
9. 媒体扫描，包含卡分组， u盘，media分区
10. vold 相关磁盘分区调整
    + media 分区
    + usb多分区
    + 外置卡 支持多分区
11. 图片硬件码适配
12. mini charge支持单口， 双口充电规格以及电池曲线
13. 支持mass storage设备
    android默认支持mtp设备，不支持mass storage设备
14. 3g dongle 支持
15. usb host支持，
16. vendor apk
17. 支持WIFI驱动的加载和卸载方式
18. 文件系统支持 exfat ntfs等规格
19. 个性化的规格支持
***** android版本升级步骤:
****** 全功能带起以及适配我们改动的规格（4~6周1
+ 先带起软解  1周
+ 带起GPU UI （取决于android 改动大小 一周）
+ 带起音视频硬解 （2~4周，取决于音视频框架改动大小）
+ 适配android新特性（2~4周，取决于android版本的改动大小）
+ 适配我们个性化规格（2~3周）
****** 系统测试和DEBUG （8周）
****** 主要风险
+ 原生架构变化带来风险， 比如虚拟机架构变化带来的风险。
  在4.4到5.1上带来很多问题，都比较花时间。
***** android O的建议做法：
+ 适配硬解码视频（可以考虑支持全格式）
+ 适配GPU
+ 原生规格，只支持重点规格， 一些不必要或难以支持的暂不支持
+ CTS 测试分析一下报告，非必要问题不解决
+ 原生bug不解决
+ 不测试apk兼容性
+ 个性化规格暂不支持，等有需求逐步增加
***** 音视频支持规格
****** 原生视频容器：
mpeg2ps
mpeg2ts
matroska
Mp4
方案新增容器：flv,wmv,rm,avi,
另外mpeg2ps替换成了我们自己的parser
****** 原生视频格式：
avc(h264,只支持baseline)
hevc
h263
mpeg2
vp9

方案新增视频格式：
与IC有关，以s700为例。avc hevc h263 mpeg2 都替换为我们的硬件解码。
除此之外，增加了vp6,vp8,vc1,mpeg4,rv34,flv1,mjpg,msm4等硬件解码格式。
另外还有avs和wmv8纯软件解码
****** 原生音频容器和音频格式：
mp3,amr,aac,flac,g711,gsm.mp3,raw,vorbis,opus。
方案新增音频容器和音频格式：
wmalsl,wmapro,wmastd,ac3,acelp,dts,pcm,mp3, flac, ape
***** 总的来说
+ 就算只做必要的工作， 还是有不少的工作量的
+ 只做基本的功能
+ 音视频的全格式可以考虑去掉一些有风险和权利金的的格式，
  带起需要的格式工作量相对还好。
  音视频主要的工作量在于解决GMS问题， 以及解决中的各种兼容性问题。

*** 老刘邮件
昨天晚上开完珠海研发会议, 我意识到市场部和研发部门之间的项目太多了.    项目很轻易的就立起来了.   这样会造成珠海研发团队失焦, 也会事实上造成研发资源浪费且效率低下.   我分析产生这个现象的几个原因如下：　
1:   市场部同事和研发主管，互相之间感情深厚，很容易就沟通．所以，谈着谈着就立项了
2:   珠海的研发主管对销售业绩渴盼, 很希望通过自己或自己部门的努力, 多做几个客户案, 以期望销售业绩成长
3: 市场部同事在和珠海研发主管探讨项目可行性的时候，发现某项研发工作恰好也是另一个市场部项目所需要的，就以这个为托词（或心理安慰），心里想，反正另一个项目也需要用到这个技术积累，那我这个项目先做了，在这个技术上的投入，不完全算是我这个项目成本．　
4: 研发部主管(及／或市场部同事)把市场部想当然认为是研发部门的主管或者资源调动方．而忘记了研发部门必须要有自己的一些研发技术路线图和自己独立支配的研发资源．　
5: 市场部核算投入产出不合理或者不严谨．要么是想着配合某个感情好的客户，要么是粗略计算一下，觉得值得投入，就想当然的调集了珠海的研发资源．而没有考虑利用行业内的资源整合．没有考虑如何以四两拨千斤(公司内部资源的四两，拨行业内的千斤)
6: 市场部／研发部门，谈着谈着某个项目就偷跑了．研发偷跑可以．但应该算是预研．研发主管不能把偷跑／预研混淆了．还说自己人力不够用．
7: 市场部同事在找研发主管，讨论某个项目可行性的时候，研发主管就”误以为”项目要开工了．然后就指挥人力开干了．市场部同事对这个事情有时候是不知情，有时候是知情也不拦着，半推半就就把项目推下去了．　　　
综上种种，目前的状态是　研发主管／市场部同事　都有天然的立项冲动．就导致了现在这个样子，项目就不清不楚进到珠海了．然后珠海的研发主管在完成某个必须的研发项目的时候（例如芯片项目），就有可能感觉到人力不足．　
请研发主管，尤其是珠海的研发主管，务必要保持住自己的技术主线．不可以被客户项目一时的假繁荣假热情迷住了双眼．那都是假象．很多客户案也是对方一时热情．不能随便让一个客户案就进入珠海．
请市场部　务必遵守工作原则，正式立项的项目，当然可以调集珠海的资源．未立项的项目，可以找珠海评估可行性．但是客户案，必须走一个立项流程．哪怕是邮件立项也可以．不能把客户案当作个体户的方式去经营．　
请珠海的研发主管，把你们手上所从事的项目，列一列，让对应的市场经理来认领．如果无人认领的，立刻停工(或者不计算为客户项目，只算是预研)．　　
请市场部同事，在你认领项目之前，先与我和业务主管讨论．这个项目有没有四两拨千斤？　
*** 目前正在做的项目整理
| 名称      | 类别         | PM     | 阶段     | 描述                                                                                                                                            |
| ZS350A    | 标案项目     | 肖凯平 | 第二阶段 | + SPI NAND支持，用来支持卡缓存 + 蓝牙音箱规格支持，需要支持avrcp a2dp + 蓝牙WIFI combo + 魔音支持 + VAD支持 + speex-ogg + 触摸按键 + WIFI省功耗 |
| LS370A    | 标案项目     | 肖凯平 | 第二阶段 | + 支持andorid 正版视频apk + ios 视频聊天apk测试                                                                                                 |
| LS360F    | 准备立项标案 | 肖凯平 |          | + 规范化bsp （kernel boot config） + kernel升级到3.10 + 支持16M nor方案 + 整合openWRT发型版 + 移植音视频框架 + 支持camera                       |
| 5601      | IC项目       | 张天益 | testchip | + 方案验证 + SDK开发                                                                                                                            |
| AD700A    | 标案项目     | 何建雄 | 第二阶段 | + LInux发型版支持 + linux版本视频硬解码支持 + GPU硬加速支持 + Android项目的需要珠海支持需求                                                     |
| 火百灵/KT | 未立项客案   | 张洪波 |          | + 支持火百灵/KT，基于LS360F完成一个智能音箱客案 + 最早是计划做为WIFI音箱的beta客户导入的                                                        |

** 半年BP会议
*** 邝建涛
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201B53353@srv-mail-02.actions.com.cn][2017 年中BP会 -- 智慧计算 ]]
**** 上半年（1-5月）的主要工作：
收敛S500客户，开发中项目落地，完成开发评估板CB6的开发，完善资料文档、
外设、LINUX；
S700开发评估板（CB7）的第一阶段开发完成；
S700 Beta客户车机（头枕）项目启动；
VR客户项目的落地，工程收敛，业务持续关注；
平板保持一定出货量，7059C出货进度不如预期；
**** 现在及下半年（6-10月）主要工作：
S500评估板批量开始销售，业务配合方糖客户推广，承接项目，核心板开发完成，
准备批量出货；
S700的CB7完成批量，核心板完成开发，7月下旬开始批量销售，预计到8月底完
成第二阶段软件开发（完善外设，文档，LINUX，论坛建设）；
7月份S700头枕小批量，8月份车机试产；
8月初7013小批量；
8月底开始保持一定密度进行S700的宣传活动到年底：发布S700车机，开发板的
推广活动，香港电子展；
9月初开始预研S700升级安卓系统O可行性，如果可行，应在10月以前开始，可以
适当拉长时间分阶段完成；
9月开始S900开发评估板（CB9）第一阶段开发，预计年底前完成批量，同时完成
文档；
平板持续保持一定出货量，VR业务保持关注，业务关注跟进当期市场热点（如近
期的王者荣耀游戏机S900，迷你KTV）;
**** 年底到明年上半年：（11---）
随着S500有一定的客户基础及技术积累，业务和方糖主导开始5206（39S、39ST）
在特定市场或订单的清货动作，可能包括部分7059C在非平板市场出货；
低端平板保持持续出货；
到年底，已经完成S700/S900 基本平台的积累，工具及配套资料的准备，此时应
该逐渐回归市场业务的角色定位及分工，加强业务客户推广；
**** 业务
1.经销商，核心方案商的建设，为新进客户提供技术及商务服务（保证基本生存，
改善经营）；
2.寻找一家有配合意愿，在不同地区有丰富客户基础，渠道能力的分销商（类似
大联大），以我们目前AP的现状，从某类行业客户或特定市场开始会比较容易找
到共同利益点切入；（业绩突破）
3.重点、标杆客户的攻关；（稳步成长）
4.从既有客户项目，产品发现可以以点带面的方向；（稳步成长）
5.抓住当期市场热点，不一定是中长期可耕耘方向，特定订单；（意外惊喜）
**** 市场
1.及时发现新兴热点产品，组织内外部资源快速导入，预判是否中长期可耕耘方
向；
2.寻找预判传统行业可能的智能化趋势，看好方向主动提前布局；
3.关注外围一些核心算法，应用；
4.关注核心配套资源动态趋势；
5.平台各主次分支的同步管理，平台的持续完善（比如DDR模板，板型，外设，
系统）工作的规划;
6.外围生态，论坛的建设，宣传；
**** 工程
1.客户FAE的支持工作；
2.协助PM持续完善平台，同步主次分支；
3.协助核心客户或重点项目的开发；
4.持续提升客户服务的效率，包括支持系统，工具，开发文档优化，服务流程，
新客户工程培训；
5.学习，积累，自身综合能力的提升；
**** 几个关键词：
聚焦：我们是推平台，卖IC的，不是推方案的（至少一段时间）
收敛：我们的平台是S700/S900
库存：我们目前仍有一定的库存风险，需要降低盘活库存（5201:480K，
5202:2.5M，5206:1M）
生存：我们的首要任务是先养活自己
**** FCST
PAD：
上半年：出货600K，ASP:USD2.35
下半年：100K-150K/M，ASP:USD2.35
AP:单位：K套
　                    Q1   Q2    Q3    Q4
S500/7059/V500        13   47    60    80
ASP                   $4.2 $4.2  $4.5  $4.5
S700/V700             2    8     10    30
ASP                   $4.8 $4.8  $4.8  $4.8
S900                  2    10    10    10
ASP                   $12.5$12.5 $12.5 $12.5
Others（39/39ST/7013）5    5     20    80
ASP                   $2.0 $2.0  $2.0  $2.0
Total(数量）          22   70    100   200
Total(金额）          $99.2$370.8$483.0$789.0
注：7013数量暂共估70K，要到8月份会相对准一些；
**** 需要的支持：
公司的理解支持，给予时间；
关键节点的工程人力投入（火上浇油）；
*** Android 版本升级
**** 相对于原生版本改动
相对于android原生版本的改动，主要集中在以下方面（工作量由高到低）：
1. CTS 和CTS verify失败项解决
   + 音视频
   + camera
   + 512M内存
2. GMS apk兼容性解决
3. 系统测试apk兼容性解决
4. 音视频支持硬解码
5. 音视频兼容性问题解决
6. selinux相关的策略修改和支持
7. 支持HDMI以及多显示设备相关功能
8. modify工具支持
9. 媒体扫描，包含卡分组， u盘，media分区
10. vold 相关磁盘分区调整
    + media 分区
    + usb多分区
    + 外置卡 支持多分区
11. 图片硬件码适配
12. mini charge支持单口， 双口充电规格以及电池曲线
13. 支持mass storage设备
    android默认支持mtp设备，不支持mass storage设备
14. 3g dongle 支持
15. usb host支持，
16. vendor apk
17. 支持WIFI驱动的加载和卸载方式
18. 文件系统支持 exfat ntfs等规格
19. 个性化的规格支持
**** android版本升级步骤:
***** 全功能带起以及适配我们改动的规格（4~6周1
+ 先带起软解  1周
+ 带起GPU UI （取决于android 改动大小 一周）
+ 带起音视频硬解 （2~4周，取决于音视频框架改动大小）
+ 适配android新特性（2~4周，取决于android版本的改动大小）
+ 适配我们个性化规格（2~3周）
***** 系统测试和DEBUG （8周）

***** 主要风险
+ 原生架构变化带来风险， 比如虚拟机架构变化带来的风险。
  在4.4到5.1上带来很多问题，都比较花时间。
**** android O的建议做法：
+ 适配硬解码视频（可以考虑支持全格式）
+ 适配GPU
+ 原生规格，只支持重点规格， 一些不必要或难以支持的暂不支持
+ CTS 测试分析一下报告，非必要问题不解决
+ 原生bug不解决
+ 不测试apk兼容性
+ 个性化规格暂不支持，等有需求逐步增加

** 20170630：IC项目增加软件架构师
*** 会议目的
后续的ic项目， 需要补强软件架构评估这一个工作。主要目的如下：
+ 能够满足公司内部的标案开发需求外，
+ 也可以比较容易的支持客户的二次开发。
+ 可以比较容易的支持多种软件架构
尽可能避免出现IC的硬件不必要的限制软件的扩展性，尽可能避免IC硬件和软件做不必要的耦合。
*** 达成协议
+ 设立新的角色，软件架构师  5119 周晓磊   5118B  5116C(5120) 刘炜 5601 魏华铭
+ GPL会提供IC主要的市场需求给到软件架构师
+ 软件架构师需要参加spec的评审会议，如果对spec有异议，不能在会议中解决时，需要GPL来协调解决
+ IP需要标准化， 和保持延续性，尽可能保持接口（寄存器）的一致性，
+ 软件架构师需要输出软件架构评估文档
*** 待办：
+ review一下IC项目开发流程，看是否需要修改流程，加入相关活动 （蔡青）
+ review下几个IC项目，看必须的ip的规范程度是否需要改进  （
  + 5116C 刘炜  吴玉凡
  + 5118B  刘炜  蔡李镇
  + 5119  周晓磊

** 20170602研发三部SRD例会报告
#+TITLE:20170602研发三部SRD例会报告
#+LATEX_HEADER: \usepackage{xeCJK}
#+LATEX_HEADER: \setCJKmainfont{STKaiti}
#+OPTIONS: \n:t todo:nil
*** 标案项目相关
**** 3703
+ 兼容性测试中测试出一个nand的问题， 补测兼容性，已经证实解决
+ 发布文档都已经准备完成
+ 确定是用0527tag发布，开始走发布流程
+ ios app地平想本周提供，但还需要更新库，应用流程也有修改，发布后继续
+ 客户试产样机，LCD需要拉伸，也需要改版
+ 目前客户试产尚缺少在线教育和点播的规格，发布后按照新需求进行
**** 3503
+ 第四轮要点测试，今天完成，测试仍有20多个bug，需要再增加1轮要点测试。
  预计的发布时间预计在16号左右，较原计划有接近2周的delay
+ 目前已经开始导入试产客户
**** 3605
+ 上层准备使用openWRT的发型版，这个文件系统会很小，基本的只有3M多，
+ 目前上层比较明确的需求有
  + alsa lib支持
  + wifi bt支持
  + 播放器支持
  + AVS支持
+ 底层BSP后续会在S700 S900的BSP上来支持3605D
  这样考虑的主要原因是S700的BSP比较规范一些，包括kernel本身， uboot， dts， 分区表等
  另外，kernel版本也新一些
  后续维护的工作也会好一些，有kernel升级要求的话，也容易支持一些
**** 5601
+ 示例开发
  同时具有central和peripheral角色的示例
+ OTA机制开发
+ 加密流程验证
+ 分析airoha语音遥控器性能和耗电
  使用的标准的hid 协议
  传输语音时6.4KB/s， 每个包20个byte， 一个周期4个包， 12.5ms的链接周期
  在语音操作的时候好点8.8ma， 无广播时好点 8.3ua，广播时5.4ma ~7ma， tx峰值13.9ma
+ 5601两个对传
  使用合适的连接周期，和最大包长251，可以达到40kB/s

*** 预研相关
**** 有进展
***** 5118B ROM独立
已经初步讨论了做法，主要由以下几点：
+ rom中的baseband代码， 目前需要的延时，关中断，以及memcpy memset等常用函数，可以通过自己实现的方式来完成， 延时不再使用cpu counter，而是保留一个timer给rom用
  初步看ROM中的代码没有依赖OS的其他系统原语
+ rom的工程需要独立于SDK编译， 与SDK的直接的接口通过提供独立的符号表
+ ROM中使用的RAM，需要集中到一起，定位到整个RAM空间的开始，或者末尾，不要把RAM空间割裂，这样会便于开发和LInk的处理。
+ nor上的baseband代码和ROM中的baseband代码直接是通过一个函数表来交互的， nor上的部分，有依赖os相关以及SDK部分相关的接口， 不同的OS需要适配这部分
+ rom中的代码的patch机制是通过固定的函数表来实现的， 这个不同的os都比较容易支持
+ rom中需要的malloc接口，由于是在中断中调用的，同时还不清楚最高使用的内存大小，这个接口的实现建议在sdk中实现
+ ROM代码调整后，需要在zephyr和gl5118 sdk中都需要验证， 前者可以使用ic来验证，后者需要使用fpga验证，并且需要送测
+ 时间上， zephyr这边先开始，预计2周时间可以提供rom版本，之后就可以两边并行修改和验证
***** 亚马逊AVS
AVS部分，3503上由于其他任务打断工作暂停，后续转其他人先在3605D上来支持。
目前还在看amazon提供的树莓派的参考实现
***** 双系统支持快速倒车
增加了DE叠加的功能，目前雷达叠加的效果已经可以出来，基本已经可以满足瑞泰的要求
***** Linux 发行版
****** OpenWRT
研究了OpenWRT，后续3605可以使用这个linux的发行版， size比较小， 比较适合音频平台
***** 第三方sdk和云服务
****** broadcom Wiced SDK
SDK已经更新到5.0， 支持了更多的组件
+ 支持 FreeRTOS Nuttx  ThreadX，抽象了一个wiced_rtos的抽象层
+ 支持蓝牙（蓝牙部分未开源）
+ WIFI支持部分，除了wifi模组内部的firmware是一个二进制外，sdio驱动，  wifi driver，soft ap， wifi p2p，WDS， wpa suplicant等都是开源的， 对RTOS os的依赖，没有直接依赖，主要依赖RTOS抽象层的 mutex， 信号量，延时以及timer等接口， 使用zephyr也比较容易实现， 所以后续可以我们自己来porting wifi的支持到zephyr上。
  相对于南方硅谷的WIFI，我们可以学到更多东西。
+ 支持音频解码，
+ 支持多个网络协议栈 lwip  Netx(未开源) Nuttx_ns
+ 支持比较丰富的上层协议，mqtt， coap，http2等
***** AS216B
已经提供环境，科胜讯的数据通路已经通了，目前还有问题
**** 未有进展部分
***** android O 已经发布预览版，还未安排看
***** 3703 Linux平台，支持android 版本的爱奇艺apk，暂停
***** 5601 支持zephyr， 后续安排
***** BLE mesh规范已经发布，暂停
*** 支持工作
**** V700`
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEAA68@srv-mail-02.actions.com.cn][答复: 【V700】泽迪分体机沟通]]
**** 7051
***** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0503DFC1@srv-mail-02.actions.com.cn][答复: 【酷哭】7051 USB 摄像头使用异常]]
***** [[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F131102791903@srv-mail-02.actions.com.cn][ATS3703-LS370A-ISS 工业级产品专项]]
***** [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C348@srv-mail-02.actions.com.cn][答复: 7051 sensor抓图时间确认]]
***** [[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEA95E@srv-mail-02.actions.com.cn][705B晨芯儿童机项目USB大口U盘不能挂载问题]]
***** [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B040FDBC8@srv-mail-02.actions.com.cn][答复: 7051晨芯儿童机硬件开关调试]]
***** 7051 领芯以太网支持
**** s900
***** 陀螺漂移问题
***** TODO  [[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D5CBB@srv-mail-02.actions.com.cn][S900 APK 主界面反应迟钝]]
***** s900 申报项目支持
***** s900 显示黑色效果差
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103465A7A@srv-mail-02.actions.com.cn][答复: S900 VR样机显示黑色资源q效果差]]
***** openMaxIL
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D592D@srv-mail-02.actions.com.cn][答复: OpenMaxIL]]
**** 7059
mipi屏支持
上海7059 GPU问题
**** 瑞泰
+ 1080P LVDS屏
+ OTA 升级uboot
+ CVBS IN 被裁掉
+ HDMI IN
+ 倒车支持叠加
**** S700
***** DONE [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0503DD58@srv-mail-02.actions.com.cn][答复: 700H265解码 ]]
CLOSED: [2017-06-02 Fri 13:47]
***** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C393@srv-mail-02.actions.com.cn][答复: 【AD700A】【图库】图库应用裁剪usb中的图片保存时报错]]
***** TODO [[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10353B88B@srv-mail-02.actions.com.cn][答复: S700 bugreview记录-----------HDMI输出开机logo转到开机动画过程中必现花屏现象]]
***** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0503D883@srv-mail-02.actions.com.cn][答复: 方糖关于S700 CB7 HDMI目前使用的问题]]
***** TODO [[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEADC5@srv-mail-02.actions.com.cn][答复: CB7（S700）网络丢包问题]]
***** 方糖USB3.0驱动
***** 双屏异显性能确认
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103465B94@srv-mail-02.actions.com.cn][答复: S700 双屏异显DEMO及性能确认]]
***** 开机logo花屏问题
** 2017.5.17 方案团队分工规划
*** 工作分工
**** paul
+ 无线音频
**** 姚
**** 张
** 20170510 研发三部SRD例会报告
*** 标案项目相关
**** 3703
   地平线相关的问题已经解决， 第5轮测试本周完成， 比预期delay 4天，报bug较少，不排除是测试力度的原因。
   目前测试资源特别紧张， 一轮测试要排期2周以上，还会delay， 是最大的风险。
**** 3503
+ 继续调整优化系统的内存管理方式，以及内存使用方式， 解决各个场景下内存紧张的情况。
+ 增加了边下边播功能，在有插卡的情况下， 可以很快下载完成， 避免网络的影响。
+ 在没有卡存在的情况，调整网络策略， 尽可能的开更过的buffer给网络使用。
+ 目前有发现WIFI场景长时间老化，WIFI会断线重连，还在和南方硅谷协调解决中
+ BLE已经调通，争取下轮测试整合测试
+ 蓝牙音箱的功能，目前只能采用双系统的方式来支持
+ 传统蓝牙的支持，要整合到zephyr中有两种可能：
  1. 使用rom的baseband代码，外围构造适配层，模拟5118的环境， 这个合肥团队可能会做
  2. 构造比较独立一些的baseband代码，让baseband不要和sdk绑定那么紧， 关键时序的代码放在ram中执行，不关键的部分放在nor上执行。 这部分预计在10月份之后方亮这边才有人力配合。
  3. 5118 Plus建议考虑一下baseband更独立一些的做法
**** 3605
+ 支持medai win 以及火百灵的一些alsa的需求，
+ 目前来看, 3605D需要提供一个类似X1000 的linux原生上层会比较好一些，客户需要编译和使用linux的第三方库。有一些和android的上层和工具链是不兼容的。
+ bsp（bootloader + kernel + driver），也有两条路线
  + 沿用370a的bsp， 这样最快，但有一些不是很规范的东西， 比如没有使用uboot，dts，以及clk tree 和 dma 框架都没有使用通用的框架， 其中uboot和dts影响稍大。
  + 考虑到3605只做音频部分， 可以在目前s700/s900的sdk上支持7051， 这样的话， 后续一个bsp可以支持更多ic， 长远看是有利的。
**** 5601
+ 使用nxp的支持CMSIS DAP的芯片，已经可以和我们5601的板子配合起来， 可以实现通过usb连接电脑
  + jtag开发调试
  + 串口打印
  + 像使用U盘一些， 通过drag & drop的方式烧写固件
+ 整理sdk应用开发文档
+ 整理SDK架构和使用文档
+ 规划开发板
*** 预研相关
**** 有进展
***** 亚马逊 IOT，AVS
   + 在3503上try通aws IOT的小设备，并可以被echo控制，已经try通， 还未整合到sdk中。
***** 双系统支持快速倒车， 已经可以demo， 下周
***** 第三方sdk和云服务
****** microsoft Azure
是一个类似google 和亚马逊的通用云计算平台， 有小的iot支持和机器学习， 没有看到语音相关支持
****** 华为 liteos
只开放了kernel部分， 上层协议和其他组件没有开源，可能后续会开源
****** 京东
开放了完整的sdk， 有小系统的接口， 还没有跑起来， 据称
ram:4-6K
rom:184K
里面定义的api有适合局域网控制的 。
有比较多的内容是跟菜谱等小家电内容相关的
****** 庆科 WIFI iot 的sdk
主要是基于broadcom的wiced WIFI的sdk上增加一些服务开发出来的，
相对于wiced wifi 增加了一些网络协议， 但同时闭源一些核心的内容。
**** 未有进展部分
***** android O 已经发布预览版，还未安排看
***** 3703 Linux平台，支持android 版本的爱奇艺apk，已经抽时间开始评估, 但预期工作量会比较大
***** 亚马逊 IOT，AVS
   + 使用 3503 实现alexa AVS设备
   这两部分将来都作为sample整合到SDK中（保持zephyr的架构），在一个SDK中整合各种各样的samle，故事机算一个，avs和IOT也算另外的两个， 将来可以继续整合百度等其他的sample。
***** 5601 支持zephyr， 后续安排
***** BLE mesh规范已经发布，目前还未有开源实现，预计过一段时间在zephyr上会有，是否需要投入精力去搞。
*** 支持工作
**** S700
***** 瑞泰
****** TODO U盘升级
****** 瑞泰cvbs in
****** 卡量产
******  双系统倒车
****** 蓝牙slave
****** sofia资料
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A246B5@srv-mail-02.actions.com.cn][答复: 瑞泰项目未来几个需要做的事情]]
***** V700 泽迪
****** TODO  v700 泽迪分体机hdmi输出
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8FCE9@srv-mail-02.actions.com.cn][V700泽迪分体机hdmi输出竖屏信号问题]]
****** 泽迪V700 双屏
****** TODO 泽迪V700 usb支持nanoc的陀螺仪
***** AD700A
****** S700 QCB
****** s700 以太网支持
****** S700 蓝牙支持slave模式  李钊军
****** S700 蓝牙支持pcm
****** S700 revovery老化
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A9008C@srv-mail-02.actions.com.cn][答复: 答复: S700 recovery老化卡死在Android动画问题]]
****** s700 绿屏
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103465020@srv-mail-02.actions.com.cn][答复: 答复: S700 多任务操作下小机出现绿屏]]
****** TODO S700 usb otg
***** wilinko debian
客户自己使用我们的sdk， 自己编译了新的initrd， 新的debian jessie可以完整跑起来。
***** ubuntu linux 支持 S700
**** S500
***** TODO 点创车机老化 camera问题
***** 文晟
[[mu4e:msgid:0E3AB831E505F842818BA4F9798C30A4016F11D3@srv-mail-02.actions.com.cn][答复: 【S500】文晟 USB通信20170425]]
ov5460 camera倒立
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F37DC2@srv-mail-02.actions.com.cn][答复: 文晟7059 ov5640 camera拍照后照片放到PC上倒立180°]]
***** 方糖 ubuntu支持旋转（竖屏）
**** 7059
***** 凯硕达
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F37853@srv-mail-02.actions.com.cn][答复: 【7059】铠硕达200WmipiCamera调试]]
psdio wifi死机， 主要是sdio的max block大小原因
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103464E9E@srv-mail-02.actions.com.cn][答复: KSD死机打印]]
ksd 性能相关问题调试
***** 7059 以太网台湾支持
[[mu4e:msgid:45C9CD6E9A1F8E40A999E51EF137BF15324A1B@srv-mail-02.actions.com.cn][RE: 答复: About ATM7059 /S500 RTL8201 相關眼圖測試_初版]]
***** 通文达屏问题
***** 7059 mipi屏幕调试
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103464ED5@srv-mail-02.actions.com.cn][答复: 7059C 7寸MIPI调试资料]]
**** S900
***** s900 项目申报
***** 领芯EDP屏支持
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB8B5@srv-mail-02.actions.com.cn][答复: 领芯S900工控板子的eDP屏的调试]]
***** 900c youtube 问题
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8FE69@srv-mail-02.actions.com.cn][【v700】【YouTube】v700 nibiru海外版固件使用YouTube tv版播放搜索视频报错]]r
***** 900c 电池 FCC未更新
**** 3605
***** media Win
mediaWin alsa 支持， 编译环境， tinyalsa支持
***** 火百灵
提供sdk给对方
tinyalsa 提供
alsa lib调试
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB7DC@srv-mail-02.actions.com.cn][RE: 深圳广佳乐新智能的ATS3605的远场语音识别的方案]]
***** 3605 linux 环境
** 业务工程配合
*** 梅利
+ 业务会分成产品线业务， 不在按照客户来区分
+ 业务信息分两类
  + 一些客户面消息，可能会跟预研方向相关
  + 具体需要，基本就是3~5个月就需要完成的
+ 业务工程会议可以试行
+ 工程需要更重视项目完成的时间准确性
+
** 0418FAE支持方式
*** rk的方式
+ rk的支持方式，WIKI多人编辑
+ 不通过qq交互， 而听过wiki交互
+ 通过ticket交互
+ 有简报
+ 所有的版本发布和历史都在论坛有体现
*** actions
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8F9B3@srv-mail-02.actions.com.cn][答复: FAE支持方式改善探讨]]
** 20170405 研发三部SRD例会报告
*** 项目相关
1. 3703
   标案我们负责的部分基本完成， 回归和发布测试即可， 目前地平线部分还有较多问题， 预计会因为这个原因delay
   重点的几个：
   视频聊天，license验证，ota升级，其中在线视频质量是最大的问题， 但目前进展不是很好。
2. 3503
   主要规格已经开发完成，未完成的规格不影响送测， 目前还在完善缺少的规格： 序列号烧写，pcba等
   目前有发现WIFI场景长时间老化，系统会崩溃的问题，在debug中。
   送测样机有delay， 暂时使用内部的dvp来做冒烟测试来送测。
   BLE支持整合的zephyr中
3. 3605
   提供了SDK给link play，但对方应该没动
   提供了SDK给media win， 对方已经使用起来， 目前提了新一些需求， 在跟进解决中
4. 5601
   ROM代码已经freeze
   开发方式已经请paul这边的工程师做了试用，反馈情况还好，从开发方式上和EFLASH基本没有差别。编程模型等都比较好用。 由于时间有限，没有能做完一个profile的开发。
   从技术角度而言：
   E2prom的开发方式， 不需要使用到bank机制， 但需要使用很多rom中的代码，客户开发需要熟悉我们较多接口， 同时，在debug调试的时候， 遇到rom中的代码的时候，客户会无法有debug。
   Spi nor方式的开发，没有E2Prom方式开发的限制， 客户开发和和EFLASH的方案基本相同，调试的时候在使用断点和单步调试的时候， 与ELASH有不同， 单步的时候会单步到我们的bank miss代码中， 断点需要停两次，第一次是引起缺页的E800指令，第二次才是page miss后的代码。这一点是硬件架构决定，无法解决。
   能够做到完全和EFLASH相同的nor flash方案，需要使用cache架构才行，必须让软件使用透明 这样调试器会看不到这个差异。
   Page Miss的架构要做到这一点，需要完全做到IC的内部，不能让软件实时处理。但可以让软件配置。（比如像MMU的页表）。
*** 预研相关
1. GMS 7.0 的要求
   1. Play Store 的Settings 菜单里面会显示这款机器是否有通过GMS认证，现在已经实施；
   2. 针对没有通过GMS认证的7.0机器，系统会通过Play store推送信息给使用者，大概内容为：该设备不合法，请退回给零售商。预计2017年4月初开始实施；
   3. 从2017年8月份开始，所有使用安卓系统的机器，不管是什么版本，如果没有通过GMS认证，谷歌会让机器停止使用谷歌所有的应用；
   4. 针对出货量超过100K的机器，谷歌强制要求每3个月做一次安全补丁的更新并提交谷歌报备，每3年做一次系统更新并提交谷歌报备，如果每3个月没有更新安全补丁导致安全补丁版本过低，谷歌会取消这款机器的GMS认证。
   5. 谷歌对mada的规划
       目前拿到MADA的OEM/ODM一共有66家（不含品牌商），但是谷歌现在要砍掉46家，只保留20家，具体哪20家厂商能续签MADA应用在4月份有 确定消息。
   6. 关于指纹机器，Andriod 7.0 对于TEE的要求，在CDD文件的7.3.10 中Google 明确要求指纹信息存放在TEE环境下
   7. 鉴于没有按照Google CDD要求的情况，用非正常手段测过CTS所带来的风险
      + 如果Google 抽查到客户样机没有把指纹信息放在TEE里，可能会终止MADA协议
      + 如果方案商/品牌商借用其他厂商的MADA，那么终止MADA协议，会导致这个提供MADA
      + 如果测试机构（3PL）没有检测出手机里的指纹放在TEE里， 一旦google查出来后，有可能对测试机构采取措施，也有可能取消测试机构的官方测试资格。
   8. 使用硬件支持的密钥库，可更安全地在 Android 设备上创建、存储和使用加密密钥。它们可保护密钥免受 Linux 内核、潜在的 Android 漏洞的攻击，也可防止从已取得根权限的设备提取密钥。
   9. 为了让硬件支持的密钥库使用起来更简单和更安全，Android N 引入了密钥认证。应用和关闭的设备可使用密钥认证以坚决地确定 RSA 或 EC 密钥对是否受硬件支持、密钥对的属性如何，以及其使用和有效性有何限制。应用和关闭的设备服务可以通过 X.509 认证证书（必须由有效的认证密钥签署）请求有关密钥对的信息。认证密钥是一个 ECDSA 签署密钥，其在出厂时被注入设备的硬件支持的密钥库。因此，有效的认证密钥签署的认证证书可确认硬件支持的密钥库是否存在，以及该密钥库中密钥对的详细信息。为确保设备使用安全的官方 Android 出厂映像，密钥认证要求设备 bootloader向可信执行环境(TEE)提供以下信息：设备上安装的操作系统版本和补丁级别  ● 验证的启动公钥和锁定状态。  ● 除密钥认证外，Android N 还推出了指纹绑定密钥，在指纹注册时不会撤销。
2. Aandroid O 已经发布预览版，还未安排看
3. 3703 Linux平台，支持android 版本的爱奇艺apk，已经抽时间开始评估, 但预期工作量会比较大
4. 亚马逊 IOT，AVS
   + 在3503上try通aws IOT的小设备，并可以被echo控制，正在进行
   + 使用 3503 实现alexa AVS设备
   这两部分将来都作为sample整合到SDK中（保持zephyr的架构），在一个SDK中整合各种各样的samle，故事机算一个，avs和IOT也算另外的两个， 将来可以继续整合百度等其他的sample。
5. 百度云
   百度语音识别，以及TTS的接口都有开放， 都是http+jason的方式来访问， 跟操作系统无关，已经可以在3503上使用。
   目前3503使用的roboo智能管家也是使用百度后台，讯飞已经不再支持故事机等嵌入式
   Duer OS目前已经开了发布会， 目前支持的是RDA的模组，包含语义对话等功能，这部分目前还没有开源， 预计6月份开源。
   Duer OS目前使用的arm mbed OS，但对OS没有偏好，使用其他OS也可以。等开源后再看
6. 96 board
   5118 目前要支持96 board还缺少一些硬件规格，一组I2C，一组Uart和GPIO个数。
   5118 plus倒是可以满足要求，但有一点不方便操作的是mips平台。
   目前linaro也在推动百度zephyr的事情， 比较有兴趣和我们一起去推动和百度语音的对接
7. 阿里云
   简单看了下， 语音识别的接口开发http API的只有一个文件识别的接口，需要先录制好语音文件，并把文件上传到阿里云，然后再调用语音识别接口
   其他实时识别，以及语义聊天等功能，只提供了linux， android 的c++ 和 java的sdk，没有开放http的接口
   语义聊天等主要场景还是集中的跟ali的业务接近的区域，并不是家庭以及儿童的方向。
8. 5601 支持zephyr， 后续安排
9. BLE mesh规范已经发布，目前还未有开源实现，预计过一段时间在zephyr上会有，是否需要投入精力去搞。
10. 双系统支持快速倒车， 未开始
** 20070301
*** Android项目
+ S700带起了方糖CB6版型， 发给瑞泰做车机方案第一阶段
+ 使用GS900增加96 board版型（TAG 0227）， 使用该分支和版型做后续S900推广。
+ 瑞泰第一阶段需求评估完成， 第二阶段主要工作在双系统和U盘量产。
+ 拜访了视美泰，了解多很多商显的需求， 初步看工作量比较大。
+ Google DayDream中的APK从手机上抠出来，经过debug可以在5209上跑起来，IMG GPU的部分VR扩展还不能用，沟通中，进展较慢。
+ Android 7.0 GMS，目前了解到的情况需要A53等Arm V8架构的cpu才可以支持TEE。 A5 A7 A9的CPU应该不能过。
+ 差异化和VR的支持工作。（Linux X11选择， HDMI IN，KODI小窗口等需求）	支持S700
***  5601项目
GL5601_FPGA方案
+ 方案进度
  Beacon和数传（module）功能开发和测试已完成。
  Rom固化代码大部分完成。
  Eeprom/spinor方案SDK开发已开始进行。

*** 5119
IVT第一阶段代码完成， IVT库从130K压缩到110，第二阶段的工作， 需要从应用，IVT库以及控制器各方代码一起联动， 后续由柯海涛接手。
+ Rom固化代码预计在3/10前整合完成。之后安排代码review。
+ Eeprom方案SDK预计在在3/10提供，外部开发人员可进入。
+ Spinor方案开发SDK预计在3/17提供。

*** 3703儿童机器人
        1.       标案进度
1）第一轮完整测试送测，功能测试本周一完成，限于测试人力和测试内容全部测试完成在3月4号。
2）视频通话demo已联调通过，人脸贴图跟应用的联调还未完成。视频通话和人脸注册的应用UI已完成初步设计，规格确认后可切图提供开发。该部分整体进度偏慢，要加快赶上下一轮的要点测试（3月8号）。
2	主要问题
1）	多场景卡死：包括卡拉ok返回主界面、视频返回列表界面等出现卡死，主要是
内存不够问题。
3	规格风险
   目前视频点播看来是wifi视频类必须的规格，还在想办法解决视频点播的技术路线。	1．	第三方功能整合
2．	内存优化
3．	视频点播功能技术路线
3503 WIFI 微信故事机	1	播放在线MP3的功能已经调通， 低码率的流畅，高码率的320Kbps，偶尔有卡顿， 还在澄清。
2	内存MP3场景已经使用130多K， 还在整合WMA格式，预计内存基本够用。留给算法的预计可以到70~80K内存。
3	系统播放mp3场景，cache miss在1%左右，网络开销大概20M CPU（这个跟网络带宽需求有关，越高的带宽需求，需要的CPU越高，1M cpu基本等于20kbps）， 可以留给解码部分有100M左右以上的运算能力。
4	在调试过程中，需要调整解码库的内存使用方式， 以及消除不同解码库中的重复代码。
5	US281a SDK的蓝牙controller ROM代码和SDK的其他部分（驱动，C库，profile等）都有很强耦合，很难脱离us281a的环境， 需要重新剥离一份controller代码适配到zephyr上。
6	主要的技术风险已经排除	1．	按照项目计划开发功能
2．	继续优化内存
3．	解码库部分也需要做调整来优化内存使用， 和节省代码空间来减少cache miss。
4．	蓝牙功能整合
3605 WIFI音箱	1	拜访了乐韵瑞，了解清楚了软件需求， 剩下较多的工作主要在nor方案支持， 以及linux的蓝牙功能支持， 这部分有一些工作量， 有人力冲突。
2	已经准备了板子和初步的软件sdk环境提供给对方， 乐韵瑞本周培训，预计下周有结果	继续完成蓝牙和NOR方案
预研	研究了amazon avs设备，以及alexa平台平台的实现， 搭建了实验环境，基本弄清楚了实现原理。 Alexa avs的sdk已经提供了开源的参考实现。
** 愿景规划
*** 20170401 远景
[[mu4e:msgid:DB539A2A09F34D4B9989A23D1D3BF4FE016F4D91@srv-mail-02.actions.com.cn][关于愿景规划和产品规划]]
*** 0405公司后面主线
**** 无线通信仍然是主线
+ 蓝牙音频， 市场是很清楚的， 5.1 继续投入， RF和modem自己做， baseband可以考虑ceva升级
+ BLE   5.1 目前市场看不清楚，研发端可以考虑第一版外购，第二版开始自己研发
**** WIFI只需要整合的机会， 不自己做
**** 规避NbIOT，但需要继续关注对主线影响
**** 低功耗是系统级技术
+ 近期需要努力去耕耘的，有机会就耕耘，提升质量标准
+ 切入角度可以从蓝牙音频开始
**** 音频前处理
+ VUI void user interface，新世代
+ 凡是受到VUI影响的市场都需要跟进， 类似触摸屏的革命
+ 直接服务VUI的， 比如前处理， 5315， 多mic处理
**** 智能语音jr
  + 近场 + 按键
  + 近场 + 命令词
    唤醒词检测 VAD一定是加分项，sensory算法
    目前主要都是使用DSP做的
  + 远场 + 3m + 双mic
    DSP可以搞定
  + 5119， 5118plus仅仅是噱头， 有核高基就有，没有就没有
  + 5116， 5116c
    must 近场命令词唤醒
    最好支持双mic
  + 规划新IC
    双mic或三mic，需要和科胜讯竞争
    强烈建议 m3 + DSP
**** 图像识别+图像处理
不做消费类产品
* AP
** Linux 发行版
*** debian
s900 96boards
http://builds.96boards.org/snapshots/bubblegum/linaro/debian/latest/
https://github.com/ofree/ramdisk
https://github.com/ofree/linux/tree/bubblegum96-3.10
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F36FEB@srv-mail-02.actions.com.cn][这张图是linux的架构图吗？]]
** S700
*** 快速倒车
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B05144FF2@srv-mail-02.actions.com.cn][快速倒车移植文档]]
*** 第二阶段规格
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201AEB3F5@srv-mail-02.actions.com.cn][答复: AD700A第二阶段规格讨论]]
*** 方糖规格
**** TODO [[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061654AE@srv-mail-02.actions.com.cn][转发: 答复: CubieBoard7-S700 第二阶段协作开发]]
*** ubuntu 环境
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F10353C339@srv-mail-02.actions.com.cn][GS700E 的ubuntu xml]]
*** UI性能
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04FA97DD@srv-mail-02.actions.com.cn][发送电子邮件: GS700D_UI_性能评估数据.xls, GS700D_UI_性能评估报告.doc]]
*** 视频
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0503D16D@srv-mail-02.actions.com.cn][答复: H.264性能数据]]
** 支持工作
*** 7059 以太网台湾支持
[[mu4e:msgid:45C9CD6E9A1F8E40A999E51EF137BF15324A1B@srv-mail-02.actions.com.cn][RE: 答复: About ATM7059 /S500 RTL8201 相關眼圖測試_初版]]
*** 3605
mediaWin alsa 支持， 编译环境， tinyalsa支持
*** s900 项目申报
*** twd屏问题
*** 泽迪V700 双屏
*** 泽迪V700 usb支持nanoc的陀螺仪
*** S700 revovery老化
硬件修改了， 没有通知软件
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A9008C@srv-mail-02.actions.com.cn][答复: 答复: S700 recovery老化卡死在Android动画问题]]
*** s700 绿屏
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103465020@srv-mail-02.actions.com.cn][答复: 答复: S700 多任务操作下小机出现绿屏]]
*** TODO S700 usb otg
*** 领芯EDP屏支持
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB8B5@srv-mail-02.actions.com.cn][答复: 领芯S900工控板子的eDP屏的调试]]
*** 900c youtube 问题
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8FE69@srv-mail-02.actions.com.cn][【v700】【YouTube】v700 nibiru海外版固件使用YouTube tv版播放搜索视频报错]]r
*** ksd 性能相关问题调试
+ sdio wifi死机， 主要是sdio的max block大小原因
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103464E9E@srv-mail-02.actions.com.cn][答复: KSD死机打印]]
*** 7059 mipi屏幕调试
[[mu4e:msgid:DC4E6E803E914F4B8AFE57F1456019F103464ED5@srv-mail-02.actions.com.cn][答复: 7059C 7寸MIPI调试资料]]
*** 文晟
[[mu4e:msgid:0E3AB831E505F842818BA4F9798C30A4016F11D3@srv-mail-02.actions.com.cn][答复: 【S500】文晟 USB通信20170425]]
*** 火百灵
提供sdk给对方
tinyalsa 提供
alsa lib调试
*** TODO  v700 泽迪分体机hdmi输出
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A8FCE9@srv-mail-02.actions.com.cn][V700泽迪分体机hdmi输出竖屏信号问题]]
*** 文晟
ov5460 camera倒立
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F37DC2@srv-mail-02.actions.com.cn][答复: 文晟7059 ov5640 camera拍照后照片放到PC上倒立180°]]
*** 乐百灵
[[mu4e:msgid:DB7FD3E3699F5F46AC82EDB1899F1311026EB7DC@srv-mail-02.actions.com.cn][RE: 深圳广佳乐新智能的ATS3605的远场语音识别的方案]]
4.14号拜访乐白灵的出差记录，请各位知悉。

乐百灵

l 给我们演示了双MIC的样机效果（宣传指标：远场5m，唤醒率94%，识别率90%），
唤醒不了的情况还是比较多发生（给我们的解释是里面的测试固件，其实我们手
上的echo dot也一样）。

l 乐百灵的这款双MIC采用的方式直接CX20921贴主板上，没有用模块。AEC没有
使用ADC，直接使用的是AP出来的I2S的输出连接到CX20921上，CX20921负责下采
样。同时这个方案是有音效的，音效是外挂IC，也就是说当前的AEC是从音效处
理之前采集的。他给我们的说法是这样做多对性能有影响的，只是当时为了省
ADC才这样做了。

l 乐百灵采用的是云之声的语音识别算法，云之声将云识别算法和CX20921打包
方式给乐白灵。

l 唤醒词部分是他们自己的算法，他们可以更换唤醒词。咨询唤醒词的运算量，
他说的他们自己的很小。他对CX20921的冷唤醒词识别不是很看好。

l 他也提到了Airpaly和DLNA的需求是WIFI音箱的must需求。

l 语音识别库：老朱看来认为故事机和WIFI音箱是两个不同的产品，对算法要求
不同，他给我们的解释是故事机针对小孩，WIFI音箱针对大人，大人小孩的声音
识别训练模型是有差异的（待确认），我们3503故事机和WIFI音箱公用语音识别
的方式关注一下这个。

l 乐白灵的模具因为语音识别做过多次调整，最后选择将MIC的腔体放在上偏后
面，同时模具设计上对震动音箱等都有充分考虑。他的说法是这部分对算法效果
影响非常大。

l 他们手上有语音识别且蓝牙和WIFI切换的模具，是一款公模。比较切合我们
ATS3503的WIFI音箱的方案需求。

l 初步沟通准备从他们家购买单MIC和双MIC的模具作为我们标案开发使用。
*** 地平线
**** 内存泄露问题
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C2DF@srv-mail-02.actions.com.cn][答复: hobocCAPI精简版]]
*** 瑞泰
**** 瑞泰cvbs in
**** 卡量产
**** TODO U盘升级
**** TODO 双系统倒车
**** 蓝牙slave
**** sofia资料
[[mu4e:msgid:FD60D12E0517B0429F825C3DEC8BD06201A246B5@srv-mail-02.actions.com.cn][答复: 瑞泰项目未来几个需要做的事情]]
*** wilinko debian
客户自己使用我们的sdk， 自己编译了新的initrd， 新的debian jessie可以完整跑起来。
*** 凯硕达
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F37853@srv-mail-02.actions.com.cn][答复: 【7059】铠硕达200WmipiCamera调试]]
*** S900 双屏支持
**** TODO 文档
*** S900 HDMI IN
**** TODO 文档
*** AD700A标案
*** TODO S700 QC 廖田养
*** s700 以太网支持  李钊军
*** S700 蓝牙支持slave模式  李钊军
*** TODO  S700 蓝牙支持pcm
*** ubuntu支持旋转（竖屏） 刘世军
*** tv in支持  黄海宇  瑞泰
*** ubuntu linux 支持 S700 廖田养
*** 3605 linux 环境 廖田养
*** 900c 电池 FCC未更新
*** TODO 点创车机老化 camera问题
** 客户需求
*** 视美泰
**** 性能要求
+ 循环视频播放相同或者不同格式视频时间需大于240小时。不卡顿，不退出，不暂停。
+ USB或者CSI等摄像头须预览或者录像时间大于240小时。不卡顿，不退出，不暂停。
+ WIFI，以太网，3G能连接上网时间大于240小时。
+ 音视频需要支持多种视频格式和高清视频，长时间播放无黑屏和死机现象。
+ 支持双屏同/异显示（LVDS显示界面，HDMI显示视频），播放高清视频无抖动，卡顿现象。
+ USB,IIC触摸屏流畅，不断点，不卡顿。
+ 强行掉电开机后必须保证能工作的有（测试次数大于4000次）：
+ 前置USB摄像头能正常使用；
+ 后置USB摄像头能正常使用；
+ SD卡分区可读写
+ U盘分区可读写
+ WIFI自动连接，获取IP，上网；或者能与手机直连
+ ETH 自动连接，获取IP，上网
+ 3G自动连接，获取IP，上网
+ BT自动连接
+ 能进入android桌面，并不能恢复出厂设置。
+ USB触摸屏能正常使用
+ WIFI，以太网ETH，3G数据通信保证不丢包，吞吐量足够大。（ping 192.xxx.xxx.xxx -n 102400 -l 10240）
+ 多个视频同时播放高清视频的解码能力，性能，音视频同步。
**** 软件系统要求
+ 软件固件同时支持1G,2G DDR的容量,无需更换固件.
+ 开机时间5秒内需显示Logo，20S内进入Android桌面。任何原因关机须显示框等正常关机，时间在5秒内完全断电关机。HDMI与LVDS须同时显示,相差不得大于3S.
+ 全志三个阶段Logo需要支持不同分辨率，不同屏幕旋转状态正常显示。支持更换Logo方案。
+ 恢复出厂设置或者update升级,需要HDMI,LVDS都可以显示UI,不得黑屏.
+ 支持截屏。需要支持0,90,180,270旋转屏后的截屏保存。
+ 屏幕旋转模式须支持0,90,180,270旋转，包括3个阶段的logo显示,界面UI，视频等等都需要旋转。
+ 屏幕状态栏隐藏设置，同时支持手势方式显示或者隐藏状态栏。（如华为手机荣耀6）
+ 声音输出通道设置，可以设置自动检测和Codec，HDMI强制输出等不同通道输出。
+ 2G，3G，4G模块需要兼容性支持。支持模拟语音与数据通信。当无3G等模块插入时，须模拟3G模块，包括手机信息等，如IMEI号码等等信息供应用使用。支持3G通话，如手机操作。
+ 循环播放视频时，视频切换时黑屏时间少于1S。
+ USB外设支持：
  3G dongle，
  USB读卡器，
  USB触摸屏，
  USB摄像头：支持录像，录音。支持QQ视频通话问题。
+ 串口外设支持（包括USB转TTL，PL2303，FT2303等）
  POS打印机，
  读卡器等外设。
+ 默认支持GooglePlay等APK。
+ 摄像头APK进入前，需要支持手动选择使用前置和后置摄像头。
+ 设置APK关于设备项目中，须加入我们特定信息：如DDR，EMMC大小，MCU版本号等等。
+ 须支持遥控盒子功能和鼠标模式。IR至少需支持Setting里面设置，Launch，浏览器和输入法正常应用。
+ 支持升级方式：USB升级，TF 升级卡升级，TF update.zip升级。其中TF update.zip升级能做到插入TF卡后,无需操作就直接升级了.
+ 支持恢复出厂方式：（无论是HDMI，LVDS，VGA输出， 恢复出厂设置需要统一通知用户，包括正在进行，成功，失败信息。）
+ 支持标准视美泰API方式。包括APK看门狗，视美泰板卡识别。
+ 支持定时开关机，加密系统。
+ 支持多家广告机发布系统：如实验室，星际，南翼和视展等等。
+ 静默安装APK。
+ 开关机指示灯定义与实现：
+ 网络优先级设置：ETH>WIFI>3G。可在设置进行选择。
+ HDMI，VGA，LVDS显示下，支持调节显示亮度，对比度和饱和度等显示设置。
+ 串口，IIC，扩展IO口，须提供接口以便支持应用层APP调用。串口支持485协议。
+ 需要支持单/双路,6/8位RGB_LVDS输出。支持双路8位 1080P，Freq=168MHz输出。
+ 支持双屏同/异显。（至少LVDS显示界面，HDMI显示视频,图片）。
+ 单WIFI 8188ETV和WIFI+BT 8723BU 模块，支持双频WIFI2.4+5G，软件能自动识别。
+ 支持TF卡/U盘进行参数配置，其中包括
  + 屏参设置
  + 屏幕旋转模式
  + 屏幕状态栏默认隐藏配置
  + 声音大小，喇叭，耳机，3G
  + 声音输出通道默认配置
  + USB HID的VID，PID设置
  + USB触摸屏原点位置
  + IIC电容屏配置，IC芯片，地址，大小分辨率，原点位置（为了兼容多家IIC触摸不造成软件分支）
  + WIFI AP默认名称和密码配置
  + 遥控器机器码厂家配置
  + 3G模块名称配置。（为了兼容多家3G模块不造成软件分支）
  + 是否支持3G模块选择。（为了支持多串口，兼容USB转TTL，PL2303，FT2303等）
  + 调试背光频率，相位和默认背光强度。
+ 一键恢复出厂设置。
+ 支持TF卡/U盘OTA完整固件升级。
+ Bootlogo 支持动态更改，支持旋转0 90 180 270度。
+ USB摄像头支持500W。
+ 支持假待机，关闭LVDS，eDP，HDMI，VGA等显示，声音，只是系统在后台运行。
* doc
** WIFI
https://en.wikipedia.org/wiki/Wi-Fi
https://en.wikipedia.org/wiki/IEEE_802.11
** commn lisp
*** slime
https://www.common-lisp.net/project/slime/doc/html/index.html#SEC_Contents

** share lib 空间优化
https://stackoverflow.com/questions/31354641/c-reduce-library-size-by-excluding-unnecessary-functions-programmatically
https://stackoverflow.com/questions/8021470/how-to-optimize-size-of-shared-library

*** elf
https://docs.oracle.com/cd/E19683-01/817-3677/6mj8mbtc9/index.html#chapter6-73709

** LInux网站
*** mail list
搜素patch 得到日期
http://www.gossamer-threads.com/lists/linux/kernel/
通过日期+1查找archiver
https://lkml.org/
http://vger.kernel.org/lkml/
*** linux actions upstreaming
https://git.kernel.org/pub/scm/linux/kernel/git/afaerber/linux-actions.git/log/?h=v4.13/arm
*** other
https://git.kernel.org/cgit/
http://kernelnewbies.org/
http://www.tux.org/lkml/
http://lwn.net/
http://linux-mm.org/
http://stackoverflow.com
http://askubuntu.com/
http://gmane.org  邮件列表
http://en.wikipedia.org/wiki/Unix_philosophy
http://blog.csdn.net/21cnbao?viewmode=contents
http://lxr.free-electrons.com/
http://www.linuxfromscratch.org
https://0xax.gitbooks.io/linux-insides/content/Concepts/per-cpu.html
linux inside book
https://www.gitbook.com/book/0xax/linux-insides
http://advdbg.org
** LInux distribution
*** general
https://en.wikipedia.org/wiki/Linux_distribution
https://en.wikipedia.org/wiki/DistroWatch
https://en.wikipedia.org/wiki/Comparison_of_Linux_distributions
**** C standard library
https://en.wikipedia.org/wiki/C_standard_library
C date and time functions
https://en.wikipedia.org/wiki/C_date_and_time_functions
https://en.wikipedia.org/wiki/UClibc
https://git.uclibc.org/uClibc/
http://www.kumouse.com/?p=1051
***** Comparison of C/POSIX standard library implementations for Linux
http://www.etalabs.net/compare_libcs.html
***** android
https://en.wikipedia.org/wiki/Hybris_(software)


**** Lightweight Linux distribution
https://en.wikipedia.org/wiki/Lightweight_Linux_distribution
***** Tiny Core Linux
https://en.wikipedia.org/wiki/Tiny_Core_Linux
http://tinycorelinux.net
"Tiny Core" (16 MB) is the recommended option for new users who have a wired network connection. It includes the base Core system and a dynamic FLTK/FLWM graphical user interface.[4]

"Core" (11 MB) (also known as "Micro Core Linux") is a smaller variant of Tiny Core without a graphical desktop, though additional extensions can be added to create a system with a graphical desktop environment.[4]

"dCore" (12 MB) is a core made from Debian or Ubuntu compatible files that uses import and the SCE package format,[5] a self-contained package format for the Tiny Core distribution since 5.x series.

"CorePure64" is a notable port of "Core" to the x86_64 architecture.

"Core Plus" (106 MB) is "an installation image and not the distribution".[4] It is composed of Tiny Core with additional functionality, most notably wireless support and non-US keyboard support.[4]

"piCore" is the Raspberry Pi port of "Core."
****** FLTK
https://en.wikipedia.org/wiki/FLTK
The Fast Light Toolkit (FLTK, pronounced fulltick)[3] is a cross-platform widget (graphical control element) library for graphical user interfaces (GUIs), developed by Bill Spitzak and others. Made to accommodate 3D graphics programming, it has an interface to OpenGL, but it is also suitable for general GUI programming.
****** FLWM
The Fast Light Window Manager is a stacking window manager written in C++ and available for redistribution under the terms of the GNU General Public Licence. FLWM is the default window manager for Tiny Core Linux.

**** Linux on embedded systems
***** Buildroot
https://en.wikipedia.org/wiki/Buildroot
***** Yocto Project
https://en.wikipedia.org/wiki/Yocto_Project
The Yocto Project is a Linux Foundation workgroup whose goal is to produce tools and processes that will enable the creation of Linux distributions for embedded software that are independent of the underlying architecture of the embedded software itself.

The project offers different sized targets from "tiny" to fully featured images which are configurable and customisable by the end user. The project encourages interaction with upstream projects and has contributed heavily to OpenEmbedded-Core and BitBake as well as to numerous upstream projects, including the Linux kernel.[citation needed] The resulting images are typically useful in systems where embedded Linux would be used, these being single-use focused systems or systems without the usual screens/input devices associated with desktop Linux systems.

As well as building Linux systems, there is also an ability to generate a toolchain for cross compilation and a software development kit (SDK) tailored to their own distribution, also referred to as the Application Developer Toolkit (ADT). The project tries to be software and vendor agnostic. Thus, for example, it is possible to select which package manager format to use (deb, rpm, or ipk).
***** Deciding between Buildroot & Yocto
https://lwn.net/Articles/682540/
Buildroot, he said, focuses on simplicity. The core Buildroot tool is kept as small and as simple as possible, which makes it easy to use and understand. All special cases are handled in extensions, and Buildroot re-uses existing tools like kconfig wherever possible. Thus, he said, learning Buildroot means learning tools that are applicable in other scenarios.

Belloni continued, Yocto tries to be versatile and support a wide range of embedded systems. It does that by defining builds in recipes, which specify what software to build and how to build it, and by supporting layers, which are recipe collections written and maintained by the development community. Layers allow the community to support new boards or architectures, define new application stacks, or support entirely new use cases. By relying on cleanly defined layers, the default system image defined can remain small.

First, Buildroot currently supports a smaller set of available packages—a little over 1800. The list includes all of the core options one would expect, from graphics layers to application toolkits to multimedia frameworks and programming languages. But it is a curated list of packages and, notably, it does not include any development tools (e.g., compilers and linkers) to run on the target system. Buildroot targets are meant to be the end product, not the development system. Yocto, however, does provide target toolchains—and much more. About 8400 packages are available in total, including some of questionable value for current systems, like Qt 3. But there are packages for more programming languages, including some like Go and Rust that are not available for Buildroot, and there are layers available for many containerization and virtualization frameworks (use cases that are outside of Buildroot's scope).

Dependency handling differs as well. Buildroot again takes a minimalist approach: whenever a new package is added, it is built with as many features disabled as possible. That allows the creation of small footprints: the minimal image is just 2MB. But Buildroot does include a number of automatic dependencies, Petazzoni said. For instance, adding OpenSSL to the configuration will automatically add SSL support for other packages that include an SSL option. In Yocto, package configuration is done at the distribution layer: enabling SSL support enables it for every package by default, although it can still be disabled for individual packages (or enabled for individual packages, if it is set to be off by default). These dependencies can be overridden at the machine-configuration level, but that is considered bad practice.

***** OpenEmbedded
https://en.wikipedia.org/wiki/OpenEmbedded
OpenEmbedded is a software framework used for creating Linux distributions aimed for, but not restricted to, embedded devices. The build system is based on BitBake recipes,[2] which behave like Gentoo Linux ebuilds.

Recipes in the old OpenEmbedded-Classic were all found in one place. In the new OpenEmbedded-Core, the structure has changed into meta layers[3][4] to make adding custom recipes easier.
**** Linux From Scratch
https://en.wikipedia.org/wiki/Linux_From_Scratch
List of Linux distributions
https://en.wikipedia.org/wiki/List_of_Linux_distributions
Filesystem Hierarchy Standard
https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard
https://en.wikipedia.org/wiki/Linux_Standard_Base
***** Embedded Linux Wiki
http://elinux.org/Main_Page
***** OpenRC
https://en.wikipedia.org/wiki/OpenRC
https://en.wikipedia.org/wiki/Linux_for_mobile_devices

**** GUI
***** X Window System
https://en.wikipedia.org/wiki/X_Window_System

The X Window System (X11, or shortened to simply X) is a windowing system for bitmap displays, common on UNIX-like computer operating systems.

X provides the basic framework for a GUI environment: drawing and moving windows on the display device and interacting with a mouse and keyboard. X does not mandate the user interface – this is handled by individual programs. As such, the visual styling of X-based environments varies greatly; different programs may present radically different interfaces.
****** Software architecture
X uses a client–server model: an X server communicates with various client programs. The server accepts requests for graphical output (windows) and sends back user input (from keyboard, mouse, or touchscreen). The server may function as:
+ an application displaying to a window of another display system
+ a system program controlling the video output of a PC
+ a dedicated piece of hardware
This client–server terminology – the user's terminal being the server and the applications being the clients – often confuses new X users, because the terms appear reversed. But X takes the perspective of the application, rather than that of the end-user: X provides display and I/O services to applications, so it is a server; applications use these services, thus they are clients.

The communication protocol between server and client operates network-transparently: the client and server may run on the same machine or on different ones, possibly with different architectures and operating systems. A client and server can even communicate securely over the Internet by tunneling the connection over an encrypted network session.

To use an X client application on a remote machine, the user may do the following:

+ on the local machine, open a terminal window
+ use ssh with the X forwarding argument to connect to the remote machine
+ request local display/input service (e.g., export DISPLAY=[user's machine]:0 if not using SSH with X forwarding enabled)
The remote X client application will then make a connection to the user's local X server, providing display and input to the user.

****** X Window System core protocol
https://en.wikipedia.org/wiki/X_Window_System_core_protocol
******* Overview[edit]
Communication between server and clients is done by exchanging packets over a channel. The connection is established by the client (how the client is started is not specified in the protocol). The client also sends the first packet, containing the byte order to be used and information about the version of the protocol and the kind of authentication the client expects the server to use. The server answers by sending back a packet stating the acceptance or refusal of the connection, or with a request for a further authentication. If the connection is accepted, the acceptance packet contains data for the client to use in the subsequent interaction with the server.

After connection is established, four types of packets are exchanged between client and server over the channel:

+ Request: The client requests information from the server or requests it to perform an action.
+ Reply: The server responds to a request. Not all requests generate replies.
+ Event: The server informs the client of an event, such as keyboard or mouse input, a window being moved, resized or exposed, etc.
+ Error: The server sends an error packet if a request is invalid. Since requests are queued, error packets generated by a request may not be sent immediately.
Request and reply packets have varying length, while event and error packets have a fixed length of 32 bytes.

Request packets are numbered sequentially by the server as soon as it receives them: the first request from a client is numbered 1, the second 2, etc. The least significant 16 bits of the sequential number of a request is included in the reply and error packets generated by the request, if any. They are also included in event packets to indicate the sequential number of the request that the server is currently processing or has just finished processing.
******** xlib
https://en.wikipedia.org/wiki/Xlib

****** Competitors
Android which runs on the Linux kernel, uses its own system for drawing the user interface known as SurfaceFlinger. 3D rendering is handled by EGL.

Wayland is being developed by several X.Org developers as a prospective replacement for X. It works directly with the GPU hardware, via DRI. Wayland can run an X.org server as a client, which can be rootless.[13] A proprietary port of the Wayland backend to the Raspberry Pi was completed in 2013.[14] The project reached version 1.0 in 2012. Like Android, Wayland is EGL-based.

Mir is a project from Canonical Ltd. with goals similar to Wayland.[15] Mir is intended to work with mobile devices using ARM chipsets (a stated goal is compatibility with Android device-drivers) as well as x86 desktops. Like Android, Mir/UnityNext are EGL-based. Backwards compatibility with X client-applications is accomplished via Xmir.

Other alternatives attempt to avoid the overhead of X by working directly with the hardware; such projects include DirectFB.[16] (The Direct Rendering Infrastructure (DRI), which aims to provide a reliable kernel-level interface to the framebuffer, might[citation needed] make these efforts redundant.)

***** Window manager
https://en.wikipedia.org/wiki/Window_manager
When a window manager is running, some kinds of interaction between the X server and its clients are redirected through the window manager. In particular, whenever an attempt to show a new window is made, this request is redirected to the window manager, which decides the initial position of the window. Additionally, most modern window managers are reparenting, which usually leads to a banner being placed at the top of the window and a decorative frame being drawn around the window. These two elements are controlled by the window manager rather than the program. Therefore, when the user clicks or drags these elements, it is the window manager that takes the appropriate actions (such as moving or resizing the window).
****** Comparison of X window managers
https://en.wikipedia.org/wiki/Comparison_of_X_window_managers
****** Compositing window manager
https://en.wikipedia.org/wiki/Compositing_window_manager
A compositing window manager, or compositor, is a window manager that provides applications with an off-screen buffer for each window. The window manager composites the window buffers into an image representing the screen and writes the result into the display memory.[1][2]
Compositing window managers may perform additional processing on buffered windows, applying 2D and 3D animated effects such as blending, fading, scaling, rotation, duplication, bending and contortion, shuffling, blurring, redirecting applications, and translating windows into one of a number of displays and virtual desktops. Computer graphics technology allows for visual effects to be rendered in real time such as drop shadows, live previews, and complex animation.[3][4] Since the screen is double buffered, it does not flicker during updates

******* AIGLX
Accelerated Indirect GLX ("AIGLX") is an open source project founded by Red Hat and the Fedora community, led by Kristian Høgsberg,[1] to allow accelerated indirect GLX rendering capabilities to the X.Org Server and DRI drivers. This allows remote X clients to get fully hardware accelerated rendering over the GLX protocol; coincidentally, this development was required for OpenGL compositing window managers to function with hardware acceleration.

******* GLX
GLX (initialism for "OpenGL Extension to the X Window System") is an extension to the X Window System core protocol providing an interface between OpenGL and the X Window System as well as extensions to OpenGL itself. It enables programs wishing to use OpenGL to do so within a window provided by the X Window System. GLX distinguishes two "states": indirect state and direct state.

******** GLX consists of three parts:

An API that provides OpenGL functions to an X Window System application.
An extension of the X protocol, which allows the client (the OpenGL application) to send 3D rendering commands to the X server (the software responsible for the display). The client and server software may run on different computers.
An extension of the X server that receives the rendering commands from the client and passes them on to the installed OpenGL library
If client and server are running on the same computer and an accelerated 3D graphics card using a suitable driver is available, the former two components can be bypassed by DRI. In this case, the client application is then allowed to directly access the video hardware through several API layers.

******* Hardware overlay
https://en.wikipedia.org/wiki/Hardware_overlay
******* Chroma key
https://en.wikipedia.org/wiki/Chroma_key

****** Stacking window manager
A stacking window manager (also called floating window manager) is a window manager that draws all windows in a specific order, allowing them to overlap, using a technique called painter's algorithm. All window managers that allow the overlapping of windows but are not compositing window managers are considered stacking window managers, although it is possible that not all use exactly the same methods. Other window managers that are not considered stacking window managers are those that do not allow the overlapping of windows, which are called tiling window managers.[1]

Stacking window managers allow windows to overlap by drawing them one at a time. Stacking, or repainting (in reference to painter's algorithm) refers to the rendering of each window as an image, painted directly over the desktop, and over any other windows that might already have been drawn, effectively erasing the areas that are covered. The process usually starts with the desktop, and proceeds by drawing each window and any child windows from back to front, until finally the foreground window is drawn.[2]
The order in which windows are to be stacked is called their z-order.

***** Display server
https://en.wikipedia.org/wiki/Display_server
A display server or window server is a program whose primary task is to coordinate the input and output of its clients to and from the rest of the operating system, the hardware, and each other. The display server communicates with its clients over the display server protocol, a communications protocol, which can be network-transparent or simply network-capable.
****** List of display servers
https://en.wikipedia.org/wiki/List_of_display_servers

****** X11
One example of a display server is the X.Org Server, which runs on top of the kernel (usually a Unix-based kernel, such as Linux or BSD). It receives data from evdev and passes it to one of its clients. The display server also receives data from its clients; it processes the data, it does the compositing and passes the data to one of three kernel components – DRM, gem or KMS driver. The component writes the data into the framebuffer and content of the framebuffer is transmitted to the connected screen and displayed. X relies on GLX.

One of the implementations of display server concept is X Window System, in particular its actually used version – X.Org Server and Xlib and XCB client libraries. The X.Org Server is a display server, but in its current implementation it relies on a second program, the compositing window manager, to do the compositing. Examples are Mutter or KWin.

******* X display manager (program type)
https://en.wikipedia.org/wiki/X_display_manager_(program_type)
In the X Window System, an X display manager is a graphical login manager which starts a session on an X server from the same or another computer.

A login screen shown by the KDM display manager.
A display manager presents the user with a login screen. A session starts when a user successfully enters a valid combination of username and password.

******** Local and remote display management[edit]
A display manager can run on the same computer where the user sits—starting one or more X servers, displaying the login screen at the beginning and (optionally) every time the user logs out—or on a remote one, working according to the XDMCP protocol.

In the X Window System, the X server runs on the computer in front of the user. The X server may connect to a display manager running on another computer, starting a session which may comprise a variety of programs running on that other computer.

The XDMCP protocol mandates that the X server starts autonomously and connects to the display manager. In the X Window System paradigm, the server runs on the computer providing the display and input devices. A server can connect, using the XDMCP protocol, to a display manager running on another computer, requesting it to start the session. In this case, the X server acts as a graphical telnet client while the display manager acts like a telnet server: users start programs from the computer running the display manager, while their input and output take place on the computer where the server (and the user) sits.
***** X.Org Server
https://en.wikipedia.org/wiki/X.Org_Server
X.Org Server is the free and open source implementation of the display server for the X Window System stewarded by the X.Org Foundation.

Implementations of the client side of the protocol are available e.g. in the form of Xlib and XCB.
****** Device Independent X (DIX)[edit]
The Device Independent X (DIX) is the part of the X.Org Server that interacts with clients and implements software rendering. Basically everything in the server except for the hw/ directory. The main loop and the event delivery are part of the DIX.[6]
An X server has a tremendous amount of functionality that must be implemented to support the X core protocol. This includes code tables, glyph rasterization and caching, XLFDs, and the entire core rendering API that draws stippled lines, polygons, wide arcs and many more state-of-the-1980s style graphics primitives.
****** Device Dependent X (DDX)[edit]
The Device Dependent X (DDX) is the part of the x-server that interacts with the hardware. In the X.Org Server source code, each directory under "hw" corresponds to one DDX. Hardware comprises graphics cards as well as mouse and keyboards. Each driver is hardware specific and implemented as a separate loadable module.
******* 2D graphics driver
For historical reasons the X.Org Server still contains graphics device drivers supporting some form of 2D rendering acceleration. In ancient times, the mode-setting was done by some x-server graphics device drivers specific to some video controller/graphics card. To this mode-setting functionality, additional support for 2D acceleration was added when such became available with various GPUs. The mode-setting functionality was moved into the DRM and is being exposed through an DRM mode-setting interface, the new approach being called "kernel mode-setting" (KMS). But the 2D rendering acceleration remained.

****** Wayland
Display servers that implement the Wayland display server protocol, are called Wayland compositors. Like any display server, a Wayland compositor is responsible for handling input and output for its clients and – in contrast to X11 – additionally for the compositing. Examples are Weston, Mutter, KWin or Enlightenment.

Wayland compositors communicate with Wayland clients over the Wayland display server protocol. This protocol defines that clients can directly write data into the framebuffer using the EGL rendering API. The display server still gets to decide which window is on top and thus visible to the user and also still is responsible for passing data regarding to input devices from evdev to its clients.

******* Wayland (display server protocol)
https://en.wikipedia.org/wiki/Wayland_(display_server_protocol)
https://wayland.freedesktop.org
Wayland is a computer protocol that specifies the communication between a display server (called a Wayland compositor[clarification needed]) and its clients, as well as a reference implementation of the protocol in the C programming language.[7]

Wayland is developed by a group of volunteers initially led by Kristian Høgsberg as a free and open community-driven project with the aim of replacing the X Window System with a modern, simpler windowing system in Linux and other Unix-like operating systems.[7] The project's source code is published under the terms of the MIT License, a permissive free software licence.[8][4]
******** Mutter (software)
https://en.wikipedia.org/wiki/Mutter_(software)
Mutter is a window manager initially designed and implemented for the X Window System, and recently has evolved to be a Wayland compositor. It became the default window manager in GNOME 3, replacing Metacity[5] which used GTK+ for rendering. Mutter uses a graphics library called Clutter giving it OpenGL capability. The name is a portmanteau of Metacity and Clutter.

******** KWin
https://en.wikipedia.org/wiki/KWin
KWin is a window manager for the X Window System and is currently in the process of becoming a Wayland compositor.[3] It is released as part of KDE Plasma 5 for which it is the default window manager. KWin can also be used on its own or with other desktop environments.

******** Enlightenment (software)
https://en.wikipedia.org/wiki/Enlightenment_(software)

******** Mesa (computer graphics)
Mesa is an open-source implementation of the OpenGL, Vulkan and other specifications. Its most important user surfacing parts are the two graphics drivers mostly developed and funded by Intel and AMD, which are using those implementations. The smaller GeForce graphics driver Nouveau in contrast is mostly a community effort. Mesa implements a cross-language, cross-platform (mostly on BSD and Linux distributions), vendor-neutral standard API for interfacing with diverse vendor-specific graphics hardware drivers.

****** Mir
The Mir display server comes with its own Mir display server protocol different from the protocols X11 or Wayland. Mir will additionally support the X11 and maybe the Wayland protocol. It was developed by Canonical and was intended to be the display server of choice for Ubuntu.
******* Mir (software)
https://en.wikipedia.org/wiki/Mir_(software)
Mir is a computer display server for the Linux operating system that is under development by Canonical Ltd. It was planned to replace the currently used X Window System for Ubuntu.
****** SurfaceFlinger
For Android (another Linux kernel-based operating system primarily for mobile devices) Google developed a display server called SurfaceFlinger:[2]

Everything in Android is rendered to a "surface"; "surfaces" are produced by applications and placed into a queue that is managed by SurfaceFlinger.[3][4]
****** DirectFB
https://en.wikipedia.org/wiki/DirectFB
http://www.directfb.org

DirectFB (Direct Frame Buffer) is a software library with a small memory footprint that provides graphics acceleration, input device handling and abstraction layer, and integrated windowing system with support for translucent windows and multiple display layers on top of the Linux framebuffer without requiring any kernel modifications.[2] DirectFB is free and open-source software subject to the terms of the GNU Lesser General Public License (LGPL).

DirectFB can host XDirectFB, a rootless X server implementation that uses DirectFB windows for X11 top-level windows. XDirectFB is an interface that mimics the X11 interface through the DirectFB API to simplify running applications written for X11 on DirectFB.[4]
DirectFBGL is an OpenGL extension for DirectFB/XDirectFB that uses Direct Rendering Infrastructure (DRI) in the Mesa 3D library to support OpenGL hardware acceleration.

******* Linux framebuffer
https://en.wikipedia.org/wiki/Linux_framebuffer
The Linux framebuffer (fbdev) is a graphic hardware-independent abstraction layer to show graphics on a computer monitor, typically on the console.[1] The word framebuffer means a part of video memory containing a current video frame, and the Linux framebuffer means “access method to the framebuffer under the Linux kernel”, without relying on system-specific libraries such as SVGALib or another user space software.
******** There are three applications of the Linux framebuffer.
+ An implementation of text Linux console that doesn't use hardware text mode (useful when that mode is unavailable, or to overcome its restrictions on glyph size, number of code points etc.). One popular aspect of this is the ability to have console show the Tux logo at boot up.
+ A possible graphic output method for a display server, independent of video adapter hardware and its drivers.
+ Graphic programs avoiding the heavy overhead of the X Window System.

Examples of the third application include Linux programs such as MPlayer, links2, Netsurf, fbida,[2] and fim [3] and libraries such as GGI, SDL, GTK+, and Qt, which can all use the framebuffer directly. This use case is particularly popular in embedded systems.

The now defunct DirectFB is another project aimed at providing a framework for hardware acceleration of the Linux framebuffer.
There was also a windowing system called FramebufferUI (fbui) implemented in kernel-space that provided a basic 2D windowing experience with very little memory use.[4]

***** Direct Rendering Manager
https://en.wikipedia.org/wiki/Direct_Rendering_Manager
In computing, the Direct Rendering Manager (DRM), a subsystem of the Linux kernel, interfaces with the GPUs of modern video cards. DRM exposes an API that user-space programs can use to send commands and data to the GPU, and to perform operations such as configuring the mode setting of the display. DRM was first developed as the kernel space component of the X Server's Direct Rendering Infrastructure,[1] but since then it has been used by other graphic stack alternatives such as Wayland.
User-space programs can use the DRM API to command the GPU to do hardware-accelerated 3D rendering and video decoding as well as GPGPU computing.
****** Direct Rendering Infrastructure (DRI)
https://en.wikipedia.org/wiki/Direct_Rendering_Infrastructure
The Direct Rendering Infrastructure (DRI) is a framework for allowing direct access to graphics hardware under the X Window System in a safe, efficient way.[6] The main use of DRI is to provide hardware acceleration for the Mesa implementation of OpenGL. DRI has also been adapted to provide OpenGL acceleration on a framebuffer console without a display server running

DRI implementation is scattered through the X Server and its associated client libraries, Mesa 3D and the Direct Rendering Manager kernel subsystem.[6] All of its source code is free software.
******* Overview
X clients should have direct access to graphics hardware rather than relying on a third party process to do so, saving all the IPC overload. This approach is called "direct rendering" as opposed to the "indirect rendering" provided by the classical X architecture. The Direct Rendering Infrastructure was initially developed to allow any X client to perform 3D rendering using this "direct rendering" approach
It should be noted that nothing prevents DRI from being used to implement accelerated 2D direct rendering within an X client.[3] Simply no one has had the need to do so because the 2D indirect rendering performance was good enough.

****** DMA Buffer Sharing and PRIME
The DMA Buffer Sharing API (often abbreviated as DMA-BUF) is a Linux kernel internal API designed to provide a generic mechanism to share DMA buffers across multiple devices, possibly managed by different types of device drivers.[25][26] For example, a Video4Linux device and a graphics adapter device could share buffers through DMA-BUF to achieve zero-copy of the data of a video stream produced by the first and consumed by the latter. Any Linux device driver can implement this API as exporter, as user (consumer) or both.
****** Hardware overlay
https://en.wikipedia.org/wiki/Hardware_overlay
****** Chroma key
https://en.wikipedia.org/wiki/Chroma_key
****** X video extension
https://en.wikipedia.org/wiki/X_video_extension
The video controller has to provide the required functions.
The device driver software for the video controller and the X display server program have to implement the XVideo interface.
The video playback software has to make use of this interface.
Most modern video controllers provide the functions required for XVideo; this feature is known as hardware scaling and YUV acceleration or sometimes as 2D hardware acceleration.

Video playback programs that run under the X Window system, such as MPlayer, MythTV or xine, typically have an option to enable XVideo output. It is very advisable to switch on this option if the system GPU video-hardware and device drivers supports XVideo and more modern rendering systems such as OpenGL and VDPAU are unavailable – the speedup is very noticeable even on a fast CPU.
****** Multiple buffering
https://en.wikipedia.org/wiki/Multiple_buffering#Page_flipping
****** Swap Chain
https://en.wikipedia.org/wiki/Swap_Chain
In computer graphics, a swap chain is a series of virtual framebuffers utilized by the graphics card and graphics API for frame rate stabilization and several other functions. The swap chain usually exists in graphics memory, but it can exist in system memory as well. The non-utilization of a swap chain may result in stuttering rendering, but its existence and utilization are required by many graphics APIs. A swap chain with two buffers is a double buffer.

In every swap chain there are at least two buffers. The first framebuffer, the screenbuffer, is the buffer that is rendered to the output of the video card. The remaining buffers are known as backbuffers. Each time a new frame is displayed, the first backbuffer in the swap chain takes the place of the screenbuffer, this is called presentation or swapping. A variety of other actions may be taken on the previous screenbuffer and other backbuffers (if they exist). The screenbuffer may be simply overwritten or returned to the back of the swap chain for further processing. The action taken is decided by the client application and is API dependent.

***** Free and open-source graphics device driver
https://en.wikipedia.org/wiki/Free_and_open-source_graphics_device_driver
The free and open-source drivers are primarily developed on Linux and for Linux. They have been under constant development by the Linux kernel developers, by 3rd party programming enthusiasts and also by employees of companies such as e.g.AMD. Each driver is composed out of five parts:

+ Linux kernel component DRM
+ Linux kernel component KMS driver: basically the device driver for the display controller
+ user-space component libDRM: a wrapper library for the system calls of the DRM, should only be used by Mesa 3D
+ user-space component in Mesa 3D: this component is highly hardware specific, is being executed on the CPU and does the translation of e.g. OpenGL commands into machine code for the GPU;
because of the split nature of the device driver, marshalling is possible;
Mesa 3D is the only available free and open-source implementation of OpenGL, OpenGL ES, OpenVG, GLX, EGL and OpenCL
as of July 2014 most of these components are written conforming to the Gallium3D-specifications;
there is a fully functional State Tracker for Direct3D version 9 written in C and an un-maintained one for Direct3D versions 10 and 11 written in C++.[19]
+ Device Dependent X (DDX), an additional special and distinct 2D graphics device driver extra for X.Org Server (Which is going to be replaced by Glamor)

****** ARM[edit]
See also: Mali
ARM Holdings is a fabless semiconductor company which licenses SIP cores. They are known for the licensing the ARM instruction set and CPUs based upon it but they also develop and license the Mali series of GPUs. On January 21, 2012, Phoronix reported that Luc Verhaegen was driving a reverse-engineering attempt aimed at the ARM Holdings Mali series of GPUs, specifically the Mali-200 and Mali-400 versions. The reverse-engineering project, called lima, was presented at FOSDEM, February 4, 2012.[34][35] On February 2, 2013, Verhaegen demonstrated Quake III Arena in timedemo mode, running on top of the Lima driver.[36]

ARM has shown no intention of providing support for their graphics acceleration hardware licensed under some free and open-source license. But in December 2015 and April 2016 ARM employees did send patches for the Linux kernel to support at least their display controller SIP blocks "ARM HDLCD display controller" and Mali DP500, DP550 and DP650.[37][38]

****** Imagination Technologies[edit]
See also: PowerVR
Imagination Technologies is a fabless semiconductor company that develops and licenses semiconductor intellectual property cores, among which are the PowerVR GPUs. Intel has manufactured a number of PowerVR based GPUs. PowerVR GPUs are widely used in mobile SoCs. Imagination Technologies does not provide a FOSS driver or any public documentation for the PowerVR. Due to its wide use in embedded devices, the Free Software Foundation has put reverse-engineering of the PowerVR driver on a high-priority project list.[39]

PowerVR reverse engineering project
**** RPM Package Manager
https://en.wikipedia.org/wiki/RPM_Package_Manager
**** Software repository
https://en.wikipedia.org/wiki/Software_repository
| Language     | Process                   | Repository               | How to install         | platform  | Autochecks |
| C++          |                           | Boost                    |                        |           |            |
| Haskell      | (CABAL)                   | Hackage                  | [1]                    |           |            |
| Java         |                           | Maven                    | [2]                    |           |            |
| Julia        |                           | [3]                      |                        |           |            |
| Common Lisp  |                           | Quicklisp                | [4]                    |           |            |
| .NET         | NuGet                     | NuGet                    | [5]                    |           |            |
| Node.js      |                           | NPM                      | [6]                    |           |            |
| Perl         |                           | CPAN                     | PPM[7]                 |           |            |
| PHP          | PEAR                      | PECL                     |                        |           |            |
| Python       | Setuptools                | PyPI                     | pip, EasyInstall, PyPM |           |            |
| R            | R CMD check process[2][3] | CRAN                     | install.packages       | R-Forge   |            |
| Bioconductor | BiocLite.R                |                          |                        |           |            |
| Ruby         | RubyGems                  | Ruby Application Archive |                        | RubyForge |            |
| TeX, LaTeX   |                           | CTAN                     |                        |           |            |
https://en.wikipedia.org/wiki/Boost_(C%2B%2B_libraries)
https://en.wikipedia.org/wiki/Apache_Maven
**** COCOMO
https://en.wikipedia.org/wiki/COCOMO
*** Debian
https://en.wikipedia.org/wiki/Debian#Embedded_systems
Debian has access to online repositories that contain over 50,000 software packages[8] making it the largest software compilation.[9] Debian officially contains only free software, but non-free software can be downloaded from the Debian repositories and installed.[10] Debian includes popular free programs such as LibreOffice,[11] Firefox web browser, Evolution mail, K3b disc burner, VLC media player, GIMP image editor, and Evince document viewer.[10] Debian is a popular choice for web servers

**** Package management[edit]
Package management operations can be performed with different tools available on Debian, from the lowest level command dpkg to graphical front-ends like Synaptic. The recommended standard for administering packages on a Debian system is the apt toolset.[96]

dpkg provides the low-level infrastructure for package management.[97] The dpkg database contains the list of installed software on the current system. The dpkg command tool does not know about repositories. The command can work with local .deb package files, and information from the dpkg database.[98]

**** APT tools[edit]

Using Aptitude to view Debian package details

Package installed with Aptitude
An Advanced Packaging Tool (APT) tool allows administering an installed Debian system to retrieve and resolve package dependencies from repositories. APT tools share dependency information and cached packages.[96]

+ Aptitude is a command line tool that also offers a text-based user interface. The program comes with enhancements such as better search on package metadata.[96]
+ apt-get and apt-cache are command tools of the standard apt package. apt-get installs and removes packages, and apt-cache is used for searching packages and displaying package information.[96]

**** dpkg
To install a .deb package:
dpkg -i filename.deb
where filename.deb is the name of the Debian package (such as pkgname_0.00-1_amd64.deb).

The list of installed packages can be obtained with:
dpkg -l [optional pattern]
To remove an installed package:

dpkg -r packagename

**** Advanced Packaging Tool

***** apt-get[edit]
apt-get is the command line package management tool supplied with the Debian package apt. APT searches its cached list of packages and lists the dependencies that must be installed or updated.

Triggers are the treatment of deferred actions.

APT retrieves, configures and installs the dependencies automatically.

Update, upgrade and dist-upgrade[edit]

****** Other commands used in apt-get:

+ update is used to resynchronize the package index files from their sources. The lists of available packages are fetched from the location(s) specified in /etc/apt/sources.list. For example, when using a Debian archive, this command retrieves and scans the Packages.gz files, so that information about new and updated packages is available.
+ upgrade is used to install the newest versions of all packages currently installed on the system from the sources enumerated in /etc/apt/sources.list. Packages currently installed with new versions available are retrieved and upgraded; under no circumstances are currently installed packages removed, or packages not already installed retrieved and installed. New versions of currently installed packages that cannot be upgraded without changing the install status of another package will be left at their current version.
+ dist-upgrade, in addition to performing the function of upgrade, also intelligently handles changing dependencies with new versions of packages; apt-get has a "smart" conflict resolution system, and it will attempt to upgrade the most important packages at the expense of less important ones if necessary. The /etc/apt/sources.list file contains a list of locations from which to retrieve desired package files.[12] aptitude has a smarter dist-upgrade feature called full-upgrade.[13]

***** apt-file[edit]
apt-file is a command to find which package includes a specific file, or to list all files included in a package. It is packaged separately from the main APT utilities.

Example to find a package:
$ apt-file update         # Fetch the files installed by the packages in local cache
$ apt-file find vmlinuz   # Find all packages providing a filename vmlinuz

** openWRT
https://en.wikipedia.org/wiki/OpenWrt
OpenWrt is an open source project for embedded operating system based on Linux, primarily used on embedded devices to route network traffic. The main components are Linux, util-linux, uClibc or musl,[5] and BusyBox. All components have been optimized for size, to be small enough for fitting into the limited storage and memory available in home routers.

OpenWrt is configured using a command-line interface (ash shell), or a web interface (LuCI). There are about 3500 optional software packages available for installation via the opkg package management system.
*** PulseAudio
https://en.wikipedia.org/wiki/PulseAudio
https://en.wikipedia.org/wiki/Comparison_of_free_software_for_audio
*** MPD
https://en.wikipedia.org/wiki/Music_Player_Daemon
*** opkg
https://en.wikipedia.org/wiki/Opkg
opkg (Open PacKaGe management) is a lightweight package management system based upon ipkg. It is written in C and resembles APT/dpkg in operation. It is intended for use on embedded GNU/Linux devices and is used in this capacity in the OpenEmbedded and OpenWrt projects.[2]

Opkg was originally forked from ipkg by the Openmoko project.[3] More recently, development of opkg has moved from its old Google Code repository to Yocto Project where it is actively maintained again.

openwrt框架分析
http://blog.csdn.net/kingvenll/article/details/27545221
openwrt: Makefile 框架分析
http://blog.csdn.net/flexman09/article/details/51849707

*** openWRT 发布包
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0453C3DA@srv-mail-02.actions.com.cn][转发: LS3605 OPENWRT]]
** libusb
*** libusb
    * libusb的官方网站：
      * http://libusb.
    * 代码：
      * https://github.com/libusb/libusb
    * 示例代码：
      * https://github.com/libusb/libusb/tree/master/examples
    * 一些文章
      * Android 用 libusb 操作 USB 设备，无须 root
      * http://blog.csdn.net/hubbybob1/article/details/52101356
      * (转载)libusb开发者指南
      * http://www.cnblogs.com/ele-eye/p/3261970.html
*** gaget cofigFS
  * 源码：
    * https://github.com/libusbg/libusbg
  * 文章：
    * Linux usb gadget configfs用法
    * http://blog.csdn.net/zoosenpin/article/details/38224149
    * How to enable Android ConfigFS gadgets
    * http://blog.csdn.net/ztguang/article/details/53106556
** RTOS
http://electronics360.globalspec.com/article/6887/the-rtos-in-2016
*** Internet of things
https://en.wikipedia.org/wiki/Internet_of_things
*** Comparison of real-time operating systems
https://en.wikipedia.org/wiki/Comparison_of_real-time_operating_systems
**** Contiki
https://en.wikipedia.org/wiki/Contiki
Contiki is designed to run on types of hardware devices that are severely constrained in memory, power, processing power, and communication bandwidth. A typical Contiki system has memory on the order of kilobytes, a power budget on the order of milliwatts, processing speed measured in megahertz, and communication bandwidth on the order of hundreds of kilobits/second. Such systems include many types of embedded systems, and old 8-bit computers.
**** RIOT (operating system)
RIOT is a small operating system for networked, memory-constrained systems with a focus on low-power wireless Internet of Things (IoT) devices. It is open-source software, released under the GNU Lesser General Public License (LGPL). Due to this unclonable license and its large independent community RIOT is often referred to as the Linux of the Internet of Things.
**** Zephyr (operating system)
https://en.wikipedia.org/wiki/Zephyr_(operating_system)
The Zephyr kernel is small and designed for use on resource-constrained systems: from simple embedded environmental sensors and light emitting diode (LED) wearables to sophisticated smart watches and IoT wireless gateways.

The kernel offers several features that distinguish it from other small OSes:
+ Single address-space
+ Highly configurable
+ Resources defined at compile-time
+ Minimal error checking
+ Development services
** scheme

https://github.com/cisco/chezscheme
** quicklisp
**** yason
(defvar *json-string* "[{\"foo\":1,\"bar\":[7,8,9]},2,3,4,[5,6,7],true,null]")
(let* ((result (yason:parse *json-string*)))
  (print result)
  (alexandria:hash-table-plist (first result)))

(yason:encode
 (list (alexandria:plist-hash-table
        '("foo" 1 "bar" (7 8 9))
        :test #'equal)
       2 3 4
       '(5 6 7)
       t nil)
 *standard-output*)

(yason:with-output (*standard-output*)
  (yason:with-object ()
    (yason:encode-object-element "hello" "hu hu")
    (yason:with-object-element ("harr")
      (yason:with-array ()
        (dotimes (i 3)
          (yason:encode-array-element i))))))
(yason:with-output (*standard-output*)
  (yason:with-array ()
    (dotimes (i 3)
      (yason:encode-array-element i))))

(yason:encode
 (alexandria:plist-hash-table
  '("format"  "pcm" "rate" "8000" "channel" "1"
    "cuid" "serial987654321"
    "speech" "len")
  :test #'equal)
 *standard-output*)
**** cl-async
  http://orthecreedence.github.io/cl-async/documentation
  (load "/Users/zhangdongfeng/quicklisp/dists/quicklisp/software/slime-v2.18/contrib/swank-listener-hooks.lisp")
  (as:start-event-loop
          (lambda ()
            (format t "Exiting event loop.~%")))
(as:start-event-loop
          (lambda ()
            (as:delay
             (lambda ()
               (format t "Timer fired. Exiting.~%"))
             :time 3)))

(defun my-echo-server ()
  (format t "Starting server.~%")
  (as:tcp-server nil 9003  ; nil is "0.0.0.0"
                 (lambda (socket data)
                   ;; echo the data back into the socket
                   (as:write-socket-data socket data))
                 (lambda (err) (format t "listener event: ~a~%" err)))
  ;; catch sigint
  (as:signal-handler 2 (lambda (sig)
                         (declare (ignore sig))
                         (as:exit-event-loop))))

(as:start-event-loop #'my-echo-server)

(ql:quickload :cl-async)

(defun do-lookups ()
  (dolist (lookup `(("google.com")
                    ("musio.com" . ,as:+af-inet+)
                    ("www.google.com" . ,as:+af-inet6+)))
    (let ((host (car lookup))
          (family (if (cdr lookup) (cdr lookup) as:+af-unspec+)))
      (as:dns-lookup host
                     (lambda (addr fam)
                       (declare (ignore fam))
                       (format t "~a resolved to ~s (~s)~%" host addr family))
                     :event-cb (lambda (ev)
                                 (format t "ev: ~a(~a): ~a~%" host family ev))
                     :family family))))

(as:start-event-loop #'do-lookups)



(defun get-http-response (host &optional (port 80))
  (as:tcp-connect host port
    (lambda (sock data)
      (unless (as:socket-closed-p sock)
        (as:close-socket sock))
      (format t "~a" (babel:octets-to-string data)))
    (lambda (ev)
      (format t "ev: ~a~%" ev))
    :data (format nil "GET / HTTP/1.1~c~cHost: ~a~c~c~c~c"
                  #\return #\newline
                  host
                  #\return #\newline
                  #\return #\newline)
    :read-timeout 5))

(as:start-event-loop (lambda () (get-http-response "www.baidu.com")))
**** sb-textinfo

http://nikodemus.github.io/sb-texinfo/
https://github.com/sionescu/texinfo-docstrings

(sb-texinfo:generate-includes #p "/Users/zhangdongfeng/quicklisp/dists/quicklisp/software/babel-20150608-git/doc/include/" (list :babel :babel-streams :babel-tests))
**** roswell
https://github.com/roswell/roswell\

https://github.com/roswell/roswell/wiki/0.-FAQ


ros install elf
~/.roswell/local-projects
ln -s ~/quicklisp/local-projects/ ~/.roswell/local-projects


ros init
ros init test

#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#

(defun fact (n)
  (if (zerop n)
      1
      (* n (fact (1- n)))))

(defun main (n &rest argv)
  (declare (ignore argv))
  (format t "~&Factorial ~D = ~D~%" n (fact (parse-integer n))))

./test.ros 3
ros build test.ros
**** cl-project
(cl-project:make-project #p"~/.roswell/local-projects/cl-demo/"
                                  :depends-on '(:clack :cl-annot))
https://github.com/fukamachi/cl-project
http://labs.ariel-networks.com/cl-style-guide.html

**** flexi-streams

https://github.com/edicl

 unicode, utf-8, codepage的含义 以及 相互关系
http://blog.csdn.net/normallife/article/details/8548306

http://weitz.de/flexi-streams/

utf8汉字编码16进制对照
http://blog.chinaunix.net/uid-25544300-id-3281847.html

(defun bar (pathspec)
        "With a flexi stream."
        (with-open-file (out pathspec
                             :direction :output
                             :if-exists :supersede
                             :element-type 'octet
                                        ;:external-format '(:latin-1 :eol-style :lf)
                             )
          (setq out (make-flexi-stream out :external-format :utf-8))
          (write-line "ÄÖÜ1" out)
          (setf (flexi-stream-external-format out) '(:latin-1 :eol-style :lf))
          (write-line "ÄÖÜ2" out)
          (write-byte #xeb out)
          (write-byte #xa3 out)
          (write-byte #xa4 out)
          (write-byte #xa5 out)
                                        ;          (write-sequence #(#xa3 #xa4 #xa5) out)
          (setf (flexi-stream-external-format out) :ucs-2be)
          (write-line "ÄÖÜ3" out)))

(defun baz (pathspec)
        (let (result)
          (with-open-file (in pathspec :element-type 'octet)
            (setq in (make-flexi-stream in :external-format :utf-8))
            (push (read-line in) result)
            (push (read-byte in) result)
            (setf (flexi-stream-external-format in) '(:latin-1 :eol-style :lf))
            (push (read-line in) result)
            (setf (flexi-stream-external-format in) :greek)
            (push (read-char in) result)
            (setf (flexi-stream-external-format in) :latin0)
            (let ((string (make-string 3 :element-type 'character)))
              (read-sequence string in)
              (push string result))
            (let ((octets (make-array 2 :element-type 'octet)))
              (read-sequence octets in)
              (push octets result))
            (setf (flexi-stream-external-format in) :ucs-2be)
            (push (read-line in) result))
          (nreverse result)))

**** CFFI
https://common-lisp.net/project/cffi/manual/html_node/
 (defpackage :cffi-user
    (:use :common-lisp :cffi))
  (in-package :cffi-user)
  (define-foreign-library libcurl
    (:darwin (:or "libcurl.3.dylib" "libcurl.dylib"))
    (:unix (:or "libcurl.so.3" "libcurl.so"))
    (t (:default "libcurl")))
  (use-foreign-library libcurl)

  (defctype curl-code :int)
  ;;; Initialize libcurl with FLAGS.
  (defcfun "curl_global_init" curl-code
    (flags :long))
(curl-global-init 0)
(defcfun "curl_easy_init" :pointer)

  (defcfun "curl_easy_cleanup" :void
    (easy-handle :pointer))
(defparameter *easy-handle* (curl-easy-init))

(defmacro define-curl-options (name type-offsets &rest enum-args)
    (flet ((enumerated-value (type offset)
             (+ (getf type-offsets type) offset)))
      `(progn
         (defcenum ,name
           ,@(loop for (name type number) in enum-args
                collect (list name (enumerated-value type number))))
         ',name)))                ;for REPL users' sanity

  (define-curl-options curl-option
      (long 0 objectpoint 10000 functionpoint 20000 off-t 30000)
    (:noprogress long 43)
    (:nosignal long 99)
    (:errorbuffer objectpoint 10)
    (:url objectpoint 2))

(foreign-funcall "curl_easy_setopt"
               :pointer *easy-handle*
               curl-option :nosignal :long 1 curl-code)

 (defctype easy-handle :pointer)

 (defmacro curl-easy-setopt (easy-handle enumerated-name
                              value-type new-value)
    `(foreign-funcall "curl_easy_setopt" easy-handle ,easy-handle
                      curl-option ,enumerated-name
                      ,value-type ,new-value curl-code))

** email
How to get email from exchange server without Outlook
http://blog.binchen.org/posts/how-to-get-email-from-exchange-server-without-outlook.html
http://davmail.sourceforge.net
http://growl.info

Emacs for Email
http://henry-y.github.io/emacs-for-email.html
http://blog.csdn.net/csfreebird/article/details/41408205
http://www.linuxidc.com/Linux/2014-11/109749.htm
Emacs as email client with offlineimap and mu4e on OS X
https://medium.com/@kirang89/emacs-as-email-client-with-offlineimap-and-mu4e-on-os-x-3ba55adc78b6
https://coldnew.github.io/blog/2016/01-02_mu4e/
http://www.djcbsoftware.nl/code/mu/mu4e/General.html
Does mu4e support searching for CJK (Chinese-Japanese-Korean) characters? Yes, if you have Xapian 1.2.8 or newer, and set the environment variable XAPIAN_CJK_NGRAM to non-empty before indexing, both when using mu from the command-line and from mu4e.
https://xapian.org
http://blog.csdn.net/visualcatsharp/article/details/4176083
https://emacs-china.org/t/imap-idle-mu4e/498
mu 解决中文搜索的问题，需要使用xapian的rsto的分支版本， cjk_words分支， 重新build， 以及重新build mu软件才可以。 参加xapian的pull request 180
https://github.com/rsto/xapian
http://blog.chedushi.com/archives/8498
export PKG_CONFIG_PATH=/usr/local/Cellar/icu4c/58.2/lib/pkgconfig/
export ICU_LIBS=/usr/local/Cellar/icu4c/58.2/lib
export ICU_INCLUDES=/usr/local/Cellar/icu4c/58.2/include
./configure
https://www.postgresql.org/message-id/071e7c00-beba-480d-fa62-0fbcf3fa7360@2ndquadrant.com
http://userguide.icu-project.org/howtouseicu


https://github.com/djcb/mu
https://www.emacswiki.org/emacs/mu4e
http://www.djcbsoftware.nl/code/mu/mu4e/index.htmln
machine localhost  login zhangdf password javateam1#  port 1025

Ten email commandments
http://timharford.com/2013/09/3180/
http://pragmaticemacs.com/emacs/master-your-inbox-with-mu4e-and-org-mode/
http://matt.hackinghistory.ca/2016/11/18/sending-html-mail-with-mu4e/
http://kitchingroup.cheme.cmu.edu/blog/2016/10/29/Sending-html-emails-from-org-mode-with-org-mime/
http://kitchingroup.cheme.cmu.edu/blog/category/orgmode/

http://orgmode.org/worg/org-contrib/org-mime.html
** Emacs编辑器——王垠
*** regexp
http://ergoemacs.org/emacs/emacs_regex.html
*** intro
  http://blog.csdn.net/superwen_go/article/details/8235185
  有哪些是必备的emacs扩展？
  https://www.zhihu.com/question/21943533
  Programming in Emacs+Sematic
  http://docs.huihoo.com/homepage/shredderyin/wiki/ProgrammingTricks.html
  Sams Teach Yourself Emacs in 24 Hours
  http://docs.huihoo.com/homepage/shredderyin/emacs24/index.htm
  我的Emacs折腾经验谈(一) 一些给新人的建议 –
  http://www.tuicool.com/articles/rIBBJn
  Emacs: How to Install Packages Using ELPA, MELPA
  http://ergoemacs.org/emacs/emacs_package_system.html
  Quickly finding project files using Emacs EDE
  http://stackoverflow.com/questions/23950534/quickly-finding-project-files-using-emacs-ede
  The function to show current file's full path in mini buffer
  http://stackoverflow.com/questions/3669511/the-function-to-show-current-files-full-path-in-mini-buffer
  Imenu显示符号列表
  http://www.gnu.org/software/emacs/manual/html_node/emacs/Imenu.html
  InteractivelyDoThings
  http://stackoverflow.com/questions/7394289/how-can-i-more-easily-switch-between-buffers-in-emacs
  https://www.emacswiki.org/emacs/InteractivelyDoThings
  Searching for marked (selected) text in Emacs
  http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html#SEC_Contents
  Emacs dired 模式
  http://blog.csdn.net/cxmanzhao/article/details/5685016
  emacs 快捷键（包括C／C++模式）
  http://www.cnblogs.com/xinxianshi/archive/2011/07/20/2157264.html

  CUA的矩形块操作很给力啊
http://www.cnblogs.com/bamanzi/archive/2011/02/28/emacs-cua-rectangle-cool.html
*** Emacs 24.4 Released, How to Install it in Ubuntu 14.04
  http://ubuntuhandbook.org/index.php/2014/10/emacs-24-4-released-install-in-ubuntu-14-04/
  https://www.emacswiki.org/emacs/SiteMap
  Emacs Starter Kit
  http://eschulte.github.io/emacs-starter-kit/
http://book.emacs-china.org
*** emacs + cscope 的使用
  http://blog.chinaunix.net/uid-20788636-id-1841254.html
  在Emacs下用C/C++编程
  http://blog.chinaunix.net/uid-9478057-id-2002272.html
  http://www.caole.net/diary/emacs_write_cpp.html
  使用gtags、etags、cscope、grep浏览源代码
  http://blog.csdn.net/wuyao721/article/details/3059242
  Cscope在emacs中的配置与使用
  http://www.cnblogs.com/jtf-china/articles/2077922.html
  一年成为Emacs高手(像神一样使用编辑器)
  http://blog.csdn.net/redguardtoo/article/details/7222501/
  https://www.emacswiki.org
  https://github.com/purcell/emacs.d
  https://www.emacswiki.org/emacs/EmacsWiki
  暴增 Emacs 生产力的十大最佳插件
  http://www.linuxidc.com/Linux/2016-01/127456.htm
  A Package in a league of its own: Helm
  http://tuhdo.github.io/helm-intro.html
  https://www.emacswiki.org/emacs/FindFileInProject
  rst mode in emacs on osx - cannot create pdf
  http://stackoverflow.com/questions/12602490/rst-mode-in-emacs-on-osx-cannot-create-pdf
  https://www.gnu.org/gnu/rms-lisp.html
  http://mirror.hust.edu.cn/gnu/
  https://en.wikipedia.org/wiki/Emacs_Lisp
*** init.el
  git clone https://github.com/purcell/emacs.d.git ~/.emacs.d
  (require 'ido)
  (ido-mode t)
  (setq auto-save-default nil)
  (require 'xcscope)
  (add-hook 'c-mode-common-hook 'cscope-minor-mode)
**** mu4e
(require 'mu4e)
(setq mu4e-maildir "~/mail")
(setq mu4e-drafts-folder "/Drafts")
(setq mu4e-sent-folder   "/Sent")
(setq mu4e-sent-messages-behavior 'delete)
(setq mu4e-get-mail-command "offlineimap")

;; shortcuts
(setq mu4e-maildir-shortcuts
      '( ("/INBOX"               . ?i)
         ("/Sentl"   . ?s)))

;; something about ourselves
(setq
 user-mail-address "zhangdf@actions-semi.com"
 user-full-name  "张东风"
 mu4e-compose-signature
 (concat
  "Regards,\n"
  "dongfeng\n"))

;; show images
(setq mu4e-show-images t)

;; use imagemagick, if available
(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))

;; convert html emails properly
;; Possible options:
;;   - html2text -utf8 -width 72
;;   - textutil -stdin -format html -convert txt -stdout
;;   - html2markdown | grep -v '&nbsp_place_holder;' (Requires html2text pypi)
;;   - w3m -dump -cols 80 -T text/html
;;   - view in browser (provided below)
(setq mu4e-html2text-command "textutil -stdin -format html -convert txt -stdout")

;; spell check
(add-hook 'mu4e-compose-mode-hook
          (defun my-do-compose-stuff ()
            "My settings for message composition."
            (set-fill-column 72)
            (flyspell-mode)))

;; add option to view html message in a browser
;; `aV` in view to activate
(add-to-list 'mu4e-view-actions
             '("ViewInBrowser" . mu4e-action-view-in-browser) t)

;; fetch mail every 10 mins
(setq mu4e-update-interval 600)

(require 'smtpmail)

;; alternatively, for emacs-24 you can use:
(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-stream-type 'plain
      smtpmail-default-smtp-server "localhost"
      smtpmail-smtp-server "localhost"
      smtpmail-smtp-service 1025)
(setq mu4e-sent-messages-behavior 'delete)
*** magit
  https://github.com/magit/magit/blob/master/Documentation/magit.texi
  http://blog.csdn.net/amuseme_lu/article/details/6931908
  http://www.emacswiki.org/emacs/Magit
  https://magit.vc/manual/magit/Getting-started.html
** cscope
   find frameworks/ packages/ bionic/ dalvik/ bootable/ libcore/ -name '*.c' -print -o -name '*.h' -print -o -name '*.cpp' -print -o -name '*.java' -print > cscope.files
   cscope –b –q -k
   find frameworks/ packages/ bionic/ dalvik/ bootable/ libcore/ -name '*.c' -print -o -name '*.h' -print -o -name '*.cpp' -print -o -name '*.java' –print | xargs etags -a
* 5601
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F7490632A697@srv-mail-02.actions.com.cn][答复: 关于GL5601A版上增加cache机制的评估]]
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0514442A@srv-mail-02.actions.com.cn][移动端BLE APP需求讨论]]
** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B051441D6@srv-mail-02.actions.com.cn][Nordic-Thingy-52 开发套件]]
** 语音遥控器
[[mu4e:msgid:1B6B99321A9A92489ABE223C54DA0BAE2CCCC248@MAIL-AP.ampak.com.tw][RE: 答复: <矩芯/意天> 提供语音遥控器头端补丁]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749062606C0@srv-mail-02.actions.com.cn][cordio_ble4.2_传输性能]]
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B051441E1@srv-mail-02.actions.com.cn][Realtek8762的蓝牙遥控器头端的补丁]]
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0514433D@srv-mail-02.actions.com.cn][转发: 关于RFSEN的双向音频遥控器资料]]
** TODO [[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B051441D6@srv-mail-02.actions.com.cn][Nordic-Thingy-52 开发套件]]
** cmsis dap
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F749061D527B@srv-mail-02.actions.com.cn][答复: 5601_DAPLink（cmsis-dap）]]
l 支持CMSIS-DAP debug protocol：
Keil MDK/IAR Workbench/pyOCD都已经支持CMSIS-DAP，可以通过daplink进行
debug（单步、断点等）和load（hex文件烧写）。
l USB Disk drag and drop programming：
插上后Pc上弹出一个udisk。将bin/hex文件拖到udisk后自动完成烧写。
*暂时只支持16KB eeprom。
l USB Serial Port：
插上后Pc上会增加一个串口设备。
*串口打印数据较多时，会有数据丢失。
后续规划evb板可以集成这款daplink。
** arm
*** UPF
ARM答复是我们如果做了比较大的代码修改，参加是有意义的

For our partners that are licensing our technology, they will already gain the benefits, since we attend them and put the fixes in our code.
Only if Actions is making heavy changes to our code, the it would make sense for them to attend.
What would be more valuable for them is to purchase 3rd party compliance testers. For RF there is R+S and Anritsu. For Link Layer, Ellisys.




Hi 深遠,
If you need more information on Bluetooth World/UPF, please feel free to let us know.

@ Bluetooth World Asia , please see :
https://www.bluetooth.com/news-events/events/2017/bluetooth-asia-2017

@ Bluetooth World, please see:
https://bluetoothworldevent.com/

@UPF, Please see our feedback as following:
UPF events are testing events to catch interoperability issues. We also find them to be good opportunities to network and to collaborate about the effects of new specification changes.
For our partners that are licensing our technology, they will already gain the benefits, since we attend them and put the fixes in our code.
Only if Actions is making heavy changes to our code, the it would make sense for them to attend.

** 策略
发件人: 陶永耀
发送时间: 2017年3月6日 16:55
收件人: 黄少彬; 张天益; Connie Meng; 张东风; 魏华铭
抄送: 杨哲军; 阳昕; 易宏伟; 龚建; Chris Chang; 桂阳
主题: 答复: 关于智能珠宝-低功耗的传输

按我的理解先回答一下。
Pm和业务同样会遭遇类似的疑问，多给点理由，会是好事。^_^

1、	如果只是作为数据传输，需要的系统功耗并不大，因此RAM上动态功耗是会比Eflash小，但是不见得整体功耗优势会很大。只有对于有算法带宽需求的应用，功耗优势才会被放大。
Yytao：这个要看具体场景。确实要看有多少是在程序运行的，算系统功耗的占空比。

2、	对于beacon类应用，通常CPU此时是休眠的，beacon定期发送的数据（ADV）通常有BLE内部实现，无需叫醒主控。也就是说此时系统的功耗可能可以忽略。
Yytao：这个也要算下beacon代码运行的占空比。特别是定制需求的的beacon，还有带mesh的beacon。至少sram架构不会高于eflash，只是看有多明显的价值。

3、	个人的疑问，如果beacon用于替代说明书之类的东西，为何不采用二维码之类更简单且更低成本的做法？
Yytao：这个暂时只有二维码“更不易损坏”一条价值，ble比二维码的距离远的好处，暂时还突出不出来。^_^。这是广告推送的一种用法。


总之，ble这颗的需求排序：低功耗，大容量，低成本。
这三句话都是有条件来说的，推广的时候可以针对场景来强调：
在低成本对手中（一般也是nor结构），我们是低功耗的（功耗优化设计的单模的RF，和以sram运行程序的mem架构）。
在低功耗对手中，我们是大容量的（一般是128kbyte，我们是512kbyte），而且是低成本的（是nordic51822价格的80%）。
还有个重要前提，开发难度和nordic差异不大，工具链，量产流程都一样，不信就试试看！^_^
服务就更不用说，比nordic好，更超过dialog和ti。

** info
发件人: 陶永耀
发送时间: 2017年3月6日 14:23
收件人: 张天益; Connie Meng; 张东风; 魏华铭
抄送: 杨哲军; 阳昕; 易宏伟; 龚建; 黄少彬; Chris Chang; 桂阳
主题: 关于智能珠宝-低功耗的传输


http://www.eet-china.com/news/article/201702280853?utm_source=EETC%20Article%20Alert&utm_medium=Email&utm_campaign=2017-03-01
巴菲特高调进入智能珠宝市场，可穿戴行业要变天？
•	2017年2月28日
智能珠宝，可能是穿戴式的一个重要分支。
从现在看最大量的51比52更有价值。
受益最大的应该是dialog和nordic的51822，Ti2541（但主要被51822打击）

关键是低功耗，mem的大小还不是最关键。
传统产品的，智能化升级是关键。有和没有的差别带来的天量。包括低功耗数传。
而功能多和少的差别，对量的影响次之，而且功耗会更大。

比如现在的心率，吃功耗和处理能力。主要还是运动人群用，使用受限。而且不准，量的增加不会多过低功耗的ble穿戴式设备。
至少我这么看。

所以我感觉发挥ble的本身的价值，低功耗的无线传输。会是一个主要的方向。再加上加密，数据安全（aes可被调用）。比如纽扣电池的蓝牙锁。
会比提升运算能力更有爆发力。

我打个比方，如果能在，16kbyte能解决的问题。一次把nor的程序load到程序中，基本数传的profile被rom化了。
可以做到比eflash运行程序更低的功耗。比eflash base的noric的51822更低。Wafer的制造成本也比eflash低了30%。
扩展性上，比dialog的14580的otp更有扩展性。

而且beacon的价值也是要沿着低功耗的传输来做。
比如之前google的提到的，不带说明的药盒，做成耗材，将成为天量。

看后续ble的产品是否可以沿这个方向做一些宣传和技术突破，看看价值。
这里需要更多的技术数据的支撑。

以上推测，来自两点基本前提（或假设）：
1，在sram运行程序，比eflash运行可大幅降低。比如30%。
2，不含eflash的制程比不带elfash制程可大幅便宜。比如30%
而且系统功耗占较大，常驻运行空间需求较低的场景。

至于如何找到功耗更低，容量小的低价norflash可以通过合作来达成，比如一年100M的单可以考虑定制flash容量和规格。
当然前提也是要有这样一类大的市场出现。可以用5601的市场推广来摸索一下这种可能性。
参考

** 开发方式

*** spinor
rodata问题
+ rodata不能放在nor上， 而只能放在ram中， 放在ram中，
+ switch case， 以及literal pool, short string等也会需要访问data的page miss问题

搜了一下，keil编译器提供下面这个编译选项可以去除代码段中的数据
--execute_only

这个等效于加上了下面这几个编译选项
--no_integer_literal_pools.
--no_float_literal_pools.
--no_string_literal_pools.
--no_branch_tables.

相对于EFLASH方案， spi nor使用page miss的方式，在调试方式上有两点不同，
*bluetooh



+ 如果设置的断电刚好是nor上代码，设置的断点会停两次， 第一次停在E800，第二次才是正确的指令
+ 在单步调试nor上的代码的时候， 在debug窗口看到的都是e800 单步后，才会变成正确的指令
*** 使用感受
我就说一下我的这个想法吧：
1、从开发环境的使用角度来讲，使用的是keil集成开发环境，编译、下载都还挺方便的，和TI的IAR开发环境没啥差别。

2、调试手段可以用标准的Jlink，并且还可以通过打印调试，debug起来很容易。
从上面的感觉这比我以前用的泰凌微TLSR8266，要更好一些。

从ble的软件结构来看，这种事件驱动的前后台系统，和我以前用过的Ti的也差不多，这应该不是难点。

我们当前从eeprom或者flash中读取代码到ram中运行，但是这一点当前项目封装的还比较好，从应用层几乎看不到与从flash中直接运行的区别。

是否需要开发者过多的关心sct文件，也就是内存的分布问题，这一点我还不是太清楚。最好不要开发者过多的关心sct文件，否者就会增加开发的门槛。

另外，对硬件的操作我们应该提供尽量多的、完善的代码，这一点我们目前的sdk上有，不知道做的是不是灵活、完善。

目前就这些看法哈。
发件人: 魏华铭
发送时间: 2017年3月27日 16:25
收件人: 吴升
抄送: 张东风; 杨哲军; 陈元捷; 刘世军
主题: GL5601-SDK-使用感受
重要性: 高

Hi吴升：

         上周末学习使用GL5601-SDK感觉如何？

开发方式和你之前用过的TI有哪些区别？使用上是否有不方便的地方？学习难度是否合理？请帮忙列举出来。

谢谢！
* 5116
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F3707F@srv-mail-02.actions.com.cn][US282F SDK培训(一)]]
* 5118+
定位：低端数码管蓝牙音箱市场
基本需求：GL5118+数码管+RTC+红外
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74905FF9BFF@srv-mail-02.actions.com.cn][答复: GL5118Plus对CPU速度和RAM增加的需求讨论]]
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B0514425A@srv-mail-02.actions.com.cn][答复: GL5118B/GL5116C支持规格]]
** romcode
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906260921@srv-mail-02.actions.com.cn][关于5118 的内存空间！]]
[[mu4e:msgid:2FF4B6792E0FC64E87AA66610E97F74906260B6A@srv-mail-02.actions.com.cn][答复: GL5118B 蓝牙固化代码调整相关讨论]]
* misc
https://mail.actions-semi.com/exchange/
** samba win7 访问问题
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04FAA450@srv-mail-02.actions.com.cn][答复: 一个服务器访问的问题！]]
** 电话会议
如之前沟通，为确保项目进展顺利，接下来安排了每周一下午4:30双方研发周会，
沟通重点炬芯这边的情况：1.进度 2.风险，3接下来优先级（包含但不限于以上内容）。

电话拨打：0756-3673740 +（虚拟电话会议室号码）有欢迎词后输入（密码）会有滴的一声进入会议系统。

虚拟电话会议室号码    密码
      5655            1234  （默认首选）
      5666            1234
      5677            5678

** ip
*** 外网ip
auto eth0
iface eth0 inet static
address 112.91.148.197
netmask 255.255.255.248
gateway 112.91.148.193
dns-nameservers 221.5.88.88

    IP地址：221.4.209.99，子网掩码：255.255.255.224（即27位），网关：221.4.209.97
    邮件先给你，我现在上去重新连接一下线。
http://xp9802.iteye.com/blog/2120351
busybox ifconfig eth0 221.4.209.99 netmask 255.255.255.224
busybox route add default gw 221.4.209.97

** RDQA
[[mu4e:msgid:5EBFE11104EFEA4981C19EC8D2C2946B04F3719B@srv-mail-02.actions.com.cn][答复: 关于研发流程的优化建议收集和处理]]
** WIFI密码
ACTZH-PAD-GMS1  Gms@2016
ACTZH-PAD-FW2 Actspa@2016
ACTZH-PAD-FW1 ActsFW2010
ACTZH-PAD-GMS2 201601@GMS
ACTZH-PAD-PMD PMD123456
Guest WIFI：actSguesT201601
ssid="ACTZH-PAD-GMS2"   psk="201601@GMS"
ssid="ACTZH-PAD-PMD"    psk="PMD123456"
ssid="ACTZH-PAD-GMS1"   psk="Gms@2016"
ssid="ACTZH-PAD-FW1"   psk="ActsFW2010"
ssid="ACTZH-PAD-FW2"   psk="Actspa@2016"
** priv
*** 身份证
张江帆 410711200607043059
李宏 410702197902161022
张子越 410711201103060036
** 服务器密码
|      服务器ip | 性质       |   hosts指向 | jdk1.8安装情况 | 密码              |
|  192.168.4.20 | 编译服务器 | 192.168.4.3 | 已安装         | password          |
| 192.168.4.220 | 编译服务器 | 192.168.4.3 | 已安装         | password          |
|  192.168.4.19 | 编译服务器 | 192.168.4.3 | 已安装         | root/actions@2014 |
|  192.168.4.28 | 编译服务器 | 192.168.4.3 | 已安装         | password          |
|  192.168.1.27 | 编译服务器 | 192.168.4.3 | 已安装         | root/zhangdf1     |
|  192.168.1.11 | 编译服务器 | 192.168.4.3 | 已安装         | root/actions@2011 |
|   192.168.0.3 | 编译服务器 | 192.168.4.3 | ——             | root/actions@2011 |
| 192.168.4.107 | 编译服务器 | 192.168.4.3 | 已安装         |                   |
| 192.168.4.233 | 编译服务器 | 192.168.4.3 | 已安装         | password          |

交接服务器信息：
1. git代码服务器原先有两台，一台是主机（master），一台是从机（slave），后来从机改为了gerrit服务器，所以现在都是用主机下载代码。
2. gitolite代码服务器：srv-srdgit /192.168.4.3，帐号密码：root/3392353zzh
3. gerrit代码服务器：srv-srdgit-02 /192.168.4.4：root/3392353zzh
4. 还有一台旧的代码服务器：fwgitsrv：root/3392353zzh
5. 发布服务器srv-padgit-out（192.168.1.11），root/3392353zzh，
6. jenkins服务器srv-ess-jenkins（192.168.4.27）：fwint/csrd4#fw

* 出差报告
** 2017-0405
*** linaro 96board
96boards 的软件支持：
+ 优先支持的os，比如android zephyr由linaro完成
+ 社区会搞定其他大部分的OS
+ win10等os的支持，是linaro完全不知情的
linaro比较有兴趣去和百度去推动语音+zephyr+百度的DuerOS的事情

** 2017-03-23
*** 南方硅谷
+ Airkiss可以通过多次join的方式来看是否仍有问题
+ 断线问题需要有抓包数据
+ 抢带宽的问题，可以尝试使用IP的qos来解决，SSL看下有没有BB的做法
+ 更新新版驱动问题， 有修正一些bug， 看是否有改善断网的问题
+ 内存节省， 通过在driver中保留两个1.5k的buffer， 在net_input中，拷贝到zephyr中的n_buf中， n_buf可以frag分片
+ 休眠 WIFI模组，保持长连接， 连续RX  需要90多ma， 100ms唤醒1次，10ma 3.3V， 级别3， 级别10最低
+ sniffer空气抓包工具，推荐型号
+ 29号给南方硅谷板子
+ 3503 后续给南方硅谷固件， 不用给源码。
*** S700 S900支持策略
+ S700/V700/S900共用一个SDK，发布的时候同时发布，不特别区分不同IC的不同SDK发布。
+ 测试优先安排S700的SDK的发布以及测试，S700发布计划依然按照4月底计划努力，V700/S900可以后续再安排，作为第二阶段。
+ S700的开发板是CB6，S900的开发板是96Board。关于出货给客户的类似开发板子板的方糖的板子最好抄96board的设计。
+ V700的标案规格就是平板的规格。
+ 泽迪的V700先用GS700E出货，最后可以切换到现在的SDK。

*** 方糖拜访
+ S500 CB6,  S700 CB7
+ S700 linx ubutu版本已经带起
+ 方糖带起GPU加速
+ 炬芯带起硬解码
+ s700 的效果不能比S500差
+ hdmi 分辨率如何设置， 好像不支持

** 2017-02-17 LinkPlay
LinkPlay:
MTK方案：5V 300~400ma， 关掉RF 80ma 5V， 没有standby功能。
alexa 加harman  等有新客户开案

要求：
功耗降低， WIFI+5G， 需要支持WIFI休眠。

认证要求：
alexa 直接对接amazon

ASR02模组的原因：
sensory， 唤醒词收费。 echo alexa amazon
模拟容易解决。

唤醒词模型， 在ap上可以放比较大的模型。 DSP做不了大的模型。
休眠状态， WIFI不断开。  拾音。
科胜讯 唤醒词50ma。
Broadcom 43455，Ap6255。
WIFI认证只需要我们调通模组就好。 认证由linkplay搞。

亚马逊认证流程：
3天， 房间，声压计， 唤醒的， 等有很多环境。
测试唤醒， 误唤醒， 24小时不能超过3次。
环境噪音低于65db，
在云端有log。
具体指标：
近场80公分， 50db ，近场不播放音乐。
原厂 3米， 最大音量播放  85db， 人声 50db
亚马逊静音房测试。

mic的要求：
mic使用驻极体 mic， 全向。  mic的一致性要求很好， 使用特别出货测试。
一致性主要是灵敏度等参数。 ADC的动态范围。
对mic拜访，模具结构都有特别的要求。
多mic有声源定位， 但后者实际使用并不好用。 跟摆放位置， 遮挡关系都很大。

软件需求：
1 harman推荐方式
2 X1000的文档，比较全。
3 broadcom WIFI认证， BQB认证 和 WIFI long认证 君正都比较熟悉
4 哈曼 推荐了amlogic A111的芯片。 推荐。
哈曼 已经引入了这个方案进入google chrome cast。
5 音箱 95db 和 105db是两个坎。
6 SPDIF IN的要求。

mtk bsp的要求：
1 def config 客户可以自己搞定。
2 音频驱动alsa， 不需要tiny alsa， alsa util等。
3 wifi dns， dhcp， wpa， 标准socket。
4 hostapd 需要
5 busybox需要支持网络管理， 不确认是不是在busybox中。
6 wifi 测试工具。 + wifi认证固件。
7 bootloader可以用自己的。
8 BT 功能。 需要做完善。 A2DP， AVRCP ，HFP。
AVRCP 需要回声消除。  需要提供蓝牙的sdk的接口。
A2DP的发射。
9 SDIO 支持 2.0， 5G最好能够SDIO 3.0
10 WIFI的休眠唤醒。 通过WIFI唤醒CPU。 在休眠的时候需要保持链接。
11 cpu资源要求。 第一阶段不是问题。
